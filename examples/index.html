<head>
  <script type="module">
    import createREGL from "regl";
    import bunny from "bunny";
    import normals from "angle-normals";
    import createCamera from "inertial-turntable-camera";
    import interactionEvents from "normalized-interaction-events";

    document.addEventListener("DOMContentLoaded", function () {
      const regl = createREGL();
      const drawBunny = regl({
        vert: `
      precision mediump float;
      attribute vec3 positions, normals;
      uniform mat4 projection, view;
      varying vec3 n;
      void main () {
        n = normals;
        gl_Position = projection * view * vec4(positions, 1);
      }`,
        frag: `
      precision mediump float;
      varying vec3 n;
      void main () {
        gl_FragColor = vec4(0.5 + 0.5 * n, 1);
      }`,
        cull: { enable: true, face: "back" },
        attributes: {
          ...bunny,
          normals: normals(bunny.cells, bunny.positions),
        },
        elements: bunny.cells,
        count: bunny.cells.length * 3,
      });

      const camera = (window.camera = createCamera({
        aspectRatio: window.innerWidth / window.innerHeight,
        distance: 20,
        center: [0, 4, 0],
        rotationDecayTime: 500,
        panDecayTime: 500,
        zoomDecayTime: 500
      }));

      const setCameraUniforms = regl({
        uniforms: {
          projection: (ctx, camera) => camera.state.projection,
          view: (ctx, camera) => camera.state.view,
        },
      });

      const radiansPerHalfScreenWidth = Math.PI * 1;

      interactionEvents(regl._gl.canvas)
        .on("wheel", function (ev) {
          camera.zoom(ev.x, ev.y, Math.exp(-ev.dy) - 1.0);
          ev.originalEvent.preventDefault();
        })
        .on("mousemove", function (ev) {
          if (!ev.active || ev.buttons !== 1) return;

          if (ev.mods.shift) {
            camera.pan(ev.dx, ev.dy);
          } else if (ev.mods.meta) {
            camera.pivot(ev.dx, ev.dy);
          } else {
            camera.rotate(
              -ev.dx * radiansPerHalfScreenWidth,
              -ev.dy * radiansPerHalfScreenWidth
            );
          }
          ev.originalEvent.preventDefault();
        })
        .on("touchmove", function (ev) {
          if (!ev.active) return;
          camera.rotate(
            -ev.dx * radiansPerHalfScreenWidth,
            -ev.dy * radiansPerHalfScreenWidth
          );
          ev.originalEvent.preventDefault();
        })
        .on("pinchmove", function (ev) {
          if (!ev.active) return;
          camera.zoom(ev.x, ev.y, 1 - ev.zoomx);
          camera.pan(ev.dx, ev.dy);
        })
        .on("touchstart", (ev) => ev.originalEvent.preventDefault())
        .on("pinchstart", (ev) => ev.originalEvent.preventDefault());

      regl.frame(() => {
        camera.tick({
          near: camera.params.distance * 0.01,
          far: camera.params.distance * 2 + 200,
        });

        setCameraUniforms(camera, () => {
          if (!camera.state.dirty) return;
          regl.clear({ color: [0, 0, 0, 1], depth: 1 });
          drawBunny();
        });
      });

      window.addEventListener(
        "resize",
        function () {
          width = window.innerWidth;
          height = window.innerHeight;
          camera.resize(width / height);
        },
        false
      );
    });
  </script>
</head>
<body></body>
