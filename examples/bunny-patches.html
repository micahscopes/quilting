<head> </head>
<body>
  <script type="module" async>
    const matcapUrls = import.meta.glob("./matcaps/*.png");
    import seafoam from "./textures/seafoam.png";
    import bunny from "bunny";
    import simplify from "mesh-simplify";
    // import Patch, {randomPoints, QUAD, TRI} from "../src/patch";
    // import { range, sample } from "lodash-es";
    // import { sub, normalize } from "@thi.ng/vectors";

    // const randomElement = (array) =>
    //   array[Math.floor(Math.random() * array.length)];

    document.addEventListener("DOMContentLoaded", async function () {
      const seafoamImage = await new Promise((resolve) => {
        const im = new Image();
        im.crossOrigin = "anonymous";
        im.src = seafoam;
        im.onload = () =>
          resolve(Object.assign(im, { style: "max-width:200px" }));
      });
      const matcapImages = await Promise.all(
        Object.keys(matcapUrls).map(
          (url) =>
            new Promise((resolve) => {
              const im = new Image();
              im.crossOrigin = "anonymous";
              im.src = url;
              im.onload = () =>
                resolve(Object.assign(im, { style: "max-width:200px" }));
            })
        )
      );
      // const regl = createREGL({
      //   extensions: [
      //     "oes_standard_derivatives",
      //     "oes_element_index_uint", // necessary to support high resolution patches
      //   ],
      // });

      // const simpleBunny = simplify(bunny.cells, bunny.positions)(8200)
      // const bunnyPolys = simpleBunny.cells.map(cell => cell.map(i => simpleBunny.positions[i]))
      // console.log('bunny polys', bunnyPolys)

      // const N = 5;
      // const patch = Patch(regl, 64, {type: TRI});

      // const matcap = regl.texture({ data: randomElement(matcapImages) });
      // const matcaps = matcapImages.map((data) => regl.texture({ data }));
      // const texture = regl.texture({ data: seafoamImage });

      // const defaultWeights = () => ({w0: [1,1,0,1], w1: [1,1,0,0], w2: [0.1,0.1,0.4,0]})
      // const patchesProps = bunnyPolys.map(([p0, p1, p2]) => ({ matcap: sample(matcaps), texture, p0, p1, p2, ...defaultWeights()}));

      // const draw = (props) => {
      //   // for (let p of patches) {
      //   props = patchesProps.map((patches) => ({ ...patches, ...props }));

      //   const batch = [
      //     ///
      //     ...props,
      //   ];
      //   // console.log(batch.length)
      //   patch(batch);
      //   // }
      // };

      // // console.log(camera);
      // regl.frame(() => {
      //   meter.tickStart();
      //   camera.tick({
      //     near: camera.params.distance * 0.01,
      //     far: camera.params.distance * 2 + 200,
      //   });

      //   setCameraUniforms(camera, () => {
      //     // if (!camera.state.dirty) return;
      //     regl.clear({ color: [0, 0, 0, 1], depth: 1 });
      //     draw({ eye: camera.state.eye });
      //   });
      //   meter.tick();
      // });
    });
  </script>
</body>
