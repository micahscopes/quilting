<head> </head>
<body>
  <script type="module" async>
    import FPS from "fpsmeter";
    import createREGL from "regl";
    import createRESL from "resl";
    import matcapUrls from "./matcaps/*.png";
    import seafoam from "./textures/seafoam.png";
    import createCamera from "inertial-turntable-camera";
    import interactionEvents from "normalized-interaction-events";
    import Patch, {
      randomPoints,
      QUAD,
      TRI,
      gl,
      randomUnit,
      membersCGA3,
    } from "../src/patch";
    import { range, sample, fromPairs, zip, union, spread } from "lodash-es";
    import { sub, normalize } from "@thi.ng/vectors";
    import cube from "primitive-cube";
    import simplify from "mesh-simplify";
    // console.log(FPS)
    const meter = new FPSMeter();

    const randomElement = (array) =>
      array[Math.floor(Math.random() * array.length)];

    const product = (...a) =>
      a.reduce((a, b) => a.flatMap((d) => b.map((e) => [d, e].flat())));

    console.log("hello");
    document.addEventListener("DOMContentLoaded", async function () {
      const regl = createREGL({
        extensions: [
          "oes_standard_derivatives",
          "oes_element_index_uint", // necessary to support high resolution patches
        ],
      });

      const seafoamImage = await new Promise((resolve) => {
        const im = new Image();
        im.crossOrigin = "anonymous";
        im.src = seafoam;
        im.onload = () =>
          resolve(Object.assign(im, { style: "max-width:200px" }));
      });
      const matcapImages = await Promise.all(
        Object.values(matcapUrls).map(
          (url) =>
            new Promise((resolve) => {
              const im = new Image();
              im.crossOrigin = "anonymous";
              im.src = url;
              im.onload = () =>
                resolve(Object.assign(im, { style: "max-width:200px" }));
            })
        )
      );

      // const simpleBunny = simplify(bunny.cells, bunny.positions)(8200);
      // const bunnyPolys = simpleBunny.cells.map((cell) =>
      //   cell.map((i) => simpleBunny.positions[i])
      // );
      // console.log("bunny polys", bunnyPolys);
      const cubeGeometry = cube();
      console.log(cubeGeometry);
      const cubePolys = cubeGeometry.cells.map((cell) =>
        cell.map((i) => cubeGeometry.positions[i])
      );
      console.log("cube polys", cubePolys);

      const N = 5;
      const shape = TRI;
      const patch = Patch(regl, 256, {
        shape,
        weightType: "CGA3",
      });

      const matcap = regl.texture({ data: randomElement(matcapImages) });
      const matcaps = matcapImages.map((data) => regl.texture({ data }));
      const texture = regl.texture({ data: seafoamImage });

      const zeroCGA3 = () => fromPairs(zip(membersCGA3, new Array(32).fill(0)));
      const randomWeight = () => {
        weight = zeroCGA3();
        weight.scalar = 0.8;
        weight.e12 = 0.5;
        weight.e13 = 0.2;
        weight.e23 = 0.4;
        return weight;
      };
      const concat = spread(union);
      const cga3fromGrades = (...grades) => {
        const gradeMembers = concat(grades);
        const members = (new Array(32))
          .fill(0)
          .map((x, i) => (gradeMembers[i] ? gradeMembers[i] : x));
        x = fromPairs(zip(membersCGA3, members));
        return x;
      };
      const defaultWeights = () => ({
        w0: cga3fromGrades([1], randomUnit(0.00, 5), randomUnit(6.1, 25 ) ),
        w1: cga3fromGrades([1], randomUnit(0.00, 5), randomUnit(6.1, 25 ) ),
        w2: cga3fromGrades([1], randomUnit(0.00, 5), randomUnit(6.1, 25 ) ),
        w3: cga3fromGrades([1], randomUnit(0.00, 5), randomUnit(6.1, 25 ) ),
      });
      console.log(defaultWeights(), randomUnit(1, 32));
      // console.log(membersCGA3)
      // console.log(zip(membersCGA3, [1,-1, 1, 1, 0,0,0,1, 0,0,-2,0, 0,0,0,2]))

      const patchesProps = cubePolys.map(([p0, p1, p2]) => ({
        matcap: sample(matcaps),
        texture,
        p0,
        p1,
        p2,
        ...defaultWeights(),
      }));

      const draw = (props) => {
        // for (let p of patches) {
        props = patchesProps.map((patches) => ({ ...patches, ...props }));

        const batch = [
          ///
          ...props,
        ];
        // console.log(batch.length)
        patch(batch);
        // }
      };

      const decayTime = 100;
      const camera = (window.camera = createCamera({
        aspectRatio: window.innerWidth / window.innerHeight,
        distance: 30,
        center: [0, 0, 0],
        rotationDecayTime: decayTime,
        panDecayTime: decayTime,
        zoomDecayTime: decayTime,
      }));

      const setCameraUniforms = regl({
        uniforms: {
          projection: (ctx, camera) => camera.state.projection,
          view: (ctx, camera) => camera.state.view,
        },
      });

      const radiansPerHalfScreenWidth = Math.PI * 1;

      interactionEvents(regl._gl.canvas)
        .on("wheel", function (ev) {
          camera.zoom(ev.x, ev.y, Math.exp(-ev.dy) - 1.0);
          ev.originalEvent.preventDefault();
        })
        .on("mousemove", function (ev) {
          if (!ev.active || ev.buttons !== 1) return;

          if (ev.mods.shift) {
            camera.pan(ev.dx, ev.dy);
          } else if (ev.mods.meta) {
            camera.pivot(ev.dx, ev.dy);
          } else {
            camera.rotate(
              -ev.dx * radiansPerHalfScreenWidth,
              -ev.dy * radiansPerHalfScreenWidth
            );
          }
          ev.originalEvent.preventDefault();
        })
        .on("touchmove", function (ev) {
          if (!ev.active) return;
          camera.rotate(
            -ev.dx * radiansPerHalfScreenWidth,
            -ev.dy * radiansPerHalfScreenWidth
          );
          ev.originalEvent.preventDefault();
        })
        .on("pinchmove", function (ev) {
          if (!ev.active) return;
          camera.zoom(ev.x, ev.y, 1 - ev.zoomx);
          camera.pan(ev.dx, ev.dy);
        })
        .on("touchstart", (ev) => ev.originalEvent.preventDefault())
        .on("pinchstart", (ev) => ev.originalEvent.preventDefault());

      // console.log(camera);
      regl.frame(() => {
        meter.tickStart();
        camera.tick({
          near: camera.params.distance * 0.01,
          far: camera.params.distance * 2 + 200,
        });

        setCameraUniforms(camera, () => {
          // if (!camera.state.dirty) return;
          regl.clear({ color: [0, 0, 0, 1], depth: 1 });
          draw({ eye: camera.state.eye });
        });
        meter.tick();
      });

      window.addEventListener(
        "resize",
        function () {
          width = window.innerWidth;
          height = window.innerHeight;
          camera.resize(width / height);
        },
        false
      );
    });
  </script>
</body>
