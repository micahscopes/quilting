const p = function polyfill() {
    const relList = document.createElement('link').relList;
    if (relList && relList.supports && relList.supports('modulepreload')) {
        return;
    }
    for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
    }
    new MutationObserver((mutations) => {
        for (const mutation of mutations) {
            if (mutation.type !== 'childList') {
                continue;
            }
            for (const node of mutation.addedNodes) {
                if (node.tagName === 'LINK' && node.rel === 'modulepreload')
                    processPreload(node);
            }
        }
    }).observe(document, { childList: true, subtree: true });
    function getFetchOpts(script) {
        const fetchOpts = {};
        if (script.integrity)
            fetchOpts.integrity = script.integrity;
        if (script.referrerpolicy)
            fetchOpts.referrerPolicy = script.referrerpolicy;
        if (script.crossorigin === 'use-credentials')
            fetchOpts.credentials = 'include';
        else if (script.crossorigin === 'anonymous')
            fetchOpts.credentials = 'omit';
        else
            fetchOpts.credentials = 'same-origin';
        return fetchOpts;
    }
    function processPreload(link) {
        if (link.ep)
            // ep marker = processed
            return;
        link.ep = true;
        // prepopulate the load record
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
    }
};true&&p();

const scriptRel = 'modulepreload';const seen = {};const base = '/quilting/prerelease/april-13-2022/';const __vitePreload = function preload(baseModule, deps) {
    // @ts-ignore
    if (!true || !deps || deps.length === 0) {
        return baseModule();
    }
    return Promise.all(deps.map((dep) => {
        // @ts-ignore
        dep = `${base}${dep}`;
        // @ts-ignore
        if (dep in seen)
            return;
        // @ts-ignore
        seen[dep] = true;
        const isCss = dep.endsWith('.css');
        const cssSelector = isCss ? '[rel="stylesheet"]' : '';
        // @ts-ignore check if the file is already preloaded by SSR markup
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
            return;
        }
        // @ts-ignore
        const link = document.createElement('link');
        // @ts-ignore
        link.rel = isCss ? 'stylesheet' : scriptRel;
        if (!isCss) {
            link.as = 'script';
            link.crossOrigin = '';
        }
        link.href = dep;
        // @ts-ignore
        document.head.appendChild(link);
        if (isCss) {
            return new Promise((res, rej) => {
                link.addEventListener('load', res);
                link.addEventListener('error', () => rej(new Error(`Unable to preload CSS for ${dep}`)));
            });
        }
    })).then(() => baseModule());
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

var freeGlobal$1 = freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal$1 || freeSelf || Function('return this')();

var root$1 = root;

/** Built-in value references. */
var Symbol$1 = root$1.Symbol;

var Symbol$2 = Symbol$1;

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$3.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$3.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$4.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$2.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$1 = Array.isArray;

var isArray$2 = isArray$1;

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$1(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$1(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject$1(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity$2(value) {
  return value;
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction$1(value) {
  if (!isObject$1(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */
var coreJsData = root$1['__core-js_shared__'];

var coreJsData$1 = coreJsData;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/** Used for built-in method references. */
var funcProto$1 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$1 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$1.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty$3).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject$1(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

var defineProperty$1 = defineProperty;

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty$1 ? identity$2 : function(func, string) {
  return defineProperty$1(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

var baseSetToString$1 = baseSetToString;

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString$1);

var setToString$1 = setToString;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$3 = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax$3(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax$3(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString$1(overRest(func, start, identity$2), func + '');
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike$1(value) {
  return value != null && isLength(value.length) && !isFunction$1(value);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject$1(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike$1(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

var isArguments$1 = isArguments;

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/** Built-in value references. */
var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray$2(value) || isArguments$1(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil$1 = Math.ceil,
    nativeMax$2 = Math.max;

/**
 * Creates an array of elements split into groups the length of `size`.
 * If `array` can't be split evenly, the final chunk will be the remaining
 * elements.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to process.
 * @param {number} [size=1] The length of each chunk
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the new array of chunks.
 * @example
 *
 * _.chunk(['a', 'b', 'c', 'd'], 2);
 * // => [['a', 'b'], ['c', 'd']]
 *
 * _.chunk(['a', 'b', 'c', 'd'], 3);
 * // => [['a', 'b', 'c'], ['d']]
 */
function chunk(array, size, guard) {
  if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
    size = 1;
  } else {
    size = nativeMax$2(toInteger(size), 0);
  }
  var length = array == null ? 0 : array.length;
  if (!length || size < 1) {
    return [];
  }
  var index = 0,
      resIndex = 0,
      result = Array(nativeCeil$1(length / size));

  while (index < length) {
    result[resIndex++] = baseSlice(array, index, (index += size));
  }
  return result;
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike$1(value);
}

/**
 * The inverse of `_.toPairs`; this method returns an object composed
 * from key-value `pairs`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} pairs The key-value pairs.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.fromPairs([['a', 1], ['b', 2]]);
 * // => { 'a': 1, 'b': 2 }
 */
function fromPairs(pairs) {
  var index = -1,
      length = pairs == null ? 0 : pairs.length,
      result = {};

  while (++index < length) {
    var pair = pairs[index];
    result[pair[0]] = pair[1];
  }
  return result;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax$1 = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax$1(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range$1 = createRange();

var range$2 = range$1;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.zip` except that it accepts an array of grouped
 * elements and creates an array regrouping the elements to their pre-zip
 * configuration.
 *
 * @static
 * @memberOf _
 * @since 1.2.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @returns {Array} Returns the new array of regrouped elements.
 * @example
 *
 * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
 * // => [['a', 1, true], ['b', 2, false]]
 *
 * _.unzip(zipped);
 * // => [['a', 'b'], [1, 2], [true, false]]
 */
function unzip(array) {
  if (!(array && array.length)) {
    return [];
  }
  var length = 0;
  array = arrayFilter(array, function(group) {
    if (isArrayLikeObject(group)) {
      length = nativeMax(group.length, length);
      return true;
    }
  });
  return baseTimes(length, function(index) {
    return arrayMap(array, baseProperty(index));
  });
}

/**
 * Creates an array of grouped elements, the first of which contains the
 * first elements of the given arrays, the second of which contains the
 * second elements of the given arrays, and so on.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to process.
 * @returns {Array} Returns the new array of grouped elements.
 * @example
 *
 * _.zip(['a', 'b'], [1, 2], [true, false]);
 * // => [['a', 1, true], ['b', 2, false]]
 */
var zip$1 = baseRest(unzip);

var zip$2 = zip$1;

///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////

// https://www.khronos.org/registry/webgl/specs/1.0/
// https://www.khronos.org/registry/webgl/specs/latest/2.0/#1.1
const GL = {
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_BUFFER_BIT
        @private
     */
    DEPTH_BUFFER_BIT: 0x00000100,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BUFFER_BIT
        @private
     */
    STENCIL_BUFFER_BIT: 0x00000400,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_BUFFER_BIT
        @private
     */
    COLOR_BUFFER_BIT: 0x00004000,
    /**
        @type {GLenum}
        @name PicoGL.POINTS
        @private
     */
    POINTS: 0x0000,
    /**
        @type {GLenum}
        @name PicoGL.LINES
        @private
     */
    LINES: 0x0001,
    /**
        @type {GLenum}
        @name PicoGL.LINE_LOOP
        @private
     */
    LINE_LOOP: 0x0002,
    /**
        @type {GLenum}
        @name PicoGL.LINE_STRIP
        @private
     */
    LINE_STRIP: 0x0003,
    /**
        @type {GLenum}
        @name PicoGL.TRIANGLES
        @private
     */
    TRIANGLES: 0x0004,
    /**
        @type {GLenum}
        @name PicoGL.TRIANGLE_STRIP
        @private
     */
    TRIANGLE_STRIP: 0x0005,
    /**
        @type {GLenum}
        @name PicoGL.TRIANGLE_FAN
        @private
     */
    TRIANGLE_FAN: 0x0006,
    /**
        @type {GLenum}
        @name PicoGL.ZERO
        @private
     */
    ZERO: 0,
    /**
        @type {GLenum}
        @name PicoGL.ONE
        @private
     */
    ONE: 1,
    /**
        @type {GLenum}
        @name PicoGL.SRC_COLOR
        @private
     */
    SRC_COLOR: 0x0300,
    /**
        @type {GLenum}
        @name PicoGL.ONE_MINUS_SRC_COLOR
        @private
     */
    ONE_MINUS_SRC_COLOR: 0x0301,
    /**
        @type {GLenum}
        @name PicoGL.SRC_ALPHA
        @private
     */
    SRC_ALPHA: 0x0302,
    /**
        @type {GLenum}
        @name PicoGL.ONE_MINUS_SRC_ALPHA
        @private
     */
    ONE_MINUS_SRC_ALPHA: 0x0303,
    /**
        @type {GLenum}
        @name PicoGL.DST_ALPHA
        @private
     */
    DST_ALPHA: 0x0304,
    /**
        @type {GLenum}
        @name PicoGL.ONE_MINUS_DST_ALPHA
        @private
     */
    ONE_MINUS_DST_ALPHA: 0x0305,
    /**
        @type {GLenum}
        @name PicoGL.DST_COLOR
        @private
     */
    DST_COLOR: 0x0306,
    /**
        @type {GLenum}
        @name PicoGL.ONE_MINUS_DST_COLOR
        @private
     */
    ONE_MINUS_DST_COLOR: 0x0307,
    /**
        @type {GLenum}
        @name PicoGL.SRC_ALPHA_SATURATE
        @private
     */
    SRC_ALPHA_SATURATE: 0x0308,
    /**
        @type {GLenum}
        @name PicoGL.FUNC_ADD
        @private
     */
    FUNC_ADD: 0x8006,
    /**
        @type {GLenum}
        @name PicoGL.BLEND_EQUATION
        @private
     */
    BLEND_EQUATION: 0x8009,
    /**
        @type {GLenum}
        @name PicoGL.BLEND_EQUATION_RGB
        @private
     */
    BLEND_EQUATION_RGB: 0x8009,
    /**
        @type {GLenum}
        @name PicoGL.BLEND_EQUATION_ALPHA
        @private
     */
    BLEND_EQUATION_ALPHA: 0x883D,
    /**
        @type {GLenum}
        @name PicoGL.FUNC_SUBTRACT
        @private
     */
    FUNC_SUBTRACT: 0x800A,
    /**
        @type {GLenum}
        @name PicoGL.FUNC_REVERSE_SUBTRACT
        @private
     */
    FUNC_REVERSE_SUBTRACT: 0x800B,
    /**
        @type {GLenum}
        @name PicoGL.BLEND_DST_RGB
        @private
     */
    BLEND_DST_RGB: 0x80C8,
    /**
        @type {GLenum}
        @name PicoGL.BLEND_SRC_RGB
        @private
     */
    BLEND_SRC_RGB: 0x80C9,
    /**
        @type {GLenum}
        @name PicoGL.BLEND_DST_ALPHA
        @private
     */
    BLEND_DST_ALPHA: 0x80CA,
    /**
        @type {GLenum}
        @name PicoGL.BLEND_SRC_ALPHA
        @private
     */
    BLEND_SRC_ALPHA: 0x80CB,
    /**
        @type {GLenum}
        @name PicoGL.CONSTANT_COLOR
        @private
     */
    CONSTANT_COLOR: 0x8001,
    /**
        @type {GLenum}
        @name PicoGL.ONE_MINUS_CONSTANT_COLOR
        @private
     */
    ONE_MINUS_CONSTANT_COLOR: 0x8002,
    /**
        @type {GLenum}
        @name PicoGL.CONSTANT_ALPHA
        @private
     */
    CONSTANT_ALPHA: 0x8003,
    /**
        @type {GLenum}
        @name PicoGL.ONE_MINUS_CONSTANT_ALPHA
        @private
     */
    ONE_MINUS_CONSTANT_ALPHA: 0x8004,
    /**
        @type {GLenum}
        @name PicoGL.BLEND_COLOR
        @private
     */
    BLEND_COLOR: 0x8005,
    /**
        @type {GLenum}
        @name PicoGL.ARRAY_BUFFER
        @private
     */
    ARRAY_BUFFER: 0x8892,
    /**
        @type {GLenum}
        @name PicoGL.ELEMENT_ARRAY_BUFFER
        @private
     */
    ELEMENT_ARRAY_BUFFER: 0x8893,
    /**
        @type {GLenum}
        @name PicoGL.ARRAY_BUFFER_BINDING
        @private
     */
    ARRAY_BUFFER_BINDING: 0x8894,
    /**
        @type {GLenum}
        @name PicoGL.ELEMENT_ARRAY_BUFFER_BINDING
        @private
     */
    ELEMENT_ARRAY_BUFFER_BINDING: 0x8895,
    /**
        @type {GLenum}
        @name PicoGL.STREAM_DRAW
        @private
     */
    STREAM_DRAW: 0x88E0,
    /**
        @type {GLenum}
        @name PicoGL.STATIC_DRAW
        @private
     */
    STATIC_DRAW: 0x88E4,
    /**
        @type {GLenum}
        @name PicoGL.DYNAMIC_DRAW
        @private
     */
    DYNAMIC_DRAW: 0x88E8,
    /**
        @type {GLenum}
        @name PicoGL.BUFFER_SIZE
        @private
     */
    BUFFER_SIZE: 0x8764,
    /**
        @type {GLenum}
        @name PicoGL.BUFFER_USAGE
        @private
     */
    BUFFER_USAGE: 0x8765,
    /**
        @type {GLenum}
        @name PicoGL.CURRENT_VERTEX_ATTRIB
        @private
     */
    CURRENT_VERTEX_ATTRIB: 0x8626,
    /**
        @type {GLenum}
        @name PicoGL.FRONT
        @private
     */
    FRONT: 0x0404,
    /**
        @type {GLenum}
        @name PicoGL.BACK
        @private
     */
    BACK: 0x0405,
    /**
        @type {GLenum}
        @name PicoGL.FRONT_AND_BACK
        @private
     */
    FRONT_AND_BACK: 0x0408,
    /**
        @type {GLenum}
        @name PicoGL.CULL_FACE
        @private
     */
    CULL_FACE: 0x0B44,
    /**
        @type {GLenum}
        @name PicoGL.BLEND
        @private
     */
    BLEND: 0x0BE2,
    /**
        @type {GLenum}
        @name PicoGL.DITHER
        @private
     */
    DITHER: 0x0BD0,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_TEST
        @private
     */
    STENCIL_TEST: 0x0B90,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_TEST
        @private
     */
    DEPTH_TEST: 0x0B71,
    /**
        @type {GLenum}
        @name PicoGL.SCISSOR_TEST
        @private
     */
    SCISSOR_TEST: 0x0C11,
    /**
        @type {GLenum}
        @name PicoGL.POLYGON_OFFSET_FILL
        @private
     */
    POLYGON_OFFSET_FILL: 0x8037,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLE_ALPHA_TO_COVERAGE
        @private
     */
    SAMPLE_ALPHA_TO_COVERAGE: 0x809E,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLE_COVERAGE
        @private
     */
    SAMPLE_COVERAGE: 0x80A0,
    /**
        @type {GLenum}
        @name PicoGL.NO_ERROR
        @private
     */
    NO_ERROR: 0,
    /**
        @type {GLenum}
        @name PicoGL.INVALID_ENUM
        @private
     */
    INVALID_ENUM: 0x0500,
    /**
        @type {GLenum}
        @name PicoGL.INVALID_VALUE
        @private
     */
    INVALID_VALUE: 0x0501,
    /**
        @type {GLenum}
        @name PicoGL.INVALID_OPERATION
        @private
     */
    INVALID_OPERATION: 0x0502,
    /**
        @type {GLenum}
        @name PicoGL.OUT_OF_MEMORY
        @private
     */
    OUT_OF_MEMORY: 0x0505,
    /**
        @type {GLenum}
        @name PicoGL.CW
        @private
     */
    CW: 0x0900,
    /**
        @type {GLenum}
        @name PicoGL.CCW
        @private
     */
    CCW: 0x0901,
    /**
        @type {GLenum}
        @name PicoGL.LINE_WIDTH
        @private
     */
    LINE_WIDTH: 0x0B21,
    /**
        @type {GLenum}
        @name PicoGL.ALIASED_POINT_SIZE_RANGE
        @private
     */
    ALIASED_POINT_SIZE_RANGE: 0x846D,
    /**
        @type {GLenum}
        @name PicoGL.ALIASED_LINE_WIDTH_RANGE
        @private
     */
    ALIASED_LINE_WIDTH_RANGE: 0x846E,
    /**
        @type {GLenum}
        @name PicoGL.CULL_FACE_MODE
        @private
     */
    CULL_FACE_MODE: 0x0B45,
    /**
        @type {GLenum}
        @name PicoGL.FRONT_FACE
        @private
     */
    FRONT_FACE: 0x0B46,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_RANGE
        @private
     */
    DEPTH_RANGE: 0x0B70,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_WRITEMASK
        @private
     */
    DEPTH_WRITEMASK: 0x0B72,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_CLEAR_VALUE
        @private
     */
    DEPTH_CLEAR_VALUE: 0x0B73,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_FUNC
        @private
     */
    DEPTH_FUNC: 0x0B74,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_CLEAR_VALUE
        @private
     */
    STENCIL_CLEAR_VALUE: 0x0B91,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_FUNC
        @private
     */
    STENCIL_FUNC: 0x0B92,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_FAIL
        @private
     */
    STENCIL_FAIL: 0x0B94,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_PASS_DEPTH_FAIL
        @private
     */
    STENCIL_PASS_DEPTH_FAIL: 0x0B95,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_PASS_DEPTH_PASS
        @private
     */
    STENCIL_PASS_DEPTH_PASS: 0x0B96,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_REF
        @private
     */
    STENCIL_REF: 0x0B97,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_VALUE_MASK
        @private
     */
    STENCIL_VALUE_MASK: 0x0B93,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_WRITEMASK
        @private
     */
    STENCIL_WRITEMASK: 0x0B98,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BACK_FUNC
        @private
     */
    STENCIL_BACK_FUNC: 0x8800,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BACK_FAIL
        @private
     */
    STENCIL_BACK_FAIL: 0x8801,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BACK_PASS_DEPTH_FAIL
        @private
     */
    STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BACK_PASS_DEPTH_PASS
        @private
     */
    STENCIL_BACK_PASS_DEPTH_PASS: 0x8803,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BACK_REF
        @private
     */
    STENCIL_BACK_REF: 0x8CA3,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BACK_VALUE_MASK
        @private
     */
    STENCIL_BACK_VALUE_MASK: 0x8CA4,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BACK_WRITEMASK
        @private
     */
    STENCIL_BACK_WRITEMASK: 0x8CA5,
    /**
        @type {GLenum}
        @name PicoGL.VIEWPORT
        @private
     */
    VIEWPORT: 0x0BA2,
    /**
        @type {GLenum}
        @name PicoGL.SCISSOR_BOX
        @private
     */
    SCISSOR_BOX: 0x0C10,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_CLEAR_VALUE
        @private
     */
    COLOR_CLEAR_VALUE: 0x0C22,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_WRITEMASK
        @private
     */
    COLOR_WRITEMASK: 0x0C23,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_ALIGNMENT
        @private
     */
    UNPACK_ALIGNMENT: 0x0CF5,
    /**
        @type {GLenum}
        @name PicoGL.PACK_ALIGNMENT
        @private
     */
    PACK_ALIGNMENT: 0x0D05,
    /**
        @type {GLenum}
        @name PicoGL.MAX_TEXTURE_SIZE
        @private
     */
    MAX_TEXTURE_SIZE: 0x0D33,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VIEWPORT_DIMS
        @private
     */
    MAX_VIEWPORT_DIMS: 0x0D3A,
    /**
        @type {GLenum}
        @name PicoGL.SUBPIXEL_BITS
        @private
     */
    SUBPIXEL_BITS: 0x0D50,
    /**
        @type {GLenum}
        @name PicoGL.RED_BITS
        @private
     */
    RED_BITS: 0x0D52,
    /**
        @type {GLenum}
        @name PicoGL.GREEN_BITS
        @private
     */
    GREEN_BITS: 0x0D53,
    /**
        @type {GLenum}
        @name PicoGL.BLUE_BITS
        @private
     */
    BLUE_BITS: 0x0D54,
    /**
        @type {GLenum}
        @name PicoGL.ALPHA_BITS
        @private
     */
    ALPHA_BITS: 0x0D55,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_BITS
        @private
     */
    DEPTH_BITS: 0x0D56,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BITS
        @private
     */
    STENCIL_BITS: 0x0D57,
    /**
        @type {GLenum}
        @name PicoGL.POLYGON_OFFSET_UNITS
        @private
     */
    POLYGON_OFFSET_UNITS: 0x2A00,
    /**
        @type {GLenum}
        @name PicoGL.POLYGON_OFFSET_FACTOR
        @private
     */
    POLYGON_OFFSET_FACTOR: 0x8038,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_BINDING_2D
        @private
     */
    TEXTURE_BINDING_2D: 0x8069,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLE_BUFFERS
        @private
     */
    SAMPLE_BUFFERS: 0x80A8,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLES
        @private
     */
    SAMPLES: 0x80A9,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLE_COVERAGE_VALUE
        @private
     */
    SAMPLE_COVERAGE_VALUE: 0x80AA,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLE_COVERAGE_INVERT
        @private
     */
    SAMPLE_COVERAGE_INVERT: 0x80AB,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_TEXTURE_FORMATS
        @private
     */
    COMPRESSED_TEXTURE_FORMATS: 0x86A3,
    /**
        @type {GLenum}
        @name PicoGL.DONT_CARE
        @private
     */
    DONT_CARE: 0x1100,
    /**
        @type {GLenum}
        @name PicoGL.FASTEST
        @private
     */
    FASTEST: 0x1101,
    /**
        @type {GLenum}
        @name PicoGL.NICEST
        @private
     */
    NICEST: 0x1102,
    /**
        @type {GLenum}
        @name PicoGL.GENERATE_MIPMAP_HINT
        @private
     */
    GENERATE_MIPMAP_HINT: 0x8192,
    /**
        @type {GLenum}
        @name PicoGL.BYTE
        @private
     */
    BYTE: 0x1400,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_BYTE
        @private
     */
    UNSIGNED_BYTE: 0x1401,
    /**
        @type {GLenum}
        @name PicoGL.SHORT
        @private
     */
    SHORT: 0x1402,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_SHORT
        @private
     */
    UNSIGNED_SHORT: 0x1403,
    /**
        @type {GLenum}
        @name PicoGL.INT
        @private
     */
    INT: 0x1404,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT
        @private
     */
    UNSIGNED_INT: 0x1405,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT
        @private
     */
    FLOAT: 0x1406,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_COMPONENT
        @private
     */
    DEPTH_COMPONENT: 0x1902,
    /**
        @type {GLenum}
        @name PicoGL.ALPHA
        @private
     */
    ALPHA: 0x1906,
    /**
        @type {GLenum}
        @name PicoGL.RGB
        @private
     */
    RGB: 0x1907,
    /**
        @type {GLenum}
        @name PicoGL.RGBA
        @private
     */
    RGBA: 0x1908,
    /**
        @type {GLenum}
        @name PicoGL.LUMINANCE
        @private
     */
    LUMINANCE: 0x1909,
    /**
        @type {GLenum}
        @name PicoGL.LUMINANCE_ALPHA
        @private
     */
    LUMINANCE_ALPHA: 0x190A,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_SHORT_4_4_4_4
        @private
     */
    UNSIGNED_SHORT_4_4_4_4: 0x8033,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_SHORT_5_5_5_1
        @private
     */
    UNSIGNED_SHORT_5_5_5_1: 0x8034,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_SHORT_5_6_5
        @private
     */
    UNSIGNED_SHORT_5_6_5: 0x8363,
    /**
        @type {GLenum}
        @name PicoGL.FRAGMENT_SHADER
        @private
     */
    FRAGMENT_SHADER: 0x8B30,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_SHADER
        @private
     */
    VERTEX_SHADER: 0x8B31,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VERTEX_ATTRIBS
        @private
     */
    MAX_VERTEX_ATTRIBS: 0x8869,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VERTEX_UNIFORM_VECTORS
        @private
     */
    MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VARYING_VECTORS
        @private
     */
    MAX_VARYING_VECTORS: 0x8DFC,
    /**
        @type {GLenum}
        @name PicoGL.MAX_COMBINED_TEXTURE_IMAGE_UNITS
        @private
     */
    MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VERTEX_TEXTURE_IMAGE_UNITS
        @private
     */
    MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C,
    /**
        @type {GLenum}
        @name PicoGL.MAX_TEXTURE_IMAGE_UNITS
        @private
     */
    MAX_TEXTURE_IMAGE_UNITS: 0x8872,
    /**
        @type {GLenum}
        @name PicoGL.MAX_FRAGMENT_UNIFORM_VECTORS
        @private
     */
    MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD,
    /**
        @type {GLenum}
        @name PicoGL.SHADER_TYPE
        @private
     */
    SHADER_TYPE: 0x8B4F,
    /**
        @type {GLenum}
        @name PicoGL.DELETE_STATUS
        @private
     */
    DELETE_STATUS: 0x8B80,
    /**
        @type {GLenum}
        @name PicoGL.LINK_STATUS
        @private
     */
    LINK_STATUS: 0x8B82,
    /**
        @type {GLenum}
        @name PicoGL.VALIDATE_STATUS
        @private
     */
    VALIDATE_STATUS: 0x8B83,
    /**
        @type {GLenum}
        @name PicoGL.ATTACHED_SHADERS
        @private
     */
    ATTACHED_SHADERS: 0x8B85,
    /**
        @type {GLenum}
        @name PicoGL.ACTIVE_UNIFORMS
        @private
     */
    ACTIVE_UNIFORMS: 0x8B86,
    /**
        @type {GLenum}
        @name PicoGL.ACTIVE_ATTRIBUTES
        @private
     */
    ACTIVE_ATTRIBUTES: 0x8B89,
    /**
        @type {GLenum}
        @name PicoGL.SHADING_LANGUAGE_VERSION
        @private
     */
    SHADING_LANGUAGE_VERSION: 0x8B8C,
    /**
        @type {GLenum}
        @name PicoGL.CURRENT_PROGRAM
        @private
     */
    CURRENT_PROGRAM: 0x8B8D,
    /**
        @type {GLenum}
        @name PicoGL.NEVER
        @private
     */
    NEVER: 0x0200,
    /**
        @type {GLenum}
        @name PicoGL.LESS
        @private
     */
    LESS: 0x0201,
    /**
        @type {GLenum}
        @name PicoGL.EQUAL
        @private
     */
    EQUAL: 0x0202,
    /**
        @type {GLenum}
        @name PicoGL.LEQUAL
        @private
     */
    LEQUAL: 0x0203,
    /**
        @type {GLenum}
        @name PicoGL.GREATER
        @private
     */
    GREATER: 0x0204,
    /**
        @type {GLenum}
        @name PicoGL.NOTEQUAL
        @private
     */
    NOTEQUAL: 0x0205,
    /**
        @type {GLenum}
        @name PicoGL.GEQUAL
        @private
     */
    GEQUAL: 0x0206,
    /**
        @type {GLenum}
        @name PicoGL.ALWAYS
        @private
     */
    ALWAYS: 0x0207,
    /**
        @type {GLenum}
        @name PicoGL.KEEP
        @private
     */
    KEEP: 0x1E00,
    /**
        @type {GLenum}
        @name PicoGL.REPLACE
        @private
     */
    REPLACE: 0x1E01,
    /**
        @type {GLenum}
        @name PicoGL.INCR
        @private
     */
    INCR: 0x1E02,
    /**
        @type {GLenum}
        @name PicoGL.DECR
        @private
     */
    DECR: 0x1E03,
    /**
        @type {GLenum}
        @name PicoGL.INVERT
        @private
     */
    INVERT: 0x150A,
    /**
        @type {GLenum}
        @name PicoGL.INCR_WRAP
        @private
     */
    INCR_WRAP: 0x8507,
    /**
        @type {GLenum}
        @name PicoGL.DECR_WRAP
        @private
     */
    DECR_WRAP: 0x8508,
    /**
        @type {GLenum}
        @name PicoGL.VENDOR
        @private
     */
    VENDOR: 0x1F00,
    /**
        @type {GLenum}
        @name PicoGL.RENDERER
        @private
     */
    RENDERER: 0x1F01,
    /**
        @type {GLenum}
        @name PicoGL.VERSION
        @private
     */
    VERSION: 0x1F02,
    /**
        @type {GLenum}
        @name PicoGL.NEAREST
        @private
     */
    NEAREST: 0x2600,
    /**
        @type {GLenum}
        @name PicoGL.LINEAR
        @private
     */
    LINEAR: 0x2601,
    /**
        @type {GLenum}
        @name PicoGL.NEAREST_MIPMAP_NEAREST
        @private
     */
    NEAREST_MIPMAP_NEAREST: 0x2700,
    /**
        @type {GLenum}
        @name PicoGL.LINEAR_MIPMAP_NEAREST
        @private
     */
    LINEAR_MIPMAP_NEAREST: 0x2701,
    /**
        @type {GLenum}
        @name PicoGL.NEAREST_MIPMAP_LINEAR
        @private
     */
    NEAREST_MIPMAP_LINEAR: 0x2702,
    /**
        @type {GLenum}
        @name PicoGL.LINEAR_MIPMAP_LINEAR
        @private
     */
    LINEAR_MIPMAP_LINEAR: 0x2703,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_MAG_FILTER
        @private
     */
    TEXTURE_MAG_FILTER: 0x2800,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_MIN_FILTER
        @private
     */
    TEXTURE_MIN_FILTER: 0x2801,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_WRAP_S
        @private
     */
    TEXTURE_WRAP_S: 0x2802,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_WRAP_T
        @private
     */
    TEXTURE_WRAP_T: 0x2803,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_2D
        @private
     */
    TEXTURE_2D: 0x0DE1,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE
        @private
     */
    TEXTURE: 0x1702,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_CUBE_MAP
        @private
     */
    TEXTURE_CUBE_MAP: 0x8513,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_BINDING_CUBE_MAP
        @private
     */
    TEXTURE_BINDING_CUBE_MAP: 0x8514,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_CUBE_MAP_POSITIVE_X
        @private
     */
    TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_CUBE_MAP_NEGATIVE_X
        @private
     */
    TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_CUBE_MAP_POSITIVE_Y
        @private
     */
    TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_CUBE_MAP_NEGATIVE_Y
        @private
     */
    TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_CUBE_MAP_POSITIVE_Z
        @private
     */
    TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_CUBE_MAP_NEGATIVE_Z
        @private
     */
    TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A,
    /**
        @type {GLenum}
        @name PicoGL.MAX_CUBE_MAP_TEXTURE_SIZE
        @private
     */
    MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE0
        @private
     */
    TEXTURE0: 0x84C0,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE1
        @private
     */
    TEXTURE1: 0x84C1,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE2
        @private
     */
    TEXTURE2: 0x84C2,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE3
        @private
     */
    TEXTURE3: 0x84C3,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE4
        @private
     */
    TEXTURE4: 0x84C4,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE5
        @private
     */
    TEXTURE5: 0x84C5,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE6
        @private
     */
    TEXTURE6: 0x84C6,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE7
        @private
     */
    TEXTURE7: 0x84C7,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE8
        @private
     */
    TEXTURE8: 0x84C8,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE9
        @private
     */
    TEXTURE9: 0x84C9,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE10
        @private
     */
    TEXTURE10: 0x84CA,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE11
        @private
     */
    TEXTURE11: 0x84CB,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE12
        @private
     */
    TEXTURE12: 0x84CC,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE13
        @private
     */
    TEXTURE13: 0x84CD,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE14
        @private
     */
    TEXTURE14: 0x84CE,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE15
        @private
     */
    TEXTURE15: 0x84CF,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE16
        @private
     */
    TEXTURE16: 0x84D0,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE17
        @private
     */
    TEXTURE17: 0x84D1,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE18
        @private
     */
    TEXTURE18: 0x84D2,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE19
        @private
     */
    TEXTURE19: 0x84D3,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE20
        @private
     */
    TEXTURE20: 0x84D4,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE21
        @private
     */
    TEXTURE21: 0x84D5,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE22
        @private
     */
    TEXTURE22: 0x84D6,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE23
        @private
     */
    TEXTURE23: 0x84D7,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE24
        @private
     */
    TEXTURE24: 0x84D8,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE25
        @private
     */
    TEXTURE25: 0x84D9,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE26
        @private
     */
    TEXTURE26: 0x84DA,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE27
        @private
     */
    TEXTURE27: 0x84DB,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE28
        @private
     */
    TEXTURE28: 0x84DC,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE29
        @private
     */
    TEXTURE29: 0x84DD,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE30
        @private
     */
    TEXTURE30: 0x84DE,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE31
        @private
     */
    TEXTURE31: 0x84DF,
    /**
        @type {GLenum}
        @name PicoGL.ACTIVE_TEXTURE
        @private
     */
    ACTIVE_TEXTURE: 0x84E0,
    /**
        @type {GLenum}
        @name PicoGL.REPEAT
        @private
     */
    REPEAT: 0x2901,
    /**
        @type {GLenum}
        @name PicoGL.CLAMP_TO_EDGE
        @private
     */
    CLAMP_TO_EDGE: 0x812F,
    /**
        @type {GLenum}
        @name PicoGL.MIRRORED_REPEAT
        @private
     */
    MIRRORED_REPEAT: 0x8370,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_VEC2
        @private
     */
    FLOAT_VEC2: 0x8B50,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_VEC3
        @private
     */
    FLOAT_VEC3: 0x8B51,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_VEC4
        @private
     */
    FLOAT_VEC4: 0x8B52,
    /**
        @type {GLenum}
        @name PicoGL.INT_VEC2
        @private
     */
    INT_VEC2: 0x8B53,
    /**
        @type {GLenum}
        @name PicoGL.INT_VEC3
        @private
     */
    INT_VEC3: 0x8B54,
    /**
        @type {GLenum}
        @name PicoGL.INT_VEC4
        @private
     */
    INT_VEC4: 0x8B55,
    /**
        @type {GLenum}
        @name PicoGL.BOOL
        @private
     */
    BOOL: 0x8B56,
    /**
        @type {GLenum}
        @name PicoGL.BOOL_VEC2
        @private
     */
    BOOL_VEC2: 0x8B57,
    /**
        @type {GLenum}
        @name PicoGL.BOOL_VEC3
        @private
     */
    BOOL_VEC3: 0x8B58,
    /**
        @type {GLenum}
        @name PicoGL.BOOL_VEC4
        @private
     */
    BOOL_VEC4: 0x8B59,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT2
        @private
     */
    FLOAT_MAT2: 0x8B5A,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT3
        @private
     */
    FLOAT_MAT3: 0x8B5B,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT4
        @private
     */
    FLOAT_MAT4: 0x8B5C,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLER_2D
        @private
     */
    SAMPLER_2D: 0x8B5E,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLER_CUBE
        @private
     */
    SAMPLER_CUBE: 0x8B60,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_ENABLED
        @private
     */
    VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_SIZE
        @private
     */
    VERTEX_ATTRIB_ARRAY_SIZE: 0x8623,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_STRIDE
        @private
     */
    VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_TYPE
        @private
     */
    VERTEX_ATTRIB_ARRAY_TYPE: 0x8625,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_NORMALIZED
        @private
     */
    VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_POINTER
        @private
     */
    VERTEX_ATTRIB_ARRAY_POINTER: 0x8645,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
        @private
     */
    VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F,
    /**
        @type {GLenum}
        @name PicoGL.IMPLEMENTATION_COLOR_READ_TYPE
        @private
     */
    IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A,
    /**
        @type {GLenum}
        @name PicoGL.IMPLEMENTATION_COLOR_READ_FORMAT
        @private
     */
    IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B,
    /**
        @type {GLenum}
        @name PicoGL.COMPILE_STATUS
        @private
     */
    COMPILE_STATUS: 0x8B81,
    /**
        @type {GLenum}
        @name PicoGL.LOW_FLOAT
        @private
     */
    LOW_FLOAT: 0x8DF0,
    /**
        @type {GLenum}
        @name PicoGL.MEDIUM_FLOAT
        @private
     */
    MEDIUM_FLOAT: 0x8DF1,
    /**
        @type {GLenum}
        @name PicoGL.HIGH_FLOAT
        @private
     */
    HIGH_FLOAT: 0x8DF2,
    /**
        @type {GLenum}
        @name PicoGL.LOW_INT
        @private
     */
    LOW_INT: 0x8DF3,
    /**
        @type {GLenum}
        @name PicoGL.MEDIUM_INT
        @private
     */
    MEDIUM_INT: 0x8DF4,
    /**
        @type {GLenum}
        @name PicoGL.HIGH_INT
        @private
     */
    HIGH_INT: 0x8DF5,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER
        @private
     */
    FRAMEBUFFER: 0x8D40,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER
        @private
     */
    RENDERBUFFER: 0x8D41,
    /**
        @type {GLenum}
        @name PicoGL.RGBA4
        @private
     */
    RGBA4: 0x8056,
    /**
        @type {GLenum}
        @name PicoGL.RGB5_A1
        @private
     */
    RGB5_A1: 0x8057,
    /**
        @type {GLenum}
        @name PicoGL.RGB565
        @private
     */
    RGB565: 0x8D62,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_COMPONENT16
        @private
     */
    DEPTH_COMPONENT16: 0x81A5,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_INDEX
        @private
     */
    STENCIL_INDEX: 0x1901,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_INDEX8
        @private
     */
    STENCIL_INDEX8: 0x8D48,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_STENCIL
        @private
     */
    DEPTH_STENCIL: 0x84F9,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_WIDTH
        @private
     */
    RENDERBUFFER_WIDTH: 0x8D42,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_HEIGHT
        @private
     */
    RENDERBUFFER_HEIGHT: 0x8D43,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_INTERNAL_FORMAT
        @private
     */
    RENDERBUFFER_INTERNAL_FORMAT: 0x8D44,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_RED_SIZE
        @private
     */
    RENDERBUFFER_RED_SIZE: 0x8D50,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_GREEN_SIZE
        @private
     */
    RENDERBUFFER_GREEN_SIZE: 0x8D51,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_BLUE_SIZE
        @private
     */
    RENDERBUFFER_BLUE_SIZE: 0x8D52,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_ALPHA_SIZE
        @private
     */
    RENDERBUFFER_ALPHA_SIZE: 0x8D53,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_DEPTH_SIZE
        @private
     */
    RENDERBUFFER_DEPTH_SIZE: 0x8D54,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_STENCIL_SIZE
        @private
     */
    RENDERBUFFER_STENCIL_SIZE: 0x8D55,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE
        @private
     */
    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME
        @private
     */
    FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL
        @private
     */
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE
        @private
     */
    FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT0
        @private
     */
    COLOR_ATTACHMENT0: 0x8CE0,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_ATTACHMENT
        @private
     */
    DEPTH_ATTACHMENT: 0x8D00,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_ATTACHMENT
        @private
     */
    STENCIL_ATTACHMENT: 0x8D20,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_STENCIL_ATTACHMENT
        @private
     */
    DEPTH_STENCIL_ATTACHMENT: 0x821A,
    /**
        @type {GLenum}
        @name PicoGL.NONE
        @private
     */
    NONE: 0,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_COMPLETE
        @private
     */
    FRAMEBUFFER_COMPLETE: 0x8CD5,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_INCOMPLETE_ATTACHMENT
        @private
     */
    FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT
        @private
     */
    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_INCOMPLETE_DIMENSIONS
        @private
     */
    FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_UNSUPPORTED
        @private
     */
    FRAMEBUFFER_UNSUPPORTED: 0x8CDD,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_BINDING
        @private
     */
    FRAMEBUFFER_BINDING: 0x8CA6,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_BINDING
        @private
     */
    RENDERBUFFER_BINDING: 0x8CA7,
    /**
        @type {GLenum}
        @name PicoGL.MAX_RENDERBUFFER_SIZE
        @private
     */
    MAX_RENDERBUFFER_SIZE: 0x84E8,
    /**
        @type {GLenum}
        @name PicoGL.INVALID_FRAMEBUFFER_OPERATION
        @private
     */
    INVALID_FRAMEBUFFER_OPERATION: 0x0506,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_FLIP_Y_WEBGL
        @private
     */
    UNPACK_FLIP_Y_WEBGL: 0x9240,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL
        @private
     */
    UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241,
    /**
        @type {GLenum}
        @name PicoGL.CONTEXT_LOST_WEBGL
        @private
     */
    CONTEXT_LOST_WEBGL: 0x9242,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_COLORSPACE_CONVERSION_WEBGL
        @private
     */
    UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243,
    /**
        @type {GLenum}
        @name PicoGL.BROWSER_DEFAULT_WEBGL
        @private
     */
    BROWSER_DEFAULT_WEBGL: 0x9244,
    /**
        @type {GLenum}
        @name PicoGL.READ_BUFFER
        @private
     */
    READ_BUFFER: 0x0C02,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_ROW_LENGTH
        @private
     */
    UNPACK_ROW_LENGTH: 0x0CF2,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_SKIP_ROWS
        @private
     */
    UNPACK_SKIP_ROWS: 0x0CF3,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_SKIP_PIXELS
        @private
     */
    UNPACK_SKIP_PIXELS: 0x0CF4,
    /**
        @type {GLenum}
        @name PicoGL.PACK_ROW_LENGTH
        @private
     */
    PACK_ROW_LENGTH: 0x0D02,
    /**
        @type {GLenum}
        @name PicoGL.PACK_SKIP_ROWS
        @private
     */
    PACK_SKIP_ROWS: 0x0D03,
    /**
        @type {GLenum}
        @name PicoGL.PACK_SKIP_PIXELS
        @private
     */
    PACK_SKIP_PIXELS: 0x0D04,
    /**
        @type {GLenum}
        @name PicoGL.COLOR
        @private
     */
    COLOR: 0x1800,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH
        @private
     */
    DEPTH: 0x1801,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL
        @private
     */
    STENCIL: 0x1802,
    /**
        @type {GLenum}
        @name PicoGL.RED
        @private
     */
    RED: 0x1903,
    /**
        @type {GLenum}
        @name PicoGL.RGB8
        @private
     */
    RGB8: 0x8051,
    /**
        @type {GLenum}
        @name PicoGL.RGBA8
        @private
     */
    RGBA8: 0x8058,
    /**
        @type {GLenum}
        @name PicoGL.RGB10_A2
        @private
     */
    RGB10_A2: 0x8059,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_BINDING_3D
        @private
     */
    TEXTURE_BINDING_3D: 0x806A,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_SKIP_IMAGES
        @private
     */
    UNPACK_SKIP_IMAGES: 0x806D,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_IMAGE_HEIGHT
        @private
     */
    UNPACK_IMAGE_HEIGHT: 0x806E,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_3D
        @private
     */
    TEXTURE_3D: 0x806F,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_WRAP_R
        @private
     */
    TEXTURE_WRAP_R: 0x8072,
    /**
        @type {GLenum}
        @name PicoGL.MAX_3D_TEXTURE_SIZE
        @private
     */
    MAX_3D_TEXTURE_SIZE: 0x8073,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_2_10_10_10_REV
        @private
     */
    UNSIGNED_INT_2_10_10_10_REV: 0x8368,
    /**
        @type {GLenum}
        @name PicoGL.MAX_ELEMENTS_VERTICES
        @private
     */
    MAX_ELEMENTS_VERTICES: 0x80E8,
    /**
        @type {GLenum}
        @name PicoGL.MAX_ELEMENTS_INDICES
        @private
     */
    MAX_ELEMENTS_INDICES: 0x80E9,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_MIN_LOD
        @private
     */
    TEXTURE_MIN_LOD: 0x813A,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_MAX_LOD
        @private
     */
    TEXTURE_MAX_LOD: 0x813B,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_BASE_LEVEL
        @private
     */
    TEXTURE_BASE_LEVEL: 0x813C,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_MAX_LEVEL
        @private
     */
    TEXTURE_MAX_LEVEL: 0x813D,
    /**
        @type {GLenum}
        @name PicoGL.MIN
        @private
     */
    MIN: 0x8007,
    /**
        @type {GLenum}
        @name PicoGL.MAX
        @private
     */
    MAX: 0x8008,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_COMPONENT24
        @private
     */
    DEPTH_COMPONENT24: 0x81A6,
    /**
        @type {GLenum}
        @name PicoGL.MAX_TEXTURE_LOD_BIAS
        @private
     */
    MAX_TEXTURE_LOD_BIAS: 0x84FD,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_COMPARE_MODE
        @private
     */
    TEXTURE_COMPARE_MODE: 0x884C,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_COMPARE_FUNC
        @private
     */
    TEXTURE_COMPARE_FUNC: 0x884D,
    /**
        @type {GLenum}
        @name PicoGL.CURRENT_QUERY
        @private
     */
    CURRENT_QUERY: 0x8865,
    /**
        @type {GLenum}
        @name PicoGL.QUERY_RESULT
        @private
     */
    QUERY_RESULT: 0x8866,
    /**
        @type {GLenum}
        @name PicoGL.QUERY_RESULT_AVAILABLE
        @private
     */
    QUERY_RESULT_AVAILABLE: 0x8867,
    /**
        @type {GLenum}
        @name PicoGL.STREAM_READ
        @private
     */
    STREAM_READ: 0x88E1,
    /**
        @type {GLenum}
        @name PicoGL.STREAM_COPY
        @private
     */
    STREAM_COPY: 0x88E2,
    /**
        @type {GLenum}
        @name PicoGL.STATIC_READ
        @private
     */
    STATIC_READ: 0x88E5,
    /**
        @type {GLenum}
        @name PicoGL.STATIC_COPY
        @private
     */
    STATIC_COPY: 0x88E6,
    /**
        @type {GLenum}
        @name PicoGL.DYNAMIC_READ
        @private
     */
    DYNAMIC_READ: 0x88E9,
    /**
        @type {GLenum}
        @name PicoGL.DYNAMIC_COPY
        @private
     */
    DYNAMIC_COPY: 0x88EA,
    /**
        @type {GLenum}
        @name PicoGL.MAX_DRAW_BUFFERS
        @private
     */
    MAX_DRAW_BUFFERS: 0x8824,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER0
        @private
     */
    DRAW_BUFFER0: 0x8825,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER1
        @private
     */
    DRAW_BUFFER1: 0x8826,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER2
        @private
     */
    DRAW_BUFFER2: 0x8827,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER3
        @private
     */
    DRAW_BUFFER3: 0x8828,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER4
        @private
     */
    DRAW_BUFFER4: 0x8829,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER5
        @private
     */
    DRAW_BUFFER5: 0x882A,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER6
        @private
     */
    DRAW_BUFFER6: 0x882B,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER7
        @private
     */
    DRAW_BUFFER7: 0x882C,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER8
        @private
     */
    DRAW_BUFFER8: 0x882D,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER9
        @private
     */
    DRAW_BUFFER9: 0x882E,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER10
        @private
     */
    DRAW_BUFFER10: 0x882F,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER11
        @private
     */
    DRAW_BUFFER11: 0x8830,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER12
        @private
     */
    DRAW_BUFFER12: 0x8831,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER13
        @private
     */
    DRAW_BUFFER13: 0x8832,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER14
        @private
     */
    DRAW_BUFFER14: 0x8833,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER15
        @private
     */
    DRAW_BUFFER15: 0x8834,
    /**
        @type {GLenum}
        @name PicoGL.MAX_FRAGMENT_UNIFORM_COMPONENTS
        @private
     */
    MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8B49,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VERTEX_UNIFORM_COMPONENTS
        @private
     */
    MAX_VERTEX_UNIFORM_COMPONENTS: 0x8B4A,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLER_3D
        @private
     */
    SAMPLER_3D: 0x8B5F,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLER_2D_SHADOW
        @private
     */
    SAMPLER_2D_SHADOW: 0x8B62,
    /**
        @type {GLenum}
        @name PicoGL.FRAGMENT_SHADER_DERIVATIVE_HINT
        @private
     */
    FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8B8B,
    /**
        @type {GLenum}
        @name PicoGL.PIXEL_PACK_BUFFER
        @private
     */
    PIXEL_PACK_BUFFER: 0x88EB,
    /**
        @type {GLenum}
        @name PicoGL.PIXEL_UNPACK_BUFFER
        @private
     */
    PIXEL_UNPACK_BUFFER: 0x88EC,
    /**
        @type {GLenum}
        @name PicoGL.PIXEL_PACK_BUFFER_BINDING
        @private
     */
    PIXEL_PACK_BUFFER_BINDING: 0x88ED,
    /**
        @type {GLenum}
        @name PicoGL.PIXEL_UNPACK_BUFFER_BINDING
        @private
     */
    PIXEL_UNPACK_BUFFER_BINDING: 0x88EF,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT2x3
        @private
     */
    FLOAT_MAT2x3: 0x8B65,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT2x4
        @private
     */
    FLOAT_MAT2x4: 0x8B66,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT3x2
        @private
     */
    FLOAT_MAT3x2: 0x8B67,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT3x4
        @private
     */
    FLOAT_MAT3x4: 0x8B68,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT4x2
        @private
     */
    FLOAT_MAT4x2: 0x8B69,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT4x3
        @private
     */
    FLOAT_MAT4x3: 0x8B6A,
    /**
        @type {GLenum}
        @name PicoGL.SRGB
        @private
     */
    SRGB: 0x8C40,
    /**
        @type {GLenum}
        @name PicoGL.SRGB8
        @private
     */
    SRGB8: 0x8C41,
    /**
        @type {GLenum}
        @name PicoGL.SRGB8_ALPHA8
        @private
     */
    SRGB8_ALPHA8: 0x8C43,
    /**
        @type {GLenum}
        @name PicoGL.COMPARE_REF_TO_TEXTURE
        @private
     */
    COMPARE_REF_TO_TEXTURE: 0x884E,
    /**
        @type {GLenum}
        @name PicoGL.RGBA32F
        @private
     */
    RGBA32F: 0x8814,
    /**
        @type {GLenum}
        @name PicoGL.RGB32F
        @private
     */
    RGB32F: 0x8815,
    /**
        @type {GLenum}
        @name PicoGL.RGBA16F
        @private
     */
    RGBA16F: 0x881A,
    /**
        @type {GLenum}
        @name PicoGL.RGB16F
        @private
     */
    RGB16F: 0x881B,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_INTEGER
        @private
     */
    VERTEX_ATTRIB_ARRAY_INTEGER: 0x88FD,
    /**
        @type {GLenum}
        @name PicoGL.MAX_ARRAY_TEXTURE_LAYERS
        @private
     */
    MAX_ARRAY_TEXTURE_LAYERS: 0x88FF,
    /**
        @type {GLenum}
        @name PicoGL.MIN_PROGRAM_TEXEL_OFFSET
        @private
     */
    MIN_PROGRAM_TEXEL_OFFSET: 0x8904,
    /**
        @type {GLenum}
        @name PicoGL.MAX_PROGRAM_TEXEL_OFFSET
        @private
     */
    MAX_PROGRAM_TEXEL_OFFSET: 0x8905,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VARYING_COMPONENTS
        @private
     */
    MAX_VARYING_COMPONENTS: 0x8B4B,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_2D_ARRAY
        @private
     */
    TEXTURE_2D_ARRAY: 0x8C1A,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_BINDING_2D_ARRAY
        @private
     */
    TEXTURE_BINDING_2D_ARRAY: 0x8C1D,
    /**
        @type {GLenum}
        @name PicoGL.R11F_G11F_B10F
        @private
     */
    R11F_G11F_B10F: 0x8C3A,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_10F_11F_11F_REV
        @private
     */
    UNSIGNED_INT_10F_11F_11F_REV: 0x8C3B,
    /**
        @type {GLenum}
        @name PicoGL.RGB9_E5
        @private
     */
    RGB9_E5: 0x8C3D,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_5_9_9_9_REV
        @private
     */
    UNSIGNED_INT_5_9_9_9_REV: 0x8C3E,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_BUFFER_MODE
        @private
     */
    TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8C7F,
    /**
        @type {GLenum}
        @name PicoGL.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
        @private
     */
    MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8C80,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_VARYINGS
        @private
     */
    TRANSFORM_FEEDBACK_VARYINGS: 0x8C83,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_BUFFER_START
        @private
     */
    TRANSFORM_FEEDBACK_BUFFER_START: 0x8C84,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_BUFFER_SIZE
        @private
     */
    TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8C85,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
        @private
     */
    TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8C88,
    /**
        @type {GLenum}
        @name PicoGL.RASTERIZER_DISCARD
        @private
     */
    RASTERIZER_DISCARD: 0x8C89,
    /**
        @type {GLenum}
        @name PicoGL.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS
        @private
     */
    MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8C8A,
    /**
        @type {GLenum}
        @name PicoGL.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS
        @private
     */
    MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8C8B,
    /**
        @type {GLenum}
        @name PicoGL.INTERLEAVED_ATTRIBS
        @private
     */
    INTERLEAVED_ATTRIBS: 0x8C8C,
    /**
        @type {GLenum}
        @name PicoGL.SEPARATE_ATTRIBS
        @private
     */
    SEPARATE_ATTRIBS: 0x8C8D,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_BUFFER
        @private
     */
    TRANSFORM_FEEDBACK_BUFFER: 0x8C8E,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_BUFFER_BINDING
        @private
     */
    TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8C8F,
    /**
        @type {GLenum}
        @name PicoGL.RGBA32UI
        @private
     */
    RGBA32UI: 0x8D70,
    /**
        @type {GLenum}
        @name PicoGL.RGB32UI
        @private
     */
    RGB32UI: 0x8D71,
    /**
        @type {GLenum}
        @name PicoGL.RGBA16UI
        @private
     */
    RGBA16UI: 0x8D76,
    /**
        @type {GLenum}
        @name PicoGL.RGB16UI
        @private
     */
    RGB16UI: 0x8D77,
    /**
        @type {GLenum}
        @name PicoGL.RGBA8UI
        @private
     */
    RGBA8UI: 0x8D7C,
    /**
        @type {GLenum}
        @name PicoGL.RGB8UI
        @private
     */
    RGB8UI: 0x8D7D,
    /**
        @type {GLenum}
        @name PicoGL.RGBA32I
        @private
     */
    RGBA32I: 0x8D82,
    /**
        @type {GLenum}
        @name PicoGL.RGB32I
        @private
     */
    RGB32I: 0x8D83,
    /**
        @type {GLenum}
        @name PicoGL.RGBA16I
        @private
     */
    RGBA16I: 0x8D88,
    /**
        @type {GLenum}
        @name PicoGL.RGB16I
        @private
     */
    RGB16I: 0x8D89,
    /**
        @type {GLenum}
        @name PicoGL.RGBA8I
        @private
     */
    RGBA8I: 0x8D8E,
    /**
        @type {GLenum}
        @name PicoGL.RGB8I
        @private
     */
    RGB8I: 0x8D8F,
    /**
        @type {GLenum}
        @name PicoGL.RED_INTEGER
        @private
     */
    RED_INTEGER: 0x8D94,
    /**
        @type {GLenum}
        @name PicoGL.RGB_INTEGER
        @private
     */
    RGB_INTEGER: 0x8D98,
    /**
        @type {GLenum}
        @name PicoGL.RGBA_INTEGER
        @private
     */
    RGBA_INTEGER: 0x8D99,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLER_2D_ARRAY
        @private
     */
    SAMPLER_2D_ARRAY: 0x8DC1,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLER_2D_ARRAY_SHADOW
        @private
     */
    SAMPLER_2D_ARRAY_SHADOW: 0x8DC4,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLER_CUBE_SHADOW
        @private
     */
    SAMPLER_CUBE_SHADOW: 0x8DC5,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_VEC2
        @private
     */
    UNSIGNED_INT_VEC2: 0x8DC6,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_VEC3
        @private
     */
    UNSIGNED_INT_VEC3: 0x8DC7,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_VEC4
        @private
     */
    UNSIGNED_INT_VEC4: 0x8DC8,
    /**
        @type {GLenum}
        @name PicoGL.INT_SAMPLER_2D
        @private
     */
    INT_SAMPLER_2D: 0x8DCA,
    /**
        @type {GLenum}
        @name PicoGL.INT_SAMPLER_3D
        @private
     */
    INT_SAMPLER_3D: 0x8DCB,
    /**
        @type {GLenum}
        @name PicoGL.INT_SAMPLER_CUBE
        @private
     */
    INT_SAMPLER_CUBE: 0x8DCC,
    /**
        @type {GLenum}
        @name PicoGL.INT_SAMPLER_2D_ARRAY
        @private
     */
    INT_SAMPLER_2D_ARRAY: 0x8DCF,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_SAMPLER_2D
        @private
     */
    UNSIGNED_INT_SAMPLER_2D: 0x8DD2,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_SAMPLER_3D
        @private
     */
    UNSIGNED_INT_SAMPLER_3D: 0x8DD3,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_SAMPLER_CUBE
        @private
     */
    UNSIGNED_INT_SAMPLER_CUBE: 0x8DD4,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_SAMPLER_2D_ARRAY
        @private
     */
    UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8DD7,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_COMPONENT32F
        @private
     */
    DEPTH_COMPONENT32F: 0x8CAC,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH32F_STENCIL8
        @private
     */
    DEPTH32F_STENCIL8: 0x8CAD,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_32_UNSIGNED_INT_24_8_REV
        @private
     */
    FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8DAD,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING
        @private
     */
    FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE
        @private
     */
    FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_RED_SIZE
        @private
     */
    FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE
        @private
     */
    FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE
        @private
     */
    FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE
        @private
     */
    FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE
        @private
     */
    FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE
        @private
     */
    FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_DEFAULT
        @private
     */
    FRAMEBUFFER_DEFAULT: 0x8218,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_24_8
        @private
     */
    UNSIGNED_INT_24_8: 0x84FA,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH24_STENCIL8
        @private
     */
    DEPTH24_STENCIL8: 0x88F0,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_NORMALIZED
        @private
     */
    UNSIGNED_NORMALIZED: 0x8C17,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_FRAMEBUFFER_BINDING
        @private
     */
    DRAW_FRAMEBUFFER_BINDING: 0x8CA6,
    /**
        @type {GLenum}
        @name PicoGL.READ_FRAMEBUFFER
        @private
     */
    READ_FRAMEBUFFER: 0x8CA8,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_FRAMEBUFFER
        @private
     */
    DRAW_FRAMEBUFFER: 0x8CA9,
    /**
        @type {GLenum}
        @name PicoGL.READ_FRAMEBUFFER_BINDING
        @private
     */
    READ_FRAMEBUFFER_BINDING: 0x8CAA,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_SAMPLES
        @private
     */
    RENDERBUFFER_SAMPLES: 0x8CAB,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER
        @private
     */
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8CD4,
    /**
        @type {GLenum}
        @name PicoGL.MAX_COLOR_ATTACHMENTS
        @private
     */
    MAX_COLOR_ATTACHMENTS: 0x8CDF,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT1
        @private
     */
    COLOR_ATTACHMENT1: 0x8CE1,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT2
        @private
     */
    COLOR_ATTACHMENT2: 0x8CE2,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT3
        @private
     */
    COLOR_ATTACHMENT3: 0x8CE3,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT4
        @private
     */
    COLOR_ATTACHMENT4: 0x8CE4,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT5
        @private
     */
    COLOR_ATTACHMENT5: 0x8CE5,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT6
        @private
     */
    COLOR_ATTACHMENT6: 0x8CE6,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT7
        @private
     */
    COLOR_ATTACHMENT7: 0x8CE7,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT8
        @private
     */
    COLOR_ATTACHMENT8: 0x8CE8,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT9
        @private
     */
    COLOR_ATTACHMENT9: 0x8CE9,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT10
        @private
     */
    COLOR_ATTACHMENT10: 0x8CEA,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT11
        @private
     */
    COLOR_ATTACHMENT11: 0x8CEB,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT12
        @private
     */
    COLOR_ATTACHMENT12: 0x8CEC,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT13
        @private
     */
    COLOR_ATTACHMENT13: 0x8CED,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT14
        @private
     */
    COLOR_ATTACHMENT14: 0x8CEE,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT15
        @private
     */
    COLOR_ATTACHMENT15: 0x8CEF,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE
        @private
     */
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8D56,
    /**
        @type {GLenum}
        @name PicoGL.MAX_SAMPLES
        @private
     */
    MAX_SAMPLES: 0x8D57,
    /**
        @type {GLenum}
        @name PicoGL.HALF_FLOAT
        @private
     */
    HALF_FLOAT: 0x140B,
    /**
        @type {GLenum}
        @name PicoGL.RG
        @private
     */
    RG: 0x8227,
    /**
        @type {GLenum}
        @name PicoGL.RG_INTEGER
        @private
     */
    RG_INTEGER: 0x8228,
    /**
        @type {GLenum}
        @name PicoGL.R8
        @private
     */
    R8: 0x8229,
    /**
        @type {GLenum}
        @name PicoGL.RG8
        @private
     */
    RG8: 0x822B,
    /**
        @type {GLenum}
        @name PicoGL.R16F
        @private
     */
    R16F: 0x822D,
    /**
        @type {GLenum}
        @name PicoGL.R32F
        @private
     */
    R32F: 0x822E,
    /**
        @type {GLenum}
        @name PicoGL.RG16F
        @private
     */
    RG16F: 0x822F,
    /**
        @type {GLenum}
        @name PicoGL.RG32F
        @private
     */
    RG32F: 0x8230,
    /**
        @type {GLenum}
        @name PicoGL.R8I
        @private
     */
    R8I: 0x8231,
    /**
        @type {GLenum}
        @name PicoGL.R8UI
        @private
     */
    R8UI: 0x8232,
    /**
        @type {GLenum}
        @name PicoGL.R16I
        @private
     */
    R16I: 0x8233,
    /**
        @type {GLenum}
        @name PicoGL.R16UI
        @private
     */
    R16UI: 0x8234,
    /**
        @type {GLenum}
        @name PicoGL.R32I
        @private
     */
    R32I: 0x8235,
    /**
        @type {GLenum}
        @name PicoGL.R32UI
        @private
     */
    R32UI: 0x8236,
    /**
        @type {GLenum}
        @name PicoGL.RG8I
        @private
     */
    RG8I: 0x8237,
    /**
        @type {GLenum}
        @name PicoGL.RG8UI
        @private
     */
    RG8UI: 0x8238,
    /**
        @type {GLenum}
        @name PicoGL.RG16I
        @private
     */
    RG16I: 0x8239,
    /**
        @type {GLenum}
        @name PicoGL.RG16UI
        @private
     */
    RG16UI: 0x823A,
    /**
        @type {GLenum}
        @name PicoGL.RG32I
        @private
     */
    RG32I: 0x823B,
    /**
        @type {GLenum}
        @name PicoGL.RG32UI
        @private
     */
    RG32UI: 0x823C,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ARRAY_BINDING
        @private
     */
    VERTEX_ARRAY_BINDING: 0x85B5,
    /**
        @type {GLenum}
        @name PicoGL.R8_SNORM
        @private
     */
    R8_SNORM: 0x8F94,
    /**
        @type {GLenum}
        @name PicoGL.RG8_SNORM
        @private
     */
    RG8_SNORM: 0x8F95,
    /**
        @type {GLenum}
        @name PicoGL.RGB8_SNORM
        @private
     */
    RGB8_SNORM: 0x8F96,
    /**
        @type {GLenum}
        @name PicoGL.RGBA8_SNORM
        @private
     */
    RGBA8_SNORM: 0x8F97,
    /**
        @type {GLenum}
        @name PicoGL.SIGNED_NORMALIZED
        @private
     */
    SIGNED_NORMALIZED: 0x8F9C,
    /**
        @type {GLenum}
        @name PicoGL.COPY_READ_BUFFER
        @private
     */
    COPY_READ_BUFFER: 0x8F36,
    /**
        @type {GLenum}
        @name PicoGL.COPY_WRITE_BUFFER
        @private
     */
    COPY_WRITE_BUFFER: 0x8F37,
    /**
        @type {GLenum}
        @name PicoGL.COPY_READ_BUFFER_BINDING
        @private
     */
    COPY_READ_BUFFER_BINDING: 0x8F36,
    /**
        @type {GLenum}
        @name PicoGL.COPY_WRITE_BUFFER_BINDING
        @private
     */
    COPY_WRITE_BUFFER_BINDING: 0x8F37,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BUFFER
        @private
     */
    UNIFORM_BUFFER: 0x8A11,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BUFFER_BINDING
        @private
     */
    UNIFORM_BUFFER_BINDING: 0x8A28,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BUFFER_START
        @private
     */
    UNIFORM_BUFFER_START: 0x8A29,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BUFFER_SIZE
        @private
     */
    UNIFORM_BUFFER_SIZE: 0x8A2A,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VERTEX_UNIFORM_BLOCKS
        @private
     */
    MAX_VERTEX_UNIFORM_BLOCKS: 0x8A2B,
    /**
        @type {GLenum}
        @name PicoGL.MAX_FRAGMENT_UNIFORM_BLOCKS
        @private
     */
    MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8A2D,
    /**
        @type {GLenum}
        @name PicoGL.MAX_COMBINED_UNIFORM_BLOCKS
        @private
     */
    MAX_COMBINED_UNIFORM_BLOCKS: 0x8A2E,
    /**
        @type {GLenum}
        @name PicoGL.MAX_UNIFORM_BUFFER_BINDINGS
        @private
     */
    MAX_UNIFORM_BUFFER_BINDINGS: 0x8A2F,
    /**
        @type {GLenum}
        @name PicoGL.MAX_UNIFORM_BLOCK_SIZE
        @private
     */
    MAX_UNIFORM_BLOCK_SIZE: 0x8A30,
    /**
        @type {GLenum}
        @name PicoGL.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS
        @private
     */
    MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8A31,
    /**
        @type {GLenum}
        @name PicoGL.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS
        @private
     */
    MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8A33,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BUFFER_OFFSET_ALIGNMENT
        @private
     */
    UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8A34,
    /**
        @type {GLenum}
        @name PicoGL.ACTIVE_UNIFORM_BLOCKS
        @private
     */
    ACTIVE_UNIFORM_BLOCKS: 0x8A36,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_TYPE
        @private
     */
    UNIFORM_TYPE: 0x8A37,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_SIZE
        @private
     */
    UNIFORM_SIZE: 0x8A38,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BLOCK_INDEX
        @private
     */
    UNIFORM_BLOCK_INDEX: 0x8A3A,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_OFFSET
        @private
     */
    UNIFORM_OFFSET: 0x8A3B,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_ARRAY_STRIDE
        @private
     */
    UNIFORM_ARRAY_STRIDE: 0x8A3C,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_MATRIX_STRIDE
        @private
     */
    UNIFORM_MATRIX_STRIDE: 0x8A3D,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_IS_ROW_MAJOR
        @private
     */
    UNIFORM_IS_ROW_MAJOR: 0x8A3E,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BLOCK_BINDING
        @private
     */
    UNIFORM_BLOCK_BINDING: 0x8A3F,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BLOCK_DATA_SIZE
        @private
     */
    UNIFORM_BLOCK_DATA_SIZE: 0x8A40,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BLOCK_ACTIVE_UNIFORMS
        @private
     */
    UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8A42,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES
        @private
     */
    UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8A43,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER
        @private
     */
    UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8A44,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER
        @private
     */
    UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8A46,
    /**
        @type {GLenum}
        @name PicoGL.INVALID_INDEX
        @private
     */
    INVALID_INDEX: 0xFFFFFFFF,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VERTEX_OUTPUT_COMPONENTS
        @private
     */
    MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122,
    /**
        @type {GLenum}
        @name PicoGL.MAX_FRAGMENT_INPUT_COMPONENTS
        @private
     */
    MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125,
    /**
        @type {GLenum}
        @name PicoGL.MAX_SERVER_WAIT_TIMEOUT
        @private
     */
    MAX_SERVER_WAIT_TIMEOUT: 0x9111,
    /**
        @type {GLenum}
        @name PicoGL.OBJECT_TYPE
        @private
     */
    OBJECT_TYPE: 0x9112,
    /**
        @type {GLenum}
        @name PicoGL.SYNC_CONDITION
        @private
     */
    SYNC_CONDITION: 0x9113,
    /**
        @type {GLenum}
        @name PicoGL.SYNC_STATUS
        @private
     */
    SYNC_STATUS: 0x9114,
    /**
        @type {GLenum}
        @name PicoGL.SYNC_FLAGS
        @private
     */
    SYNC_FLAGS: 0x9115,
    /**
        @type {GLenum}
        @name PicoGL.SYNC_FENCE
        @private
     */
    SYNC_FENCE: 0x9116,
    /**
        @type {GLenum}
        @name PicoGL.SYNC_GPU_COMMANDS_COMPLETE
        @private
     */
    SYNC_GPU_COMMANDS_COMPLETE: 0x9117,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNALED
        @private
     */
    UNSIGNALED: 0x9118,
    /**
        @type {GLenum}
        @name PicoGL.SIGNALED
        @private
     */
    SIGNALED: 0x9119,
    /**
        @type {GLenum}
        @name PicoGL.ALREADY_SIGNALED
        @private
     */
    ALREADY_SIGNALED: 0x911A,
    /**
        @type {GLenum}
        @name PicoGL.TIMEOUT_EXPIRED
        @private
     */
    TIMEOUT_EXPIRED: 0x911B,
    /**
        @type {GLenum}
        @name PicoGL.CONDITION_SATISFIED
        @private
     */
    CONDITION_SATISFIED: 0x911C,
    /**
        @type {GLenum}
        @name PicoGL.WAIT_FAILED
        @private
     */
    WAIT_FAILED: 0x911D,
    /**
        @type {GLenum}
        @name PicoGL.SYNC_FLUSH_COMMANDS_BIT
        @private
     */
    SYNC_FLUSH_COMMANDS_BIT: 0x00000001,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_DIVISOR
        @private
     */
    VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88FE,
    /**
        @type {GLenum}
        @name PicoGL.ANY_SAMPLES_PASSED
        @private
     */
    ANY_SAMPLES_PASSED: 0x8C2F,
    /**
        @type {GLenum}
        @name PicoGL.ANY_SAMPLES_PASSED_CONSERVATIVE
        @private
     */
    ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8D6A,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLER_BINDING
        @private
     */
    SAMPLER_BINDING: 0x8919,
    /**
        @type {GLenum}
        @name PicoGL.RGB10_A2UI
        @private
     */
    RGB10_A2UI: 0x906F,
    /**
        @type {GLenum}
        @name PicoGL.INT_2_10_10_10_REV
        @private
     */
    INT_2_10_10_10_REV: 0x8D9F,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK
        @private
     */
    TRANSFORM_FEEDBACK: 0x8E22,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_PAUSED
        @private
     */
    TRANSFORM_FEEDBACK_PAUSED: 0x8E23,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_ACTIVE
        @private
     */
    TRANSFORM_FEEDBACK_ACTIVE: 0x8E24,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_BINDING
        @private
     */
    TRANSFORM_FEEDBACK_BINDING: 0x8E25,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_IMMUTABLE_FORMAT
        @private
     */
    TEXTURE_IMMUTABLE_FORMAT: 0x912F,
    /**
        @type {GLenum}
        @name PicoGL.MAX_ELEMENT_INDEX
        @private
     */
    MAX_ELEMENT_INDEX: 0x8D6B,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_IMMUTABLE_LEVELS
        @private
     */
    TEXTURE_IMMUTABLE_LEVELS: 0x82DF,
    /**
        @type {GLenum}
        @name PicoGL.TIMEOUT_IGNORED
        @private
     */
    TIMEOUT_IGNORED: -1,
    /**
        @type {GLenum}
        @name PicoGL.MAX_CLIENT_WAIT_TIMEOUT_WEBGL
        @private
     */
    MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 0x9247,

    // https://www.khronos.org/registry/webgl/extensions/EXT_disjoint_timer_query_webgl2/
    /**
        @type {GLenum}
        @name PicoGL.QUERY_COUNTER_BITS_EXT
        @private
     */
    QUERY_COUNTER_BITS_EXT: 0x8864,
    /**
        @type {GLenum}
        @name PicoGL.TIME_ELAPSED_EXT
        @private
     */
    TIME_ELAPSED_EXT: 0x88BF,
    /**
        @type {GLenum}
        @name PicoGL.TIMESTAMP_EXT
        @private
     */
    TIMESTAMP_EXT: 0x8E28,
    /**
        @type {GLenum}
        @name PicoGL.GPU_DISJOINT_EXT
        @private
     */
    GPU_DISJOINT_EXT: 0x8FBB,

    // https://www.khronos.org/registry/webgl/extensions/EXT_texture_filter_anisotropic/
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_MAX_ANISOTROPY_EXT
        @private
     */
    TEXTURE_MAX_ANISOTROPY_EXT: 0x84FE,
    /**
        @type {GLenum}
        @name PicoGL.MAX_TEXTURE_MAX_ANISOTROPY_EXT
        @private
     */
    MAX_TEXTURE_MAX_ANISOTROPY_EXT: 0x84FF,

    // https://www.khronos.org/registry/webgl/extensions/WEBGL_debug_renderer_info/
    /**
        @type {GLenum}
        @name PicoGL.UNMASKED_VENDOR_WEBGL
        @private
     */
    UNMASKED_VENDOR_WEBGL: 0x9245,
    /**
        @type {GLenum}
        @name PicoGL.UNMASKED_RENDERER_WEBGL
        @private
     */
    UNMASKED_RENDERER_WEBGL: 0x9246,

    // https://www.khronos.org/registry/webgl/extensions/KHR_parallel_shader_compile/
    /**
        @type {GLenum}
        @name PicoGL.COMPLETION_STATUS_KHR
        @private
     */
    COMPLETION_STATUS_KHR: 0x91B1,

    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGB_S3TC_DXT1_EXT
        @private
     */
    COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83F0,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_S3TC_DXT1_EXT
        @private
     */
    COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83F1,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_S3TC_DXT3_EXT
        @private
     */
    COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83F2,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_S3TC_DXT5_EXT
        @private
     */
    COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83F3,

    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB_S3TC_DXT1_EXT
        @private
     */
    COMPRESSED_SRGB_S3TC_DXT1_EXT: 0x8C4C,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT
        @private
     */
    COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 0x8C4D,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT
        @private
     */
    COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 0x8C4E,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
        @private
     */
    COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 0x8C4F,

    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_R11_EAC
        @private
     */
    COMPRESSED_R11_EAC: 0x9270,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SIGNED_R11_EAC
        @private
     */
    COMPRESSED_SIGNED_R11_EAC: 0x9271,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RG11_EAC
        @private
     */
    COMPRESSED_RG11_EAC: 0x9272,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SIGNED_RG11_EAC
        @private
     */
    COMPRESSED_SIGNED_RG11_EAC: 0x9273,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGB8_ETC2
        @private
     */
    COMPRESSED_RGB8_ETC2: 0x9274,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ETC2
        @private
     */
    COMPRESSED_SRGB8_ETC2: 0x9275,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2
        @private
     */
    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9276,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2
        @private
     */
    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9277,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA8_ETC2_EAC
        @private
     */
    COMPRESSED_RGBA8_ETC2_EAC: 0x9278,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
        @private
     */
    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9279,

    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
        @private
     */
    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8C00,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
        @private
     */
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8C01,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
        @private
     */
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8C02,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
        @private
     */
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8C03,

    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_4x4_KHR
        @private
     */
    COMPRESSED_RGBA_ASTC_4x4_KHR: 0x93B0,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_5x4_KHR
        @private
     */
    COMPRESSED_RGBA_ASTC_5x4_KHR: 0x93B1,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_5x5_KHR
        @private
     */
    COMPRESSED_RGBA_ASTC_5x5_KHR: 0x93B2,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_6x5_KHR
        @private
     */
    COMPRESSED_RGBA_ASTC_6x5_KHR: 0x93B3,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_6x6_KHR
        @private
     */
    COMPRESSED_RGBA_ASTC_6x6_KHR: 0x93B4,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_8x5_KHR
        @private
     */
    COMPRESSED_RGBA_ASTC_8x5_KHR: 0x93B5,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_8x6_KHR
        @private
     */
    COMPRESSED_RGBA_ASTC_8x6_KHR: 0x93B6,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_8x8_KHR
        @private
     */
    COMPRESSED_RGBA_ASTC_8x8_KHR: 0x93B7,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_10x5_KHR
        @private
     */
    COMPRESSED_RGBA_ASTC_10x5_KHR: 0x93B8,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_10x6_KHR
        @private
     */
    COMPRESSED_RGBA_ASTC_10x6_KHR: 0x93B9,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_10x8_KHR
        @private
     */
    COMPRESSED_RGBA_ASTC_10x8_KHR: 0x93BA,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_10x10_KHR
        @private
     */
    COMPRESSED_RGBA_ASTC_10x10_KHR: 0x93BB,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_12x10_KHR
        @private
     */
    COMPRESSED_RGBA_ASTC_12x10_KHR: 0x93BC,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_12x12_KHR
        @private
     */
    COMPRESSED_RGBA_ASTC_12x12_KHR: 0x93BD,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
        @private
     */
    COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR: 0x93D0,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
        @private
     */
    COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR: 0x93D1,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
        @private
     */
    COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR: 0x93D2,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
        @private
     */
    COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR: 0x93D3,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
        @private
     */
    COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR: 0x93D4,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
        @private
     */
    COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR: 0x93D5,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
        @private
     */
    COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR: 0x93D6,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
        @private
     */
    COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR: 0x93D7,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
        @private
     */
    COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR: 0x93D8,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
        @private
     */
    COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR: 0x93D9,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
        @private
     */
    COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR: 0x93DA,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
        @private
     */
    COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR: 0x93DB,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
        @private
     */
    COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR: 0x93DC,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
        @private
     */
    COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR: 0x93DD
};


const TYPE_SIZE = {
    [GL.BYTE]: 1,
    [GL.UNSIGNED_BYTE]: 1,
    [GL.SHORT]: 2,
    [GL.UNSIGNED_SHORT]: 2,
    [GL.INT]: 4,
    [GL.UNSIGNED_INT]: 4,
    [GL.FLOAT]: 4
};

// Internal format => [format, type]
const TEXTURE_FORMATS = {
    [GL.R8]: [ GL.RED, GL.UNSIGNED_BYTE ],
    [GL.R8_SNORM]: [ GL.RED, GL.BYTE ],
    [GL.R16F]: [ GL.RED, GL.FLOAT ],
    [GL.R32F]: [ GL.RED, GL.FLOAT ],
    [GL.R8UI]: [ GL.RED_INTEGER, GL.UNSIGNED_BYTE ],
    [GL.R8I]: [ GL.RED_INTEGER, GL.BYTE ],
    [GL.R16UI]: [ GL.RED_INTEGER, GL.UNSIGNED_SHORT ],
    [GL.R16I]: [ GL.RED_INTEGER, GL.SHORT ],
    [GL.R32UI]: [ GL.RED_INTEGER, GL.UNSIGNED_INT ],
    [GL.R32I]: [ GL.RED_INTEGER, GL.INT ],
    [GL.RG8]: [ GL.RG, GL.UNSIGNED_BYTE ],
    [GL.RG8_SNORM]: [ GL.RG, GL.BYTE ],
    [GL.RG16F]: [ GL.RG, GL.FLOAT ],
    [GL.RG32F]: [ GL.RG, GL.FLOAT ],
    [GL.RG8UI]: [ GL.RG_INTEGER, GL.UNSIGNED_BYTE ],
    [GL.RG8I]: [ GL.RG_INTEGER, GL.BYTE ],
    [GL.RG16UI]: [ GL.RG_INTEGER, GL.UNSIGNED_SHORT ],
    [GL.RG16I]: [ GL.RG_INTEGER, GL.SHORT ],
    [GL.RG32UI]: [ GL.RG_INTEGER, GL.UNSIGNED_INT ],
    [GL.RG32I]: [ GL.RG_INTEGER, GL.INT ],
    [GL.RGB8]: [ GL.RGB, GL.UNSIGNED_BYTE ],
    [GL.SRGB8]: [ GL.RGB, GL.UNSIGNED_BYTE ],
    [GL.RGB565]: [ GL.RGB, GL.UNSIGNED_SHORT_5_6_5 ],
    [GL.RGB8_SNORM]: [ GL.RGB, GL.BYTE ],
    [GL.R11F_G11F_B10F]: [ GL.RGB, GL.UNSIGNED_INT_10F_11F_11F_REV ],
    [GL.RGB9_E5]: [ GL.RGB, GL.UNSIGNED_INT_5_9_9_9_REV ],
    [GL.RGB16F]: [ GL.RGB, GL.FLOAT ],
    [GL.RGB32F]: [ GL.RGB, GL.FLOAT ],
    [GL.RGB8UI]: [ GL.RGB_INTEGER, GL.UNSIGNED_BYTE ],
    [GL.RGB8I]: [ GL.RGB_INTEGER, GL.BYTE ],
    [GL.RGB16UI]: [ GL.RGB_INTEGER, GL.UNSIGNED_SHORT ],
    [GL.RGB16I]: [ GL.RGB_INTEGER, GL.SHORT ],
    [GL.RGB32UI]: [ GL.RGB_INTEGER, GL.UNSIGNED_INT ],
    [GL.RGB32I]: [ GL.RGB_INTEGER, GL.INT ],
    [GL.RGBA8]: [ GL.RGBA, GL.UNSIGNED_BYTE ],
    [GL.SRGB8_ALPHA8]: [ GL.RGBA, GL.UNSIGNED_BYTE ],
    [GL.RGBA8_SNORM]: [ GL.RGBA, GL.BYTE ],
    [GL.RGB5_A1]: [ GL.RGBA, GL.UNSIGNED_SHORT_5_5_5_1 ],
    [GL.RGBA4]: [ GL.RGBA, GL.UNSIGNED_SHORT_4_4_4_4 ],
    [GL.RGB10_A2]: [ GL.RGBA, GL.UNSIGNED_INT_2_10_10_10_REV ],
    [GL.RGBA16F]: [ GL.RGBA, GL.FLOAT ],
    [GL.RGBA32F]: [ GL.RGBA, GL.FLOAT ],
    [GL.RGBA8UI]: [ GL.RGBA_INTEGER, GL.UNSIGNED_BYTE ],
    [GL.RGBA8I]: [ GL.RGBA_INTEGER, GL.BYTE ],
    [GL.RGB10_A2UI]: [ GL.RGBA_INTEGER, GL.UNSIGNED_INT_2_10_10_10_REV ],
    [GL.RGBA16UI]: [ GL.RGBA_INTEGER, GL.UNSIGNED_SHORT ],
    [GL.RGBA16I]: [ GL.RGBA_INTEGER, GL.SHORT ],
    [GL.RGBA32I]: [ GL.RGBA_INTEGER, GL.INT ],
    [GL.RGBA32UI]: [ GL.RGBA_INTEGER, GL.UNSIGNED_INT ],
    [GL.DEPTH_COMPONENT16]: [ GL.DEPTH_COMPONENT, GL.UNSIGNED_SHORT ],
    [GL.DEPTH_COMPONENT24]: [ GL.DEPTH_COMPONENT, GL.UNSIGNED_INT ],
    [GL.DEPTH_COMPONENT32F]: [ GL.DEPTH_COMPONENT, GL.FLOAT ],
    [GL.DEPTH24_STENCIL8]: [ GL.DEPTH_STENCIL, GL.UNSIGNED_INT_24_8 ],
    [GL.DEPTH32F_STENCIL8]: [ GL.DEPTH_STENCIL, GL.FLOAT_32_UNSIGNED_INT_24_8_REV ]
};

const COMPRESSED_TEXTURE_TYPES = {
    [GL.COMPRESSED_RGB_S3TC_DXT1_EXT]: true,
    [GL.COMPRESSED_RGBA_S3TC_DXT1_EXT]: true,
    [GL.COMPRESSED_RGBA_S3TC_DXT3_EXT]: true,
    [GL.COMPRESSED_RGBA_S3TC_DXT5_EXT]: true,
    [GL.COMPRESSED_SRGB_S3TC_DXT1_EXT]: true,
    [GL.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT]: true,
    [GL.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT]: true,
    [GL.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT]: true,
    [GL.COMPRESSED_R11_EAC]: true,
    [GL.COMPRESSED_SIGNED_R11_EAC]: true,
    [GL.COMPRESSED_RG11_EAC]: true,
    [GL.COMPRESSED_SIGNED_RG11_EAC]: true,
    [GL.COMPRESSED_RGB8_ETC2]: true,
    [GL.COMPRESSED_SRGB8_ETC2]: true,
    [GL.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2]: true,
    [GL.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2]: true,
    [GL.COMPRESSED_RGBA8_ETC2_EAC]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC]: true,
    [GL.COMPRESSED_RGBA_ASTC_4x4_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_5x4_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_5x5_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_6x5_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_6x6_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_8x5_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_8x6_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_8x8_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_10x5_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_10x6_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_10x8_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_10x10_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_12x10_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_12x12_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR]: true,
    [GL.COMPRESSED_RGB_PVRTC_4BPPV1_IMG]: true,
    [GL.COMPRESSED_RGB_PVRTC_2BPPV1_IMG]: true,
    [GL.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG]: true,
    [GL.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG]: true
};

const WEBGL_INFO = {};

const DUMMY_UNIT_ARRAY = new Array(1);

const DUMMY_OBJECT = {};

// DEPRECATED
const TEXTURE_FORMAT_DEFAULTS = {
    [GL.UNSIGNED_BYTE]: {
        [GL.RED]: GL.R8,
        [GL.RG]: GL.RG8,
        [GL.RGB]: GL.RGB8,
        [GL.RGBA]: GL.RGBA8
    },

    [GL.UNSIGNED_SHORT]: {
        [GL.DEPTH_COMPONENT]: GL.DEPTH_COMPONENT16
    },

    [GL.FLOAT]: {
        [GL.RED]: GL.R16F,
        [GL.RG]: GL.RG16F,
        [GL.RGB]: GL.RGB16F,
        [GL.RGBA]: GL.RGBA16F,
        [GL.DEPTH_COMPONENT]: GL.DEPTH_COMPONENT32F
    }
};

///////////////////////////////////////////////////////////////////////////////////

/**
    Cubemap for environment mapping.

    @class Cubemap
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLTexture} texture Handle to the texture.
    @prop {GLenum} type Type of data stored in the texture.
    @prop {GLenum} format Layout of texture data.
    @prop {GLenum} internalFormat Internal arrangement of the texture data.
    @prop {Number} currentUnit The current texture unit this cubemap is bound to.
    @prop {boolean} flipY Whether the y-axis is flipped for this cubemap.
    @prop {boolean} premultiplyAlpha Whether alpha should be pre-multiplied when loading this cubemap.
    @prop {Object} appState Tracked GL state.
*/
class Cubemap {

    constructor(gl, appState, options) {

        this.gl = gl;
        this.texture = null;
        this.appState = appState;

        this.compressed = COMPRESSED_TEXTURE_TYPES[options.internalFormat];

        if (options.format !== undefined) {
            console.warn("Cubemap option 'format' is deprecated and will be removed. Use 'internalFormat' with a sized format instead.");
            this.compressed = Boolean(COMPRESSED_TEXTURE_TYPES[options.format]);
            if (options.type === undefined) {
                options.type = options.format === GL.DEPTH_COMPONENT ? GL.UNSIGNED_SHORT : GL.UNSIGNED_BYTE;
            }
            if (options.internalFormat === undefined) {
                if (this.compressed) {
                    options.internalFormat = options.format;
                } else {
                    options.internalFormat = TEXTURE_FORMAT_DEFAULTS[options.type][options.format];
                }
            }
        }

        if (this.compressed) {
            // For compressed textures, just need to provide one of format, internalFormat.
            // The other will be the same.
            this.internalFormat = options.internalFormat;
            this.format = options.internalFormat;
            this.type = GL.UNSIGNED_BYTE;
        } else {
            this.internalFormat = options.internalFormat !== undefined ? options.internalFormat : GL.RGBA8;

            let formatInfo = TEXTURE_FORMATS[this.internalFormat];
            this.format = formatInfo[0];
            this.type = options.type !== undefined ? options.type : formatInfo[1];
        }

        // -1 indicates unbound
        this.currentUnit = -1;

        let arrayData = Array.isArray(options.negX);
        let negX = arrayData ? options.negX[0] : options.negX;

        let {
            width = negX.width,
            height = negX.height,
            flipY = false,
            premultiplyAlpha = false,
            minFilter = negX ? GL.LINEAR_MIPMAP_NEAREST : GL.NEAREST,
            magFilter = negX ? GL.LINEAR : GL.NEAREST,
            wrapS = GL.REPEAT,
            wrapT = GL.REPEAT,
            compareMode = GL.NONE,
            compareFunc = GL.LEQUAL,
            minLOD = null,
            maxLOD = null,
            baseLevel = null,
            maxLevel = null,
            maxAnisotropy = 1
        } = options;

        this.width = width;
        this.height = height;
        this.flipY = flipY;
        this.premultiplyAlpha = premultiplyAlpha;
        this.minFilter = minFilter;
        this.magFilter = magFilter;
        this.wrapS = wrapS;
        this.wrapT = wrapT;
        this.compareMode = compareMode;
        this.compareFunc = compareFunc;
        this.minLOD = minLOD;
        this.maxLOD = maxLOD;
        this.baseLevel = baseLevel;
        this.maxLevel = maxLevel;
        this.maxAnisotropy = Math.min(maxAnisotropy, WEBGL_INFO.MAX_TEXTURE_ANISOTROPY);
        this.mipmaps = (minFilter === GL.LINEAR_MIPMAP_NEAREST || minFilter === GL.LINEAR_MIPMAP_LINEAR);
        this.miplevelsProvided = arrayData && options.negX.length > 1;
        this.levels = this.mipmaps ? Math.floor(Math.log2(Math.min(this.width, this.height))) + 1 : 1;

        this.restore(options);
    }

    /**
        Restore cubemap after context loss.

        @method
        @param {Object} [options] Texture options.
        @param {HTMLElement|ArrayBufferView} [options.negX] The image data for the negative X direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.posX] The image data for the positive X direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.negY] The image data for the negative Y direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.posY] The image data for the positive Y direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.negZ] The image data for the negative Z direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.posZ] The image data for the positive Z direction.
                Can be any format that would be accepted by texImage2D.
        @return {Cubemap} The Cubemap object.
    */
    restore(options = DUMMY_OBJECT) {
        this.texture = this.gl.createTexture();

        if (this.currentUnit !== -1) {
            this.appState.textures[this.currentUnit] = null;
        }

        this.bind(0);
        this.gl.texParameteri(GL.TEXTURE_CUBE_MAP, GL.TEXTURE_MAG_FILTER, this.magFilter);
        this.gl.texParameteri(GL.TEXTURE_CUBE_MAP, GL.TEXTURE_MIN_FILTER, this.minFilter);
        this.gl.texParameteri(GL.TEXTURE_CUBE_MAP, GL.TEXTURE_WRAP_S, this.wrapS);
        this.gl.texParameteri(GL.TEXTURE_CUBE_MAP, GL.TEXTURE_WRAP_T, this.wrapT);
        this.gl.texParameteri(GL.TEXTURE_CUBE_MAP, GL.TEXTURE_COMPARE_FUNC, this.compareFunc);
        this.gl.texParameteri(GL.TEXTURE_CUBE_MAP, GL.TEXTURE_COMPARE_MODE, this.compareMode);

        if (this.baseLevel !== null) {
            this.gl.texParameteri(GL.TEXTURE_CUBE_MAP, GL.TEXTURE_BASE_LEVEL, this.baseLevel);
        }

        if (this.maxLevel !== null) {
            this.gl.texParameteri(GL.TEXTURE_CUBE_MAP, GL.TEXTURE_MAX_LEVEL, this.maxLevel);
        }

        if (this.minLOD !== null) {
            this.gl.texParameteri(GL.TEXTURE_CUBE_MAP, GL.TEXTURE_MIN_LOD, this.minLOD);
        }

        if (this.maxLOD !== null) {
            this.gl.texParameteri(GL.TEXTURE_CUBE_MAP, GL.TEXTURE_MAX_LOD, this.maxLOD);
        }

        if (this.maxAnisotropy > 1) {
            this.gl.texParameteri(GL.TEXTURE_CUBE_MAP, GL.TEXTURE_MAX_ANISOTROPY_EXT, this.maxAnisotropy);
        }

        this.gl.texStorage2D(GL.TEXTURE_CUBE_MAP, this.levels, this.internalFormat, this.width, this.height);

        let { negX, posX, negY, posY, negZ, posZ } = options;

        if (negX) {
            this.faceData(GL.TEXTURE_CUBE_MAP_NEGATIVE_X, negX);
            this.faceData(GL.TEXTURE_CUBE_MAP_POSITIVE_X, posX);
            this.faceData(GL.TEXTURE_CUBE_MAP_NEGATIVE_Y, negY);
            this.faceData(GL.TEXTURE_CUBE_MAP_POSITIVE_Y, posY);
            this.faceData(GL.TEXTURE_CUBE_MAP_NEGATIVE_Z, negZ);
            this.faceData(GL.TEXTURE_CUBE_MAP_POSITIVE_Z, posZ);
        }

        if (this.mipmaps && !this.miplevelsProvided) {
            this.gl.generateMipmap(GL.TEXTURE_CUBE_MAP);
        }

        return this;
    }

    /**
        Delete this cubemap.

        @method
        @return {Cubemap} The Cubemap object.
    */
    delete() {
        if (this.texture) {
            this.gl.deleteTexture(this.texture);
            this.texture = null;
            this.appState.textures[this.currentUnit] = null;
            this.currentUnit = -1;
        }

        return this;
    }

    // Input data for one cubemap face.
    faceData(face, data) {
        if (!Array.isArray(data)) {
            DUMMY_UNIT_ARRAY[0] = data;
            data = DUMMY_UNIT_ARRAY;
        }

        let numLevels = this.mipmaps ? data.length : 1;
        let width = this.width;
        let height = this.height;
        let i;

        this.gl.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, this.flipY);
        this.gl.pixelStorei(GL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);

        if (this.compressed) {
            for (i = 0; i < numLevels; ++i) {
                this.gl.compressedTexSubImage2D(face, i, 0, 0, width, height, this.format, data[i]);
                width = Math.max(width >> 1, 1);
                height = Math.max(height >> 1, 1);
            }
        } else {
            for (i = 0; i < numLevels; ++i) {
                this.gl.texSubImage2D(face, i, 0, 0, width, height, this.format, this.type, data[i]);
                width = Math.max(width >> 1, 1);
                height = Math.max(height >> 1, 1);
            }
        }

        return this;
    }

    // Bind this cubemap to a texture unit.
    bind(unit) {
        let currentTexture = this.appState.textures[unit];

        if (this.appState.activeTexture !== unit) {
            this.gl.activeTexture(GL.TEXTURE0 + unit);
            this.appState.activeTexture = unit;
        }

        if (currentTexture !== this) {
            if (currentTexture) {
                currentTexture.currentUnit = -1;
            }

            if (this.currentUnit !== -1) {
                this.appState.textures[this.currentUnit] = null;
            }

            this.gl.bindTexture(GL.TEXTURE_CUBE_MAP, this.texture);

            this.appState.textures[unit] = this;
            this.currentUnit = unit;
        }

        return this;
    }

}

///////////////////////////////////////////////////////////////////////////////////

/**
    A DrawCall represents the program and values of associated
    attributes, uniforms and textures for a single draw call.

    @class DrawCall
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {Program} currentProgram The program to use for this draw call.
    @prop {VertexArray} currentVertexArray Vertex array to use for this draw call.
    @prop {TransformFeedback} currentTransformFeedback Transform feedback to use for this draw call.
    @prop {Array} uniformBuffers Ordered list of active uniform buffers.
    @prop {Array} uniformBlockNames Ordered list of uniform block names.
    @prop {Number} uniformBlockCount Number of active uniform blocks for this draw call.
    @prop {Object} uniformIndices Map of uniform names to indices in the uniform arrays.
    @prop {Array} uniformNames Ordered list of uniform names.
    @prop {Array} uniformValue Ordered list of uniform values.
    @prop {number} uniformCount The number of active uniforms for this draw call.
    @prop {Array} textures Array of active textures.
    @prop {number} textureCount The number of active textures for this draw call.
    @prop {Object} appState Tracked GL state.
    @prop {GLsizei} numElements The number of element to draw.
    @prop {GLsizei} numInstances The number of instances to draw.
*/
class DrawCall {

    constructor(gl, appState, program, vertexArray = null, primitive) {
        this.gl = gl;
        this.currentProgram = program;
        this.drawPrimitive = GL.TRIANGLES;
        this.currentVertexArray = vertexArray;
        this.currentTransformFeedback = null;
        this.appState = appState;

        this.uniformIndices = {};
        this.uniformNames = new Array(WEBGL_INFO.MAX_UNIFORMS);
        this.uniformValues = new Array(WEBGL_INFO.MAX_UNIFORMS);
        this.uniformCount = 0;
        this.uniformBuffers = new Array(WEBGL_INFO.MAX_UNIFORM_BUFFERS);
        this.uniformBlockNames = new Array(WEBGL_INFO.MAX_UNIFORM_BUFFERS);
        this.uniformBlockCount = 0;
        this.textures = new Array(WEBGL_INFO.MAX_TEXTURE_UNITS);
        this.textureCount = 0;

        this.offsets = new Int32Array(1);
        this.numElements = new Int32Array(1);
        this.numInstances = new Int32Array(1);

        this.numDraws = 1;
        this.drawCountsFromVertexArray = true;

        if (primitive !== undefined) {
            console.warn("Primitive argument to 'App.createDrawCall' is deprecated and will be removed. Use 'DrawCall.primitive' instead.");
            this.primitive(primitive);
        }
    }

    /**
        Set the current draw primitive for this draw call.

        @method
        @param {GLenum} primitive Primitive to draw.
        @return {DrawCall} The DrawCall object.
    */
    primitive(primitive) {
        this.drawPrimitive = primitive;

        return this;
    }

    /**
        Set the current TransformFeedback object for draw.

        @method
        @param {TransformFeedback} transformFeedback Transform Feedback to set.
        @return {DrawCall} The DrawCall object.
    */
    transformFeedback(transformFeedback) {
        this.currentTransformFeedback = transformFeedback;

        return this;
    }

    /**
        Set the value for a uniform. Array uniforms are supported by
        using appending "[0]" to the array name and passing a flat array
        with all required values.

        @method
        @param {string} name Uniform name.
        @param {any} value Uniform value.
        @return {DrawCall} The DrawCall object.
    */
    uniform(name, value) {
        let index = this.uniformIndices[name];
        if (index === undefined) {
            index = this.uniformCount++;
            this.uniformIndices[name] = index;
            this.uniformNames[index] = name;
        }
        this.uniformValues[index] = value;

        return this;
    }

    /**
        Set texture to bind to a sampler uniform.

        @method
        @param {string} name Sampler uniform name.
        @param {Texture|Cubemap} texture Texture or Cubemap to bind.
        @return {DrawCall} The DrawCall object.
    */
    texture(name, texture) {
        let unit = this.currentProgram.samplers[name];
        this.textures[unit] = texture;

        return this;
    }

    /**
        Set uniform buffer to bind to a uniform block.

        @method
        @param {string} name Uniform block name.
        @param {UniformBuffer} buffer Uniform buffer to bind.
        @return {DrawCall} The DrawCall object.
    */
    uniformBlock(name, buffer) {
        let base = this.currentProgram.uniformBlocks[name];
        this.uniformBuffers[base] = buffer;

        return this;
    }

    /**
        Ranges in the vertex array to draw. Multiple arguments can be provided to set up
        a multi-draw. Note that after this method is called, draw counts will no longer
        automatically be pulled from the VertexArray.

        @method
        @param {...Array} counts Variable number of 2 or 3 element arrays, each containing:
            <ul>
                <li> (Number) Number of elements to skip at the start of the array.
                <li> (Number) Number of elements to draw.
                <li> (Number - optional) Number of instances to draw of the given range.
            </ul>
        @return {DrawCall} The DrawCall object.
    */
    drawRanges(...counts) {
        this.numDraws = counts.length;

        if (this.offsets.length < this.numDraws) {
            this.offsets = new Int32Array(this.numDraws);
        }

        if (this.numElements.length < this.numDraws) {
            this.numElements = new Int32Array(this.numDraws);
        }

        if (this.numInstances.length < this.numDraws) {
            this.numInstances = new Int32Array(this.numDraws);
        }

        for (let i = 0; i < this.numDraws; ++i) {
            let count = counts[i];

            this.offsets[i] = count[0];
            this.numElements[i] = count[1];
            this.numInstances[i] = count[2] || 1;
        }

        this.drawCountsFromVertexArray = false;

        return this;
    }

    /**
        Draw based on current state.

        @method
        @return {DrawCall} The DrawCall object.
    */
    draw() {
        let uniformNames = this.uniformNames;
        let uniformValues = this.uniformValues;
        let uniformBuffers = this.uniformBuffers;
        let uniformBlockCount = this.currentProgram.uniformBlockCount;
        let textures = this.textures;
        let textureCount = this.currentProgram.samplerCount;
        let indexed = false;

        this.currentProgram.bind();

        if (this.currentVertexArray) {
            this.currentVertexArray.bind();
            indexed = this.currentVertexArray.indexed;

            if (this.drawCountsFromVertexArray) {
                this.numElements[0] = this.currentVertexArray.numElements;
                this.numInstances[0] = this.currentVertexArray.numInstances;
            }
        }

        for (let uIndex = 0; uIndex < this.uniformCount; ++uIndex) {
            this.currentProgram.uniform(uniformNames[uIndex], uniformValues[uIndex]);
        }

        for (let base = 0; base < uniformBlockCount; ++base) {
            uniformBuffers[base].bind(base);
        }

        for (let tIndex = 0; tIndex < textureCount; ++tIndex) {
            textures[tIndex].bind(tIndex);
        }

        if (this.currentTransformFeedback) {
            this.currentTransformFeedback.bind();
            this.gl.beginTransformFeedback(this.drawPrimitive);
        } else if (this.appState.transformFeedback) {
            this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, null);
            this.appState.transformFeedback = null;
        }

        if (WEBGL_INFO.MULTI_DRAW_INSTANCED) {
            let ext = this.appState.extensions.multiDrawInstanced;
            if (indexed) {
                ext.multiDrawElementsInstancedWEBGL(this.drawPrimitive, this.numElements, 0, this.currentVertexArray.indexType, this.offsets, 0, this.numInstances, 0, this.numDraws);
            } else {
                ext.multiDrawArraysInstancedWEBGL(this.drawPrimitive, this.offsets, 0, this.numElements, 0, this.numInstances, 0, this.numDraws);
            }
        } else if (indexed) {
            for (let i = 0; i < this.numDraws; ++i) {
                this.gl.drawElementsInstanced(this.drawPrimitive, this.numElements[i], this.currentVertexArray.indexType, this.offsets[i], this.numInstances[i]);
            }
        } else {
            for (let i = 0; i < this.numDraws; ++i) {
                this.gl.drawArraysInstanced(this.drawPrimitive, this.offsets[i], this.numElements[i], this.numInstances[i]);
            }
        }

        if (this.currentTransformFeedback) {
            this.gl.endTransformFeedback();
        }

        return this;
    }

}

///////////////////////////////////////////////////////////////////////////////////

/**
    General-purpose texture.

    @class Texture
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLTexture} texture Handle to the texture.
    @prop {number} width Texture width.
    @prop {number} height Texture height.
    @prop {number} depth Texture depth.
    @prop {GLenum} binding Binding point for the texture.
    @prop {GLenum} type Type of data stored in the texture.
    @prop {GLenum} format Layout of texture data.
    @prop {GLenum} internalFormat Internal arrangement of the texture data.
    @prop {number} currentUnit The current texture unit this texture is bound to.
    @prop {boolean} is3D Whether this texture contains 3D data.
    @prop {boolean} flipY Whether the y-axis is flipped for this texture.
    @prop {boolean} premultiplyAlpha Whether alpha should be pre-multiplied when loading this texture.
    @prop {boolean} mipmaps Whether this texture is using mipmap filtering
        (and thus should have a complete mipmap chain).
    @prop {Object} appState Tracked GL state.
*/
class Texture {
    constructor(gl, appState, binding, image, width = image.width, height = image.height, depth, is3D, options = DUMMY_OBJECT) {

        this.gl = gl;
        this.binding = binding;
        this.texture = null;
        this.width = width || 0;
        this.height = height || 0;
        this.depth = depth || 0;
        this.is3D = is3D;
        this.appState = appState;

        this.compressed = Boolean(COMPRESSED_TEXTURE_TYPES[options.internalFormat]);

        if (options.format !== undefined) {
            console.warn("Texture option 'format' is deprecated and will be removed. Use 'internalFormat' with a sized format instead.");
            this.compressed = Boolean(COMPRESSED_TEXTURE_TYPES[options.format]);
            if (options.type === undefined) {
                options.type = options.format === GL.DEPTH_COMPONENT ? GL.UNSIGNED_SHORT : GL.UNSIGNED_BYTE;
            }
            if (options.internalFormat === undefined) {
                if (this.compressed) {
                    options.internalFormat = options.format;
                } else {
                    options.internalFormat = TEXTURE_FORMAT_DEFAULTS[options.type][options.format];
                }
            }
        }

        if (this.compressed) {
            // For compressed textures, just need to provide one of format, internalFormat.
            // The other will be the same.
            this.internalFormat = options.internalFormat;
            this.format = this.internalFormat;
            this.type = GL.UNSIGNED_BYTE;
        } else {
            this.internalFormat = options.internalFormat !== undefined ? options.internalFormat : GL.RGBA8;

            let formatInfo = TEXTURE_FORMATS[this.internalFormat];
            this.format = formatInfo[0];
            this.type = options.type !== undefined ? options.type : formatInfo[1];
        }

        // -1 indicates unbound
        this.currentUnit = -1;

        // Sampling parameters
        let {
            minFilter = image ? GL.LINEAR_MIPMAP_NEAREST : GL.NEAREST,
            magFilter = image ? GL.LINEAR : GL.NEAREST,
            wrapS = GL.REPEAT,
            wrapT = GL.REPEAT,
            wrapR = GL.REPEAT,
            compareMode = GL.NONE,
            compareFunc = GL.LEQUAL,
            minLOD = null,
            maxLOD = null,
            baseLevel = null,
            maxLevel = null,
            maxAnisotropy = 1,
            flipY = false,
            premultiplyAlpha = false
        } = options;

        this.minFilter = minFilter;
        this.magFilter = magFilter;
        this.wrapS = wrapS;
        this.wrapT = wrapT;
        this.wrapR = wrapR;
        this.compareMode = compareMode;
        this.compareFunc = compareFunc;
        this.minLOD = minLOD;
        this.maxLOD = maxLOD;
        this.baseLevel = baseLevel;
        this.maxLevel = maxLevel;
        this.maxAnisotropy = Math.min(maxAnisotropy, WEBGL_INFO.MAX_TEXTURE_ANISOTROPY);
        this.flipY = flipY;
        this.premultiplyAlpha = premultiplyAlpha;
        this.mipmaps = (minFilter === GL.LINEAR_MIPMAP_NEAREST || minFilter === GL.LINEAR_MIPMAP_LINEAR);

        this.restore(image);
    }

    /**
        Restore texture after context loss.

        @method
        @param {HTMLElement|ArrayBufferView|Array} [image] Image data. An array can be passed to manually set all levels
            of the mipmap chain. If a single level is passed and mipmap filtering is being used,
            generateMipmap() will be called to produce the remaining levels.
        @return {Texture} The Texture object.
    */
    restore(image) {
        this.texture = null;
        this.resize(this.width, this.height, this.depth);

        if (image) {
            this.data(image);
        }

        return this;
    }

    /**
        Re-allocate texture storage.

        @method
        @param {number} width Image width.
        @param {number} height Image height.
        @param {number} [depth] Image depth or number of images. Required when passing 3D or texture array data.
        @return {Texture} The Texture object.
    */
    resize(width, height, depth) {
        depth = depth || 0;

        if (this.texture && width === this.width && height === this.height && depth === this.depth) {
            return this;
        }

        this.gl.deleteTexture(this.texture);
        if (this.currentUnit !== -1) {
            this.appState.textures[this.currentUnit] = null;
        }

        this.texture = this.gl.createTexture();
        this.bind(Math.max(this.currentUnit, 0));

        this.width = width;
        this.height = height;
        this.depth = depth;

        this.gl.texParameteri(this.binding, GL.TEXTURE_MIN_FILTER, this.minFilter);
        this.gl.texParameteri(this.binding, GL.TEXTURE_MAG_FILTER, this.magFilter);
        this.gl.texParameteri(this.binding, GL.TEXTURE_WRAP_S, this.wrapS);
        this.gl.texParameteri(this.binding, GL.TEXTURE_WRAP_T, this.wrapT);
        this.gl.texParameteri(this.binding, GL.TEXTURE_WRAP_R, this.wrapR);
        this.gl.texParameteri(this.binding, GL.TEXTURE_COMPARE_FUNC, this.compareFunc);
        this.gl.texParameteri(this.binding, GL.TEXTURE_COMPARE_MODE, this.compareMode);

        if (this.minLOD !== null) {
            this.gl.texParameterf(this.binding, GL.TEXTURE_MIN_LOD, this.minLOD);
        }

        if (this.maxLOD !== null) {
            this.gl.texParameterf(this.binding, GL.TEXTURE_MAX_LOD, this.maxLOD);
        }

        if (this.baseLevel !== null) {
            this.gl.texParameteri(this.binding, GL.TEXTURE_BASE_LEVEL, this.baseLevel);
        }

        if (this.maxLevel !== null) {
            this.gl.texParameteri(this.binding, GL.TEXTURE_MAX_LEVEL, this.maxLevel);
        }

        if (this.maxAnisotropy > 1) {
            this.gl.texParameteri(this.binding, GL.TEXTURE_MAX_ANISOTROPY_EXT, this.maxAnisotropy);
        }

        let levels;
        if (this.is3D) {
            if (this.mipmaps) {
                levels = Math.floor(Math.log2(Math.max(Math.max(this.width, this.height), this.depth))) + 1;
            } else {
                levels = 1;
            }
            this.gl.texStorage3D(this.binding, levels, this.internalFormat, this.width, this.height, this.depth);
        } else {
            if (this.mipmaps) {
                levels = Math.floor(Math.log2(Math.max(this.width, this.height))) + 1;
            } else {
                levels = 1;
            }
            this.gl.texStorage2D(this.binding, levels, this.internalFormat, this.width, this.height);
        }

        return this;
    }

    /**
        Set the image data for the texture. An array can be passed to manually set all levels
        of the mipmap chain. If a single level is passed and mipmap filtering is being used,
        generateMipmap() will be called to produce the remaining levels.
        NOTE: the data must fit the currently-allocated storage!

        @method
        @param {HTMLImageElement|ArrayBufferView|Array} data Image data. If an array is passed, it will be
            used to set mip map levels.
        @return {Texture} The Texture object.
    */
    data(data) {
        if (!Array.isArray(data)) {
            DUMMY_UNIT_ARRAY[0] = data;
            data = DUMMY_UNIT_ARRAY;
        }

        let numLevels = this.mipmaps ? data.length : 1;
        let width = this.width;
        let height = this.height;
        let depth = this.depth;
        let generateMipmaps = this.mipmaps && data.length === 1;
        let i;

        this.bind(Math.max(this.currentUnit, 0));
        this.gl.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, this.flipY);
        this.gl.pixelStorei(GL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);

        if (this.compressed) {
            if (this.is3D) {
                for (i = 0; i < numLevels; ++i) {
                    this.gl.compressedTexSubImage3D(this.binding, i, 0, 0, 0, width, height, depth, this.format, data[i]);
                    width = Math.max(width >> 1, 1);
                    height = Math.max(height >> 1, 1);
                    depth = Math.max(depth >> 1, 1);
                }
            } else {
                for (i = 0; i < numLevels; ++i) {
                    this.gl.compressedTexSubImage2D(this.binding, i, 0, 0, width, height, this.format, data[i]);
                    width = Math.max(width >> 1, 1);
                    height = Math.max(height >> 1, 1);
                }
            }
        } else if (this.is3D) {
            for (i = 0; i < numLevels; ++i) {
                this.gl.texSubImage3D(this.binding, i, 0, 0, 0, width, height, depth, this.format, this.type, data[i]);
                width = Math.max(width >> 1, 1);
                height = Math.max(height >> 1, 1);
                depth = Math.max(depth >> 1, 1);
            }
        } else {
            for (i = 0; i < numLevels; ++i) {
                this.gl.texSubImage2D(this.binding, i, 0, 0, width, height, this.format, this.type, data[i]);
                width = Math.max(width >> 1, 1);
                height = Math.max(height >> 1, 1);
            }
        }

        if (generateMipmaps) {
            this.gl.generateMipmap(this.binding);
        }

        return this;
    }

    /**
        Delete this texture.

        @method
        @return {Texture} The Texture object.
    */
    delete() {
        if (this.texture) {
            this.gl.deleteTexture(this.texture);
            this.texture = null;

            if (this.currentUnit !== -1 && this.appState.textures[this.currentUnit] === this) {
                this.appState.textures[this.currentUnit] = null;
                this.currentUnit = -1;
            }
        }

        return this;
    }

    /**
        Bind this texture to a texture unit.

        @method
        @ignore
        @return {Texture} The Texture object.
    */
    bind(unit) {
        let currentTexture = this.appState.textures[unit];

        if (this.appState.activeTexture !== unit) {
            this.gl.activeTexture(GL.TEXTURE0 + unit);
            this.appState.activeTexture = unit;
        }

        if (currentTexture !== this) {
            if (currentTexture) {
                currentTexture.currentUnit = -1;
            }

            if (this.currentUnit !== -1) {
                this.appState.textures[this.currentUnit] = null;
            }

            this.gl.bindTexture(this.binding, this.texture);

            this.appState.textures[unit] = this;
            this.currentUnit = unit;
        }

        return this;
    }

}

///////////////////////////////////////////////////////////////////////////////////

/**
    Offscreen drawing attachment.

    @class Renderbuffer
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLRenderbuffer} renderbuffer Handle to the renderbuffer.
    @prop {number} width Renderbuffer width.
    @prop {number} height Renderbuffer height.
    @prop {GLenum} internalFormat Internal arrangement of the renderbuffer data.
    @prop {number} samples Number of MSAA samples.
*/
class Renderbuffer {
    constructor(gl, width, height, internalFormat, samples = 0) {
        this.gl = gl;
        this.renderbuffer = null;
        this.width = width;
        this.height = height;
        this.internalFormat = internalFormat;
        this.samples = samples;
        this.restore();
    }

    /**
        Restore renderbuffer after context loss.

        @method
        @return {Renderbuffer} The Renderbuffer object.
    */
    restore() {
        this.renderbuffer = this.gl.createRenderbuffer();
        this.resize(this.width, this.height);

        return this;
    }

    /**
        Resize the renderbuffer.

        @method
        @param {number} width New width of the renderbuffer.
        @param {number} height New height of the renderbuffer.
        @return {Renderbuffer} The Renderbuffer object.
    */
    resize(width, height) {
        this.width = width;
        this.height = height;
        this.gl.bindRenderbuffer(GL.RENDERBUFFER, this.renderbuffer);
        this.gl.renderbufferStorageMultisample(GL.RENDERBUFFER, this.samples, this.internalFormat, this.width, this.height);
        this.gl.bindRenderbuffer(GL.RENDERBUFFER, null);

        return this;
    }

    /**
        Delete this renderbuffer.

        @method
        @return {Renderbuffer} The Renderbuffer object.
    */
    delete() {
        this.gl.deleteRenderbuffer(this.renderbuffer);
        this.renderbuffer = null;

        return this;
    }
}

///////////////////////////////////////////////////////////////////////////////////

/**
    Offscreen drawing surface.

    @class Framebuffer
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLFramebuffer} framebuffer Handle to the framebuffer.
    @prop {number} width Framebuffer width.
    @prop {number} height Framebuffer height.
    @prop {Array} colorAttachments Array of color attachments.
    @prop {Texture|Renderbuffer} depthAttachment Depth attachment.
    @prop {Object} appState Tracked GL state.
*/
class Framebuffer {

    constructor(gl, appState) {
        this.gl = gl;
        this.framebuffer = null;
        this.appState = appState;

        this.numColorTargets = 0;

        this.colorAttachments = [];
        this.colorAttachmentEnums = [];
        this.colorAttachmentTargets = [];
        this.depthAttachment = null;
        this.depthAttachmentTarget = null;

        this.width = 0;
        this.height = 0;

        this.restore();
    }

    /**
        Restore framebuffer after context loss.

        @method
        @return {Framebuffer} The Framebuffer object.
    */
    restore() {
        let currentFramebuffers = this.appState.framebuffers;
        for (let binding in currentFramebuffers) {
            if (currentFramebuffers[binding] === this) {
                currentFramebuffers[binding] = null;
            }
        }

        this.framebuffer = this.gl.createFramebuffer();

        return this;
    }

    /**
        Attach a color target to this framebuffer.

        @method
        @param {number} index Color attachment index.
        @param {Texture|Cubemap|Renderbuffer} attachment The texture, cubemap or renderbuffer to attach.
        @param {GLenum} [target] The texture target or layer to attach. If the texture is 3D or a texture array,
            defaults to 0, otherwise to TEXTURE_2D. Ignored for renderbuffers.
        @return {Framebuffer} The Framebuffer object.
    */
    colorTarget(index, attachment, target = attachment.is3D ? 0 : GL.TEXTURE_2D) {

        if (index >= this.numColorTargets) {
            let numColorTargets = index + 1;
            this.colorAttachmentEnums.length = numColorTargets;
            this.colorAttachments.length = numColorTargets;
            this.colorAttachmentTargets.length = numColorTargets;

            for (let i = this.numColorTargets; i < numColorTargets - 1; ++i) {
                this.colorAttachmentEnums[i] = GL.NONE;
                this.colorAttachments[i] = null;
                this.colorAttachmentTargets[i] = 0;
            }

            this.numColorTargets = numColorTargets;
        }

        this.colorAttachmentEnums[index] = GL.COLOR_ATTACHMENT0 + index;
        this.colorAttachments[index] = attachment;
        this.colorAttachmentTargets[index] = target;

        let currentFramebuffer = this.bindAndCaptureState();
        let binding = this.appState.drawFramebufferBinding;

        if (attachment instanceof Renderbuffer) {
            this.gl.framebufferRenderbuffer(binding, this.colorAttachmentEnums[index], GL.RENDERBUFFER, attachment.renderbuffer);
        } else if (attachment.is3D) {
            this.gl.framebufferTextureLayer(binding, this.colorAttachmentEnums[index], attachment.texture, 0, target);
        } else {
            this.gl.framebufferTexture2D(binding, this.colorAttachmentEnums[index], target, attachment.texture, 0);
        }

        this.gl.drawBuffers(this.colorAttachmentEnums);

        this.width = attachment.width;
        this.height = attachment.height;

        this.restoreState(currentFramebuffer);

        return this;
    }

    /**
        Attach a depth target to this framebuffer.

        @method
        @param {Texture|Cubemap|Renderbuffer} texture The texture, cubemap or renderbuffer to attach.
        @param {GLenum} [target] The texture target or layer to attach. If the texture is 3D or a texture array or renderbuffer,
            defaults to 0, otherwise to TEXTURE_2D. Ignored for renderbuffers.
        @return {Framebuffer} The Framebuffer object.
    */
    depthTarget(attachment, target = attachment.is3D ? 0 : GL.TEXTURE_2D) {

        let currentFramebuffer = this.bindAndCaptureState();
        let binding = this.appState.drawFramebufferBinding;

        this.depthAttachment = attachment;
        this.depthAttachmentTarget = target;

        if (attachment instanceof Renderbuffer) {
            this.gl.framebufferRenderbuffer(binding, GL.DEPTH_ATTACHMENT, GL.RENDERBUFFER, attachment.renderbuffer);
        } else if (attachment.is3D) {
            this.gl.framebufferTextureLayer(binding, GL.DEPTH_ATTACHMENT, attachment.texture, 0, target);
        } else {
            this.gl.framebufferTexture2D(binding, GL.DEPTH_ATTACHMENT, target, attachment.texture, 0);
        }

        this.width = attachment.width;
        this.height = attachment.height;

        this.restoreState(currentFramebuffer);

        return this;
    }

    /**
        Resize all attachments.

        @method
        @param {number} [width=app.width] New width of the framebuffer.
        @param {number} [height=app.height] New height of the framebuffer.
        @return {Framebuffer} The Framebuffer object.
    */
    resize(width = this.gl.drawingBufferWidth, height = this.gl.drawingBufferHeight) {

        let currentFramebuffer = this.bindAndCaptureState();
        let binding = this.appState.drawFramebufferBinding;

        for (let i = 0; i < this.numColorTargets; ++i) {
            let attachment = this.colorAttachments[i];

            if (!attachment) {
                continue;
            }

            attachment.resize(width, height);
            if (attachment instanceof Texture) {
                // Texture resizing recreates the texture object.
                if (attachment.is3D) {
                    this.gl.framebufferTextureLayer(binding, this.colorAttachmentEnums[i], attachment.texture, 0, this.colorAttachmentTargets[i]);
                } else {
                    this.gl.framebufferTexture2D(binding, this.colorAttachmentEnums[i], this.colorAttachmentTargets[i], attachment.texture, 0);
                }
            }
        }

        if (this.depthAttachment) {
            this.depthAttachment.resize(width, height);
            if (this.depthAttachment instanceof Texture) {
                // Texture resizing recreates the texture object.
                if (this.depthAttachment.is3D) {
                    this.gl.framebufferTextureLayer(binding, GL.DEPTH_ATTACHMENT, this.depthAttachment.texture, 0, this.depthAttachmentTarget);
                } else {
                    this.gl.framebufferTexture2D(binding, GL.DEPTH_ATTACHMENT, this.depthAttachmentTarget, this.depthAttachment.texture, 0);
                }
            }
        }

        this.width = width;
        this.height = height;

        this.restoreState(currentFramebuffer);

        return this;
    }

    /**
        Delete this framebuffer.

        @method
        @return {Framebuffer} The Framebuffer object.
    */
    delete() {
        if (this.framebuffer) {
            this.gl.deleteFramebuffer(this.framebuffer);
            this.framebuffer = null;

            let currentFramebuffers = this.appState.framebuffers;
            for (let binding in currentFramebuffers) {
                if (currentFramebuffers[binding] === this) {
                    this.gl.bindFramebuffer(binding, null);
                    currentFramebuffers[binding] = null;
                }
            }
        }

        return this;
    }

    /**
        Get the current status of this framebuffer.

        @method
        @return {GLenum} The current status of this framebuffer.
    */
    getStatus() {
        let currentFramebuffer = this.bindAndCaptureState();
        let binding = this.appState.drawFramebufferBinding;
        let status = this.gl.checkFramebufferStatus(binding);
        this.restoreState(currentFramebuffer);

        return status;
    }

    /**
        Bind as the draw framebuffer

        @method
        @ignore
        @return {Framebuffer} The Framebuffer object.
    */
    bindForDraw() {
        let binding = this.appState.drawFramebufferBinding;
        let currentFramebuffers = this.appState.framebuffers;
        if (currentFramebuffers[binding] !== this) {
            this.gl.bindFramebuffer(binding, this.framebuffer);
            currentFramebuffers[binding] = this;
        }

        return this;
    }

    /**
        Bind as the read framebuffer

        @method
        @ignore
        @return {Framebuffer} The Framebuffer object.
    */
    bindForRead() {
        let binding = this.appState.readFramebufferBinding;
        let currentFramebuffers = this.appState.framebuffers;
        if (currentFramebuffers[binding] !== this) {
            this.gl.bindFramebuffer(binding, this.framebuffer);
            currentFramebuffers[binding] = this;
        }

        return this;
    }

    /**
        Bind for a framebuffer state update.
        Capture current binding so we can restore it later.

        @method
        @ignore
        @return {Framebuffer} The Framebuffer object.
    */
    bindAndCaptureState() {
        let binding = this.appState.drawFramebufferBinding;
        let currentFramebuffer = this.appState.framebuffers[binding];

        if (currentFramebuffer !== this) {
            this.gl.bindFramebuffer(binding, this.framebuffer);
        }

        return currentFramebuffer;
    }

    /**
        Bind restore previous binding after state update

        @method
        @ignore
        @return {Framebuffer} The Framebuffer object.
    */
    restoreState(framebuffer) {
        if (framebuffer !== this) {
            let binding = this.appState.drawFramebufferBinding;
            this.gl.bindFramebuffer(binding, framebuffer ? framebuffer.framebuffer : null);
        }

        return this;
    }

    // TODO(Tarek): Transitional support for deprecated properties.
    get colorTextures() {
        console.error("Framebuffer.colorTextures is deprecated and will be removed. Please use Framebuffer.colorAttachments.");
        return this.colorAttachments;
    }

    get depthTexture() {
        console.error("Framebuffer.depthTexture is deprecated and will be removed. Please use Framebuffer.depthAttachment.");
        return this.depthAttachment;
    }

}

///////////////////////////////////////////////////////////////////////////////////

/**
    WebGL shader.

    @class Shader
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLShader} shader The shader.
*/
class Shader {

    constructor(gl, appState, type, source) {
        this.gl = gl;
        this.appState = appState;
        this.shader = null;
        this.type = type;
        this.source = source.trim();

        this.restore();
    }

    /**
        Restore shader after context loss.

        @method
        @return {Shader} The Shader object.
    */
    restore() {
        this.shader = this.gl.createShader(this.type);
        this.gl.shaderSource(this.shader, this.source);
        this.gl.compileShader(this.shader);

        return this;
    }

    /**
        Get the shader source translated for the platform's API.

        @method
        @return {String} The translated shader source.
    */
    translatedSource() {
        if (WEBGL_INFO.DEBUG_SHADERS) {
            return this.appState.extensions.debugShaders.getTranslatedShaderSource(this.shader);
        } else {
            return "(Unavailable)";
        }
    }

    /**
        Delete this shader.

        @method
        @return {Shader} The Shader object.
    */
    delete() {
        if (this.shader) {
            this.gl.deleteShader(this.shader);
            this.shader = null;
        }

        return this;
    }


    checkCompilation() {
        if (!this.gl.getShaderParameter(this.shader, GL.COMPILE_STATUS)) {
            let i, lines;

            console.error(this.gl.getShaderInfoLog(this.shader));
            lines = this.source.split("\n");
            for (i = 0; i < lines.length; ++i) {
                console.error(`${i + 1}: ${lines[i]}`);
            }
        }

        return this;
    }
}

///////////////////////////////////////////////////////////////////////////////////

// Classes to manage uniform value updates, including
// caching current values.

const UNIFORM_FUNC_NAME = {};
UNIFORM_FUNC_NAME[GL.BOOL] = "uniform1i";
UNIFORM_FUNC_NAME[GL.INT] = "uniform1i";
UNIFORM_FUNC_NAME[GL.SAMPLER_2D] = "uniform1i";
UNIFORM_FUNC_NAME[GL.INT_SAMPLER_2D] = "uniform1i";
UNIFORM_FUNC_NAME[GL.UNSIGNED_INT_SAMPLER_2D] = "uniform1i";
UNIFORM_FUNC_NAME[GL.SAMPLER_2D_SHADOW] = "uniform1i";
UNIFORM_FUNC_NAME[GL.SAMPLER_2D_ARRAY] = "uniform1i";
UNIFORM_FUNC_NAME[GL.INT_SAMPLER_2D_ARRAY] = "uniform1i";
UNIFORM_FUNC_NAME[GL.UNSIGNED_INT_SAMPLER_2D_ARRAY] = "uniform1i";
UNIFORM_FUNC_NAME[GL.SAMPLER_2D_ARRAY_SHADOW] = "uniform1i";
UNIFORM_FUNC_NAME[GL.SAMPLER_CUBE] = "uniform1i";
UNIFORM_FUNC_NAME[GL.INT_SAMPLER_CUBE] = "uniform1i";
UNIFORM_FUNC_NAME[GL.UNSIGNED_INT_SAMPLER_CUBE] = "uniform1i";
UNIFORM_FUNC_NAME[GL.SAMPLER_CUBE_SHADOW] = "uniform1i";
UNIFORM_FUNC_NAME[GL.SAMPLER_3D] = "uniform1i";
UNIFORM_FUNC_NAME[GL.INT_SAMPLER_3D] = "uniform1i";
UNIFORM_FUNC_NAME[GL.UNSIGNED_INT_SAMPLER_3D] = "uniform1i";
UNIFORM_FUNC_NAME[GL.UNSIGNED_INT] = "uniform1ui";
UNIFORM_FUNC_NAME[GL.FLOAT] = "uniform1f";
UNIFORM_FUNC_NAME[GL.FLOAT_VEC2] = "uniform2f";
UNIFORM_FUNC_NAME[GL.FLOAT_VEC3] = "uniform3f";
UNIFORM_FUNC_NAME[GL.FLOAT_VEC4] = "uniform4f";
UNIFORM_FUNC_NAME[GL.INT_VEC2] = "uniform2i";
UNIFORM_FUNC_NAME[GL.INT_VEC3] = "uniform3i";
UNIFORM_FUNC_NAME[GL.INT_VEC4] = "uniform4i";
UNIFORM_FUNC_NAME[GL.UNSIGNED_INT_VEC2] = "uniform2ui";
UNIFORM_FUNC_NAME[GL.UNSIGNED_INT_VEC3] = "uniform3ui";
UNIFORM_FUNC_NAME[GL.UNSIGNED_INT_VEC4] = "uniform4ui";
UNIFORM_FUNC_NAME[GL.BOOL_VEC2] = "uniform2i";
UNIFORM_FUNC_NAME[GL.BOOL_VEC3] = "uniform3i";
UNIFORM_FUNC_NAME[GL.BOOL_VEC4] = "uniform4i";
UNIFORM_FUNC_NAME[GL.FLOAT_MAT2] = "uniformMatrix2fv";
UNIFORM_FUNC_NAME[GL.FLOAT_MAT3] = "uniformMatrix3fv";
UNIFORM_FUNC_NAME[GL.FLOAT_MAT4] = "uniformMatrix4fv";
UNIFORM_FUNC_NAME[GL.FLOAT_MAT2x3] = "uniformMatrix2x3fv";
UNIFORM_FUNC_NAME[GL.FLOAT_MAT2x4] = "uniformMatrix2x4fv";
UNIFORM_FUNC_NAME[GL.FLOAT_MAT3x2] = "uniformMatrix3x2fv";
UNIFORM_FUNC_NAME[GL.FLOAT_MAT3x4] = "uniformMatrix3x4fv";
UNIFORM_FUNC_NAME[GL.FLOAT_MAT4x2] = "uniformMatrix4x2fv";
UNIFORM_FUNC_NAME[GL.FLOAT_MAT4x3] = "uniformMatrix4x3fv";

const UNIFORM_COMPONENT_COUNT = {};
UNIFORM_COMPONENT_COUNT[GL.BOOL] = 1;
UNIFORM_COMPONENT_COUNT[GL.INT] = 1;
UNIFORM_COMPONENT_COUNT[GL.SAMPLER_2D] = 1;
UNIFORM_COMPONENT_COUNT[GL.INT_SAMPLER_2D] = 1;
UNIFORM_COMPONENT_COUNT[GL.UNSIGNED_INT_SAMPLER_2D] = 1;
UNIFORM_COMPONENT_COUNT[GL.SAMPLER_2D_SHADOW] = 1;
UNIFORM_COMPONENT_COUNT[GL.SAMPLER_2D_ARRAY] = 1;
UNIFORM_COMPONENT_COUNT[GL.INT_SAMPLER_2D_ARRAY] = 1;
UNIFORM_COMPONENT_COUNT[GL.UNSIGNED_INT_SAMPLER_2D_ARRAY] = 1;
UNIFORM_COMPONENT_COUNT[GL.SAMPLER_2D_ARRAY_SHADOW] = 1;
UNIFORM_COMPONENT_COUNT[GL.SAMPLER_CUBE] = 1;
UNIFORM_COMPONENT_COUNT[GL.INT_SAMPLER_CUBE] = 1;
UNIFORM_COMPONENT_COUNT[GL.UNSIGNED_INT_SAMPLER_CUBE] = 1;
UNIFORM_COMPONENT_COUNT[GL.SAMPLER_CUBE_SHADOW] = 1;
UNIFORM_COMPONENT_COUNT[GL.SAMPLER_3D] = 1;
UNIFORM_COMPONENT_COUNT[GL.INT_SAMPLER_3D] = 1;
UNIFORM_COMPONENT_COUNT[GL.UNSIGNED_INT_SAMPLER_3D] = 1;
UNIFORM_COMPONENT_COUNT[GL.UNSIGNED_INT] = 1;
UNIFORM_COMPONENT_COUNT[GL.FLOAT] = 1;
UNIFORM_COMPONENT_COUNT[GL.FLOAT_VEC2] = 2;
UNIFORM_COMPONENT_COUNT[GL.FLOAT_VEC3] = 3;
UNIFORM_COMPONENT_COUNT[GL.FLOAT_VEC4] = 4;
UNIFORM_COMPONENT_COUNT[GL.INT_VEC2] = 2;
UNIFORM_COMPONENT_COUNT[GL.INT_VEC3] = 3;
UNIFORM_COMPONENT_COUNT[GL.INT_VEC4] = 4;
UNIFORM_COMPONENT_COUNT[GL.UNSIGNED_INT_VEC2] = 2;
UNIFORM_COMPONENT_COUNT[GL.UNSIGNED_INT_VEC3] = 3;
UNIFORM_COMPONENT_COUNT[GL.UNSIGNED_INT_VEC4] = 4;
UNIFORM_COMPONENT_COUNT[GL.BOOL_VEC2] = 2;
UNIFORM_COMPONENT_COUNT[GL.BOOL_VEC3] = 3;
UNIFORM_COMPONENT_COUNT[GL.BOOL_VEC4] = 4;
UNIFORM_COMPONENT_COUNT[GL.FLOAT_MAT2] = 4;
UNIFORM_COMPONENT_COUNT[GL.FLOAT_MAT3] = 9;
UNIFORM_COMPONENT_COUNT[GL.FLOAT_MAT4] = 16;
UNIFORM_COMPONENT_COUNT[GL.FLOAT_MAT2x3] = 6;
UNIFORM_COMPONENT_COUNT[GL.FLOAT_MAT2x4] = 8;
UNIFORM_COMPONENT_COUNT[GL.FLOAT_MAT3x2] = 6;
UNIFORM_COMPONENT_COUNT[GL.FLOAT_MAT3x4] = 12;
UNIFORM_COMPONENT_COUNT[GL.FLOAT_MAT4x2] = 8;
UNIFORM_COMPONENT_COUNT[GL.FLOAT_MAT4x3] = 12;

const UNIFORM_CACHE_CLASS = {};
UNIFORM_CACHE_CLASS[GL.INT] = Int32Array;
UNIFORM_CACHE_CLASS[GL.SAMPLER_2D] = Int32Array;
UNIFORM_CACHE_CLASS[GL.INT_SAMPLER_2D] = Int32Array;
UNIFORM_CACHE_CLASS[GL.UNSIGNED_INT_SAMPLER_2D] = Int32Array;
UNIFORM_CACHE_CLASS[GL.SAMPLER_2D_SHADOW] = Int32Array;
UNIFORM_CACHE_CLASS[GL.SAMPLER_2D_ARRAY] = Int32Array;
UNIFORM_CACHE_CLASS[GL.INT_SAMPLER_2D_ARRAY] = Int32Array;
UNIFORM_CACHE_CLASS[GL.UNSIGNED_INT_SAMPLER_2D_ARRAY] = Int32Array;
UNIFORM_CACHE_CLASS[GL.SAMPLER_2D_ARRAY_SHADOW] = Int32Array;
UNIFORM_CACHE_CLASS[GL.SAMPLER_CUBE] = Int32Array;
UNIFORM_CACHE_CLASS[GL.INT_SAMPLER_CUBE] = Int32Array;
UNIFORM_CACHE_CLASS[GL.UNSIGNED_INT_SAMPLER_CUBE] = Int32Array;
UNIFORM_CACHE_CLASS[GL.SAMPLER_CUBE_SHADOW] = Int32Array;
UNIFORM_CACHE_CLASS[GL.SAMPLER_3D] = Int32Array;
UNIFORM_CACHE_CLASS[GL.INT_SAMPLER_3D] = Int32Array;
UNIFORM_CACHE_CLASS[GL.UNSIGNED_INT_SAMPLER_3D] = Int32Array;
UNIFORM_CACHE_CLASS[GL.UNSIGNED_INT] = Uint32Array;
UNIFORM_CACHE_CLASS[GL.FLOAT] = Float32Array;
UNIFORM_CACHE_CLASS[GL.FLOAT_VEC2] = Float32Array;
UNIFORM_CACHE_CLASS[GL.FLOAT_VEC3] = Float32Array;
UNIFORM_CACHE_CLASS[GL.FLOAT_VEC4] = Float32Array;
UNIFORM_CACHE_CLASS[GL.INT_VEC2] = Int32Array;
UNIFORM_CACHE_CLASS[GL.INT_VEC3] = Int32Array;
UNIFORM_CACHE_CLASS[GL.INT_VEC4] = Int32Array;
UNIFORM_CACHE_CLASS[GL.UNSIGNED_INT_VEC2] = Uint32Array;
UNIFORM_CACHE_CLASS[GL.UNSIGNED_INT_VEC3] = Uint32Array;
UNIFORM_CACHE_CLASS[GL.UNSIGNED_INT_VEC4] = Uint32Array;

class SingleComponentUniform {
    
    constructor(gl, handle, type) {
        this.gl = gl;
        this.handle = handle;
        this.glFuncName = UNIFORM_FUNC_NAME[type];
        this.cache = type === GL.BOOL ? false : 0;
    }

    set(value) {
        if (this.cache !== value) {
            this.gl[this.glFuncName](this.handle, value);
            this.cache = value;
        }
    }

}

class MultiNumericUniform {

    constructor(gl, handle, type, count) {
        this.gl = gl;
        this.handle = handle;
        this.glFuncName = UNIFORM_FUNC_NAME[type] + "v";
        this.count = count;
        this.cache = new UNIFORM_CACHE_CLASS[type](UNIFORM_COMPONENT_COUNT[type] * count);
    }

    set(value) {
        for (let i = 0, len = value.length; i < len; ++i) {
            if (this.cache[i] !== value[i]) {
                this.gl[this.glFuncName](this.handle, value);
                this.cache.set(value);
                return;
            }
        }
    }

}

class MultiBoolUniform {

    constructor(gl, handle, type, count) {
        this.gl = gl;
        this.handle = handle;
        this.glFuncName = UNIFORM_FUNC_NAME[type] + "v";
        this.count = count;
        this.cache = new Array(UNIFORM_COMPONENT_COUNT[type] * count).fill(false);
    }

    set(value) {
        for (let i = 0, len = value.length; i < len; ++i) {
            if (this.cache[i] !== value[i]) {
                this.gl[this.glFuncName](this.handle, value);
                for (let j = i; j < len; j++) {
                    this.cache[j] = value[j];
                }
                return;
            }
        }
    }

}

class MatrixUniform {

    constructor(gl, handle, type, count) {
        this.gl = gl;
        this.handle = handle;
        this.glFuncName = UNIFORM_FUNC_NAME[type];
        this.count = count;
        this.cache = new Float32Array(UNIFORM_COMPONENT_COUNT[type] * count);
    }

    set(value) {
        for (let i = 0, len = value.length; i < len; ++i) {
            if (this.cache[i] !== value[i]) {
                this.gl[this.glFuncName](this.handle, false, value);
                this.cache.set(value);
                return;
            }
        }
    }

}

///////////////////////////////////////////////////////////////////////////////////

/**
    WebGL program consisting of compiled and linked vertex and fragment
    shaders.

    @class Program
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLProgram} program The WebGL program.
    @prop {array} transformFeedbackVaryings Names of transform feedback varyings, if any.
    @prop {GLenum} transformFeedbackMode Capture mode of the transform feedback.
    @prop {Object.<string, number>} attributeLocations Map of user-provided attribute names to indices, if any.
    @prop {Object} uniforms Map of uniform names to handles.
    @prop {Object} appState Tracked GL state.
*/
class Program {

    constructor(gl, appState, vsSource, fsSource, xformFeebackVars, attributeLocations, transformFeedbackMode) {
        this.gl = gl;
        this.appState = appState;
        this.program = null;
        this.transformFeedbackVaryings = xformFeebackVars || null;
        this.transformFeedbackMode = transformFeedbackMode || GL.SEPARATE_ATTRIBS;
        this.attributeLocations = attributeLocations || null;
        this.uniforms = {};
        this.uniformBlocks = {};
        this.uniformBlockCount = 0;
        this.samplers = {};
        this.samplerCount = 0;

        this.vertexSource = null;
        this.vertexShader = null;
        this.fragmentSource = null;
        this.fragmentShader = null;
        this.linked = false;

        if (typeof vsSource === "string") {
            this.vertexSource = vsSource;
        } else {
            this.vertexShader = vsSource;
        }

        if (typeof fsSource === "string") {
            this.fragmentSource = fsSource;
        } else {
            this.fragmentShader = fsSource;
        }

        this.initialize();
    }

    /**
        Restore program after context loss. Note that this
        will stall for completion. <b>App.restorePrograms</b>
        is the preferred method for program restoration as
        it will parallelize compilation where available.

        @method
        @return {Program} The Program object.
    */
    restore() {
        this.initialize();
        this.link();
        this.checkLinkage();

        return this;
    }

    /**
        Get the vertex shader source translated for the platform's API.

        @method
        @return {String} The translated vertex shader source.
    */
    translatedVertexSource() {
        if (this.vertexShader) {
            return this.vertexShader.translatedSource();
        } else {
            let vertexShader = new Shader(this.gl, this.appState, GL.VERTEX_SHADER, this.vertexSource);
            let translatedSource = vertexShader.translatedSource();
            vertexShader.delete();
            return translatedSource;
        }
    }

    /**
        Get the fragment shader source translated for the platform's API.

        @method
        @return {String} The translated fragment shader source.
    */
    translatedFragmentSource() {
        if (this.fragmentShader) {
            return this.fragmentShader.translatedSource();
        } else {
            let fragmentShader = new Shader(this.gl, this.appState, GL.FRAGMENT_SHADER, this.fragmentSource);
            let translatedSource = fragmentShader.translatedSource();
            fragmentShader.delete();
            return translatedSource;
        }
    }

    /**
        Delete this program.

        @method
        @return {Program} The Program object.
    */
    delete() {
        if (this.program) {
            this.gl.deleteProgram(this.program);
            this.program = null;

            if (this.appState.program === this) {
                this.gl.useProgram(null);
                this.appState.program = null;
            }
        }

        return this;
    }

    // Initialize program state
    initialize() {
        if (this.appState.program === this) {
            this.gl.useProgram(null);
            this.appState.program = null;
        }

        this.linked = false;
        this.uniformBlockCount = 0;
        this.samplerCount = 0;

        if (this.vertexSource) {
            this.vertexShader = new Shader(this.gl, this.appState, GL.VERTEX_SHADER, this.vertexSource);
        }

        if (this.fragmentSource) {
            this.fragmentShader = new Shader(this.gl, this.appState, GL.FRAGMENT_SHADER, this.fragmentSource);
        }

        this.program = this.gl.createProgram();

        return this;
    }

    // Attach shaders and link program.
    // Done as a separate step to avoid stalls on compileShader
    // when doing async compile.
    link() {
        this.gl.attachShader(this.program, this.vertexShader.shader);
        this.gl.attachShader(this.program, this.fragmentShader.shader);
        if (this.transformFeedbackVaryings) {
            this.gl.transformFeedbackVaryings(this.program, this.transformFeedbackVaryings, this.transformFeedbackMode);
        }
        if (this.attributeLocations) {
            for (let name in this.attributeLocations) {
                this.gl.bindAttribLocation(this.program, this.attributeLocations[name], name);
            }
        }
        this.gl.linkProgram(this.program);

        return this;
    }

    // Check if compilation is complete
    checkCompletion() {
        if (WEBGL_INFO.PARALLEL_SHADER_COMPILE) {
            return this.gl.getProgramParameter(this.program, GL.COMPLETION_STATUS_KHR);
        }

        return true;
    }

    // Check if program linked.
    // Will stall for completion.
    checkLinkage() {
        if (this.linked) {
            return this;
        }

        if (this.gl.getProgramParameter(this.program, GL.LINK_STATUS)) {
            this.linked = true;
            this.initVariables();
        } else {
            console.error(this.gl.getProgramInfoLog(this.program));
            this.vertexShader.checkCompilation();
            this.fragmentShader.checkCompilation();
        }

        if (this.vertexSource) {
            this.vertexShader.delete();
            this.vertexShader = null;
        }

        if (this.fragmentSource) {
            this.fragmentShader.delete();
            this.fragmentShader = null;
        }

        return this;
    }

    // Get variable handles from program
    initVariables() {
        this.bind();

        let numUniforms = this.gl.getProgramParameter(this.program, GL.ACTIVE_UNIFORMS);
        let textureUnit;

        for (let i = 0; i < numUniforms; ++i) {
            let uniformInfo = this.gl.getActiveUniform(this.program, i);
            let uniformHandle = this.gl.getUniformLocation(this.program, uniformInfo.name);
            let UniformClass = null;
            let type = uniformInfo.type;
            let numElements = uniformInfo.size;

            switch (type) {
                case GL.SAMPLER_2D:
                case GL.INT_SAMPLER_2D:
                case GL.UNSIGNED_INT_SAMPLER_2D:
                case GL.SAMPLER_2D_SHADOW:
                case GL.SAMPLER_2D_ARRAY:
                case GL.INT_SAMPLER_2D_ARRAY:
                case GL.UNSIGNED_INT_SAMPLER_2D_ARRAY:
                case GL.SAMPLER_2D_ARRAY_SHADOW:
                case GL.SAMPLER_CUBE:
                case GL.INT_SAMPLER_CUBE:
                case GL.UNSIGNED_INT_SAMPLER_CUBE:
                case GL.SAMPLER_CUBE_SHADOW:
                case GL.SAMPLER_3D:
                case GL.INT_SAMPLER_3D:
                case GL.UNSIGNED_INT_SAMPLER_3D:
                    textureUnit = this.samplerCount++;
                    this.samplers[uniformInfo.name] = textureUnit;
                    this.gl.uniform1i(uniformHandle, textureUnit);
                    break;
                case GL.INT:
                case GL.UNSIGNED_INT:
                case GL.FLOAT:
                    UniformClass = numElements > 1 ? MultiNumericUniform : SingleComponentUniform;
                    break;
                case GL.BOOL:
                    UniformClass = numElements > 1 ? MultiBoolUniform : SingleComponentUniform;
                    break;
                case GL.FLOAT_VEC2:
                case GL.INT_VEC2:
                case GL.UNSIGNED_INT_VEC2:
                case GL.FLOAT_VEC3:
                case GL.INT_VEC3:
                case GL.UNSIGNED_INT_VEC3:
                case GL.FLOAT_VEC4:
                case GL.INT_VEC4:
                case GL.UNSIGNED_INT_VEC4:
                    UniformClass = MultiNumericUniform;
                    break;
                case GL.BOOL_VEC2:
                case GL.BOOL_VEC3:
                case GL.BOOL_VEC4:
                    UniformClass = MultiBoolUniform;
                    break;
                case GL.FLOAT_MAT2:
                case GL.FLOAT_MAT3:
                case GL.FLOAT_MAT4:
                case GL.FLOAT_MAT2x3:
                case GL.FLOAT_MAT2x4:
                case GL.FLOAT_MAT3x2:
                case GL.FLOAT_MAT3x4:
                case GL.FLOAT_MAT4x2:
                case GL.FLOAT_MAT4x3:
                    UniformClass = MatrixUniform;
                    break;
                default:
                    console.error("Unrecognized type for uniform ", uniformInfo.name);
                    break;
            }

            if (UniformClass) {
                this.uniforms[uniformInfo.name] = new UniformClass(this.gl, uniformHandle, type, numElements);
            }
        }

        let numUniformBlocks = this.gl.getProgramParameter(this.program, GL.ACTIVE_UNIFORM_BLOCKS);

        for (let i = 0; i < numUniformBlocks; ++i) {
            let blockName = this.gl.getActiveUniformBlockName(this.program, i);
            let blockIndex = this.gl.getUniformBlockIndex(this.program, blockName);

            let uniformBlockBase = this.uniformBlockCount++;
            this.gl.uniformBlockBinding(this.program, blockIndex, uniformBlockBase);
            this.uniformBlocks[blockName] = uniformBlockBase;
        }
    }

    // Set the value of a uniform.
    uniform(name, value) {
        // some uniforms are optimized out
        if (this.uniforms[name]) {
            this.uniforms[name].set(value);
        }

        return this;
    }

    // Use this program.
    bind() {
        if (this.appState.program !== this) {
            this.gl.useProgram(this.program);
            this.appState.program = this;
        }

        return this;
    }
}

///////////////////////////////////////////////////////////////////////////////////

/**
    Generic query object.

    @class Query
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLQuery} query Query object.
    @prop {GLenum} target The type of information being queried.
    @prop {boolean} active Whether or not a query is currently in progress.
    @prop {Any} result The result of the query (only available after a call to ready() returns true).
*/
class Query {

    constructor(gl, target) {
        this.gl = gl;
        this.query = null;
        this.target = target;
        this.active = false;
        this.result = null;

        this.restore();
    }

    /**
        Restore query after context loss.

        @method
        @return {Query} The Query object.
    */
    restore() {
        this.query = this.gl.createQuery();
        this.active = false;
        this.result = null;

        return this;
    }

    /**
        Begin a query.

        @method
        @return {Query} The Query object.
    */
    begin() {
        if (!this.active) {
            this.gl.beginQuery(this.target, this.query);
            this.result = null;
        }

        return this;
    }

    /**
        End a query.

        @method
        @return {Query} The Query object.
    */
    end() {
        if (!this.active) {
            this.gl.endQuery(this.target);
            this.active = true;
        }

        return this;
    }

    /**
        Check if query result is available.

        @method
        @return {boolean} If results are available.
    */
    ready() {
        if (this.active && this.gl.getQueryParameter(this.query, GL.QUERY_RESULT_AVAILABLE)) {
            this.active = false;
            // Note(Tarek): Casting because FF incorrectly returns booleans.
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1422714
            this.result = Number(this.gl.getQueryParameter(this.query, GL.QUERY_RESULT));
            return true;
        }

        return false;
    }

    /**
        Delete this query.

        @method
        @return {Query} The Query object.
    */
    delete() {
        if (this.query) {
            this.gl.deleteQuery(this.query);
            this.query = null;
        }

        return this;
    }

}

///////////////////////////////////////////////////////////////////////////////////

/**
    Rendering timer.

    @class Timer
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {Object} cpuTimer Timer for CPU. Will be window.performance, if available, or window.Date.
    @prop {WebGLQuery} gpuTimerQuery Timer query object for GPU (if gpu timing is supported).
    @prop {boolean} gpuTimerQueryInProgress Whether a gpu timer query is currently in progress.
    @prop {number} cpuStartTime When the last CPU timing started.
    @prop {number} cpuTime Time spent on CPU during last timing. Only valid if ready() returns true.
    @prop {number} gpuTime Time spent on GPU during last timing. Only valid if ready() returns true.
            Will remain 0 if extension EXT_disjoint_timer_query_webgl2 is unavailable.
*/
class Timer {

    constructor(gl) {
        this.gl = gl;
        this.cpuTimer = window.performance || window.Date;

        this.gpuTimerQuery = null;

        this.cpuStartTime = 0;
        this.cpuTime = 0;
        this.gpuTime = 0;

        this.restore();
    }

    /**
        Restore timer after context loss.

        @method
        @return {Timer} The Timer object.
    */
    restore() {
        if (WEBGL_INFO.GPU_TIMER) {
            if (this.gpuTimerQuery) {
                this.gpuTimerQuery.restore();
            } else {
                this.gpuTimerQuery = new Query(this.gl, GL.TIME_ELAPSED_EXT);
            }
        }

        this.cpuStartTime = 0;
        this.cpuTime = 0;
        this.gpuTime = 0;

        return this;
    }


    /**
        Start timing.

        @method
        @return {Timer} The Timer object.
    */
    start() {
        if (WEBGL_INFO.GPU_TIMER) {
            if (!this.gpuTimerQuery.active) {
                this.gpuTimerQuery.begin();
                this.cpuStartTime = this.cpuTimer.now();
            }
        } else {
            this.cpuStartTime = this.cpuTimer.now();
        }

        return this;
    }


    /**
        Stop timing.

        @method
        @return {Timer} The Timer object.
    */
    end() {
        if (WEBGL_INFO.GPU_TIMER) {
            if (!this.gpuTimerQuery.active) {
                this.gpuTimerQuery.end();
                this.cpuTime = this.cpuTimer.now() - this.cpuStartTime;
            }
        } else {
            this.cpuTime = this.cpuTimer.now() - this.cpuStartTime;
        }

        return this;
    }

    /**
        Check if timing results are available. If
        this method returns true, the cpuTime and
        gpuTime properties will be set to valid
        values.

        @method
        @return {boolean} If results are available.
    */
    ready() {
        if (WEBGL_INFO.GPU_TIMER) {
            if (!this.gpuTimerQuery.active) {
                return false;
            }

            var gpuTimerAvailable = this.gpuTimerQuery.ready();
            var gpuTimerDisjoint = this.gl.getParameter(GL.GPU_DISJOINT_EXT);

            if (gpuTimerAvailable && !gpuTimerDisjoint) {
                this.gpuTime = this.gpuTimerQuery.result  / 1000000;
                return true;
            } else {
                return false;
            }
        } else {
            return Boolean(this.cpuStartTime);
        }
    }

    /**
        Delete this timer.

        @method
        @return {Timer} The Timer object.
    */
    delete() {
        if (this.gpuTimerQuery) {
            this.gpuTimerQuery.delete();
            this.gpuTimerQuery = null;
        }

        return this;
    }

}

///////////////////////////////////////////////////////////////////////////////////

/**
    Tranform feedback object.

    @class TransformFeedback
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLTransformFeedback} transformFeedback Transform feedback object.
    @prop {Object} appState Tracked GL state.
*/
class TransformFeedback {

    constructor(gl, appState) {
        this.gl = gl;
        this.appState = appState;
        this.transformFeedback = null;

        this.restore();
    }

    /**
        Restore transform feedback after context loss.

        @method
        @return {TransformFeedback} The TransformFeedback object.
    */
    restore() {
        if (this.appState.transformFeedback === this) {
            this.appState.transformFeedback = null;
        }

        this.transformFeedback = this.gl.createTransformFeedback();

        return this;
    }

    /**
        Bind a feedback buffer to capture transform output.

        @method
        @param {number} index Index of transform feedback varying to capture.
        @param {VertexBuffer} buffer Buffer to record output into.
        @return {TransformFeedback} The TransformFeedback object.
    */
    feedbackBuffer(index, buffer) {
        this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.transformFeedback);
        this.gl.bindBufferBase(GL.TRANSFORM_FEEDBACK_BUFFER, index, buffer.buffer);

        // TODO(Tarek): Firefox doesn't properly unbind TRANSFORM_FEEDBACK_BUFFER
        // bindings when TRANSFORM_FEEDBACK is unbound.
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1541396
        this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, null);
        this.gl.bindBufferBase(GL.TRANSFORM_FEEDBACK_BUFFER, index, null);

        return this;
    }

    /**
        Delete this transform feedback.

        @method
        @return {TransformFeedback} The TransformFeedback object.
    */
    delete() {
        if (this.transformFeedback) {
            this.gl.deleteTransformFeedback(this.transformFeedback);
            this.transformFeedback = null;

            if (this.appState.transformFeedback === this) {
                this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, null);
                this.appState.transformFeedback = null;
            }
        }

        return this;
    }

    /**
        Bind this transform feedback.

        @method
        @ignore
        @return {TransformFeedback} The TransformFeedback object.
    */
    bind() {
        if (this.appState.transformFeedback !== this) {
            this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.transformFeedback);
            this.appState.transformFeedback = this;
        }

        return this;
    }

}

///////////////////////////////////////////////////////////////////////////////////

/**
    Storage for uniform data. Data is stored in std140 layout.

    @class UniformBuffer
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLBuffer} buffer Allocated buffer storage.
    @prop {Float32Array} data Buffer data.
    @prop {Object} dataViews Map of base data types to matching ArrayBufferViews of the buffer data.
    @prop {Array} offsets Offsets into the array for each item in the buffer.
    @prop {Array} sizes Size of the item at the given offset.
    @prop {Array} types The base type of the item at the given offset (FLOAT, INT or UNSIGNED_INT).
    @prop {number} size The size of the buffer (in 4-byte items).
    @prop {GLenum} usage Usage pattern of the buffer.
*/
class UniformBuffer {

    constructor(gl, appState, layout, usage = gl.DYNAMIC_DRAW) {
        this.gl = gl;
        this.buffer = null;
        this.dataViews = {};
        this.offsets = new Array(layout.length);
        this.sizes = new Array(layout.length);
        this.types = new Array(layout.length);
        this.size = 0;
        this.usage = usage;
        this.appState = appState;

        // -1 indicates unbound
        this.currentBase = -1;

        for (let i = 0, len = layout.length; i < len; ++i) {
            let type = layout[i];
            switch(type) {
                case GL.FLOAT:
                case GL.INT:
                case GL.UNSIGNED_INT:
                case GL.BOOL:
                    this.offsets[i] = this.size;
                    this.sizes[i] = 1;

                    if (type === GL.INT) {
                        this.types[i] = GL.INT;
                    } else if (type === GL.UNSIGNED_INT) {
                        this.types[i] = GL.UNSIGNED_INT;
                    } else {
                        this.types[i] = GL.FLOAT;
                    }

                    this.size++;
                    break;
                case GL.FLOAT_VEC2:
                case GL.INT_VEC2:
                case GL.UNSIGNED_INT_VEC2:
                case GL.BOOL_VEC2:
                    this.size += this.size % 2;
                    this.offsets[i] = this.size;
                    this.sizes[i] = 2;

                    if (type === GL.INT_VEC2) {
                        this.types[i] = GL.INT;
                    } else if (type === GL.UNSIGNED_INT_VEC2) {
                        this.types[i] = GL.UNSIGNED_INT;
                    } else {
                        this.types[i] = GL.FLOAT;
                    }

                    this.size += 2;
                    break;
                case GL.FLOAT_VEC3:
                case GL.INT_VEC3:
                case GL.UNSIGNED_INT_VEC3:
                case GL.BOOL_VEC3:
                case GL.FLOAT_VEC4:
                case GL.INT_VEC4:
                case GL.UNSIGNED_INT_VEC4:
                case GL.BOOL_VEC4:
                    this.size += (4 - this.size % 4) % 4;
                    this.offsets[i] = this.size;
                    this.sizes[i] = 4;

                    if (type === GL.INT_VEC4 || type === GL.INT_VEC3) {
                        this.types[i] = GL.INT;
                    } else if (type === GL.UNSIGNED_INT_VEC4 || type === GL.UNSIGNED_INT_VEC3) {
                        this.types[i] = GL.UNSIGNED_INT;
                    } else {
                        this.types[i] = GL.FLOAT;
                    }

                    this.size += 4;
                    break;
                case GL.FLOAT_MAT2:
                case GL.FLOAT_MAT2x3:
                case GL.FLOAT_MAT2x4:
                    this.size += (4 - this.size % 4) % 4;
                    this.offsets[i] = this.size;
                    this.sizes[i] = 8;
                    this.types[i] = GL.FLOAT;

                    this.size += 8;
                    break;
                case GL.FLOAT_MAT3:
                case GL.FLOAT_MAT3x2:
                case GL.FLOAT_MAT3x4:
                    this.size += (4 - this.size % 4) % 4;
                    this.offsets[i] = this.size;
                    this.sizes[i] = 12;
                    this.types[i] = GL.FLOAT;

                    this.size += 12;
                    break;
                case GL.FLOAT_MAT4:
                case GL.FLOAT_MAT4x2:
                case GL.FLOAT_MAT4x3:
                    this.size += (4 - this.size % 4) % 4;
                    this.offsets[i] = this.size;
                    this.sizes[i] = 16;
                    this.types[i] = GL.FLOAT;

                    this.size += 16;
                    break;
                default:
                    console.error("Unsupported type for uniform buffer.");
            }
        }

        this.size += (4 - this.size % 4) % 4;

        this.data = new Float32Array(this.size);
        this.dataViews[GL.FLOAT] = this.data;
        this.dataViews[GL.INT] = new Int32Array(this.data.buffer);
        this.dataViews[GL.UNSIGNED_INT] = new Uint32Array(this.data.buffer);

        this.dirtyStart = this.size;
        this.dirtyEnd = 0;

        this.restore();
    }

    /**
        Restore uniform buffer after context loss.

        @method
        @return {UniformBuffer} The UniformBuffer object.
    */
    restore() {
        if (this.currentBase !== -1 && this.appState.uniformBuffers[this.currentBase] === this) {
            this.appState.uniformBuffers[this.currentBase] = null;
        }

        this.buffer = this.gl.createBuffer();
        this.gl.bindBuffer(GL.UNIFORM_BUFFER, this.buffer);
        this.gl.bufferData(GL.UNIFORM_BUFFER, this.size * 4, this.usage);
        this.gl.bindBuffer(GL.UNIFORM_BUFFER, null);

        return this;
    }

    /**
        Update data for a given item in the buffer. NOTE: Data is not
        sent the the GPU until the update() method is called!

        @method
        @param {number} index Index in the layout of item to set.
        @param {ArrayBufferView} value Value to store at the layout location.
        @return {UniformBuffer} The UniformBuffer object.
    */
    set(index, value) {
        let view = this.dataViews[this.types[index]];
        let offset = this.offsets[index];
        let size = this.sizes[index];

        if (this.sizes[index] === 1)  {
            view[offset] = value;
        } else {
            view.set(value, offset);
        }

        if (offset < this.dirtyStart) {
            this.dirtyStart = offset;
        }

        if (this.dirtyEnd < offset + size) {
            this.dirtyEnd = offset + size;
        }

        return this;
    }

    /**
        Send stored buffer data to the GPU.

        @method
        @return {UniformBuffer} The UniformBuffer object.
    */
    update() {
        if (this.dirtyStart >= this.dirtyEnd) {
            return this;
        }

        let data = this.data.subarray(this.dirtyStart, this.dirtyEnd);
        let offset = this.dirtyStart * 4;

        this.gl.bindBuffer(this.gl.UNIFORM_BUFFER, this.buffer);
        this.gl.bufferSubData(this.gl.UNIFORM_BUFFER, offset, data);
        this.gl.bindBuffer(this.gl.UNIFORM_BUFFER, null);

        this.dirtyStart = this.size;
        this.dirtyEnd = 0;

        return this;
    }

    /**
        Delete this uniform buffer.

        @method
        @return {UniformBuffer} The UniformBuffer object.
    */
    delete() {
        if (this.buffer) {
            this.gl.deleteBuffer(this.buffer);
            this.buffer = null;

            if (this.currentBase !== -1 && this.appState.uniformBuffers[this.currentBase] === this) {
                this.appState.uniformBuffers[this.currentBase] = null;
            }

            this.currentBase = -1;
        }

        return this;
    }

    /**
        Bind this uniform buffer to the given base.

        @method
        @ignore
        @return {UniformBuffer} The UniformBuffer object.
    */
    bind(base) {
        let currentBuffer = this.appState.uniformBuffers[base];

        if (currentBuffer !== this) {

            if (currentBuffer) {
                currentBuffer.currentBase = -1;
            }

            if (this.currentBase !== -1) {
                this.appState.uniformBuffers[this.currentBase] = null;
            }

            this.gl.bindBufferBase(this.gl.UNIFORM_BUFFER, base, this.buffer);

            this.appState.uniformBuffers[base] = this;
            this.currentBase = base;
        }

        return this;
    }

}

// Copyright (c) 2017 Tarek Sherif

/**
    Organizes vertex buffer and attribute state.

    @class VertexArray
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLVertexArrayObject} vertexArray Vertex array object.
    @prop {number} numElements Number of elements in the vertex array.
    @prop {boolean} indexed Whether this vertex array is set up for indexed drawing.
    @prop {GLenum} indexType Data type of the indices.
    @prop {number} numInstances Number of instances to draw with this vertex array.
    @prop {Object} appState Tracked GL state.
*/
class VertexArray {

    constructor(gl, appState) {
        this.gl = gl;
        this.appState = appState;
        this.vertexArray = null;
        this.indexType = null;
        this.indexed = false;
        this.numElements = 0;
        this.numInstances = 1;
        this.offsets = 0;
        this.numDraws = 1;
    }

    /**
        Restore vertex array after context loss.

        @method
        @return {VertexArray} The VertexArray object.
    */
    restore() {
        if (this.appState.vertexArray === this) {
            this.appState.vertexArray = null;
        }

        // re-allocate at gl level, if necessary
        if (this.vertexArray !== null) {
            this.vertexArray = this.gl.createVertexArray();
        }

        return this;
    }


    /**
        Bind an per-vertex attribute buffer to this vertex array.

        @method
        @param {number} attributeIndex The attribute location to bind to.
        @param {VertexBuffer} vertexBuffer The VertexBuffer to bind.
        @param {Object} [options] Attribute pointer options. These will override those provided in the
            VertexBuffer.
        @param {GLenum} [options.type] Type of data stored in the buffer.
        @param {GLenum} [options.size] Number of components per vertex.
        @param {GLenum} [options.stride] Number of bytes between the start of data for each vertex.
        @param {GLenum} [options.offset] Number of bytes before the start of data for the first vertex.
        @param {boolean} [options.normalized] Data is integer data that should be normalized to a float.
        @param {GLenum} [options.integer] Pass data as integers.
        @return {VertexArray} The VertexArray object.
    */
    vertexAttributeBuffer(attributeIndex, vertexBuffer, options = DUMMY_OBJECT) {
        this.attributeBuffer(attributeIndex, vertexBuffer, options, false);

        return this;
    }

    /**
        Bind an per-instance attribute buffer to this vertex array.

        @method
        @param {number} attributeIndex The attribute location to bind to.
        @param {VertexBuffer} vertexBuffer The VertexBuffer to bind.
        @param {Object} [options] Attribute pointer options. These will override those provided in the
            VertexBuffer.
        @param {GLenum} [options.type] Type of data stored in the buffer.
        @param {GLenum} [options.size] Number of components per vertex.
        @param {GLenum} [options.stride] Number of bytes between the start of data for each vertex.
        @param {GLenum} [options.offset] Number of bytes before the start of data for the first vertex.
        @param {GLenum} [options.normalized] Data is integer data that should be normalized to a float.
        @param {GLenum} [options.integer] Pass data as integers.
        @return {VertexArray} The VertexArray object.
    */
    instanceAttributeBuffer(attributeIndex, vertexBuffer, options = DUMMY_OBJECT) {
        this.attributeBuffer(attributeIndex, vertexBuffer, options, true);

        return this;
    }

    /**
        Bind an index buffer to this vertex array.

        @method
        @param {VertexBuffer} vertexBuffer The VertexBuffer to bind.
        @return {VertexArray} The VertexArray object.
    */
    indexBuffer(vertexBuffer) {
        // allocate at gl level, if necessary
        if (this.vertexArray === null) {
            this.vertexArray = this.gl.createVertexArray();
        }

        this.bind();
        this.gl.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, vertexBuffer.buffer);

        this.numElements = vertexBuffer.numItems * 3;
        this.indexType = vertexBuffer.type;
        this.indexed = true;

        return this;
    }

    /**
        Delete this vertex array.

        @method
        @return {VertexArray} The VertexArray object.
    */
    delete() {
        if (this.vertexArray) {
            this.gl.deleteVertexArray(this.vertexArray);
            this.vertexArray = null;

            if (this.appState.vertexArray === this) {
                this.gl.bindVertexArray(null);
                this.appState.vertexArray = null;
            }
        }

        return this;
    }

    // Bind this vertex array.
    bind() {
        if (this.appState.vertexArray !== this) {
            this.gl.bindVertexArray(this.vertexArray);
            this.appState.vertexArray = this;
        }

        return this;
    }

    // Generic attribute buffer attachment
    attributeBuffer(attributeIndex, vertexBuffer, options = {}, instanced) {
        // allocate at gl level, if necessary
        if (this.vertexArray === null) {
            this.vertexArray = this.gl.createVertexArray();
        }

        this.bind();
        this.gl.bindBuffer(GL.ARRAY_BUFFER, vertexBuffer.buffer);

        let {
            type = vertexBuffer.type,
            size = vertexBuffer.itemSize,
            stride = 0,
            offset = 0,
            normalized = false,
            integer = Boolean(vertexBuffer.integer && !normalized)
        } = options;

        let numColumns = vertexBuffer.numColumns;

        if (stride === 0) {
            // Set explicitly for matrix buffers
            stride = numColumns * size * TYPE_SIZE[type];
        }

        let numItems = Math.ceil((vertexBuffer.byteLength - offset) / stride);

        for (let i = 0; i < numColumns; ++i) {
            if (integer) {
                this.gl.vertexAttribIPointer(
                    attributeIndex + i,
                    size,
                    type,
                    stride,
                    offset + i * size * TYPE_SIZE[type]);
            } else {
                this.gl.vertexAttribPointer(
                    attributeIndex + i,
                    size,
                    type,
                    normalized,
                    stride,
                    offset + i * size * TYPE_SIZE[type]);
            }

            if (instanced) {
                this.gl.vertexAttribDivisor(attributeIndex + i, 1);
            }

            this.gl.enableVertexAttribArray(attributeIndex + i);
        }

        if (this.numDraws === 1) {
            if (instanced) {
                this.numInstances = numItems;
            } else if (!this.indexed) {
                this.numElements = numItems;
            }
        }

        this.gl.bindBuffer(GL.ARRAY_BUFFER, null);

        return this;
    }
}

///////////////////////////////////////////////////////////////////////////////////

const INTEGER_TYPES = {
    [GL.BYTE]: true,
    [GL.UNSIGNED_BYTE]: true,
    [GL.SHORT]: true,
    [GL.UNSIGNED_SHORT]: true,
    [GL.INT]: true,
    [GL.UNSIGNED_INT]: true
};

/**
    Storage for vertex data.

    @class VertexBuffer
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLBuffer} buffer Allocated buffer storage.
    @prop {GLenum} type The type of data stored in the buffer.
    @prop {number} itemSize Number of array elements per vertex.
    @prop {number} numItems Number of vertices represented.
    @prop {GLenum} usage The usage pattern of the buffer.
    @prop {boolean} indexArray Whether this is an index array.
    @prop {GLenum} binding GL binding point (ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER).
    @prop {Object} appState Tracked GL state.
*/
class VertexBuffer {

    constructor(gl, appState, type, itemSize, data, usage = gl.STATIC_DRAW, indexArray) {
        let numColumns;
        switch(type) {
            case GL.FLOAT_MAT4:
            case GL.FLOAT_MAT4x2:
            case GL.FLOAT_MAT4x3:
                numColumns = 4;
                break;
            case GL.FLOAT_MAT3:
            case GL.FLOAT_MAT3x2:
            case GL.FLOAT_MAT3x4:
                numColumns = 3;
                break;
            case GL.FLOAT_MAT2:
            case GL.FLOAT_MAT2x3:
            case GL.FLOAT_MAT2x4:
                numColumns = 2;
                break;
            default:
                numColumns = 1;
        }

        switch(type) {
            case GL.FLOAT_MAT4:
            case GL.FLOAT_MAT3x4:
            case GL.FLOAT_MAT2x4:
                itemSize = 4;
                type = GL.FLOAT;
                break;
            case GL.FLOAT_MAT3:
            case GL.FLOAT_MAT4x3:
            case GL.FLOAT_MAT2x3:
                itemSize = 3;
                type = GL.FLOAT;
                break;
            case GL.FLOAT_MAT2:
            case GL.FLOAT_MAT3x2:
            case GL.FLOAT_MAT4x2:
                itemSize = 2;
                type = GL.FLOAT;
                break;
        }

        let dataLength;
        let byteLength;
        if (typeof data === "number") {
            dataLength = data;
            if (type) {
                data *= TYPE_SIZE[type];
            }
            byteLength = data;
        } else {
            dataLength = data.length;
            byteLength = data.byteLength;
        }

        this.gl = gl;
        this.buffer = null;
        this.appState = appState;
        this.type = type;
        this.itemSize = itemSize;  // In bytes for interleaved arrays.
        this.numItems = type ? dataLength / (itemSize * numColumns) : byteLength / itemSize;
        this.numColumns = numColumns;
        this.byteLength = byteLength;
        this.usage = usage;
        this.indexArray = Boolean(indexArray);
        this.integer = Boolean(INTEGER_TYPES[this.type]);
        this.binding = this.indexArray ? GL.ELEMENT_ARRAY_BUFFER : GL.ARRAY_BUFFER;

        this.restore(data);
    }

    /**
        Restore vertex buffer after context loss.

        @method
        @param {ArrayBufferView|number} data Buffer data itself or the total
            number of elements to be allocated.
        @return {VertexBuffer} The VertexBuffer object.
    */
    restore(data) {
        if (!data) {
            data = this.byteLength;
        }

        // Don't want to update vertex array bindings
        if (this.appState.vertexArray) {
            this.gl.bindVertexArray(null);
            this.appState.vertexArray = null;
        }

        this.buffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.binding, this.buffer);
        this.gl.bufferData(this.binding, data, this.usage);
        this.gl.bindBuffer(this.binding, null);

        return this;
    }

    /**
        Update data in this buffer. NOTE: the data must fit
        the originally-allocated buffer!

        @method
        @param {ArrayBufferView} data Data to store in the buffer.
        @param {number} [offset=0] Byte offset into the buffer at which to start writing.
        @return {VertexBuffer} The VertexBuffer object.
    */
    data(data, offset = 0) {
        // Don't want to update vertex array bindings
        if (this.appState.vertexArray) {
            this.gl.bindVertexArray(null);
            this.appState.vertexArray = null;
        }

        this.gl.bindBuffer(this.binding, this.buffer);
        this.gl.bufferSubData(this.binding, offset, data);
        this.gl.bindBuffer(this.binding, null);

        return this;
    }

    /**
        Delete this array buffer.

        @method
        @return {VertexBuffer} The VertexBuffer object.
    */
    delete() {
        if (this.buffer) {
            this.gl.deleteBuffer(this.buffer);
            this.buffer = null;
        }

        return this;
    }

}

///////////////////////////////////////////////////////////////////////////////////

/**
    Primary entry point to PicoGL. An app will store all parts of the WebGL
    state.

    @class App
    @param {WebGLRenderingContext} gl
    @prop {HTMLElement} canvas The canvas on which this app drawing.
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {number} width The width of the drawing surface.
    @prop {number} height The height of the drawing surface.
    @prop {Object} state Tracked GL state.
    @prop {Object} state.drawFramebufferBinding=GL.DRAW_FRAMEBUFFER Binding point to bind framebuffers to for draw. Should be set before any binding occurs. Should only have values GL.DRAW_FRAMEBUFFER or GL.FRAMEBUFFER (the latter with state.readFramebufferBinding set to the same).
    @prop {Object} state.readFramebufferBinding=GL.READ_FRAMEBUFFER  Binding point to bind framebuffers to for read. Should be set before any binding occurs. Should only have values GL.READ_FRAMEBUFFER or GL.FRAMEBUFFER (the latter with state.drawFramebufferBinding set to the same).
    @prop {GLenum} clearBits Current clear mask to use with clear().
*/
class App {

    constructor(gl) {
        this.gl = gl;
        this.canvas = gl.canvas;
        this.width = this.gl.drawingBufferWidth;
        this.height = this.gl.drawingBufferHeight;
        this.viewportX = 0;
        this.viewportY = 0;
        this.viewportWidth = 0;
        this.viewportHeight = 0;
        this.currentDrawCalls = null;
        this.emptyFragmentShader = null;

        this.state = {
            program: null,
            vertexArray: null,
            transformFeedback: null,
            activeTexture: -1,
            textures: new Array(WEBGL_INFO.MAX_TEXTURE_UNITS),
            uniformBuffers: new Array(WEBGL_INFO.MAX_UNIFORM_BUFFERS),
            freeUniformBufferBases: [],
            framebuffers: {},
            drawFramebufferBinding: GL.DRAW_FRAMEBUFFER,
            readFramebufferBinding: GL.READ_FRAMEBUFFER,
            extensions: {}
        };

        this.clearBits = this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT| this.gl.STENCIL_BUFFER_BIT;

        this.cpuTime = 0;
        this.gpuTime = 0;

        this.viewport(0, 0, this.width, this.height);

        this.contextLostExt = null;
        this.contextLostListener = null;
        this.contextRestoredListener = null;
        this.contextRestoredHandler = null;

        this.initExtensions();
    }

    /**
        Simulate context loss.

        @method
        @return {App} The App object.
    */
    loseContext() {
        if (this.contextLostExt) {
            this.contextLostExt.loseContext();
        }

        return this;
    }

    /**
        Simulate context restoration.

        @method
        @return {App} The App object.
    */
    restoreContext() {
        if (this.contextLostExt) {
            this.contextLostExt.restoreContext();
        }

        return this;
    }

    /**
        Set function to handle context restoration after loss.

        @method
        @param {function} fn Context restored handler.
        @return {App} The App object.
    */
    onContextRestored(fn) {
        this.contextRestoredHandler = fn;

        this.initContextListeners();

        return this;
    }

    /**
        Enable WebGL capability (e.g. depth testing, blending, etc.).

        @method
        @param {GLenum} cap Capability to enable.
        @return {App} The App object.
    */
    enable(cap) {
        this.gl.enable(cap);

        return this;
    }

    /**
        Disable WebGL capability (e.g. depth testing, blending, etc.).

        @method
        @param {GLenum} cap Capability to disable.
        @return {App} The App object.
    */
    disable(cap) {
        this.gl.disable(cap);

        return this;
    }

    /**
        Set the color mask to selectively enable or disable particular
        color channels while rendering.

        @method
        @param {boolean} r Red channel.
        @param {boolean} g Green channel.
        @param {boolean} b Blue channel.
        @param {boolean} a Alpha channel.
        @return {App} The App object.
    */
    colorMask(r, g, b, a) {
        this.gl.colorMask(r, g, b, a);

        return this;
    }

    /**
        Set the clear color.

        @method
        @param {number} r Red channel.
        @param {number} g Green channel.
        @param {number} b Blue channel.
        @param {number} a Alpha channel.
        @return {App} The App object.
    */
    clearColor(r, g, b, a) {
        this.gl.clearColor(r, g, b, a);

        return this;
    }

    /**
        Set the clear mask bits to use when calling clear().
        E.g. app.clearMask(PicoGL.COLOR_BUFFER_BIT).

        @method
        @param {GLenum} mask Bit mask of buffers to clear.
        @return {App} The App object.
    */
    clearMask(mask) {
        this.clearBits = mask;

        return this;
    }

    /**
        Clear the canvas

        @method
        @return {App} The App object.
    */
    clear() {
        this.gl.clear(this.clearBits);

        return this;
    }

    /**
        Bind a draw framebuffer to the WebGL context.

        @method
        @param {Framebuffer} framebuffer The Framebuffer object to bind.
        @see Framebuffer
        @return {App} The App object.
    */
    drawFramebuffer(framebuffer) {
        framebuffer.bindForDraw();

        return this;
    }

    /**
        Bind a read framebuffer to the WebGL context.

        @method
        @param {Framebuffer} framebuffer The Framebuffer object to bind.
        @see Framebuffer
        @return {App} The App object.
    */
    readFramebuffer(framebuffer) {
        framebuffer.bindForRead();

        return this;
    }

    /**
        Switch back to the default framebuffer for drawing (i.e. draw to the screen).
        Note that this method resets the viewport to match the default framebuffer.

        @method
        @return {App} The App object.
    */
    defaultDrawFramebuffer() {
        let binding = this.state.drawFramebufferBinding;
        if (this.state.framebuffers[binding] !== null) {
            this.gl.bindFramebuffer(binding, null);
            this.state.framebuffers[binding] = null;
        }

        return this;
    }

    /**
        Switch back to the default framebuffer for reading (i.e. read from the screen).

        @method
        @return {App} The App object.
    */
    defaultReadFramebuffer() {
        let binding = this.state.readFramebufferBinding;
        if (this.state.framebuffers[binding] !== null) {
            this.gl.bindFramebuffer(binding, null);
            this.state.framebuffers[binding] = null;
        }

        return this;
    }

    /**
        Copy data from framebuffer attached to READ_FRAMEBUFFER to framebuffer attached to DRAW_FRAMEBUFFER.

        @method
        @param {GLenum} mask Write mask (e.g. PicoGL.COLOR_BUFFER_BIT).
        @param {Object} [options] Blit options.
        @param {number} [options.srcStartX=0] Source start x coordinate.
        @param {number} [options.srcStartY=0] Source start y coordinate.
        @param {number} [options.srcEndX=Width of the read framebuffer] Source end x coordinate.
        @param {number} [options.srcEndY=Height of the read framebuffer] Source end y coordinate.
        @param {number} [options.dstStartX=0] Destination start x coordinate.
        @param {number} [options.dstStartY=0] Destination start y coordinate.
        @param {number} [options.dstEndX=Width of the draw framebuffer] Destination end x coordinate.
        @param {number} [options.dstEndY=Height of the draw framebuffer] Destination end y coordinate.
        @param {number} [options.filter=NEAREST] Sampling filter.
        @return {App} The App object.
    */
    blitFramebuffer(mask, options = DUMMY_OBJECT) {
        let readBinding = this.state.readFramebufferBinding;
        let drawBinding = this.state.drawFramebufferBinding;
        let readFramebuffer = this.state.framebuffers[readBinding];
        let drawFramebuffer = this.state.framebuffers[drawBinding];
        let defaultReadWidth = readFramebuffer ? readFramebuffer.width : this.width;
        let defaultReadHeight = readFramebuffer ? readFramebuffer.height : this.height;
        let defaultDrawWidth = drawFramebuffer ? drawFramebuffer.width : this.width;
        let defaultDrawHeight = drawFramebuffer ? drawFramebuffer.height : this.height;

        let {
            srcStartX = 0,
            srcStartY = 0,
            srcEndX = defaultReadWidth,
            srcEndY = defaultReadHeight,
            dstStartX = 0,
            dstStartY = 0,
            dstEndX = defaultDrawWidth,
            dstEndY = defaultDrawHeight,
            filter = GL.NEAREST
        } = options;

        this.gl.blitFramebuffer(srcStartX, srcStartY, srcEndX, srcEndY, dstStartX, dstStartY, dstEndX, dstEndY, mask, filter);

        return this;
    }

    /**
        Set the depth range.

        @method
        @param {number} near Minimum depth value.
        @param {number} far Maximum depth value.
        @return {App} The App object.
    */
    depthRange(near, far) {
        this.gl.depthRange(near, far);

        return this;
    }

    /**
        Enable or disable writing to the depth buffer.

        @method
        @param {Boolean} mask The depth mask.
        @return {App} The App object.
    */
    depthMask(mask) {
        this.gl.depthMask(mask);

        return this;
    }

    /**
        Set the depth test function. E.g. app.depthFunc(PicoGL.LEQUAL).

        @method
        @param {GLenum} func The depth testing function to use.
        @return {App} The App object.
    */
    depthFunc(func) {
        this.gl.depthFunc(func);

        return this;
    }

    /**
        Set the blend function. E.g. app.blendFunc(PicoGL.ONE, PicoGL.ONE_MINUS_SRC_ALPHA).

        @method
        @param {GLenum} src The source blending weight.
        @param {GLenum} dest The destination blending weight.
        @return {App} The App object.
    */
    blendFunc(src, dest) {
        this.gl.blendFunc(src, dest);

        return this;
    }

    /**
        Set the blend function, with separate weighting for color and alpha channels.
        E.g. app.blendFuncSeparate(PicoGL.ONE, PicoGL.ONE_MINUS_SRC_ALPHA, PicoGL.ONE, PicoGL.ONE).

        @method
        @param {GLenum} csrc The source blending weight for the RGB channels.
        @param {GLenum} cdest The destination blending weight for the RGB channels.
        @param {GLenum} asrc The source blending weight for the alpha channel.
        @param {GLenum} adest The destination blending weight for the alpha channel.
        @return {App} The App object.
    */
    blendFuncSeparate(csrc, cdest, asrc, adest) {
        this.gl.blendFuncSeparate(csrc, cdest, asrc, adest);

        return this;
    }

    /**
        Set the blend equation. E.g. app.blendEquation(PicoGL.MIN).

        @method
        @param {GLenum} mode The operation to use in combining source and destination channels.
        @return {App} The App object.
    */
    blendEquation(mode) {
        this.gl.blendEquation(mode);

        return this;
    }

    /**
        Set the bitmask to use for tested stencil values.
        E.g. app.stencilMask(0xFF).
        NOTE: Only works if { stencil: true } passed as a
        context attribute when creating the App!

        @method
        @param {number} mask The mask value.
        @return {App} The App object.

    */
    stencilMask(mask) {
        this.gl.stencilMask(mask);

        return this;
    }

    /**
        Set the bitmask to use for tested stencil values for a particular face orientation.
        E.g. app.stencilMaskSeparate(PicoGL.FRONT, 0xFF).
        NOTE: Only works if { stencil: true } passed as a
        context attribute when creating the App!

        @method
        @param {GLenum} face The face orientation to apply the mask to.
        @param {number} mask The mask value.
        @return {App} The App object.
    */
    stencilMaskSeparate(face, mask) {
        this.gl.stencilMaskSeparate(face, mask);

        return this;
    }

    /**
        Set the stencil function and reference value.
        E.g. app.stencilFunc(PicoGL.EQUAL, 1, 0xFF).
        NOTE: Only works if { stencil: true } passed as a
        context attribute when creating the App!

        @method
        @param {GLenum} func The testing function.
        @param {number} ref The reference value.
        @param {GLenum} mask The bitmask to use against tested values before applying
            the stencil function.
        @return {App} The App object.
    */
    stencilFunc(func, ref, mask) {
        this.gl.stencilFunc(func, ref, mask);

        return this;
    }

    /**
        Set the stencil function and reference value for a particular face orientation.
        E.g. app.stencilFuncSeparate(PicoGL.FRONT, PicoGL.EQUAL, 1, 0xFF).
        NOTE: Only works if { stencil: true } passed as a
        context attribute when creating the App!

        @method
        @param {GLenum} face The face orientation to apply the function to.
        @param {GLenum} func The testing function.
        @param {number} ref The reference value.
        @param {GLenum} mask The bitmask to use against tested values before applying
            the stencil function.
        @return {App} The App object.
    */
    stencilFuncSeparate(face, func, ref, mask) {
        this.gl.stencilFuncSeparate(face, func, ref, mask);

        return this;
    }

    /**
        Set the operations for updating stencil buffer values.
        E.g. app.stencilOp(PicoGL.KEEP, PicoGL.KEEP, PicoGL.REPLACE).
        NOTE: Only works if { stencil: true } passed as a
        context attribute when creating the App!

        @method
        @param {GLenum} stencilFail Operation to apply if the stencil test fails.
        @param {GLenum} depthFail Operation to apply if the depth test fails.
        @param {GLenum} pass Operation to apply if the both the depth and stencil tests pass.
        @return {App} The App object.
    */
    stencilOp(stencilFail, depthFail, pass) {
        this.gl.stencilOp(stencilFail, depthFail, pass);

        return this;
    }

    /**
        Set the operations for updating stencil buffer values for a particular face orientation.
        E.g. app.stencilOpSeparate(PicoGL.FRONT, PicoGL.KEEP, PicoGL.KEEP, PicoGL.REPLACE).
        NOTE: Only works if { stencil: true } passed as a
        context attribute when creating the App!

        @method
        @param {GLenum} face The face orientation to apply the operations to.
        @param {GLenum} stencilFail Operation to apply if the stencil test fails.
        @param {GLenum} depthFail Operation to apply if the depth test fails.
        @param {GLenum} pass Operation to apply if the both the depth and stencil tests pass.
        @return {App} The App object.
    */
    stencilOpSeparate(face, stencilFail, depthFail, pass) {
        this.gl.stencilOpSeparate(face, stencilFail, depthFail, pass);

        return this;
    }

    /**
        Define the scissor box.

        @method
        @param {Number} x Horizontal position of the scissor box.
        @param {Number} y Vertical position of the scissor box.
        @param {Number} width Width of the scissor box.
        @param {Number} height Height of the scissor box.
        @return {App} The App object.
    */
    scissor(x, y, width, height) {
        this.gl.scissor(x, y, width, height);

        return this;
    }

    /**
        Set the scale and units used.

        @method
        @param {Number} factor Scale factor used to create a variable depth offset for each polygon.
        @param {Number} units Constant depth offset.
        @return {App} The App object.
    */
    polygonOffset(factor, units) {
        this.gl.polygonOffset(factor, units);

        return this;
    }

    /**
        Read a pixel's color value from the currently-bound framebuffer.

        @method
        @param {number} x The x coordinate of the pixel.
        @param {number} y The y coordinate of the pixel.
        @param {ArrayBufferView} outColor Typed array to store the pixel's color.
        @param {object} [options] Options.
        @param {GLenum} [options.type=UNSIGNED_BYTE] Type of data stored in the read framebuffer.
        @param {GLenum} [options.format=RGBA] Read framebuffer data format.
        @return {App} The App object.
    */
    readPixel(x, y, outColor, options = DUMMY_OBJECT) {
        let {
            format = GL.RGBA,
            type = GL.UNSIGNED_BYTE
        } = options;

        this.gl.readPixels(x, y, 1, 1, format, type, outColor);

        return this;
    }

    /**
        Set the viewport.

        @method
        @param {number} x Left bound of the viewport rectangle.
        @param {number} y Lower bound of the viewport rectangle.
        @param {number} width Width of the viewport rectangle.
        @param {number} height Height of the viewport rectangle.
        @return {App} The App object.
    */
    viewport(x, y, width, height) {

        if (this.viewportWidth !== width || this.viewportHeight !== height ||
                this.viewportX !== x || this.viewportY !== y) {
            this.viewportX = x;
            this.viewportY = y;
            this.viewportWidth = width;
            this.viewportHeight = height;
            this.gl.viewport(x, y, this.viewportWidth, this.viewportHeight);
        }

        return this;
    }

    /**
        Set the viewport to the full canvas.

        @method
        @return {App} The App object.
    */
    defaultViewport() {
        this.viewport(0, 0, this.width, this.height);

        return this;
    }

    /**
        Resize the drawing surface.

        @method
        @param {number} width The new canvas width.
        @param {number} height The new canvas height.
        @return {App} The App object.
    */
    resize(width, height) {
        this.canvas.width = width;
        this.canvas.height = height;

        this.width = this.gl.drawingBufferWidth;
        this.height = this.gl.drawingBufferHeight;
        this.viewport(0, 0, this.width, this.height);

        return this;
    }

    /**
        Create a program synchronously. It is highly recommended to use <b>createPrograms</b> instead as
            that method will compile shaders in parallel where possible.
        @method
        @param {Shader|string} vertexShader Vertex shader object or source code.
        @param {Shader|string} fragmentShader Fragment shader object or source code.
        @param {Object} [options] Texture options.
        @param {Object} [options.attributeLocations] Map of attribute names to locations (useful when using GLSL 1).
        @param {Array} [options.transformFeedbackVaryings] Array of varying names used for transform feedback output.
        @param {GLenum} [options.transformFeedbackMode] Capture mode of the transform feedback. (Default: PicoGL.SEPARATE_ATTRIBS).
        @return {Program} New Program object.
    */
    createProgram(vsSource, fsSource, opts = {}) {
        let {transformFeedbackVaryings, attributeLocations, transformFeedbackMode} = opts;

        return new Program(this.gl, this.state, vsSource, fsSource, transformFeedbackVaryings, attributeLocations, transformFeedbackMode)
            .link()
            .checkLinkage();
    }

    /**
        Create several programs. Preferred method for program creation as it will compile shaders
        in parallel where possible.

        @method
        @param {...Array} sources Variable number of 2 or 3 element arrays, each containing:
            <ul>
                <li> (Shader|string) Vertex shader object or source code.
                <li> (Shader|string) Fragment shader object or source code.
                <li> (Object - optional) Optional program parameters.
                <ul>
                    <li>(Object - optional) <strong><code>attributeLocations</code></strong> Map of attribute names to locations (useful when using GLSL 1).
                    <li>(Array - optional) <strong><code>transformFeedbackVaryings</code></strong> Array of varying names used for transform feedback output.
                    <li>(GLenum - optional) <strong><code>transformFeedbackMode</code></strong> Capture mode of the transform feedback. (Default: PicoGL.SEPARATE_ATTRIBS).
                </ul>
                </ul>
            </ul>
        @return {Promise<Program[]>} Promise that will resolve to an array of Programs when compilation and
            linking are complete for all programs.
    */
    createPrograms(...sources) {
        return new Promise((resolve, reject) => {
            let numPrograms = sources.length;
            let programs = new Array(numPrograms);
            let pendingPrograms = new Array(numPrograms);
            let numPending = numPrograms;

            for (let i = 0; i < numPrograms; ++i) {
                let source = sources[i];
                let vsSource = source[0];
                let fsSource = source[1];
                let opts = source[2] || {};
                let {transformFeedbackVaryings, attributeLocations, transformFeedbackMode} = opts;
                programs[i] = new Program(this.gl, this.state, vsSource, fsSource, transformFeedbackVaryings, attributeLocations, transformFeedbackMode);
                pendingPrograms[i] = programs[i];
            }

            for (let i = 0; i < numPrograms; ++i) {
                programs[i].link();
            }

            let poll = () => {
                let linked = 0;
                for (let i = 0; i < numPending; ++i) {
                    if (pendingPrograms[i].checkCompletion()) {
                        pendingPrograms[i].checkLinkage();
                        if (pendingPrograms[i].linked) {
                            ++linked;
                        } else {
                            reject(new Error("Program linkage failed"));
                            return;
                        }
                    } else {
                        pendingPrograms[i - linked] = pendingPrograms[i];
                    }
                }

                numPending -= linked;

                if (numPending === 0) {
                    resolve(programs);
                } else {
                    requestAnimationFrame(poll);
                }
            };

            poll();
        });
    }

    /**
        Restore several programs after a context loss. Will do so in parallel where available.

        @method
        @param {...Program} sources Variable number of programs to restore.

        @return {Promise<void>} Promise that will resolve once all programs have been restored.
    */
    restorePrograms(...programs) {
        return new Promise((resolve, reject) => {
            let numPrograms = programs.length;
            let pendingPrograms = programs.slice();
            let numPending = numPrograms;

            for (let i = 0; i < numPrograms; ++i) {
                programs[i].initialize();
            }

            for (let i = 0; i < numPrograms; ++i) {
                programs[i].link();
            }

            for (let i = 0; i < numPrograms; ++i) {
                programs[i].checkCompletion();
            }

            let poll = () => {
                let linked = 0;
                for (let i = 0; i < numPending; ++i) {
                    if (pendingPrograms[i].checkCompletion()) {
                        pendingPrograms[i].checkLinkage();
                        if (pendingPrograms[i].linked) {
                            ++linked;
                        } else {
                            reject(new Error("Program linkage failed"));
                            return;
                        }
                    } else {
                        pendingPrograms[i - linked] = pendingPrograms[i];
                    }
                }

                numPending -= linked;

                if (numPending === 0) {
                    resolve();
                } else {
                    requestAnimationFrame(poll);
                }
            };

            poll();
        });
    }

    /**
        Create a shader. Creating a shader separately from a program allows for
        shader reuse.

        @method
        @param {GLenum} type Shader type.
        @param {string} source Shader source.
        @return {Shader} New Shader object.
    */
    createShader(type, source) {
        return new Shader(this.gl, this.state, type, source);
    }

    /**
        Create a vertex array.

        @method
        @return {VertexArray} New VertexArray object.
    */
    createVertexArray() {
        return new VertexArray(this.gl, this.state);
    }

    /**
        Create a transform feedback object.

        @method
        @return {TransformFeedback} New TransformFeedback object.
    */
    createTransformFeedback() {
        return new TransformFeedback(this.gl, this.state);
    }

    /**
        Create a vertex buffer.

        @method
        @param {GLenum} type The data type stored in the vertex buffer.
        @param {number} itemSize Number of elements per vertex.
        @param {ArrayBufferView|number} data Buffer data itself or the total
            number of elements to be allocated.
        @param {GLenum} [usage=STATIC_DRAW] Buffer usage.
        @return {VertexBuffer} New VertexBuffer object.
    */
    createVertexBuffer(type, itemSize, data, usage) {
        return new VertexBuffer(this.gl, this.state, type, itemSize, data, usage);
    }

    /**
        Create a per-vertex matrix buffer. Matrix buffers ensure that columns
        are correctly split across attribute locations.

        @method
        @param {GLenum} type The data type stored in the matrix buffer. Valid types
        are FLOAT_MAT4, FLOAT_MAT4x2, FLOAT_MAT4x3, FLOAT_MAT3, FLOAT_MAT3x2,
        FLOAT_MAT3x4, FLOAT_MAT2, FLOAT_MAT2x3, FLOAT_MAT2x4.
        @param {ArrayBufferView} data Matrix buffer data.
        @param {GLenum} [usage=STATIC_DRAW] Buffer usage.
        @return {VertexBuffer} New VertexBuffer object.
    */
    createMatrixBuffer(type, data, usage) {
        return new VertexBuffer(this.gl, this.state, type, 0, data, usage);
    }

    /**
        Create an buffer without any structure information. Structure
        must be fully specified when binding to a VertexArray.

        @method
        @param {number} bytesPerVertex Number of bytes per vertex.
        @param {ArrayBufferView|number} data Buffer data itself or the total
            number of bytes to be allocated.
        @param {GLenum} [usage=STATIC_DRAW] Buffer usage.
        @return {VertexBuffer} New VertexBuffer object.
    */
    createInterleavedBuffer(bytesPerVertex, data, usage) {
        return new VertexBuffer(this.gl, this.state, null, bytesPerVertex, data, usage);
    }

    /**
        Create an index buffer. If the `itemSize` is not specified, it defaults to 3

        @method
        @variation 1
        @param {GLenum} type The data type stored in the index buffer.
        @param {ArrayBufferView} data Index buffer data.
        @param {GLenum} [usage=STATIC_DRAW] Buffer usage.
        @return {VertexBuffer} New VertexBuffer object.
    *//**
        Create an index buffer.

        @method
        @variation 2
        @param {GLenum} type The data type stored in the index buffer.
        @param {number} itemSize Number of elements per primitive.
        @param {ArrayBufferView} data Index buffer data.
        @param {GLenum} [usage=STATIC_DRAW] Buffer usage.
        @return {VertexBuffer} New VertexBuffer object.
    */
    createIndexBuffer(type, itemSize, data, usage) {
        if (ArrayBuffer.isView(itemSize)) {
            usage = data;
            data = itemSize;
            itemSize = 3;
        }
        return new VertexBuffer(this.gl, this.state, type, itemSize, data, usage, true);
    }

    /**
        Create a uniform buffer in std140 layout. NOTE: FLOAT_MAT2, FLOAT_MAT3x2, FLOAT_MAT4x2,
        FLOAT_MAT3, FLOAT_MAT2x3, FLOAT_MAT4x3 are supported, but must be manually padded to
        4-float column alignment by the application!

        @method
        @param {Array} layout Array indicating the order and types of items to
                        be stored in the buffer.
        @param {GLenum} [usage=DYNAMIC_DRAW] Buffer usage.
        @return {UniformBuffer} New UniformBuffer object.
    */
    createUniformBuffer(layout, usage) {
        return new UniformBuffer(this.gl, this.state, layout, usage);
    }

    /**
        Create empty 2D texture.
        @method
        @variation 1
        @param {number} width - Texture width. Required for array or empty data.
        @param {number} height - Texture height. Required for array or empty data.
        @param {Object} [options] Texture options.
        @param {GLenum} [options.internalFormat=RGBA8] Texture data internal format. Must be a sized format.
        @param {GLenum} [options.type] Type of data stored in the texture. Default based on
            <b>internalFormat</b>.
        @param {boolean} [options.flipY=false] Whether the y-axis should be flipped when unpacking the texture.
        @param {boolean} [options.premultiplyAlpha=false] Whether the alpha channel should be pre-multiplied when unpacking the texture.
        @param {GLenum} [options.minFilter] Minification filter. Defaults to
            LINEAR_MIPMAP_NEAREST if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.magFilter] Magnification filter. Defaults to LINEAR
            if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.wrapS=REPEAT] Horizontal wrap mode.
        @param {GLenum} [options.wrapT=REPEAT] Vertical wrap mode.
        @param {GLenum} [options.compareMode=NONE] Comparison mode.
        @param {GLenum} [options.compareFunc=LEQUAL] Comparison function.
        @param {GLenum} [options.baseLevel] Base mipmap level.
        @param {GLenum} [options.maxLevel] Maximum mipmap level.
        @param {GLenum} [options.minLOD] Mimimum level of detail.
        @param {GLenum} [options.maxLOD] Maximum level of detail.
        @param {GLenum} [options.maxAnisotropy] Maximum anisotropy in filtering.
        @return {Texture} New Texture object.
    *//**
        Create a 2D texture from a DOM image element.
        @method
        @variation 2
        @param {HTMLImageElement|HTMLImageElement[]} image - Image data. An array can be passed to manually set all levels
            of the mipmap chain. If a single level is passed and mipmap filtering is being used,
            generateMipmap() will be called to produce the remaining levels.
        @param {Object} [options] Texture options.
        @param {GLenum} [options.internalFormat=RGBA8] Texture data internal format. Must be a sized format.
        @param {GLenum} [options.type] Type of data stored in the texture. Default based on
            <b>intrnalFormat</b>.
        @param {boolean} [options.flipY=false] Whether the y-axis should be flipped when unpacking the texture.
        @param {boolean} [options.premultiplyAlpha=false] Whether the alpha channel should be pre-multiplied when unpacking the texture.
        @param {GLenum} [options.minFilter] Minification filter. Defaults to
            LINEAR_MIPMAP_NEAREST if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.magFilter] Magnification filter. Defaults to LINEAR
            if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.wrapS=REPEAT] Horizontal wrap mode.
        @param {GLenum} [options.wrapT=REPEAT] Vertical wrap mode.
        @param {GLenum} [options.compareMode=NONE] Comparison mode.
        @param {GLenum} [options.compareFunc=LEQUAL] Comparison function.
        @param {GLenum} [options.baseLevel] Base mipmap level.
        @param {GLenum} [options.maxLevel] Maximum mipmap level.
        @param {GLenum} [options.minLOD] Mimimum level of detail.
        @param {GLenum} [options.maxLOD] Maximum level of detail.
        @param {GLenum} [options.maxAnisotropy] Maximum anisotropy in filtering.
        @return {Texture} New Texture object.
    *//**
        Create 2D texture from a typed array.
        @method
        @variation 3
        @param {ArrayBufferView|ArrayBufferView[]} image - Image data. An array can be passed to manually set all levels
            of the mipmap chain. If a single level is passed and mipmap filtering is being used,
            generateMipmap() will be called to produce the remaining levels.
        @param {number} width - Texture width. Required for array or empty data.
        @param {number} height - Texture height. Required for array or empty data.
        @param {Object} [options] Texture options.
        @param {GLenum} [options.internalFormat=RGBA8] Texture data internal format. Must be a sized format.
        @param {GLenum} [options.type] Type of data stored in the texture. Default based on
            <b>internalFormat</b>.
        @param {boolean} [options.flipY=false] Whether the y-axis should be flipped when unpacking the texture.
        @param {boolean} [options.premultiplyAlpha=false] Whether the alpha channel should be pre-multiplied when unpacking the texture.
        @param {GLenum} [options.minFilter] Minification filter. Defaults to
            LINEAR_MIPMAP_NEAREST if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.magFilter] Magnification filter. Defaults to LINEAR
            if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.wrapS=REPEAT] Horizontal wrap mode.
        @param {GLenum} [options.wrapT=REPEAT] Vertical wrap mode.
        @param {GLenum} [options.compareMode=NONE] Comparison mode.
        @param {GLenum} [options.compareFunc=LEQUAL] Comparison function.
        @param {GLenum} [options.baseLevel] Base mipmap level.
        @param {GLenum} [options.maxLevel] Maximum mipmap level.
        @param {GLenum} [options.minLOD] Mimimum level of detail.
        @param {GLenum} [options.maxLOD] Maximum level of detail.
        @param {GLenum} [options.maxAnisotropy] Maximum anisotropy in filtering.
        @return {Texture} New Texture object.
    */
    createTexture2D(image, width, height, options) {
        if (typeof image === "number") {
            // Create empty texture just give width/height.
            options = height;
            height = width;
            width = image;
            image = null;
        } else if (height === undefined) {
            // Passing in a DOM element. Height/width not required.
            options = width;
            width = image.width;
            height = image.height;
        }

        return new Texture(this.gl, this.state, this.gl.TEXTURE_2D, image, width, height, undefined, false, options);
    }

    /**
        Create a 2D texture array.

        @method
        @param {ArrayBufferView|Array} image Pixel data. An array can be passed to manually set all levels
            of the mipmap chain. If a single level is passed and mipmap filtering is being used,
            generateMipmap() will be called to produce the remaining levels.
        @param {number} width Texture width.
        @param {number} height Texture height.
        @param {number} size Number of images in the array.
        @param {Object} [options] Texture options.
        @param {GLenum} [options.internalFormat=RGBA8] Texture data internal format. Must be a sized format.
        @param {GLenum} [options.type] Type of data stored in the texture. Default based on
            <b>internalFormat</b>.
        @param {boolean} [options.flipY=false] Whether the y-axis should be flipped when unpacking the texture.
        @param {GLenum} [options.minFilter] Minification filter. Defaults to
            LINEAR_MIPMAP_NEAREST if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.magFilter] Magnification filter. Defaults to LINEAR
            if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.wrapS=REPEAT] Horizontal wrap mode.
        @param {GLenum} [options.wrapT=REPEAT] Vertical wrap mode.
        @param {GLenum} [options.wrapR=REPEAT] Depth wrap mode.
        @param {GLenum} [options.compareMode=NONE] Comparison mode.
        @param {GLenum} [options.compareFunc=LEQUAL] Comparison function.
        @param {GLenum} [options.baseLevel] Base mipmap level.
        @param {GLenum} [options.maxLevel] Maximum mipmap level.
        @param {GLenum} [options.minLOD] Mimimum level of detail.
        @param {GLenum} [options.maxLOD] Maximum level of detail.
        @param {GLenum} [options.maxAnisotropy] Maximum anisotropy in filtering.
        @return {Texture} New Texture object.
    */
    createTextureArray(image, width, height, depth, options) {
        if (typeof image === "number") {
            // Create empty texture just give width/height/depth.
            options = depth;
            depth = height;
            height = width;
            width = image;
            image = null;
        }
        return new Texture(this.gl, this.state, this.gl.TEXTURE_2D_ARRAY, image, width, height, depth, true, options);
    }

    /**
        Create a 3D texture.

        @method
        @param {ArrayBufferView|Array} image Pixel data. An array can be passed to manually set all levels
            of the mipmap chain. If a single level is passed and mipmap filtering is being used,
            generateMipmap() will be called to produce the remaining levels.
        @param {number} width Texture width.
        @param {number} height Texture height.
        @param {number} depth Texture depth.
        @param {Object} [options] Texture options.
        @param {GLenum} [options.internalFormat=RGBA8] Texture data internal format. Must be a sized format.
        @param {GLenum} [options.type] Type of data stored in the texture. Default based on
            <b>internalFormat</b>.
        @param {boolean} [options.flipY=false] Whether the y-axis should be flipped when unpacking the texture.
        @param {GLenum} [options.minFilter] Minification filter. Defaults to
            LINEAR_MIPMAP_NEAREST if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.magFilter] Magnification filter. Defaults to LINEAR
            if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.wrapS=REPEAT] Horizontal wrap mode.
        @param {GLenum} [options.wrapT=REPEAT] Vertical wrap mode.
        @param {GLenum} [options.wrapR=REPEAT] Depth wrap mode.
        @param {GLenum} [options.compareMode=NONE] Comparison mode.
        @param {GLenum} [options.compareFunc=LEQUAL] Comparison function.
        @param {GLenum} [options.baseLevel] Base mipmap level.
        @param {GLenum} [options.maxLevel] Maximum mipmap level.
        @param {GLenum} [options.minLOD] Mimimum level of detail.
        @param {GLenum} [options.maxLOD] Maximum level of detail.
        @param {GLenum} [options.maxAnisotropy] Maximum anisotropy in filtering.
        @return {Texture} New Texture object.
    */
    createTexture3D(image, width, height, depth, options) {
        if (typeof image === "number") {
            // Create empty texture just give width/height/depth.
            options = depth;
            depth = height;
            height = width;
            width = image;
            image = null;
        }
        return new Texture(this.gl, this.state, this.gl.TEXTURE_3D, image, width, height, depth, true, options);
    }

    /**
        Create a cubemap.

        @method
        @param {Object} options Texture options.
        @param {HTMLElement|ArrayBufferView} [options.negX] The image data for the negative X direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.posX] The image data for the positive X direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.negY] The image data for the negative Y direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.posY] The image data for the positive Y direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.negZ] The image data for the negative Z direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.posZ] The image data for the positive Z direction.
                Can be any format that would be accepted by texImage2D.
        @param {number} [options.width] Cubemap side width. Defaults to the width of negX if negX is an image.
        @param {number} [options.height] Cubemap side height. Defaults to the height of negX if negX is an image.
        @param {GLenum} [options.internalFormat=RGBA8] Texture data internal format. Must be a sized format.
        @param {GLenum} [options.type] Type of data stored in the texture. Default based on
            <b>internalFormat</b>.
        @param {boolean} [options.flipY=false] Whether the y-axis should be flipped when unpacking the image.
        @param {boolean} [options.premultiplyAlpha=false] Whether the alpha channel should be pre-multiplied when unpacking the image.
        @param {GLenum} [options.minFilter] Minification filter. Defaults to
            LINEAR_MIPMAP_NEAREST if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.magFilter] Magnification filter. Defaults to LINEAR
            if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.wrapS=REPEAT] Horizontal wrap mode.
        @param {GLenum} [options.wrapT=REPEAT] Vertical wrap mode.
        @param {GLenum} [options.compareMode=NONE] Comparison mode.
        @param {GLenum} [options.compareFunc=LEQUAL] Comparison function.
        @param {GLenum} [options.baseLevel] Base mipmap level.
        @param {GLenum} [options.maxLevel] Maximum mipmap level.
        @param {GLenum} [options.minLOD] Mimimum level of detail.
        @param {GLenum} [options.maxLOD] Maximum level of detail.
        @param {GLenum} [options.maxAnisotropy] Maximum anisotropy in filtering.
        @return {Cubemap} New Cubemap object.
    */
    createCubemap(options) {
        return new Cubemap(this.gl, this.state, options);
    }

    /**
        Create a renderbuffer.

        @method
        @param {number} width Renderbuffer width.
        @param {number} height Renderbuffer height.
        @param {GLenum} internalFormat Internal arrangement of the renderbuffer data.
        @param {number} [samples=0] Number of MSAA samples.
        @return {Renderbuffer} New Renderbuffer object.
    */
    createRenderbuffer(width, height, internalFormat, samples = 0) {
        return new Renderbuffer(this.gl, width, height, internalFormat, samples);
    }

    /**
        Create a framebuffer.

        @method
        @return {Framebuffer} New Framebuffer object.
    */
    createFramebuffer() {
        return new Framebuffer(this.gl, this.state);
    }

    /**
        Create a query.

        @method
        @param {GLenum} target Information to query.
        @return {Query} New Query object.
    */
    createQuery(target) {
        return new Query(this.gl, target);
    }

    /**
        Create a timer.

        @method
        @return {Timer} New Timer object.
    */
    createTimer() {
        return new Timer(this.gl);
    }

    /**
        Create a DrawCall. A DrawCall manages the state associated with
        a WebGL draw call including a program and associated vertex data, textures,
        uniforms and uniform blocks.

        @method
        @param {Program} program The program to use for this DrawCall.
        @param {VertexArray} [vertexArray=null] Vertex data to use for drawing.
        @return {DrawCall} New DrawCall object.
    */
    createDrawCall(program, vertexArray, primitive) {
        return new DrawCall(this.gl, this.state, program, vertexArray, primitive);
    }

    // Enable extensions
    initExtensions() {
        this.gl.getExtension("EXT_color_buffer_float");
        this.gl.getExtension("OES_texture_float_linear");
        this.gl.getExtension("WEBGL_compressed_texture_s3tc");
        this.gl.getExtension("WEBGL_compressed_texture_s3tc_srgb");
        this.gl.getExtension("WEBGL_compressed_texture_etc");
        this.gl.getExtension("WEBGL_compressed_texture_astc");
        this.gl.getExtension("WEBGL_compressed_texture_pvrtc");
        this.gl.getExtension("EXT_disjoint_timer_query_webgl2");
        this.gl.getExtension("EXT_disjoint_timer_query");
        this.gl.getExtension("EXT_texture_filter_anisotropic");

        this.state.extensions.debugShaders = this.gl.getExtension("WEBGL_debug_shaders");
        this.contextLostExt = this.gl.getExtension("WEBGL_lose_context");

        // Draft extensions
        this.gl.getExtension("KHR_parallel_shader_compile");
        this.state.extensions.multiDrawInstanced = this.gl.getExtension("WEBGL_multi_draw_instanced");
    }

    initContextListeners() {
        if (this.contextRestoredHandler) {
            this.contextLostListener = (e) => {
                e.preventDefault();
            };
            this.contextRestoredListener = () => {
                this.initExtensions();
                this.contextRestoredHandler();
            };
            this.canvas.addEventListener("webglcontextlost", this.contextLostListener);
            this.canvas.addEventListener("webglcontextrestored", this.contextRestoredListener);
        } else {
            this.canvas.removeEventListener("webglcontextlost", this.contextLostListener);
            this.canvas.removeEventListener("webglcontextrestored", this.contextRestoredListener);
            this.contextLostListener = null;
            this.contextRestoredListener = null;
        }
    }

    // DEPRECATED

    depthTest() {
        console.warn("App.depthTest is deprecated. Use App.enable(PicoGL.DEPTH_TEST) instead.");
        this.enable(GL.DEPTH_TEST);

        return this;
    }

    noDepthTest() {
        console.warn("App.noDepthTest is deprecated. Use App.disable(PicoGL.DEPTH_TEST) instead.");
        this.disable(GL.DEPTH_TEST);

        return this;
    }

    blend() {
        console.warn("App.blend is deprecated. Use App.enable(PicoGL.BLEND) instead.");
        this.enable(GL.BLEND);

        return this;
    }

    noBlend() {
        console.warn("App.noBlend is deprecated. Use App.disable(PicoGL.BLEND) instead.");
        this.disable(GL.BLEND);

        return this;
    }

    stencilTest() {
        console.warn("App.stencilTest is deprecated. Use App.enable(PicoGL.STENCIL_TEST) instead.");
        this.enable(GL.STENCIL_TEST);

        return this;
    }

    noStencilTest() {
        console.warn("App.noStencilTest is deprecated. Use App.disable(PicoGL.STENCIL_TEST) instead.");
        this.disable(GL.STENCIL_TEST);

        return this;
    }

    scissorTest() {
        console.warn("App.scissorTest is deprecated. Use App.enable(PicoGL.SCISSOR_TEST) instead.");
        this.enable(GL.SCISSOR_TEST);

        return this;
    }

    noScissorTest() {
        console.warn("App.noScissorTest is deprecated. Use App.disable(PicoGL.SCISSOR_TEST) instead.");
        this.disable(GL.SCISSOR_TEST);

        return this;
    }

    rasterize() {
        console.warn("App.noRasterize is deprecated. Use App.disable(PicoGL.RASTERIZER_DISCARD) instead.");
        this.disable(GL.RASTERIZER_DISCARD);

        return this;
    }

    noRasterize() {
        console.warn("App.rasterize is deprecated. Use App.enable(PicoGL.RASTERIZER_DISCARD) instead.");
        this.enable(GL.RASTERIZER_DISCARD);

        return this;
    }

    cullBackfaces() {
        console.warn("App.cullBackfaces is deprecated. Use App.enable(PicoGL.CULL_FACE) instead.");
        this.enable(GL.CULL_FACE);

        return this;
    }

    drawBackfaces() {
        console.warn("App.drawBackfaces is deprecated. Use App.disable(PicoGL.CULL_FACE) instead.");
        this.disable(GL.CULL_FACE);

        return this;
    }

}

///////////////////////////////////////////////////////////////////////////////////

let webglInfoInitialized = false;

/**
    Global PicoGL module. For convenience, all WebGL enums are stored
    as properties of PicoGL (e.g. PicoGL.FLOAT, PicoGL.ONE_MINUS_SRC_ALPHA).

    @namespace PicoGL
*/
const PicoGL = Object.assign({
    /**
        The version of PicoGL

        @type {string}
        @name PicoGL.version
        @private
     */
    version: "0.17.9",

    /**
        WebGL information about the current system

        @type {Object.<string, *>}
        @name PicoGL.WEBGL_INFO
        @private
     */
    WEBGL_INFO,

    /**
        Create a PicoGL app. The app is the primary entry point to PicoGL. It stores
        the canvas, the WebGL context and all WebGL state.

        @function PicoGL.createApp
        @param {HTMLElement} canvas The canvas on which to create the WebGL context.
        @param {Object} [contextAttributes] Context attributes to pass when calling getContext().
        @return {App} New App object.
    */
    createApp(gl, contextAttributes) {

        // Support providing a canvas and getting a WebGL 2 context
        if (gl.tagName === "CANVAS") {
            gl = gl.getContext("webgl2", contextAttributes);
        }

        if (!webglInfoInitialized) {
            WEBGL_INFO.MAX_TEXTURE_UNITS = gl.getParameter(GL.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            WEBGL_INFO.MAX_UNIFORM_BUFFERS = gl.getParameter(GL.MAX_UNIFORM_BUFFER_BINDINGS);
            WEBGL_INFO.MAX_UNIFORMS = Math.min(
                gl.getParameter(GL.MAX_VERTEX_UNIFORM_VECTORS),
                gl.getParameter(GL.MAX_FRAGMENT_UNIFORM_VECTORS)
            );
            WEBGL_INFO.SAMPLES = gl.getParameter(GL.SAMPLES);
            WEBGL_INFO.VENDOR = "(Unknown)";
            WEBGL_INFO.RENDERER = "(Unknown)";

            // Extensions
            WEBGL_INFO.FLOAT_RENDER_TARGETS = Boolean(gl.getExtension("EXT_color_buffer_float"));
            WEBGL_INFO.LINEAR_FLOAT_TEXTURES = Boolean(gl.getExtension("OES_texture_float_linear"));
            WEBGL_INFO.S3TC_TEXTURES = Boolean(gl.getExtension("WEBGL_compressed_texture_s3tc"));
            WEBGL_INFO.S3TC_SRGB_TEXTURES = Boolean(gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"));
            WEBGL_INFO.ETC_TEXTURES = Boolean(gl.getExtension("WEBGL_compressed_texture_etc"));
            WEBGL_INFO.ASTC_TEXTURES = Boolean(gl.getExtension("WEBGL_compressed_texture_astc"));
            WEBGL_INFO.PVRTC_TEXTURES = Boolean(gl.getExtension("WEBGL_compressed_texture_pvrtc"));
            WEBGL_INFO.LOSE_CONTEXT = Boolean(gl.getExtension("WEBGL_lose_context"));
            WEBGL_INFO.DEBUG_SHADERS = Boolean(gl.getExtension("WEBGL_debug_shaders"));
            WEBGL_INFO.GPU_TIMER = Boolean(gl.getExtension("EXT_disjoint_timer_query_webgl2") || gl.getExtension("EXT_disjoint_timer_query"));

            WEBGL_INFO.TEXTURE_ANISOTROPY = Boolean(gl.getExtension("EXT_texture_filter_anisotropic"));
            WEBGL_INFO.MAX_TEXTURE_ANISOTROPY = WEBGL_INFO.TEXTURE_ANISOTROPY ? gl.getParameter(GL.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;

            WEBGL_INFO.DEBUG_RENDERER_INFO = Boolean(gl.getExtension("WEBGL_debug_renderer_info"));
            if (WEBGL_INFO.DEBUG_RENDERER_INFO) {
                WEBGL_INFO.VENDOR = gl.getParameter(GL.UNMASKED_VENDOR_WEBGL);
                WEBGL_INFO.RENDERER = gl.getParameter(GL.UNMASKED_RENDERER_WEBGL);
            }

            // Draft extensions
            WEBGL_INFO.PARALLEL_SHADER_COMPILE = Boolean(gl.getExtension("KHR_parallel_shader_compile"));
            WEBGL_INFO.MULTI_DRAW_INSTANCED = Boolean(gl.getExtension("WEBGL_multi_draw_instanced"));

            webglInfoInitialized = true;
        }
        return new App(gl);
    }
}, GL);

const bufferGetter = (gl, sourceBuffer) => (destination) => {
  gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, sourceBuffer);
  gl.getBufferSubData(gl.TRANSFORM_FEEDBACK_BUFFER, 0, destination);
};
const setStructUniforms = (drawer, baseName, values) => Object.entries(values).reduce((drawer2, [k, v]) => drawer2.uniform(`${baseName}.${k}`, v), drawer);

var transformationGL = "#version 300 es\n#define GLSLIFY 1\n// common functions and utilities\n// CGA3.glsl\nconst int Idx_CGA3_scalar = 0;\nconst int Idx_CGA3_e1 = 1;\nconst int Idx_CGA3_e2 = 2;\nconst int Idx_CGA3_e3 = 3;\nconst int Idx_CGA3_e4 = 4;\nconst int Idx_CGA3_e5 = 5;\nconst int Idx_CGA3_e12 = 6;\nconst int Idx_CGA3_e13 = 7;\nconst int Idx_CGA3_e14 = 8;\nconst int Idx_CGA3_e15 = 9;\nconst int Idx_CGA3_e23 = 10;\nconst int Idx_CGA3_e24 = 11;\nconst int Idx_CGA3_e25 = 12;\nconst int Idx_CGA3_e34 = 13;\nconst int Idx_CGA3_e35 = 14;\nconst int Idx_CGA3_e45 = 15;\nconst int Idx_CGA3_e123 = 16;\nconst int Idx_CGA3_e124 = 17;\nconst int Idx_CGA3_e125 = 18;\nconst int Idx_CGA3_e134 = 19;\nconst int Idx_CGA3_e135 = 20;\nconst int Idx_CGA3_e145 = 21;\nconst int Idx_CGA3_e234 = 22;\nconst int Idx_CGA3_e235 = 23;\nconst int Idx_CGA3_e245 = 24;\nconst int Idx_CGA3_e345 = 25;\nconst int Idx_CGA3_e1234 = 26;\nconst int Idx_CGA3_e1235 = 27;\nconst int Idx_CGA3_e1245 = 28;\nconst int Idx_CGA3_e1345 = 29;\nconst int Idx_CGA3_e2345 = 30;\nconst int Idx_CGA3_e12345 = 31;\n\nstruct CGA3 {\n    float scalar;\n    float e1;\n    float e2;\n    float e3;\n    float e4;\n    float e5;\n    float e12;\n    float e13;\n    float e14;\n    float e15;\n    float e23;\n    float e24;\n    float e25;\n    float e34;\n    float e35;\n    float e45;\n    float e123;\n    float e124;\n    float e125;\n    float e134;\n    float e135;\n    float e145;\n    float e234;\n    float e235;\n    float e245;\n    float e345;\n    float e1234;\n    float e1235;\n    float e1245;\n    float e1345;\n    float e2345;\n    float e12345;\n};\n\nCGA3 fromArray(float X[32]){\n    return CGA3(X[0], X[1], X[2], X[3], X[4], X[5], X[6], X[7], X[8], X[9], X[10], X[11], X[12], X[13], X[14], X[15], X[16], X[17], X[18], X[19], X[20], X[21], X[22], X[23], X[24], X[25], X[26], X[27], X[28], X[29], X[30], X[31]);\n}\n\nvoid toArray(CGA3 X, inout float X_ary[32]){\n    X_ary[0] = X.scalar;\n    X_ary[1] = X.e1;\n    X_ary[2] = X.e2;\n    X_ary[3] = X.e3;\n    X_ary[4] = X.e4;\n    X_ary[5] = X.e5;\n    X_ary[6] = X.e12;\n    X_ary[7] = X.e13;\n    X_ary[8] = X.e14;\n    X_ary[9] = X.e15;\n    X_ary[10] = X.e23;\n    X_ary[11] = X.e24;\n    X_ary[12] = X.e25;\n    X_ary[13] = X.e34;\n    X_ary[14] = X.e35;\n    X_ary[15] = X.e45;\n    X_ary[16] = X.e123;\n    X_ary[17] = X.e124;\n    X_ary[18] = X.e125;\n    X_ary[19] = X.e134;\n    X_ary[20] = X.e135;\n    X_ary[21] = X.e145;\n    X_ary[22] = X.e234;\n    X_ary[23] = X.e235;\n    X_ary[24] = X.e245;\n    X_ary[25] = X.e345;\n    X_ary[26] = X.e1234;\n    X_ary[27] = X.e1235;\n    X_ary[28] = X.e1245;\n    X_ary[29] = X.e1345;\n    X_ary[30] = X.e2345;\n    X_ary[31] = X.e12345;\n}\n\nvoid zero(inout float X[32]){\n    X[0] = 0.0;\n    X[1] = 0.0;\n    X[2] = 0.0;\n    X[3] = 0.0;\n    X[4] = 0.0;\n    X[5] = 0.0;\n    X[6] = 0.0;\n    X[7] = 0.0;\n    X[8] = 0.0;\n    X[9] = 0.0;\n    X[10] = 0.0;\n    X[11] = 0.0;\n    X[12] = 0.0;\n    X[13] = 0.0;\n    X[14] = 0.0;\n    X[15] = 0.0;\n    X[16] = 0.0;\n    X[17] = 0.0;\n    X[18] = 0.0;\n    X[19] = 0.0;\n    X[20] = 0.0;\n    X[21] = 0.0;\n    X[22] = 0.0;\n    X[23] = 0.0;\n    X[24] = 0.0;\n    X[25] = 0.0;\n    X[26] = 0.0;\n    X[27] = 0.0;\n    X[28] = 0.0;\n    X[29] = 0.0;\n    X[30] = 0.0;\n    X[31] = 0.0;\n}\n\nCGA3 add(CGA3 X, CGA3 Y){\n    return CGA3(X.scalar + Y.scalar, X.e1 + Y.e1, X.e2 + Y.e2, X.e3 + Y.e3, X.e4 + Y.e4, X.e5 + Y.e5, X.e12 + Y.e12, X.e13 + Y.e13, X.e14 + Y.e14, X.e15 + Y.e15, X.e23 + Y.e23, X.e24 + Y.e24, X.e25 + Y.e25, X.e34 + Y.e34, X.e35 + Y.e35, X.e45 + Y.e45, X.e123 + Y.e123, X.e124 + Y.e124, X.e125 + Y.e125, X.e134 + Y.e134, X.e135 + Y.e135, X.e145 + Y.e145, X.e234 + Y.e234, X.e235 + Y.e235, X.e245 + Y.e245, X.e345 + Y.e345, X.e1234 + Y.e1234, X.e1235 + Y.e1235, X.e1245 + Y.e1245, X.e1345 + Y.e1345, X.e2345 + Y.e2345, X.e12345 + Y.e12345);\n}\n\nCGA3 add(CGA3 X, CGA3 Y, CGA3 Z){\n    return add(add(X, Y), Z);\n}\n\nCGA3 add(CGA3 X, CGA3 Y, CGA3 Z, CGA3 P){\n    return add(add(add(X, Y), Z), P);\n}\n\n#define ONE_CGA3 CGA3(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\nCGA3 mul(float a, CGA3 X){\n    return CGA3(X.scalar*a, X.e1*a, X.e2*a, X.e3*a, X.e4*a, X.e5*a, X.e12*a, X.e13*a, X.e14*a, X.e15*a, X.e23*a, X.e24*a, X.e25*a, X.e34*a, X.e35*a, X.e45*a, X.e123*a, X.e124*a, X.e125*a, X.e134*a, X.e135*a, X.e145*a, X.e234*a, X.e235*a, X.e245*a, X.e345*a, X.e1234*a, X.e1235*a, X.e1245*a, X.e1345*a, X.e2345*a, X.e12345*a);\n}\n\nCGA3 sub(CGA3 X, CGA3 Y){\n    return CGA3(X.scalar - Y.scalar, X.e1 - Y.e1, X.e2 - Y.e2, X.e3 - Y.e3, X.e4 - Y.e4, X.e5 - Y.e5, X.e12 - Y.e12, X.e13 - Y.e13, X.e14 - Y.e14, X.e15 - Y.e15, X.e23 - Y.e23, X.e24 - Y.e24, X.e25 - Y.e25, X.e34 - Y.e34, X.e35 - Y.e35, X.e45 - Y.e45, X.e123 - Y.e123, X.e124 - Y.e124, X.e125 - Y.e125, X.e134 - Y.e134, X.e135 - Y.e135, X.e145 - Y.e145, X.e234 - Y.e234, X.e235 - Y.e235, X.e245 - Y.e245, X.e345 - Y.e345, X.e1234 - Y.e1234, X.e1235 - Y.e1235, X.e1245 - Y.e1245, X.e1345 - Y.e1345, X.e2345 - Y.e2345, X.e12345 - Y.e12345);\n}\n\n#define ZERO_CGA3 CGA3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\nCGA3 mul(int a, CGA3 X){\n    return mul(float(a), X);\n}\n\nCGA3 mul(CGA3 X, CGA3 Y){\n    return CGA3(X.e1*Y.e1 - X.e12*Y.e12 - X.e123*Y.e123 + X.e1234*Y.e1234 - X.e12345*Y.e12345 - X.e1235*Y.e1235 - X.e124*Y.e124 - X.e1245*Y.e1245 + X.e125*Y.e125 - X.e13*Y.e13 - X.e134*Y.e134 - X.e1345*Y.e1345 + X.e135*Y.e135 - X.e14*Y.e14 + X.e145*Y.e145 + X.e15*Y.e15 + X.e2*Y.e2 - X.e23*Y.e23 - X.e234*Y.e234 - X.e2345*Y.e2345 + X.e235*Y.e235 - X.e24*Y.e24 + X.e245*Y.e245 + X.e25*Y.e25 + X.e3*Y.e3 - X.e34*Y.e34 + X.e345*Y.e345 + X.e35*Y.e35 + X.e4*Y.e4 + X.e45*Y.e45 - X.e5*Y.e5 + X.scalar*Y.scalar, X.e1*Y.scalar + X.e12*Y.e2 - X.e123*Y.e23 - X.e1234*Y.e234 - X.e12345*Y.e2345 + X.e1235*Y.e235 - X.e124*Y.e24 + X.e1245*Y.e245 + X.e125*Y.e25 + X.e13*Y.e3 - X.e134*Y.e34 + X.e1345*Y.e345 + X.e135*Y.e35 + X.e14*Y.e4 + X.e145*Y.e45 - X.e15*Y.e5 - X.e2*Y.e12 - X.e23*Y.e123 + X.e234*Y.e1234 - X.e2345*Y.e12345 - X.e235*Y.e1235 - X.e24*Y.e124 - X.e245*Y.e1245 + X.e25*Y.e125 - X.e3*Y.e13 - X.e34*Y.e134 - X.e345*Y.e1345 + X.e35*Y.e135 - X.e4*Y.e14 + X.e45*Y.e145 + X.e5*Y.e15 + X.scalar*Y.e1, X.e1*Y.e12 - X.e12*Y.e1 + X.e123*Y.e13 + X.e1234*Y.e134 + X.e12345*Y.e1345 - X.e1235*Y.e135 + X.e124*Y.e14 - X.e1245*Y.e145 - X.e125*Y.e15 + X.e13*Y.e123 - X.e134*Y.e1234 + X.e1345*Y.e12345 + X.e135*Y.e1235 + X.e14*Y.e124 + X.e145*Y.e1245 - X.e15*Y.e125 + X.e2*Y.scalar + X.e23*Y.e3 - X.e234*Y.e34 + X.e2345*Y.e345 + X.e235*Y.e35 + X.e24*Y.e4 + X.e245*Y.e45 - X.e25*Y.e5 - X.e3*Y.e23 - X.e34*Y.e234 - X.e345*Y.e2345 + X.e35*Y.e235 - X.e4*Y.e24 + X.e45*Y.e245 + X.e5*Y.e25 + X.scalar*Y.e2, X.e1*Y.e13 - X.e12*Y.e123 - X.e123*Y.e12 - X.e1234*Y.e124 - X.e12345*Y.e1245 + X.e1235*Y.e125 + X.e124*Y.e1234 - X.e1245*Y.e12345 - X.e125*Y.e1235 - X.e13*Y.e1 + X.e134*Y.e14 - X.e1345*Y.e145 - X.e135*Y.e15 + X.e14*Y.e134 + X.e145*Y.e1345 - X.e15*Y.e135 + X.e2*Y.e23 - X.e23*Y.e2 + X.e234*Y.e24 - X.e2345*Y.e245 - X.e235*Y.e25 + X.e24*Y.e234 + X.e245*Y.e2345 - X.e25*Y.e235 + X.e3*Y.scalar + X.e34*Y.e4 + X.e345*Y.e45 - X.e35*Y.e5 - X.e4*Y.e34 + X.e45*Y.e345 + X.e5*Y.e35 + X.scalar*Y.e3, X.e1*Y.e14 - X.e12*Y.e124 - X.e123*Y.e1234 + X.e1234*Y.e123 + X.e12345*Y.e1235 + X.e1235*Y.e12345 - X.e124*Y.e12 + X.e1245*Y.e125 - X.e125*Y.e1245 - X.e13*Y.e134 - X.e134*Y.e13 + X.e1345*Y.e135 - X.e135*Y.e1345 - X.e14*Y.e1 - X.e145*Y.e15 - X.e15*Y.e145 + X.e2*Y.e24 - X.e23*Y.e234 - X.e234*Y.e23 + X.e2345*Y.e235 - X.e235*Y.e2345 - X.e24*Y.e2 - X.e245*Y.e25 - X.e25*Y.e245 + X.e3*Y.e34 - X.e34*Y.e3 - X.e345*Y.e35 - X.e35*Y.e345 + X.e4*Y.scalar - X.e45*Y.e5 + X.e5*Y.e45 + X.scalar*Y.e4, X.e1*Y.e15 - X.e12*Y.e125 - X.e123*Y.e1235 + X.e1234*Y.e12345 + X.e12345*Y.e1234 + X.e1235*Y.e123 - X.e124*Y.e1245 + X.e1245*Y.e124 - X.e125*Y.e12 - X.e13*Y.e135 - X.e134*Y.e1345 + X.e1345*Y.e134 - X.e135*Y.e13 - X.e14*Y.e145 - X.e145*Y.e14 - X.e15*Y.e1 + X.e2*Y.e25 - X.e23*Y.e235 - X.e234*Y.e2345 + X.e2345*Y.e234 - X.e235*Y.e23 - X.e24*Y.e245 - X.e245*Y.e24 - X.e25*Y.e2 + X.e3*Y.e35 - X.e34*Y.e345 - X.e345*Y.e34 - X.e35*Y.e3 + X.e4*Y.e45 - X.e45*Y.e4 + X.e5*Y.scalar + X.scalar*Y.e5, X.e1*Y.e2 + X.e12*Y.scalar + X.e123*Y.e3 - X.e1234*Y.e34 + X.e12345*Y.e345 + X.e1235*Y.e35 + X.e124*Y.e4 + X.e1245*Y.e45 - X.e125*Y.e5 - X.e13*Y.e23 - X.e134*Y.e234 - X.e1345*Y.e2345 + X.e135*Y.e235 - X.e14*Y.e24 + X.e145*Y.e245 + X.e15*Y.e25 - X.e2*Y.e1 + X.e23*Y.e13 + X.e234*Y.e134 + X.e2345*Y.e1345 - X.e235*Y.e135 + X.e24*Y.e14 - X.e245*Y.e145 - X.e25*Y.e15 + X.e3*Y.e123 - X.e34*Y.e1234 + X.e345*Y.e12345 + X.e35*Y.e1235 + X.e4*Y.e124 + X.e45*Y.e1245 - X.e5*Y.e125 + X.scalar*Y.e12, X.e1*Y.e3 + X.e12*Y.e23 - X.e123*Y.e2 + X.e1234*Y.e24 - X.e12345*Y.e245 - X.e1235*Y.e25 + X.e124*Y.e234 + X.e1245*Y.e2345 - X.e125*Y.e235 + X.e13*Y.scalar + X.e134*Y.e4 + X.e1345*Y.e45 - X.e135*Y.e5 - X.e14*Y.e34 + X.e145*Y.e345 + X.e15*Y.e35 - X.e2*Y.e123 - X.e23*Y.e12 - X.e234*Y.e124 - X.e2345*Y.e1245 + X.e235*Y.e125 + X.e24*Y.e1234 - X.e245*Y.e12345 - X.e25*Y.e1235 - X.e3*Y.e1 + X.e34*Y.e14 - X.e345*Y.e145 - X.e35*Y.e15 + X.e4*Y.e134 + X.e45*Y.e1345 - X.e5*Y.e135 + X.scalar*Y.e13, X.e1*Y.e4 + X.e12*Y.e24 - X.e123*Y.e234 - X.e1234*Y.e23 + X.e12345*Y.e235 - X.e1235*Y.e2345 - X.e124*Y.e2 - X.e1245*Y.e25 - X.e125*Y.e245 + X.e13*Y.e34 - X.e134*Y.e3 - X.e1345*Y.e35 - X.e135*Y.e345 + X.e14*Y.scalar - X.e145*Y.e5 + X.e15*Y.e45 - X.e2*Y.e124 - X.e23*Y.e1234 + X.e234*Y.e123 + X.e2345*Y.e1235 + X.e235*Y.e12345 - X.e24*Y.e12 + X.e245*Y.e125 - X.e25*Y.e1245 - X.e3*Y.e134 - X.e34*Y.e13 + X.e345*Y.e135 - X.e35*Y.e1345 - X.e4*Y.e1 - X.e45*Y.e15 - X.e5*Y.e145 + X.scalar*Y.e14, X.e1*Y.e5 + X.e12*Y.e25 - X.e123*Y.e235 - X.e1234*Y.e2345 + X.e12345*Y.e234 - X.e1235*Y.e23 - X.e124*Y.e245 - X.e1245*Y.e24 - X.e125*Y.e2 + X.e13*Y.e35 - X.e134*Y.e345 - X.e1345*Y.e34 - X.e135*Y.e3 + X.e14*Y.e45 - X.e145*Y.e4 + X.e15*Y.scalar - X.e2*Y.e125 - X.e23*Y.e1235 + X.e234*Y.e12345 + X.e2345*Y.e1234 + X.e235*Y.e123 - X.e24*Y.e1245 + X.e245*Y.e124 - X.e25*Y.e12 - X.e3*Y.e135 - X.e34*Y.e1345 + X.e345*Y.e134 - X.e35*Y.e13 - X.e4*Y.e145 - X.e45*Y.e14 - X.e5*Y.e1 + X.scalar*Y.e15, X.e1*Y.e123 - X.e12*Y.e13 + X.e123*Y.e1 - X.e1234*Y.e14 + X.e12345*Y.e145 + X.e1235*Y.e15 - X.e124*Y.e134 - X.e1245*Y.e1345 + X.e125*Y.e135 + X.e13*Y.e12 + X.e134*Y.e124 + X.e1345*Y.e1245 - X.e135*Y.e125 - X.e14*Y.e1234 + X.e145*Y.e12345 + X.e15*Y.e1235 + X.e2*Y.e3 + X.e23*Y.scalar + X.e234*Y.e4 + X.e2345*Y.e45 - X.e235*Y.e5 - X.e24*Y.e34 + X.e245*Y.e345 + X.e25*Y.e35 - X.e3*Y.e2 + X.e34*Y.e24 - X.e345*Y.e245 - X.e35*Y.e25 + X.e4*Y.e234 + X.e45*Y.e2345 - X.e5*Y.e235 + X.scalar*Y.e23, X.e1*Y.e124 - X.e12*Y.e14 + X.e123*Y.e134 + X.e1234*Y.e13 - X.e12345*Y.e135 + X.e1235*Y.e1345 + X.e124*Y.e1 + X.e1245*Y.e15 + X.e125*Y.e145 + X.e13*Y.e1234 - X.e134*Y.e123 - X.e1345*Y.e1235 - X.e135*Y.e12345 + X.e14*Y.e12 - X.e145*Y.e125 + X.e15*Y.e1245 + X.e2*Y.e4 + X.e23*Y.e34 - X.e234*Y.e3 - X.e2345*Y.e35 - X.e235*Y.e345 + X.e24*Y.scalar - X.e245*Y.e5 + X.e25*Y.e45 - X.e3*Y.e234 - X.e34*Y.e23 + X.e345*Y.e235 - X.e35*Y.e2345 - X.e4*Y.e2 - X.e45*Y.e25 - X.e5*Y.e245 + X.scalar*Y.e24, X.e1*Y.e125 - X.e12*Y.e15 + X.e123*Y.e135 + X.e1234*Y.e1345 - X.e12345*Y.e134 + X.e1235*Y.e13 + X.e124*Y.e145 + X.e1245*Y.e14 + X.e125*Y.e1 + X.e13*Y.e1235 - X.e134*Y.e12345 - X.e1345*Y.e1234 - X.e135*Y.e123 + X.e14*Y.e1245 - X.e145*Y.e124 + X.e15*Y.e12 + X.e2*Y.e5 + X.e23*Y.e35 - X.e234*Y.e345 - X.e2345*Y.e34 - X.e235*Y.e3 + X.e24*Y.e45 - X.e245*Y.e4 + X.e25*Y.scalar - X.e3*Y.e235 - X.e34*Y.e2345 + X.e345*Y.e234 - X.e35*Y.e23 - X.e4*Y.e245 - X.e45*Y.e24 - X.e5*Y.e2 + X.scalar*Y.e25, X.e1*Y.e134 - X.e12*Y.e1234 - X.e123*Y.e124 - X.e1234*Y.e12 + X.e12345*Y.e125 - X.e1235*Y.e1245 + X.e124*Y.e123 + X.e1245*Y.e1235 + X.e125*Y.e12345 - X.e13*Y.e14 + X.e134*Y.e1 + X.e1345*Y.e15 + X.e135*Y.e145 + X.e14*Y.e13 - X.e145*Y.e135 + X.e15*Y.e1345 + X.e2*Y.e234 - X.e23*Y.e24 + X.e234*Y.e2 + X.e2345*Y.e25 + X.e235*Y.e245 + X.e24*Y.e23 - X.e245*Y.e235 + X.e25*Y.e2345 + X.e3*Y.e4 + X.e34*Y.scalar - X.e345*Y.e5 + X.e35*Y.e45 - X.e4*Y.e3 - X.e45*Y.e35 - X.e5*Y.e345 + X.scalar*Y.e34, X.e1*Y.e135 - X.e12*Y.e1235 - X.e123*Y.e125 - X.e1234*Y.e1245 + X.e12345*Y.e124 - X.e1235*Y.e12 + X.e124*Y.e12345 + X.e1245*Y.e1234 + X.e125*Y.e123 - X.e13*Y.e15 + X.e134*Y.e145 + X.e1345*Y.e14 + X.e135*Y.e1 + X.e14*Y.e1345 - X.e145*Y.e134 + X.e15*Y.e13 + X.e2*Y.e235 - X.e23*Y.e25 + X.e234*Y.e245 + X.e2345*Y.e24 + X.e235*Y.e2 + X.e24*Y.e2345 - X.e245*Y.e234 + X.e25*Y.e23 + X.e3*Y.e5 + X.e34*Y.e45 - X.e345*Y.e4 + X.e35*Y.scalar - X.e4*Y.e345 - X.e45*Y.e34 - X.e5*Y.e3 + X.scalar*Y.e35, X.e1*Y.e145 - X.e12*Y.e1245 - X.e123*Y.e12345 + X.e1234*Y.e1235 - X.e12345*Y.e123 - X.e1235*Y.e1234 - X.e124*Y.e125 - X.e1245*Y.e12 + X.e125*Y.e124 - X.e13*Y.e1345 - X.e134*Y.e135 - X.e1345*Y.e13 + X.e135*Y.e134 - X.e14*Y.e15 + X.e145*Y.e1 + X.e15*Y.e14 + X.e2*Y.e245 - X.e23*Y.e2345 - X.e234*Y.e235 - X.e2345*Y.e23 + X.e235*Y.e234 - X.e24*Y.e25 + X.e245*Y.e2 + X.e25*Y.e24 + X.e3*Y.e345 - X.e34*Y.e35 + X.e345*Y.e3 + X.e35*Y.e34 + X.e4*Y.e5 + X.e45*Y.scalar - X.e5*Y.e4 + X.scalar*Y.e45, X.e1*Y.e23 + X.e12*Y.e3 + X.e123*Y.scalar + X.e1234*Y.e4 + X.e12345*Y.e45 - X.e1235*Y.e5 - X.e124*Y.e34 + X.e1245*Y.e345 + X.e125*Y.e35 - X.e13*Y.e2 + X.e134*Y.e24 - X.e1345*Y.e245 - X.e135*Y.e25 + X.e14*Y.e234 + X.e145*Y.e2345 - X.e15*Y.e235 - X.e2*Y.e13 + X.e23*Y.e1 - X.e234*Y.e14 + X.e2345*Y.e145 + X.e235*Y.e15 - X.e24*Y.e134 - X.e245*Y.e1345 + X.e25*Y.e135 + X.e3*Y.e12 + X.e34*Y.e124 + X.e345*Y.e1245 - X.e35*Y.e125 - X.e4*Y.e1234 + X.e45*Y.e12345 + X.e5*Y.e1235 + X.scalar*Y.e123, X.e1*Y.e24 + X.e12*Y.e4 + X.e123*Y.e34 - X.e1234*Y.e3 - X.e12345*Y.e35 - X.e1235*Y.e345 + X.e124*Y.scalar - X.e1245*Y.e5 + X.e125*Y.e45 - X.e13*Y.e234 - X.e134*Y.e23 + X.e1345*Y.e235 - X.e135*Y.e2345 - X.e14*Y.e2 - X.e145*Y.e25 - X.e15*Y.e245 - X.e2*Y.e14 + X.e23*Y.e134 + X.e234*Y.e13 - X.e2345*Y.e135 + X.e235*Y.e1345 + X.e24*Y.e1 + X.e245*Y.e15 + X.e25*Y.e145 + X.e3*Y.e1234 - X.e34*Y.e123 - X.e345*Y.e1235 - X.e35*Y.e12345 + X.e4*Y.e12 - X.e45*Y.e125 + X.e5*Y.e1245 + X.scalar*Y.e124, X.e1*Y.e25 + X.e12*Y.e5 + X.e123*Y.e35 - X.e1234*Y.e345 - X.e12345*Y.e34 - X.e1235*Y.e3 + X.e124*Y.e45 - X.e1245*Y.e4 + X.e125*Y.scalar - X.e13*Y.e235 - X.e134*Y.e2345 + X.e1345*Y.e234 - X.e135*Y.e23 - X.e14*Y.e245 - X.e145*Y.e24 - X.e15*Y.e2 - X.e2*Y.e15 + X.e23*Y.e135 + X.e234*Y.e1345 - X.e2345*Y.e134 + X.e235*Y.e13 + X.e24*Y.e145 + X.e245*Y.e14 + X.e25*Y.e1 + X.e3*Y.e1235 - X.e34*Y.e12345 - X.e345*Y.e1234 - X.e35*Y.e123 + X.e4*Y.e1245 - X.e45*Y.e124 + X.e5*Y.e12 + X.scalar*Y.e125, X.e1*Y.e34 + X.e12*Y.e234 - X.e123*Y.e24 + X.e1234*Y.e2 + X.e12345*Y.e25 + X.e1235*Y.e245 + X.e124*Y.e23 - X.e1245*Y.e235 + X.e125*Y.e2345 + X.e13*Y.e4 + X.e134*Y.scalar - X.e1345*Y.e5 + X.e135*Y.e45 - X.e14*Y.e3 - X.e145*Y.e35 - X.e15*Y.e345 - X.e2*Y.e1234 - X.e23*Y.e124 - X.e234*Y.e12 + X.e2345*Y.e125 - X.e235*Y.e1245 + X.e24*Y.e123 + X.e245*Y.e1235 + X.e25*Y.e12345 - X.e3*Y.e14 + X.e34*Y.e1 + X.e345*Y.e15 + X.e35*Y.e145 + X.e4*Y.e13 - X.e45*Y.e135 + X.e5*Y.e1345 + X.scalar*Y.e134, X.e1*Y.e35 + X.e12*Y.e235 - X.e123*Y.e25 + X.e1234*Y.e245 + X.e12345*Y.e24 + X.e1235*Y.e2 + X.e124*Y.e2345 - X.e1245*Y.e234 + X.e125*Y.e23 + X.e13*Y.e5 + X.e134*Y.e45 - X.e1345*Y.e4 + X.e135*Y.scalar - X.e14*Y.e345 - X.e145*Y.e34 - X.e15*Y.e3 - X.e2*Y.e1235 - X.e23*Y.e125 - X.e234*Y.e1245 + X.e2345*Y.e124 - X.e235*Y.e12 + X.e24*Y.e12345 + X.e245*Y.e1234 + X.e25*Y.e123 - X.e3*Y.e15 + X.e34*Y.e145 + X.e345*Y.e14 + X.e35*Y.e1 + X.e4*Y.e1345 - X.e45*Y.e134 + X.e5*Y.e13 + X.scalar*Y.e135, X.e1*Y.e45 + X.e12*Y.e245 - X.e123*Y.e2345 - X.e1234*Y.e235 - X.e12345*Y.e23 + X.e1235*Y.e234 - X.e124*Y.e25 + X.e1245*Y.e2 + X.e125*Y.e24 + X.e13*Y.e345 - X.e134*Y.e35 + X.e1345*Y.e3 + X.e135*Y.e34 + X.e14*Y.e5 + X.e145*Y.scalar - X.e15*Y.e4 - X.e2*Y.e1245 - X.e23*Y.e12345 + X.e234*Y.e1235 - X.e2345*Y.e123 - X.e235*Y.e1234 - X.e24*Y.e125 - X.e245*Y.e12 + X.e25*Y.e124 - X.e3*Y.e1345 - X.e34*Y.e135 - X.e345*Y.e13 + X.e35*Y.e134 - X.e4*Y.e15 + X.e45*Y.e1 + X.e5*Y.e14 + X.scalar*Y.e145, X.e1*Y.e1234 - X.e12*Y.e134 + X.e123*Y.e14 - X.e1234*Y.e1 - X.e12345*Y.e15 - X.e1235*Y.e145 - X.e124*Y.e13 + X.e1245*Y.e135 - X.e125*Y.e1345 + X.e13*Y.e124 + X.e134*Y.e12 - X.e1345*Y.e125 + X.e135*Y.e1245 - X.e14*Y.e123 - X.e145*Y.e1235 - X.e15*Y.e12345 + X.e2*Y.e34 + X.e23*Y.e4 + X.e234*Y.scalar - X.e2345*Y.e5 + X.e235*Y.e45 - X.e24*Y.e3 - X.e245*Y.e35 - X.e25*Y.e345 - X.e3*Y.e24 + X.e34*Y.e2 + X.e345*Y.e25 + X.e35*Y.e245 + X.e4*Y.e23 - X.e45*Y.e235 + X.e5*Y.e2345 + X.scalar*Y.e234, X.e1*Y.e1235 - X.e12*Y.e135 + X.e123*Y.e15 - X.e1234*Y.e145 - X.e12345*Y.e14 - X.e1235*Y.e1 - X.e124*Y.e1345 + X.e1245*Y.e134 - X.e125*Y.e13 + X.e13*Y.e125 + X.e134*Y.e1245 - X.e1345*Y.e124 + X.e135*Y.e12 - X.e14*Y.e12345 - X.e145*Y.e1234 - X.e15*Y.e123 + X.e2*Y.e35 + X.e23*Y.e5 + X.e234*Y.e45 - X.e2345*Y.e4 + X.e235*Y.scalar - X.e24*Y.e345 - X.e245*Y.e34 - X.e25*Y.e3 - X.e3*Y.e25 + X.e34*Y.e245 + X.e345*Y.e24 + X.e35*Y.e2 + X.e4*Y.e2345 - X.e45*Y.e234 + X.e5*Y.e23 + X.scalar*Y.e235, X.e1*Y.e1245 - X.e12*Y.e145 + X.e123*Y.e1345 + X.e1234*Y.e135 + X.e12345*Y.e13 - X.e1235*Y.e134 + X.e124*Y.e15 - X.e1245*Y.e1 - X.e125*Y.e14 + X.e13*Y.e12345 - X.e134*Y.e1235 + X.e1345*Y.e123 + X.e135*Y.e1234 + X.e14*Y.e125 + X.e145*Y.e12 - X.e15*Y.e124 + X.e2*Y.e45 + X.e23*Y.e345 - X.e234*Y.e35 + X.e2345*Y.e3 + X.e235*Y.e34 + X.e24*Y.e5 + X.e245*Y.scalar - X.e25*Y.e4 - X.e3*Y.e2345 - X.e34*Y.e235 - X.e345*Y.e23 + X.e35*Y.e234 - X.e4*Y.e25 + X.e45*Y.e2 + X.e5*Y.e24 + X.scalar*Y.e245, X.e1*Y.e1345 - X.e12*Y.e12345 - X.e123*Y.e1245 - X.e1234*Y.e125 - X.e12345*Y.e12 + X.e1235*Y.e124 + X.e124*Y.e1235 - X.e1245*Y.e123 - X.e125*Y.e1234 - X.e13*Y.e145 + X.e134*Y.e15 - X.e1345*Y.e1 - X.e135*Y.e14 + X.e14*Y.e135 + X.e145*Y.e13 - X.e15*Y.e134 + X.e2*Y.e2345 - X.e23*Y.e245 + X.e234*Y.e25 - X.e2345*Y.e2 - X.e235*Y.e24 + X.e24*Y.e235 + X.e245*Y.e23 - X.e25*Y.e234 + X.e3*Y.e45 + X.e34*Y.e5 + X.e345*Y.scalar - X.e35*Y.e4 - X.e4*Y.e35 + X.e45*Y.e3 + X.e5*Y.e34 + X.scalar*Y.e345, X.e1*Y.e234 + X.e12*Y.e34 + X.e123*Y.e4 + X.e1234*Y.scalar - X.e12345*Y.e5 + X.e1235*Y.e45 - X.e124*Y.e3 - X.e1245*Y.e35 - X.e125*Y.e345 - X.e13*Y.e24 + X.e134*Y.e2 + X.e1345*Y.e25 + X.e135*Y.e245 + X.e14*Y.e23 - X.e145*Y.e235 + X.e15*Y.e2345 - X.e2*Y.e134 + X.e23*Y.e14 - X.e234*Y.e1 - X.e2345*Y.e15 - X.e235*Y.e145 - X.e24*Y.e13 + X.e245*Y.e135 - X.e25*Y.e1345 + X.e3*Y.e124 + X.e34*Y.e12 - X.e345*Y.e125 + X.e35*Y.e1245 - X.e4*Y.e123 - X.e45*Y.e1235 - X.e5*Y.e12345 + X.scalar*Y.e1234, X.e1*Y.e235 + X.e12*Y.e35 + X.e123*Y.e5 + X.e1234*Y.e45 - X.e12345*Y.e4 + X.e1235*Y.scalar - X.e124*Y.e345 - X.e1245*Y.e34 - X.e125*Y.e3 - X.e13*Y.e25 + X.e134*Y.e245 + X.e1345*Y.e24 + X.e135*Y.e2 + X.e14*Y.e2345 - X.e145*Y.e234 + X.e15*Y.e23 - X.e2*Y.e135 + X.e23*Y.e15 - X.e234*Y.e145 - X.e2345*Y.e14 - X.e235*Y.e1 - X.e24*Y.e1345 + X.e245*Y.e134 - X.e25*Y.e13 + X.e3*Y.e125 + X.e34*Y.e1245 - X.e345*Y.e124 + X.e35*Y.e12 - X.e4*Y.e12345 - X.e45*Y.e1234 - X.e5*Y.e123 + X.scalar*Y.e1235, X.e1*Y.e245 + X.e12*Y.e45 + X.e123*Y.e345 - X.e1234*Y.e35 + X.e12345*Y.e3 + X.e1235*Y.e34 + X.e124*Y.e5 + X.e1245*Y.scalar - X.e125*Y.e4 - X.e13*Y.e2345 - X.e134*Y.e235 - X.e1345*Y.e23 + X.e135*Y.e234 - X.e14*Y.e25 + X.e145*Y.e2 + X.e15*Y.e24 - X.e2*Y.e145 + X.e23*Y.e1345 + X.e234*Y.e135 + X.e2345*Y.e13 - X.e235*Y.e134 + X.e24*Y.e15 - X.e245*Y.e1 - X.e25*Y.e14 + X.e3*Y.e12345 - X.e34*Y.e1235 + X.e345*Y.e123 + X.e35*Y.e1234 + X.e4*Y.e125 + X.e45*Y.e12 - X.e5*Y.e124 + X.scalar*Y.e1245, X.e1*Y.e345 + X.e12*Y.e2345 - X.e123*Y.e245 + X.e1234*Y.e25 - X.e12345*Y.e2 - X.e1235*Y.e24 + X.e124*Y.e235 + X.e1245*Y.e23 - X.e125*Y.e234 + X.e13*Y.e45 + X.e134*Y.e5 + X.e1345*Y.scalar - X.e135*Y.e4 - X.e14*Y.e35 + X.e145*Y.e3 + X.e15*Y.e34 - X.e2*Y.e12345 - X.e23*Y.e1245 - X.e234*Y.e125 - X.e2345*Y.e12 + X.e235*Y.e124 + X.e24*Y.e1235 - X.e245*Y.e123 - X.e25*Y.e1234 - X.e3*Y.e145 + X.e34*Y.e15 - X.e345*Y.e1 - X.e35*Y.e14 + X.e4*Y.e135 + X.e45*Y.e13 - X.e5*Y.e134 + X.scalar*Y.e1345, X.e1*Y.e12345 - X.e12*Y.e1345 + X.e123*Y.e145 - X.e1234*Y.e15 + X.e12345*Y.e1 + X.e1235*Y.e14 - X.e124*Y.e135 - X.e1245*Y.e13 + X.e125*Y.e134 + X.e13*Y.e1245 + X.e134*Y.e125 + X.e1345*Y.e12 - X.e135*Y.e124 - X.e14*Y.e1235 + X.e145*Y.e123 + X.e15*Y.e1234 + X.e2*Y.e345 + X.e23*Y.e45 + X.e234*Y.e5 + X.e2345*Y.scalar - X.e235*Y.e4 - X.e24*Y.e35 + X.e245*Y.e3 + X.e25*Y.e34 - X.e3*Y.e245 + X.e34*Y.e25 - X.e345*Y.e2 - X.e35*Y.e24 + X.e4*Y.e235 + X.e45*Y.e23 - X.e5*Y.e234 + X.scalar*Y.e2345, X.e1*Y.e2345 + X.e12*Y.e345 + X.e123*Y.e45 + X.e1234*Y.e5 + X.e12345*Y.scalar - X.e1235*Y.e4 - X.e124*Y.e35 + X.e1245*Y.e3 + X.e125*Y.e34 - X.e13*Y.e245 + X.e134*Y.e25 - X.e1345*Y.e2 - X.e135*Y.e24 + X.e14*Y.e235 + X.e145*Y.e23 - X.e15*Y.e234 - X.e2*Y.e1345 + X.e23*Y.e145 - X.e234*Y.e15 + X.e2345*Y.e1 + X.e235*Y.e14 - X.e24*Y.e135 - X.e245*Y.e13 + X.e25*Y.e134 + X.e3*Y.e1245 + X.e34*Y.e125 + X.e345*Y.e12 - X.e35*Y.e124 - X.e4*Y.e1235 + X.e45*Y.e123 + X.e5*Y.e1234 + X.scalar*Y.e12345);\n}\n\nCGA3 scalar_CGA3(float a){\n    return mul(a, ONE_CGA3);\n}\n\nCGA3 mul(CGA3 X, CGA3 Y, CGA3 Z){\n    return mul(mul(X, Y), Z);\n}\n\nCGA3 involve(CGA3 X){\n    return CGA3(X.scalar, -X.e1, -X.e2, -X.e3, -X.e4, -X.e5, X.e12, X.e13, X.e14, X.e15, X.e23, X.e24, X.e25, X.e34, X.e35, X.e45, -X.e123, -X.e124, -X.e125, -X.e134, -X.e135, -X.e145, -X.e234, -X.e235, -X.e245, -X.e345, X.e1234, X.e1235, X.e1245, X.e1345, X.e2345, -X.e12345);\n}\n\nCGA3 inner(CGA3 X, CGA3 Y){\n    return CGA3(X.e1*Y.e1 - X.e12*Y.e12 - X.e123*Y.e123 + X.e1234*Y.e1234 - X.e12345*Y.e12345 - X.e1235*Y.e1235 - X.e124*Y.e124 - X.e1245*Y.e1245 + X.e125*Y.e125 - X.e13*Y.e13 - X.e134*Y.e134 - X.e1345*Y.e1345 + X.e135*Y.e135 - X.e14*Y.e14 + X.e145*Y.e145 + X.e15*Y.e15 + X.e2*Y.e2 - X.e23*Y.e23 - X.e234*Y.e234 - X.e2345*Y.e2345 + X.e235*Y.e235 - X.e24*Y.e24 + X.e245*Y.e245 + X.e25*Y.e25 + X.e3*Y.e3 - X.e34*Y.e34 + X.e345*Y.e345 + X.e35*Y.e35 + X.e4*Y.e4 + X.e45*Y.e45 - X.e5*Y.e5, X.e12*Y.e2 - X.e123*Y.e23 - X.e1234*Y.e234 - X.e12345*Y.e2345 + X.e1235*Y.e235 - X.e124*Y.e24 + X.e1245*Y.e245 + X.e125*Y.e25 + X.e13*Y.e3 - X.e134*Y.e34 + X.e1345*Y.e345 + X.e135*Y.e35 + X.e14*Y.e4 + X.e145*Y.e45 - X.e15*Y.e5 - X.e2*Y.e12 - X.e23*Y.e123 + X.e234*Y.e1234 - X.e2345*Y.e12345 - X.e235*Y.e1235 - X.e24*Y.e124 - X.e245*Y.e1245 + X.e25*Y.e125 - X.e3*Y.e13 - X.e34*Y.e134 - X.e345*Y.e1345 + X.e35*Y.e135 - X.e4*Y.e14 + X.e45*Y.e145 + X.e5*Y.e15, X.e1*Y.e12 - X.e12*Y.e1 + X.e123*Y.e13 + X.e1234*Y.e134 + X.e12345*Y.e1345 - X.e1235*Y.e135 + X.e124*Y.e14 - X.e1245*Y.e145 - X.e125*Y.e15 + X.e13*Y.e123 - X.e134*Y.e1234 + X.e1345*Y.e12345 + X.e135*Y.e1235 + X.e14*Y.e124 + X.e145*Y.e1245 - X.e15*Y.e125 + X.e23*Y.e3 - X.e234*Y.e34 + X.e2345*Y.e345 + X.e235*Y.e35 + X.e24*Y.e4 + X.e245*Y.e45 - X.e25*Y.e5 - X.e3*Y.e23 - X.e34*Y.e234 - X.e345*Y.e2345 + X.e35*Y.e235 - X.e4*Y.e24 + X.e45*Y.e245 + X.e5*Y.e25, X.e1*Y.e13 - X.e12*Y.e123 - X.e123*Y.e12 - X.e1234*Y.e124 - X.e12345*Y.e1245 + X.e1235*Y.e125 + X.e124*Y.e1234 - X.e1245*Y.e12345 - X.e125*Y.e1235 - X.e13*Y.e1 + X.e134*Y.e14 - X.e1345*Y.e145 - X.e135*Y.e15 + X.e14*Y.e134 + X.e145*Y.e1345 - X.e15*Y.e135 + X.e2*Y.e23 - X.e23*Y.e2 + X.e234*Y.e24 - X.e2345*Y.e245 - X.e235*Y.e25 + X.e24*Y.e234 + X.e245*Y.e2345 - X.e25*Y.e235 + X.e34*Y.e4 + X.e345*Y.e45 - X.e35*Y.e5 - X.e4*Y.e34 + X.e45*Y.e345 + X.e5*Y.e35, X.e1*Y.e14 - X.e12*Y.e124 - X.e123*Y.e1234 + X.e1234*Y.e123 + X.e12345*Y.e1235 + X.e1235*Y.e12345 - X.e124*Y.e12 + X.e1245*Y.e125 - X.e125*Y.e1245 - X.e13*Y.e134 - X.e134*Y.e13 + X.e1345*Y.e135 - X.e135*Y.e1345 - X.e14*Y.e1 - X.e145*Y.e15 - X.e15*Y.e145 + X.e2*Y.e24 - X.e23*Y.e234 - X.e234*Y.e23 + X.e2345*Y.e235 - X.e235*Y.e2345 - X.e24*Y.e2 - X.e245*Y.e25 - X.e25*Y.e245 + X.e3*Y.e34 - X.e34*Y.e3 - X.e345*Y.e35 - X.e35*Y.e345 - X.e45*Y.e5 + X.e5*Y.e45, X.e1*Y.e15 - X.e12*Y.e125 - X.e123*Y.e1235 + X.e1234*Y.e12345 + X.e12345*Y.e1234 + X.e1235*Y.e123 - X.e124*Y.e1245 + X.e1245*Y.e124 - X.e125*Y.e12 - X.e13*Y.e135 - X.e134*Y.e1345 + X.e1345*Y.e134 - X.e135*Y.e13 - X.e14*Y.e145 - X.e145*Y.e14 - X.e15*Y.e1 + X.e2*Y.e25 - X.e23*Y.e235 - X.e234*Y.e2345 + X.e2345*Y.e234 - X.e235*Y.e23 - X.e24*Y.e245 - X.e245*Y.e24 - X.e25*Y.e2 + X.e3*Y.e35 - X.e34*Y.e345 - X.e345*Y.e34 - X.e35*Y.e3 + X.e4*Y.e45 - X.e45*Y.e4, X.e123*Y.e3 - X.e1234*Y.e34 + X.e12345*Y.e345 + X.e1235*Y.e35 + X.e124*Y.e4 + X.e1245*Y.e45 - X.e125*Y.e5 + X.e3*Y.e123 - X.e34*Y.e1234 + X.e345*Y.e12345 + X.e35*Y.e1235 + X.e4*Y.e124 + X.e45*Y.e1245 - X.e5*Y.e125, -X.e123*Y.e2 + X.e1234*Y.e24 - X.e12345*Y.e245 - X.e1235*Y.e25 + X.e134*Y.e4 + X.e1345*Y.e45 - X.e135*Y.e5 - X.e2*Y.e123 + X.e24*Y.e1234 - X.e245*Y.e12345 - X.e25*Y.e1235 + X.e4*Y.e134 + X.e45*Y.e1345 - X.e5*Y.e135, -X.e1234*Y.e23 + X.e12345*Y.e235 - X.e124*Y.e2 - X.e1245*Y.e25 - X.e134*Y.e3 - X.e1345*Y.e35 - X.e145*Y.e5 - X.e2*Y.e124 - X.e23*Y.e1234 + X.e235*Y.e12345 - X.e25*Y.e1245 - X.e3*Y.e134 - X.e35*Y.e1345 - X.e5*Y.e145, X.e12345*Y.e234 - X.e1235*Y.e23 - X.e1245*Y.e24 - X.e125*Y.e2 - X.e1345*Y.e34 - X.e135*Y.e3 - X.e145*Y.e4 - X.e2*Y.e125 - X.e23*Y.e1235 + X.e234*Y.e12345 - X.e24*Y.e1245 - X.e3*Y.e135 - X.e34*Y.e1345 - X.e4*Y.e145, X.e1*Y.e123 + X.e123*Y.e1 - X.e1234*Y.e14 + X.e12345*Y.e145 + X.e1235*Y.e15 - X.e14*Y.e1234 + X.e145*Y.e12345 + X.e15*Y.e1235 + X.e234*Y.e4 + X.e2345*Y.e45 - X.e235*Y.e5 + X.e4*Y.e234 + X.e45*Y.e2345 - X.e5*Y.e235, X.e1*Y.e124 + X.e1234*Y.e13 - X.e12345*Y.e135 + X.e124*Y.e1 + X.e1245*Y.e15 + X.e13*Y.e1234 - X.e135*Y.e12345 + X.e15*Y.e1245 - X.e234*Y.e3 - X.e2345*Y.e35 - X.e245*Y.e5 - X.e3*Y.e234 - X.e35*Y.e2345 - X.e5*Y.e245, X.e1*Y.e125 - X.e12345*Y.e134 + X.e1235*Y.e13 + X.e1245*Y.e14 + X.e125*Y.e1 + X.e13*Y.e1235 - X.e134*Y.e12345 + X.e14*Y.e1245 - X.e2345*Y.e34 - X.e235*Y.e3 - X.e245*Y.e4 - X.e3*Y.e235 - X.e34*Y.e2345 - X.e4*Y.e245, X.e1*Y.e134 - X.e12*Y.e1234 - X.e1234*Y.e12 + X.e12345*Y.e125 + X.e125*Y.e12345 + X.e134*Y.e1 + X.e1345*Y.e15 + X.e15*Y.e1345 + X.e2*Y.e234 + X.e234*Y.e2 + X.e2345*Y.e25 + X.e25*Y.e2345 - X.e345*Y.e5 - X.e5*Y.e345, X.e1*Y.e135 - X.e12*Y.e1235 + X.e12345*Y.e124 - X.e1235*Y.e12 + X.e124*Y.e12345 + X.e1345*Y.e14 + X.e135*Y.e1 + X.e14*Y.e1345 + X.e2*Y.e235 + X.e2345*Y.e24 + X.e235*Y.e2 + X.e24*Y.e2345 - X.e345*Y.e4 - X.e4*Y.e345, X.e1*Y.e145 - X.e12*Y.e1245 - X.e123*Y.e12345 - X.e12345*Y.e123 - X.e1245*Y.e12 - X.e13*Y.e1345 - X.e1345*Y.e13 + X.e145*Y.e1 + X.e2*Y.e245 - X.e23*Y.e2345 - X.e2345*Y.e23 + X.e245*Y.e2 + X.e3*Y.e345 + X.e345*Y.e3, X.e1234*Y.e4 + X.e12345*Y.e45 - X.e1235*Y.e5 - X.e4*Y.e1234 + X.e45*Y.e12345 + X.e5*Y.e1235, -X.e1234*Y.e3 - X.e12345*Y.e35 - X.e1245*Y.e5 + X.e3*Y.e1234 - X.e35*Y.e12345 + X.e5*Y.e1245, -X.e12345*Y.e34 - X.e1235*Y.e3 - X.e1245*Y.e4 + X.e3*Y.e1235 - X.e34*Y.e12345 + X.e4*Y.e1245, X.e1234*Y.e2 + X.e12345*Y.e25 - X.e1345*Y.e5 - X.e2*Y.e1234 + X.e25*Y.e12345 + X.e5*Y.e1345, X.e12345*Y.e24 + X.e1235*Y.e2 - X.e1345*Y.e4 - X.e2*Y.e1235 + X.e24*Y.e12345 + X.e4*Y.e1345, -X.e12345*Y.e23 + X.e1245*Y.e2 + X.e1345*Y.e3 - X.e2*Y.e1245 - X.e23*Y.e12345 - X.e3*Y.e1345, X.e1*Y.e1234 - X.e1234*Y.e1 - X.e12345*Y.e15 - X.e15*Y.e12345 - X.e2345*Y.e5 + X.e5*Y.e2345, X.e1*Y.e1235 - X.e12345*Y.e14 - X.e1235*Y.e1 - X.e14*Y.e12345 - X.e2345*Y.e4 + X.e4*Y.e2345, X.e1*Y.e1245 + X.e12345*Y.e13 - X.e1245*Y.e1 + X.e13*Y.e12345 + X.e2345*Y.e3 - X.e3*Y.e2345, X.e1*Y.e1345 - X.e12*Y.e12345 - X.e12345*Y.e12 - X.e1345*Y.e1 + X.e2*Y.e2345 - X.e2345*Y.e2, -X.e12345*Y.e5 - X.e5*Y.e12345, -X.e12345*Y.e4 - X.e4*Y.e12345, X.e12345*Y.e3 + X.e3*Y.e12345, -X.e12345*Y.e2 - X.e2*Y.e12345, X.e1*Y.e12345 + X.e12345*Y.e1, 0.0);\n}\n\nCGA3 lcontract(CGA3 X, CGA3 Y){\n    return CGA3(X.e1*Y.e1 - X.e12*Y.e12 - X.e123*Y.e123 + X.e1234*Y.e1234 - X.e12345*Y.e12345 - X.e1235*Y.e1235 - X.e124*Y.e124 - X.e1245*Y.e1245 + X.e125*Y.e125 - X.e13*Y.e13 - X.e134*Y.e134 - X.e1345*Y.e1345 + X.e135*Y.e135 - X.e14*Y.e14 + X.e145*Y.e145 + X.e15*Y.e15 + X.e2*Y.e2 - X.e23*Y.e23 - X.e234*Y.e234 - X.e2345*Y.e2345 + X.e235*Y.e235 - X.e24*Y.e24 + X.e245*Y.e245 + X.e25*Y.e25 + X.e3*Y.e3 - X.e34*Y.e34 + X.e345*Y.e345 + X.e35*Y.e35 + X.e4*Y.e4 + X.e45*Y.e45 - X.e5*Y.e5 + X.scalar*Y.scalar, -X.e2*Y.e12 - X.e23*Y.e123 + X.e234*Y.e1234 - X.e2345*Y.e12345 - X.e235*Y.e1235 - X.e24*Y.e124 - X.e245*Y.e1245 + X.e25*Y.e125 - X.e3*Y.e13 - X.e34*Y.e134 - X.e345*Y.e1345 + X.e35*Y.e135 - X.e4*Y.e14 + X.e45*Y.e145 + X.e5*Y.e15 + X.scalar*Y.e1, X.e1*Y.e12 + X.e13*Y.e123 - X.e134*Y.e1234 + X.e1345*Y.e12345 + X.e135*Y.e1235 + X.e14*Y.e124 + X.e145*Y.e1245 - X.e15*Y.e125 - X.e3*Y.e23 - X.e34*Y.e234 - X.e345*Y.e2345 + X.e35*Y.e235 - X.e4*Y.e24 + X.e45*Y.e245 + X.e5*Y.e25 + X.scalar*Y.e2, X.e1*Y.e13 - X.e12*Y.e123 + X.e124*Y.e1234 - X.e1245*Y.e12345 - X.e125*Y.e1235 + X.e14*Y.e134 + X.e145*Y.e1345 - X.e15*Y.e135 + X.e2*Y.e23 + X.e24*Y.e234 + X.e245*Y.e2345 - X.e25*Y.e235 - X.e4*Y.e34 + X.e45*Y.e345 + X.e5*Y.e35 + X.scalar*Y.e3, X.e1*Y.e14 - X.e12*Y.e124 - X.e123*Y.e1234 + X.e1235*Y.e12345 - X.e125*Y.e1245 - X.e13*Y.e134 - X.e135*Y.e1345 - X.e15*Y.e145 + X.e2*Y.e24 - X.e23*Y.e234 - X.e235*Y.e2345 - X.e25*Y.e245 + X.e3*Y.e34 - X.e35*Y.e345 + X.e5*Y.e45 + X.scalar*Y.e4, X.e1*Y.e15 - X.e12*Y.e125 - X.e123*Y.e1235 + X.e1234*Y.e12345 - X.e124*Y.e1245 - X.e13*Y.e135 - X.e134*Y.e1345 - X.e14*Y.e145 + X.e2*Y.e25 - X.e23*Y.e235 - X.e234*Y.e2345 - X.e24*Y.e245 + X.e3*Y.e35 - X.e34*Y.e345 + X.e4*Y.e45 + X.scalar*Y.e5, X.e3*Y.e123 - X.e34*Y.e1234 + X.e345*Y.e12345 + X.e35*Y.e1235 + X.e4*Y.e124 + X.e45*Y.e1245 - X.e5*Y.e125 + X.scalar*Y.e12, -X.e2*Y.e123 + X.e24*Y.e1234 - X.e245*Y.e12345 - X.e25*Y.e1235 + X.e4*Y.e134 + X.e45*Y.e1345 - X.e5*Y.e135 + X.scalar*Y.e13, -X.e2*Y.e124 - X.e23*Y.e1234 + X.e235*Y.e12345 - X.e25*Y.e1245 - X.e3*Y.e134 - X.e35*Y.e1345 - X.e5*Y.e145 + X.scalar*Y.e14, -X.e2*Y.e125 - X.e23*Y.e1235 + X.e234*Y.e12345 - X.e24*Y.e1245 - X.e3*Y.e135 - X.e34*Y.e1345 - X.e4*Y.e145 + X.scalar*Y.e15, X.e1*Y.e123 - X.e14*Y.e1234 + X.e145*Y.e12345 + X.e15*Y.e1235 + X.e4*Y.e234 + X.e45*Y.e2345 - X.e5*Y.e235 + X.scalar*Y.e23, X.e1*Y.e124 + X.e13*Y.e1234 - X.e135*Y.e12345 + X.e15*Y.e1245 - X.e3*Y.e234 - X.e35*Y.e2345 - X.e5*Y.e245 + X.scalar*Y.e24, X.e1*Y.e125 + X.e13*Y.e1235 - X.e134*Y.e12345 + X.e14*Y.e1245 - X.e3*Y.e235 - X.e34*Y.e2345 - X.e4*Y.e245 + X.scalar*Y.e25, X.e1*Y.e134 - X.e12*Y.e1234 + X.e125*Y.e12345 + X.e15*Y.e1345 + X.e2*Y.e234 + X.e25*Y.e2345 - X.e5*Y.e345 + X.scalar*Y.e34, X.e1*Y.e135 - X.e12*Y.e1235 + X.e124*Y.e12345 + X.e14*Y.e1345 + X.e2*Y.e235 + X.e24*Y.e2345 - X.e4*Y.e345 + X.scalar*Y.e35, X.e1*Y.e145 - X.e12*Y.e1245 - X.e123*Y.e12345 - X.e13*Y.e1345 + X.e2*Y.e245 - X.e23*Y.e2345 + X.e3*Y.e345 + X.scalar*Y.e45, -X.e4*Y.e1234 + X.e45*Y.e12345 + X.e5*Y.e1235 + X.scalar*Y.e123, X.e3*Y.e1234 - X.e35*Y.e12345 + X.e5*Y.e1245 + X.scalar*Y.e124, X.e3*Y.e1235 - X.e34*Y.e12345 + X.e4*Y.e1245 + X.scalar*Y.e125, -X.e2*Y.e1234 + X.e25*Y.e12345 + X.e5*Y.e1345 + X.scalar*Y.e134, -X.e2*Y.e1235 + X.e24*Y.e12345 + X.e4*Y.e1345 + X.scalar*Y.e135, -X.e2*Y.e1245 - X.e23*Y.e12345 - X.e3*Y.e1345 + X.scalar*Y.e145, X.e1*Y.e1234 - X.e15*Y.e12345 + X.e5*Y.e2345 + X.scalar*Y.e234, X.e1*Y.e1235 - X.e14*Y.e12345 + X.e4*Y.e2345 + X.scalar*Y.e235, X.e1*Y.e1245 + X.e13*Y.e12345 - X.e3*Y.e2345 + X.scalar*Y.e245, X.e1*Y.e1345 - X.e12*Y.e12345 + X.e2*Y.e2345 + X.scalar*Y.e345, -X.e5*Y.e12345 + X.scalar*Y.e1234, -X.e4*Y.e12345 + X.scalar*Y.e1235, X.e3*Y.e12345 + X.scalar*Y.e1245, -X.e2*Y.e12345 + X.scalar*Y.e1345, X.e1*Y.e12345 + X.scalar*Y.e2345, X.scalar*Y.e12345);\n}\n\nCGA3 outer(CGA3 X, CGA3 Y){\n    return CGA3(X.scalar*Y.scalar, X.e1*Y.scalar + X.scalar*Y.e1, X.e2*Y.scalar + X.scalar*Y.e2, X.e3*Y.scalar + X.scalar*Y.e3, X.e4*Y.scalar + X.scalar*Y.e4, X.e5*Y.scalar + X.scalar*Y.e5, X.e1*Y.e2 + X.e12*Y.scalar - X.e2*Y.e1 + X.scalar*Y.e12, X.e1*Y.e3 + X.e13*Y.scalar - X.e3*Y.e1 + X.scalar*Y.e13, X.e1*Y.e4 + X.e14*Y.scalar - X.e4*Y.e1 + X.scalar*Y.e14, X.e1*Y.e5 + X.e15*Y.scalar - X.e5*Y.e1 + X.scalar*Y.e15, X.e2*Y.e3 + X.e23*Y.scalar - X.e3*Y.e2 + X.scalar*Y.e23, X.e2*Y.e4 + X.e24*Y.scalar - X.e4*Y.e2 + X.scalar*Y.e24, X.e2*Y.e5 + X.e25*Y.scalar - X.e5*Y.e2 + X.scalar*Y.e25, X.e3*Y.e4 + X.e34*Y.scalar - X.e4*Y.e3 + X.scalar*Y.e34, X.e3*Y.e5 + X.e35*Y.scalar - X.e5*Y.e3 + X.scalar*Y.e35, X.e4*Y.e5 + X.e45*Y.scalar - X.e5*Y.e4 + X.scalar*Y.e45, X.e1*Y.e23 + X.e12*Y.e3 + X.e123*Y.scalar - X.e13*Y.e2 - X.e2*Y.e13 + X.e23*Y.e1 + X.e3*Y.e12 + X.scalar*Y.e123, X.e1*Y.e24 + X.e12*Y.e4 + X.e124*Y.scalar - X.e14*Y.e2 - X.e2*Y.e14 + X.e24*Y.e1 + X.e4*Y.e12 + X.scalar*Y.e124, X.e1*Y.e25 + X.e12*Y.e5 + X.e125*Y.scalar - X.e15*Y.e2 - X.e2*Y.e15 + X.e25*Y.e1 + X.e5*Y.e12 + X.scalar*Y.e125, X.e1*Y.e34 + X.e13*Y.e4 + X.e134*Y.scalar - X.e14*Y.e3 - X.e3*Y.e14 + X.e34*Y.e1 + X.e4*Y.e13 + X.scalar*Y.e134, X.e1*Y.e35 + X.e13*Y.e5 + X.e135*Y.scalar - X.e15*Y.e3 - X.e3*Y.e15 + X.e35*Y.e1 + X.e5*Y.e13 + X.scalar*Y.e135, X.e1*Y.e45 + X.e14*Y.e5 + X.e145*Y.scalar - X.e15*Y.e4 - X.e4*Y.e15 + X.e45*Y.e1 + X.e5*Y.e14 + X.scalar*Y.e145, X.e2*Y.e34 + X.e23*Y.e4 + X.e234*Y.scalar - X.e24*Y.e3 - X.e3*Y.e24 + X.e34*Y.e2 + X.e4*Y.e23 + X.scalar*Y.e234, X.e2*Y.e35 + X.e23*Y.e5 + X.e235*Y.scalar - X.e25*Y.e3 - X.e3*Y.e25 + X.e35*Y.e2 + X.e5*Y.e23 + X.scalar*Y.e235, X.e2*Y.e45 + X.e24*Y.e5 + X.e245*Y.scalar - X.e25*Y.e4 - X.e4*Y.e25 + X.e45*Y.e2 + X.e5*Y.e24 + X.scalar*Y.e245, X.e3*Y.e45 + X.e34*Y.e5 + X.e345*Y.scalar - X.e35*Y.e4 - X.e4*Y.e35 + X.e45*Y.e3 + X.e5*Y.e34 + X.scalar*Y.e345, X.e1*Y.e234 + X.e12*Y.e34 + X.e123*Y.e4 + X.e1234*Y.scalar - X.e124*Y.e3 - X.e13*Y.e24 + X.e134*Y.e2 + X.e14*Y.e23 - X.e2*Y.e134 + X.e23*Y.e14 - X.e234*Y.e1 - X.e24*Y.e13 + X.e3*Y.e124 + X.e34*Y.e12 - X.e4*Y.e123 + X.scalar*Y.e1234, X.e1*Y.e235 + X.e12*Y.e35 + X.e123*Y.e5 + X.e1235*Y.scalar - X.e125*Y.e3 - X.e13*Y.e25 + X.e135*Y.e2 + X.e15*Y.e23 - X.e2*Y.e135 + X.e23*Y.e15 - X.e235*Y.e1 - X.e25*Y.e13 + X.e3*Y.e125 + X.e35*Y.e12 - X.e5*Y.e123 + X.scalar*Y.e1235, X.e1*Y.e245 + X.e12*Y.e45 + X.e124*Y.e5 + X.e1245*Y.scalar - X.e125*Y.e4 - X.e14*Y.e25 + X.e145*Y.e2 + X.e15*Y.e24 - X.e2*Y.e145 + X.e24*Y.e15 - X.e245*Y.e1 - X.e25*Y.e14 + X.e4*Y.e125 + X.e45*Y.e12 - X.e5*Y.e124 + X.scalar*Y.e1245, X.e1*Y.e345 + X.e13*Y.e45 + X.e134*Y.e5 + X.e1345*Y.scalar - X.e135*Y.e4 - X.e14*Y.e35 + X.e145*Y.e3 + X.e15*Y.e34 - X.e3*Y.e145 + X.e34*Y.e15 - X.e345*Y.e1 - X.e35*Y.e14 + X.e4*Y.e135 + X.e45*Y.e13 - X.e5*Y.e134 + X.scalar*Y.e1345, X.e2*Y.e345 + X.e23*Y.e45 + X.e234*Y.e5 + X.e2345*Y.scalar - X.e235*Y.e4 - X.e24*Y.e35 + X.e245*Y.e3 + X.e25*Y.e34 - X.e3*Y.e245 + X.e34*Y.e25 - X.e345*Y.e2 - X.e35*Y.e24 + X.e4*Y.e235 + X.e45*Y.e23 - X.e5*Y.e234 + X.scalar*Y.e2345, X.e1*Y.e2345 + X.e12*Y.e345 + X.e123*Y.e45 + X.e1234*Y.e5 + X.e12345*Y.scalar - X.e1235*Y.e4 - X.e124*Y.e35 + X.e1245*Y.e3 + X.e125*Y.e34 - X.e13*Y.e245 + X.e134*Y.e25 - X.e1345*Y.e2 - X.e135*Y.e24 + X.e14*Y.e235 + X.e145*Y.e23 - X.e15*Y.e234 - X.e2*Y.e1345 + X.e23*Y.e145 - X.e234*Y.e15 + X.e2345*Y.e1 + X.e235*Y.e14 - X.e24*Y.e135 - X.e245*Y.e13 + X.e25*Y.e134 + X.e3*Y.e1245 + X.e34*Y.e125 + X.e345*Y.e12 - X.e35*Y.e124 - X.e4*Y.e1235 + X.e45*Y.e123 + X.e5*Y.e1234 + X.scalar*Y.e12345);\n}\n\n#define I_CGA3 CGA3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)\n\nCGA3 rcontract(CGA3 X, CGA3 Y){\n    return CGA3(X.e1*Y.e1 - X.e12*Y.e12 - X.e123*Y.e123 + X.e1234*Y.e1234 - X.e12345*Y.e12345 - X.e1235*Y.e1235 - X.e124*Y.e124 - X.e1245*Y.e1245 + X.e125*Y.e125 - X.e13*Y.e13 - X.e134*Y.e134 - X.e1345*Y.e1345 + X.e135*Y.e135 - X.e14*Y.e14 + X.e145*Y.e145 + X.e15*Y.e15 + X.e2*Y.e2 - X.e23*Y.e23 - X.e234*Y.e234 - X.e2345*Y.e2345 + X.e235*Y.e235 - X.e24*Y.e24 + X.e245*Y.e245 + X.e25*Y.e25 + X.e3*Y.e3 - X.e34*Y.e34 + X.e345*Y.e345 + X.e35*Y.e35 + X.e4*Y.e4 + X.e45*Y.e45 - X.e5*Y.e5 + X.scalar*Y.scalar, X.e1*Y.scalar + X.e12*Y.e2 - X.e123*Y.e23 - X.e1234*Y.e234 - X.e12345*Y.e2345 + X.e1235*Y.e235 - X.e124*Y.e24 + X.e1245*Y.e245 + X.e125*Y.e25 + X.e13*Y.e3 - X.e134*Y.e34 + X.e1345*Y.e345 + X.e135*Y.e35 + X.e14*Y.e4 + X.e145*Y.e45 - X.e15*Y.e5, -X.e12*Y.e1 + X.e123*Y.e13 + X.e1234*Y.e134 + X.e12345*Y.e1345 - X.e1235*Y.e135 + X.e124*Y.e14 - X.e1245*Y.e145 - X.e125*Y.e15 + X.e2*Y.scalar + X.e23*Y.e3 - X.e234*Y.e34 + X.e2345*Y.e345 + X.e235*Y.e35 + X.e24*Y.e4 + X.e245*Y.e45 - X.e25*Y.e5, -X.e123*Y.e12 - X.e1234*Y.e124 - X.e12345*Y.e1245 + X.e1235*Y.e125 - X.e13*Y.e1 + X.e134*Y.e14 - X.e1345*Y.e145 - X.e135*Y.e15 - X.e23*Y.e2 + X.e234*Y.e24 - X.e2345*Y.e245 - X.e235*Y.e25 + X.e3*Y.scalar + X.e34*Y.e4 + X.e345*Y.e45 - X.e35*Y.e5, X.e1234*Y.e123 + X.e12345*Y.e1235 - X.e124*Y.e12 + X.e1245*Y.e125 - X.e134*Y.e13 + X.e1345*Y.e135 - X.e14*Y.e1 - X.e145*Y.e15 - X.e234*Y.e23 + X.e2345*Y.e235 - X.e24*Y.e2 - X.e245*Y.e25 - X.e34*Y.e3 - X.e345*Y.e35 + X.e4*Y.scalar - X.e45*Y.e5, X.e12345*Y.e1234 + X.e1235*Y.e123 + X.e1245*Y.e124 - X.e125*Y.e12 + X.e1345*Y.e134 - X.e135*Y.e13 - X.e145*Y.e14 - X.e15*Y.e1 + X.e2345*Y.e234 - X.e235*Y.e23 - X.e245*Y.e24 - X.e25*Y.e2 - X.e345*Y.e34 - X.e35*Y.e3 - X.e45*Y.e4 + X.e5*Y.scalar, X.e12*Y.scalar + X.e123*Y.e3 - X.e1234*Y.e34 + X.e12345*Y.e345 + X.e1235*Y.e35 + X.e124*Y.e4 + X.e1245*Y.e45 - X.e125*Y.e5, -X.e123*Y.e2 + X.e1234*Y.e24 - X.e12345*Y.e245 - X.e1235*Y.e25 + X.e13*Y.scalar + X.e134*Y.e4 + X.e1345*Y.e45 - X.e135*Y.e5, -X.e1234*Y.e23 + X.e12345*Y.e235 - X.e124*Y.e2 - X.e1245*Y.e25 - X.e134*Y.e3 - X.e1345*Y.e35 + X.e14*Y.scalar - X.e145*Y.e5, X.e12345*Y.e234 - X.e1235*Y.e23 - X.e1245*Y.e24 - X.e125*Y.e2 - X.e1345*Y.e34 - X.e135*Y.e3 - X.e145*Y.e4 + X.e15*Y.scalar, X.e123*Y.e1 - X.e1234*Y.e14 + X.e12345*Y.e145 + X.e1235*Y.e15 + X.e23*Y.scalar + X.e234*Y.e4 + X.e2345*Y.e45 - X.e235*Y.e5, X.e1234*Y.e13 - X.e12345*Y.e135 + X.e124*Y.e1 + X.e1245*Y.e15 - X.e234*Y.e3 - X.e2345*Y.e35 + X.e24*Y.scalar - X.e245*Y.e5, -X.e12345*Y.e134 + X.e1235*Y.e13 + X.e1245*Y.e14 + X.e125*Y.e1 - X.e2345*Y.e34 - X.e235*Y.e3 - X.e245*Y.e4 + X.e25*Y.scalar, -X.e1234*Y.e12 + X.e12345*Y.e125 + X.e134*Y.e1 + X.e1345*Y.e15 + X.e234*Y.e2 + X.e2345*Y.e25 + X.e34*Y.scalar - X.e345*Y.e5, X.e12345*Y.e124 - X.e1235*Y.e12 + X.e1345*Y.e14 + X.e135*Y.e1 + X.e2345*Y.e24 + X.e235*Y.e2 - X.e345*Y.e4 + X.e35*Y.scalar, -X.e12345*Y.e123 - X.e1245*Y.e12 - X.e1345*Y.e13 + X.e145*Y.e1 - X.e2345*Y.e23 + X.e245*Y.e2 + X.e345*Y.e3 + X.e45*Y.scalar, X.e123*Y.scalar + X.e1234*Y.e4 + X.e12345*Y.e45 - X.e1235*Y.e5, -X.e1234*Y.e3 - X.e12345*Y.e35 + X.e124*Y.scalar - X.e1245*Y.e5, -X.e12345*Y.e34 - X.e1235*Y.e3 - X.e1245*Y.e4 + X.e125*Y.scalar, X.e1234*Y.e2 + X.e12345*Y.e25 + X.e134*Y.scalar - X.e1345*Y.e5, X.e12345*Y.e24 + X.e1235*Y.e2 - X.e1345*Y.e4 + X.e135*Y.scalar, -X.e12345*Y.e23 + X.e1245*Y.e2 + X.e1345*Y.e3 + X.e145*Y.scalar, -X.e1234*Y.e1 - X.e12345*Y.e15 + X.e234*Y.scalar - X.e2345*Y.e5, -X.e12345*Y.e14 - X.e1235*Y.e1 - X.e2345*Y.e4 + X.e235*Y.scalar, X.e12345*Y.e13 - X.e1245*Y.e1 + X.e2345*Y.e3 + X.e245*Y.scalar, -X.e12345*Y.e12 - X.e1345*Y.e1 - X.e2345*Y.e2 + X.e345*Y.scalar, X.e1234*Y.scalar - X.e12345*Y.e5, -X.e12345*Y.e4 + X.e1235*Y.scalar, X.e12345*Y.e3 + X.e1245*Y.scalar, -X.e12345*Y.e2 + X.e1345*Y.scalar, X.e12345*Y.e1 + X.e2345*Y.scalar, X.e12345*Y.scalar);\n}\n\nCGA3 reverse(CGA3 X){\n    return CGA3(X.scalar, X.e1, X.e2, X.e3, X.e4, X.e5, -X.e12, -X.e13, -X.e14, -X.e15, -X.e23, -X.e24, -X.e25, -X.e34, -X.e35, -X.e45, -X.e123, -X.e124, -X.e125, -X.e134, -X.e135, -X.e145, -X.e234, -X.e235, -X.e245, -X.e345, X.e1234, X.e1235, X.e1245, X.e1345, X.e2345, X.e12345);\n}\n\nCGA3 conjugate(CGA3 X){\n    return reverse(involve(X));\n}\n\nCGA3 outer(CGA3 X, CGA3 Y, CGA3 Z){\n    return outer(outer(X, Y), Z);\n}\n\nCGA3 invert(CGA3 X){\n    return mul(1.0/lcontract(X,conjugate(X)).scalar, conjugate(X));\n}\n\nCGA3 div(CGA3 X, CGA3 Y){\n    return mul(X, invert(Y));\n}\n\nCGA3 dual(CGA3 X){\n    return div(X, I_CGA3);\n}\n\n// H.glsl\nconst int Idx_H_real = 0;\nconst int Idx_H_i = 1;\nconst int Idx_H_j = 2;\nconst int Idx_H_k = 3;\n\nstruct H {\n    float real;\n    float i;\n    float j;\n    float k;\n};\n\nH fromArray(float X[4]){\n    return H(X[0], X[1], X[2], X[3]);\n}\n\nvoid toArray(H X, inout float X_ary[4]){\n    X_ary[0] = X.real;\n    X_ary[1] = X.i;\n    X_ary[2] = X.j;\n    X_ary[3] = X.k;\n}\n\nvoid zero(inout float X[4]){\n    X[0] = 0.0;\n    X[1] = 0.0;\n    X[2] = 0.0;\n    X[3] = 0.0;\n}\n\nH add(H X, H Y){\n    return H(X.real + Y.real, X.i + Y.i, X.j + Y.j, X.k + Y.k);\n}\n\nH add(H X, H Y, H Z){\n    return add(add(X, Y), Z);\n}\n\nH add(H X, H Y, H Z, H P){\n    return add(add(add(X, Y), Z), P);\n}\n\n#define ONE_H H(1.0, 0.0, 0.0, 0.0)\n\nH mul(float a, H X){\n    return H(X.real*a, X.i*a, X.j*a, X.k*a);\n}\n\nH sub(H X, H Y){\n    return H(X.real - Y.real, X.i - Y.i, X.j - Y.j, X.k - Y.k);\n}\n\n#define ZERO_H H(0.0, 0.0, 0.0, 0.0)\n\nH mul(int a, H X){\n    return mul(float(a), X);\n}\n\nH mul(H X, H Y){\n    return H(-X.i*Y.i - X.j*Y.j - X.k*Y.k + X.real*Y.real, X.i*Y.real + X.j*Y.k - X.k*Y.j + X.real*Y.i, -X.i*Y.k + X.j*Y.real + X.k*Y.i + X.real*Y.j, X.i*Y.j - X.j*Y.i + X.k*Y.real + X.real*Y.k);\n}\n\nH scalar_H(float a){\n    return mul(a, ONE_H);\n}\n\nH mul(H X, H Y, H Z){\n    return mul(mul(X, Y), Z);\n}\n\nH involve(H X){\n    return H(X.real, -X.i, -X.j, X.k);\n}\n\nH inner(H X, H Y){\n    return H(-X.i*Y.i - X.j*Y.j - X.k*Y.k, X.j*Y.k - X.k*Y.j, -X.i*Y.k + X.k*Y.i, 0.0);\n}\n\nH lcontract(H X, H Y){\n    return H(-X.i*Y.i - X.j*Y.j - X.k*Y.k + X.real*Y.real, X.j*Y.k + X.real*Y.i, -X.i*Y.k + X.real*Y.j, X.real*Y.k);\n}\n\nH outer(H X, H Y){\n    return H(X.real*Y.real, X.i*Y.real + X.real*Y.i, X.j*Y.real + X.real*Y.j, X.i*Y.j - X.j*Y.i + X.k*Y.real + X.real*Y.k);\n}\n\n#define I_H H(0.0, 0.0, 0.0, 1.0)\n\nH rcontract(H X, H Y){\n    return H(-X.i*Y.i - X.j*Y.j - X.k*Y.k + X.real*Y.real, X.i*Y.real - X.k*Y.j, X.j*Y.real + X.k*Y.i, X.k*Y.real);\n}\n\nH reverse(H X){\n    return H(X.real, X.i, X.j, -X.k);\n}\n\nH conjugate(H X){\n    return reverse(involve(X));\n}\n\nH outer(H X, H Y, H Z){\n    return outer(outer(X, Y), Z);\n}\n\nH invert(H X){\n    return mul(1.0/lcontract(X,conjugate(X)).real, conjugate(X));\n}\n\nH div(H X, H Y){\n    return mul(X, invert(Y));\n}\n\nH dual(H X){\n    return div(X, I_H);\n}\n\nCGA3 vecToCGA(vec3 v){\n    CGA3 X = ZERO_CGA3;\n    X.e1 = v.x;\n    X.e2 = v.y;\n    X.e3 = v.z;\n    return X;\n}\n\nCGA3 vecToCGA(vec4 v){\n    CGA3 X = ZERO_CGA3;\n    X.scalar = v.x;\n    X.e1 = v.y;\n    X.e2 = v.z;\n    X.e3 = v.w;\n    return X;\n}\n\nCGA3 weightVecToCGA(vec3 v){\n    CGA3 X = ZERO_CGA3;\n    X.e12 = -v.x;\n    X.e23 = v.y;\n    X.e13 = -v.z;\n    return X;\n}\n\nCGA3 weightVecToCGA(vec4 v){\n    CGA3 X = ZERO_CGA3;\n    X.scalar = v.x;\n    X.e23 = -v.y;\n    X.e13 = v.z;\n    X.e12 = -v.w;\n    return X;\n}\n\nvoid toVec(out vec3 x, CGA3 X) {\n    x = vec3(X.e1, X.e2, X.e3);\n}\n\nH vecToH(vec3 v){\n    H X = ZERO_H;\n    X.real = 1.0;\n    X.i = v.x;\n    X.j = v.y;\n    X.k = v.z;\n    return X;\n}\n\nH vecToH(vec4 v){\n    H X = ZERO_H;\n    X.real = v.x;\n    X.i = v.y;\n    X.j = v.z;\n    X.k = v.w;\n    return X;\n}\n\nvoid toVec(H X, inout vec4 x) {\n    x.x = X.real;\n    x.y = X.i;\n    x.z = X.j;\n    x.w = X.k;\n}\n\n// CGA3 point(vec3 x){\n//     return point(vecToCGA(x));\n// }\n\n// vec3 vecFromPoint(CGA3 x) {\n//     x = point_coords(x);\n//     return vec3(x.e1, x.e2, x.e3);\n// }\n\nCGA3 outer(CGA3 p, CGA3 q, CGA3 r, CGA3 s){\n    return outer(outer(p,q,r),s);\n}\n\nCGA3 mul(CGA3 p, CGA3 q, CGA3 r, CGA3 s){\n    return mul(mul(p,q,r),s);\n}\n\n// replace this stuff with IPNS sphere stuff\n// CGA3 sphere(vec3 a, vec3 b, vec3 c, vec3 d) {\n//     return outer(point(a), point(b), point(c), point(d));\n// }\n\n// vec3 sphere_center(vec3 a, vec3 b, vec3 c, vec3 d){\n//     CGA3 sphere = sphere(a,b,c,d);\n//     return vecFromPoint(mul(sphere, INF(), sphere));\n// }\n\n// vec3 reflect_glsl(vec3 x, CGA3 R){\n//     return vecFromPoint(mul(R,point(x),R));\n// }\n\n// float sphere_radius(vec3 a, vec3 b, vec3 c, vec3 d){\n//     CGA2 circ = sphere(a,b,c,d);\n//     return circle_radius(circ);\n// }\n\n// CGA3 dual_sphere(vec3 x){\n//     float y[3];\n//     y[0] = x[0];\n//     y[1] = x[1];\n//     y[2] = x[2];\n//     return dual_sphere(injectOneBlade(zero(), y));\n// }\n\nlayout(location = 0) in mat3x4 points;\nlayout(location = 3) in mat3x4 weights;\n\nuniform CGA3 transformation;\nuniform float angle;\nuniform vec3 x;\nuniform vec3 y;\n\nout mat3x4 transformedPoints;\nout mat3x4 transformedWeights;\nout float lod;\n\n#define ni CGA3(0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0)\n#define no CGA3(0.0,0.0,0.0,0.0,-0.5,0.5,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0)\n#define E outer(no, ni) // could optimize\n\nCGA3 upPoint(vec4 p) {\n  CGA3 X = vecToCGA(p);\n  return add(X, add(mul(0.5, mul(X, X, ni)), no));\n}\n\nCGA3 upPoint(CGA3 X) {\n  return add(X, add(mul(0.5, mul(X, X, ni)), no));\n}\n\nCGA3 downPoint(CGA3 P) {\n  CGA3 p = mul(div(outer(mul(1.0, invert(inner(P,ni))), P), E), E);\n  return p;\n  // return vec4(X.scalar, X.e1, X.e2, X.e3);\n}\n\n// CGA3 sandwichPoint(CGA3 T, CGA3 P, CGA3 hatT) {\n//   return downPoint(mul(T, upPoint(p), hatT));\n// }\n\nCGA3 upWeight(CGA3 w, vec4 pVec) {\n  CGA3 p = vecToCGA(pVec);\n  return mul(add(mul(0.5, mul(p, ni)), ONE_CGA3), w);\n}\n\nCGA3 upWeight(vec4 w, vec4 pVec) {\n  return upWeight(weightVecToCGA(w), pVec);\n}\n\nCGA3 downWeight(CGA3 W, vec4 pTransformed) {\n  CGA3 transformedP = vecToCGA(pTransformed);\n  CGA3 w = mul(invert(add(mul(mul(0.5,transformedP),ni), mul(-1.0, ONE_CGA3))), W);\n  return w;\n}\n\nCGA3 sandwichWeight(CGA3 T, CGA3 w, CGA3 hatT, vec4 p, vec4 pTransformed) {\n  return downWeight(mul(T, upWeight(w, p), hatT), pTransformed);\n}\n\nCGA3 locate(CGA3 a, CGA3 M) {\n  //  locate( a, M ) = (aM)/M\n  return div(inner(a, M), M);\n}\n\nCGA3 circumcenter(CGA3 a, CGA3 b, CGA3 c) {\n  //  circumcentre( a, b, c) = locate(a, (ab + bc + ca)/(abce))\n  return locate(a, div(add(add(outer(a,b), outer(b,c)), outer(c,a)), outer(a, outer(b, outer(c, ni)))));\n}\n\nCGA3 centroid_(CGA3 a, CGA3 b, CGA3 c) {\n  return mul(1.0/3.0, add(a, add(b,c)));\n}\n\nH midVecH(H a, H b) {\n  return mul(0.5, add(a, b));\n}\n\nfloat del(int i, int j, mat3x4 points) {\n  return length(points[i] - points[j]);\n}\n\nCGA3 q(int i, int j, mat3x4 points) {\n  return mul(1.0/del(i,j,points), weightVecToCGA(points[i] - points[j]));\n}\n\nvoid main() {\n  CGA3 T = transformation;\n  CGA3 hatT = conjugate(T);\n  // CGA3 hatT = conjugate(div(T, lcontract(T, T)));\n\n  CGA3 p1 = vecToCGA(points[0]);\n  CGA3 p2 = vecToCGA(points[1]);\n  CGA3 p3 = vecToCGA(points[2]);\n  CGA3 P1 = upPoint(points[0]);\n  CGA3 P2 = upPoint(points[1]);\n  CGA3 P3 = upPoint(points[2]);\n////////////////////////////////\n  // another try\n  vec4 v1 = points[1]-points[0];\n  vec4 v2 = points[2]-points[1];\n  vec4 v3 = points[0]-points[2];\n\n  vec4 q1 = points[0] - v1;\n  vec4 q2 = points[1] - v2;\n  vec4 q3 = points[2] - v3;\n\n  // CGA3 w1 = mul(y[0], invert(weightVecToCGA(vec4(x[0], cross(v1.yzw,v2.yzw)))));\n  // CGA3 w2 = mul(y[0], invert(weightVecToCGA(vec4(x[0], cross(v1.yzw,v2.yzw)))));\n  // CGA3 w3 = mul(y[0], invert(weightVecToCGA(vec4(x[0], cross(v1.yzw,v3.yzw)))));\n\n  H w1h = invert(vecToH(vec4(0.0, (points[0] - q1).yzw)));\n  H w2h = invert(vecToH(vec4(0.0, (points[1] - q2).yzw)));\n  H w3h = invert(vecToH(vec4(0.0, (points[2] - q3).yzw)));\n\n  // w1h.real = 1.0;\n  // w2h.real = 1.0;\n  // w3h.real = 1.0;\n\n  CGA3 w1 = weightVecToCGA(vec4(w1h.real, w1h.i, w1h.j, w1h.k));\n  CGA3 w2 = weightVecToCGA(vec4(w2h.real, w2h.i, w1h.j, w2h.k));\n  CGA3 w3 = weightVecToCGA(vec4(w3h.real, w3h.i, w1h.j, w3h.k));\n\n  // w1 = mul(x[0], add(ONE_CGA3, mul(y[0], E)));\n  // w2 = mul(x[1], add(ONE_CGA3, mul(y[1], E)));\n  // w3 = mul(x[2], add(ONE_CGA3, mul(y[2], E)));\n\n  // w1 = mul(y[0], (w1));\n  // w2 = mul(y[1], (w2));\n  // w3 = mul(y[2], (w3));\n\n  // w1.scalar = y[0];\n  // w2.scalar = y[1];\n  // w3.scalar = y[2];\n\n  // w1 = normalize(w1);\n  // w2 = normalize(w2);\n  // w3 = normalize(w3);\n\n  // CGA3 w1 = ONE_CGA3;\n  // CGA3 w2 = mul(q(1,0, points), weightVecToCGA(v3));\n  // CGA3 w3 = mul(q(1,0, points), weightVecToCGA(v3));\n  // CGA3 w3 = mul(w2, q(1,0, points));\n\n  w1 = ONE_CGA3;\n  w2 = ONE_CGA3;\n  w3 = ONE_CGA3;\n\n////////////////////////////////\n  // seems close\n//   vec4 v1 = normalize(points[1]-points[0]);\n//   vec4 v2 = normalize(points[2]-points[1]);\n//   vec4 v3 = normalize(points[0]-points[2]);\n\n//  vec4 m12 = (points[1] - points[0])/2.0;\n//  vec4 m23 = (points[2] - points[1])/2.0;\n//  vec4 m31 = (points[0] - points[2])/2.0;\n\n//   CGA3 w12_1 = invert(weightVecToCGA(m12 - points[0]));\n//   CGA3 w12_2 = invert(weightVecToCGA(points[1] - m12));\n//   CGA3 w23_2 = invert(weightVecToCGA(m23 - points[1]));\n//   CGA3 w23_3 = invert(weightVecToCGA(points[2] - m23));\n//   CGA3 w31_3 = invert(weightVecToCGA(m31 - points[2]));\n//   CGA3 w31_1 = invert(weightVecToCGA(points[0] - m31));\n\n//   CGA3 w1 = div(w12_1, w12_2);\n//   CGA3 w2 = div(w23_2, w23_3);\n//   CGA3 w3 = div(w31_3, w31_3);\n\n//   w1 = div(w1, w1);\n//   w2 = div(w2, w1);\n//   w3 = div(w3, w2);\n\n//   w1.scalar = 1.0;\n//   w2.scalar = 1.0;\n//   w3.scalar = 1.0;\n\n///////////////////////////////////////////\n\n  CGA3 p1_ = downPoint(mul(T, P1, hatT));\n  CGA3 p2_ = downPoint(mul(T, P2, hatT));\n  CGA3 p3_ = downPoint(mul(T, P3, hatT));\n\n  transformedPoints[0] = vec4(p1_.scalar, p1_.e1, p1_.e2, p1_.e3);\n  transformedPoints[1] = vec4(p2_.scalar, p2_.e1, p2_.e2, p2_.e3);\n  transformedPoints[2] = vec4(p3_.scalar, p3_.e1, p3_.e2, p3_.e3);\n\n  // CGA3 w1_ = sandwichWeight(T, w1, hatT, points[0], transformedPoints[0]);\n  // CGA3 w2_ = sandwichWeight(T, w2, hatT, points[1], transformedPoints[1]);\n  // CGA3 w3_ = sandwichWeight(T, w3, hatT, points[2], transformedPoints[2]);\n\n  // CGA3 w1_ = downPoint(mul(T, upPoint(w1), hatT));\n  // CGA3 w2_ = downPoint(mul(T, upPoint(w2), hatT));\n  // CGA3 w3_ = downPoint(mul(T, upPoint(w3), hatT));\n\n  CGA3 w1_ = mul(T, w1, hatT);\n  CGA3 w2_ = mul(T, w1, hatT);\n  CGA3 w3_ = mul(T, w1, hatT);\n\n  transformedWeights[0] = vec4(w1_.scalar, -w1_.e23, w1_.e13, -w1_.e12);\n  transformedWeights[1] = vec4(w2_.scalar, -w2_.e23, w2_.e13, -w2_.e12);\n  transformedWeights[2] = vec4(w3_.scalar, -w3_.e23, w3_.e13, -w3_.e12);\n\n  // transformedWeights[0] = vec4(w1_.scalar, w1_.e1, w1.e2, w1_.e3);\n  // transformedWeights[1] = vec4(w2_.scalar, w2_.e1, w2.e2, w2_.e3);\n  // transformedWeights[2] = vec4(w3_.scalar, w3_.e1, w3.e2, w3_.e3);\n\n  lod = transformation.e1;\n\n// override\n  // transformedPoints[0] = points[0];\n  // transformedPoints[1] = points[1];\n  // transformedPoints[2] = points[2];\n  // transformedWeights[0] = vec4(w1.scalar, -w1.e23, w1.e13, -w1.e12);\n  // transformedWeights[1] = vec4(w2.scalar, -w2.e23, w2.e13, -w2.e12);\n  // transformedWeights[2] = vec4(w3.scalar, -w3.e23, w3.e13, -w3.e12);\n}"; // eslint-disable-line

/**
 * @constant DEFAULT_OPTIONS_KEYS the default options keys
 */
var DEFAULT_OPTIONS_KEYS = {
    isEqual: true,
    isMatchingKey: true,
    isPromise: true,
    maxSize: true,
    onCacheAdd: true,
    onCacheChange: true,
    onCacheHit: true,
    transformKey: true,
};
/**
 * @function slice
 *
 * @description
 * slice.call() pre-bound
 */
var slice = Array.prototype.slice;
/**
 * @function cloneArray
 *
 * @description
 * clone the array-like object and return the new array
 *
 * @param arrayLike the array-like object to clone
 * @returns the clone as an array
 */
function cloneArray(arrayLike) {
    var length = arrayLike.length;
    if (!length) {
        return [];
    }
    if (length === 1) {
        return [arrayLike[0]];
    }
    if (length === 2) {
        return [arrayLike[0], arrayLike[1]];
    }
    if (length === 3) {
        return [arrayLike[0], arrayLike[1], arrayLike[2]];
    }
    return slice.call(arrayLike, 0);
}
/**
 * @function getCustomOptions
 *
 * @description
 * get the custom options on the object passed
 *
 * @param options the memoization options passed
 * @returns the custom options passed
 */
function getCustomOptions(options) {
    var customOptions = {};
    /* eslint-disable no-restricted-syntax */
    for (var key in options) {
        if (!DEFAULT_OPTIONS_KEYS[key]) {
            customOptions[key] = options[key];
        }
    }
    /* eslint-enable */
    return customOptions;
}
/**
 * @function isMemoized
 *
 * @description
 * is the function passed already memoized
 *
 * @param fn the function to test
 * @returns is the function already memoized
 */
function isMemoized(fn) {
    return (typeof fn === 'function' &&
        fn.isMemoized);
}
/**
 * @function isSameValueZero
 *
 * @description
 * are the objects equal based on SameValueZero equality
 *
 * @param object1 the first object to compare
 * @param object2 the second object to compare
 * @returns are the two objects equal
 */
function isSameValueZero(object1, object2) {
    // eslint-disable-next-line no-self-compare
    return object1 === object2 || (object1 !== object1 && object2 !== object2);
}
/**
 * @function mergeOptions
 *
 * @description
 * merge the options into the target
 *
 * @param existingOptions the options provided
 * @param newOptions the options to include
 * @returns the merged options
 */
function mergeOptions$1(existingOptions, newOptions) {
    // @ts-ignore
    var target = {};
    /* eslint-disable no-restricted-syntax */
    for (var key in existingOptions) {
        target[key] = existingOptions[key];
    }
    for (var key in newOptions) {
        target[key] = newOptions[key];
    }
    /* eslint-enable */
    return target;
}

// utils
var Cache = /** @class */ (function () {
    function Cache(options) {
        this.keys = [];
        this.values = [];
        this.options = options;
        var isMatchingKeyFunction = typeof options.isMatchingKey === 'function';
        if (isMatchingKeyFunction) {
            this.getKeyIndex = this._getKeyIndexFromMatchingKey;
        }
        else if (options.maxSize > 1) {
            this.getKeyIndex = this._getKeyIndexForMany;
        }
        else {
            this.getKeyIndex = this._getKeyIndexForSingle;
        }
        this.canTransformKey = typeof options.transformKey === 'function';
        this.shouldCloneArguments = this.canTransformKey || isMatchingKeyFunction;
        this.shouldUpdateOnAdd = typeof options.onCacheAdd === 'function';
        this.shouldUpdateOnChange = typeof options.onCacheChange === 'function';
        this.shouldUpdateOnHit = typeof options.onCacheHit === 'function';
    }
    Object.defineProperty(Cache.prototype, "size", {
        get: function () {
            return this.keys.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Cache.prototype, "snapshot", {
        get: function () {
            return {
                keys: cloneArray(this.keys),
                size: this.size,
                values: cloneArray(this.values),
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @function _getKeyIndexFromMatchingKey
     *
     * @description
     * gets the matching key index when a custom key matcher is used
     *
     * @param keyToMatch the key to match
     * @returns the index of the matching key, or -1
     */
    Cache.prototype._getKeyIndexFromMatchingKey = function (keyToMatch) {
        var _a = this.options, isMatchingKey = _a.isMatchingKey, maxSize = _a.maxSize;
        var keys = this.keys;
        var keysLength = keys.length;
        if (!keysLength) {
            return -1;
        }
        if (isMatchingKey(keys[0], keyToMatch)) {
            return 0;
        }
        if (maxSize > 1) {
            for (var index = 1; index < keysLength; index++) {
                if (isMatchingKey(keys[index], keyToMatch)) {
                    return index;
                }
            }
        }
        return -1;
    };
    /**
     * @function _getKeyIndexForMany
     *
     * @description
     * gets the matching key index when multiple keys are used
     *
     * @param keyToMatch the key to match
     * @returns the index of the matching key, or -1
     */
    Cache.prototype._getKeyIndexForMany = function (keyToMatch) {
        var isEqual = this.options.isEqual;
        var keys = this.keys;
        var keysLength = keys.length;
        if (!keysLength) {
            return -1;
        }
        if (keysLength === 1) {
            return this._getKeyIndexForSingle(keyToMatch);
        }
        var keyLength = keyToMatch.length;
        var existingKey;
        var argIndex;
        if (keyLength > 1) {
            for (var index = 0; index < keysLength; index++) {
                existingKey = keys[index];
                if (existingKey.length === keyLength) {
                    argIndex = 0;
                    for (; argIndex < keyLength; argIndex++) {
                        if (!isEqual(existingKey[argIndex], keyToMatch[argIndex])) {
                            break;
                        }
                    }
                    if (argIndex === keyLength) {
                        return index;
                    }
                }
            }
        }
        else {
            for (var index = 0; index < keysLength; index++) {
                existingKey = keys[index];
                if (existingKey.length === keyLength &&
                    isEqual(existingKey[0], keyToMatch[0])) {
                    return index;
                }
            }
        }
        return -1;
    };
    /**
     * @function _getKeyIndexForSingle
     *
     * @description
     * gets the matching key index when a single key is used
     *
     * @param keyToMatch the key to match
     * @returns the index of the matching key, or -1
     */
    Cache.prototype._getKeyIndexForSingle = function (keyToMatch) {
        var keys = this.keys;
        if (!keys.length) {
            return -1;
        }
        var existingKey = keys[0];
        var length = existingKey.length;
        if (keyToMatch.length !== length) {
            return -1;
        }
        var isEqual = this.options.isEqual;
        if (length > 1) {
            for (var index = 0; index < length; index++) {
                if (!isEqual(existingKey[index], keyToMatch[index])) {
                    return -1;
                }
            }
            return 0;
        }
        return isEqual(existingKey[0], keyToMatch[0]) ? 0 : -1;
    };
    /**
     * @function orderByLru
     *
     * @description
     * order the array based on a Least-Recently-Used basis
     *
     * @param key the new key to move to the front
     * @param value the new value to move to the front
     * @param startingIndex the index of the item to move to the front
     */
    Cache.prototype.orderByLru = function (key, value, startingIndex) {
        var keys = this.keys;
        var values = this.values;
        var currentLength = keys.length;
        var index = startingIndex;
        while (index--) {
            keys[index + 1] = keys[index];
            values[index + 1] = values[index];
        }
        keys[0] = key;
        values[0] = value;
        var maxSize = this.options.maxSize;
        if (currentLength === maxSize && startingIndex === currentLength) {
            keys.pop();
            values.pop();
        }
        else if (startingIndex >= maxSize) {
            // eslint-disable-next-line no-multi-assign
            keys.length = values.length = maxSize;
        }
    };
    /**
     * @function updateAsyncCache
     *
     * @description
     * update the promise method to auto-remove from cache if rejected, and
     * if resolved then fire cache hit / changed
     *
     * @param memoized the memoized function
     */
    Cache.prototype.updateAsyncCache = function (memoized) {
        var _this = this;
        var _a = this.options, onCacheChange = _a.onCacheChange, onCacheHit = _a.onCacheHit;
        var firstKey = this.keys[0];
        var firstValue = this.values[0];
        this.values[0] = firstValue.then(function (value) {
            if (_this.shouldUpdateOnHit) {
                onCacheHit(_this, _this.options, memoized);
            }
            if (_this.shouldUpdateOnChange) {
                onCacheChange(_this, _this.options, memoized);
            }
            return value;
        }, function (error) {
            var keyIndex = _this.getKeyIndex(firstKey);
            if (keyIndex !== -1) {
                _this.keys.splice(keyIndex, 1);
                _this.values.splice(keyIndex, 1);
            }
            throw error;
        });
    };
    return Cache;
}());

// cache
function createMemoizedFunction(fn, options) {
    if (options === void 0) { options = {}; }
    if (isMemoized(fn)) {
        return createMemoizedFunction(fn.fn, mergeOptions$1(fn.options, options));
    }
    if (typeof fn !== 'function') {
        throw new TypeError('You must pass a function to `memoize`.');
    }
    var _a = options.isEqual, isEqual = _a === void 0 ? isSameValueZero : _a, isMatchingKey = options.isMatchingKey, _b = options.isPromise, isPromise = _b === void 0 ? false : _b, _c = options.maxSize, maxSize = _c === void 0 ? 1 : _c, onCacheAdd = options.onCacheAdd, onCacheChange = options.onCacheChange, onCacheHit = options.onCacheHit, transformKey = options.transformKey;
    var normalizedOptions = mergeOptions$1({
        isEqual: isEqual,
        isMatchingKey: isMatchingKey,
        isPromise: isPromise,
        maxSize: maxSize,
        onCacheAdd: onCacheAdd,
        onCacheChange: onCacheChange,
        onCacheHit: onCacheHit,
        transformKey: transformKey,
    }, getCustomOptions(options));
    var cache = new Cache(normalizedOptions);
    var keys = cache.keys, values = cache.values, canTransformKey = cache.canTransformKey, shouldCloneArguments = cache.shouldCloneArguments, shouldUpdateOnAdd = cache.shouldUpdateOnAdd, shouldUpdateOnChange = cache.shouldUpdateOnChange, shouldUpdateOnHit = cache.shouldUpdateOnHit;
    // @ts-ignore
    var memoized = function memoized() {
        // @ts-ignore
        var key = shouldCloneArguments
            ? cloneArray(arguments)
            : arguments;
        if (canTransformKey) {
            key = transformKey(key);
        }
        var keyIndex = keys.length ? cache.getKeyIndex(key) : -1;
        if (keyIndex !== -1) {
            if (shouldUpdateOnHit) {
                onCacheHit(cache, normalizedOptions, memoized);
            }
            if (keyIndex) {
                cache.orderByLru(keys[keyIndex], values[keyIndex], keyIndex);
                if (shouldUpdateOnChange) {
                    onCacheChange(cache, normalizedOptions, memoized);
                }
            }
        }
        else {
            var newValue = fn.apply(this, arguments);
            var newKey = shouldCloneArguments
                ? key
                : cloneArray(arguments);
            cache.orderByLru(newKey, newValue, keys.length);
            if (isPromise) {
                cache.updateAsyncCache(memoized);
            }
            if (shouldUpdateOnAdd) {
                onCacheAdd(cache, normalizedOptions, memoized);
            }
            if (shouldUpdateOnChange) {
                onCacheChange(cache, normalizedOptions, memoized);
            }
        }
        return values[0];
    };
    memoized.cache = cache;
    memoized.fn = fn;
    memoized.isMemoized = true;
    memoized.options = normalizedOptions;
    return memoized;
}

var HAS_WEAKSET_SUPPORT = typeof WeakSet === 'function';
var keys$3 = Object.keys;
/**
 * are the values passed strictly equal or both NaN
 *
 * @param a the value to compare against
 * @param b the value to test
 * @returns are the values equal by the SameValueZero principle
 */
function sameValueZeroEqual(a, b) {
    return a === b || (a !== a && b !== b);
}
/**
 * is the value a plain object
 *
 * @param value the value to test
 * @returns is the value a plain object
 */
function isPlainObject(value) {
    return value.constructor === Object || value.constructor == null;
}
/**
 * is the value promise-like (meaning it is thenable)
 *
 * @param value the value to test
 * @returns is the value promise-like
 */
function isPromiseLike(value) {
    return !!value && typeof value.then === 'function';
}
/**
 * is the value passed a react element
 *
 * @param value the value to test
 * @returns is the value a react element
 */
function isReactElement(value) {
    return !!(value && value.$$typeof);
}
/**
 * in cases where WeakSet is not supported, creates a new custom
 * object that mimics the necessary API aspects for cache purposes
 *
 * @returns the new cache object
 */
function getNewCacheFallback() {
    var values = [];
    return {
        add: function (value) {
            values.push(value);
        },
        has: function (value) {
            return values.indexOf(value) !== -1;
        },
    };
}
/**
 * get a new cache object to prevent circular references
 *
 * @returns the new cache object
 */
var getNewCache = (function (canUseWeakMap) {
    if (canUseWeakMap) {
        return function _getNewCache() {
            return new WeakSet();
        };
    }
    return getNewCacheFallback;
})(HAS_WEAKSET_SUPPORT);
/**
 * create a custom isEqual handler specific to circular objects
 *
 * @param [isEqual] the isEqual comparator to use instead of isDeepEqual
 * @returns the method to create the `isEqual` function
 */
function createCircularEqualCreator(isEqual) {
    return function createCircularEqual(comparator) {
        var _comparator = isEqual || comparator;
        return function circularEqual(a, b, cache) {
            if (cache === void 0) { cache = getNewCache(); }
            var isCacheableA = !!a && typeof a === 'object';
            var isCacheableB = !!b && typeof b === 'object';
            if (isCacheableA || isCacheableB) {
                var hasA = isCacheableA && cache.has(a);
                var hasB = isCacheableB && cache.has(b);
                if (hasA || hasB) {
                    return hasA && hasB;
                }
                if (isCacheableA) {
                    cache.add(a);
                }
                if (isCacheableB) {
                    cache.add(b);
                }
            }
            return _comparator(a, b, cache);
        };
    };
}
/**
 * are the arrays equal in value
 *
 * @param a the array to test
 * @param b the array to test against
 * @param isEqual the comparator to determine equality
 * @param meta the meta object to pass through
 * @returns are the arrays equal
 */
function areArraysEqual(a, b, isEqual, meta) {
    var index = a.length;
    if (b.length !== index) {
        return false;
    }
    while (index-- > 0) {
        if (!isEqual(a[index], b[index], meta)) {
            return false;
        }
    }
    return true;
}
/**
 * are the maps equal in value
 *
 * @param a the map to test
 * @param b the map to test against
 * @param isEqual the comparator to determine equality
 * @param meta the meta map to pass through
 * @returns are the maps equal
 */
function areMapsEqual(a, b, isEqual, meta) {
    var isValueEqual = a.size === b.size;
    if (isValueEqual && a.size) {
        var matchedIndices_1 = {};
        a.forEach(function (aValue, aKey) {
            if (isValueEqual) {
                var hasMatch_1 = false;
                var matchIndex_1 = 0;
                b.forEach(function (bValue, bKey) {
                    if (!hasMatch_1 && !matchedIndices_1[matchIndex_1]) {
                        hasMatch_1 =
                            isEqual(aKey, bKey, meta) && isEqual(aValue, bValue, meta);
                        if (hasMatch_1) {
                            matchedIndices_1[matchIndex_1] = true;
                        }
                    }
                    matchIndex_1++;
                });
                isValueEqual = hasMatch_1;
            }
        });
    }
    return isValueEqual;
}
var OWNER = '_owner';
var hasOwnProperty$1 = Function.prototype.bind.call(Function.prototype.call, Object.prototype.hasOwnProperty);
/**
 * are the objects equal in value
 *
 * @param a the object to test
 * @param b the object to test against
 * @param isEqual the comparator to determine equality
 * @param meta the meta object to pass through
 * @returns are the objects equal
 */
function areObjectsEqual(a, b, isEqual, meta) {
    var keysA = keys$3(a);
    var index = keysA.length;
    if (keys$3(b).length !== index) {
        return false;
    }
    if (index) {
        var key = void 0;
        while (index-- > 0) {
            key = keysA[index];
            if (key === OWNER) {
                var reactElementA = isReactElement(a);
                var reactElementB = isReactElement(b);
                if ((reactElementA || reactElementB) &&
                    reactElementA !== reactElementB) {
                    return false;
                }
            }
            if (!hasOwnProperty$1(b, key) || !isEqual(a[key], b[key], meta)) {
                return false;
            }
        }
    }
    return true;
}
/**
 * are the regExps equal in value
 *
 * @param a the regExp to test
 * @param b the regExp to test agains
 * @returns are the regExps equal
 */
function areRegExpsEqual(a, b) {
    return (a.source === b.source &&
        a.global === b.global &&
        a.ignoreCase === b.ignoreCase &&
        a.multiline === b.multiline &&
        a.unicode === b.unicode &&
        a.sticky === b.sticky &&
        a.lastIndex === b.lastIndex);
}
/**
 * are the sets equal in value
 *
 * @param a the set to test
 * @param b the set to test against
 * @param isEqual the comparator to determine equality
 * @param meta the meta set to pass through
 * @returns are the sets equal
 */
function areSetsEqual(a, b, isEqual, meta) {
    var isValueEqual = a.size === b.size;
    if (isValueEqual && a.size) {
        var matchedIndices_2 = {};
        a.forEach(function (aValue) {
            if (isValueEqual) {
                var hasMatch_2 = false;
                var matchIndex_2 = 0;
                b.forEach(function (bValue) {
                    if (!hasMatch_2 && !matchedIndices_2[matchIndex_2]) {
                        hasMatch_2 = isEqual(aValue, bValue, meta);
                        if (hasMatch_2) {
                            matchedIndices_2[matchIndex_2] = true;
                        }
                    }
                    matchIndex_2++;
                });
                isValueEqual = hasMatch_2;
            }
        });
    }
    return isValueEqual;
}

var HAS_MAP_SUPPORT = typeof Map === 'function';
var HAS_SET_SUPPORT = typeof Set === 'function';
function createComparator(createIsEqual) {
    var isEqual = 
    /* eslint-disable no-use-before-define */
    typeof createIsEqual === 'function'
        ? createIsEqual(comparator)
        : comparator;
    /* eslint-enable */
    /**
     * compare the value of the two objects and return true if they are equivalent in values
     *
     * @param a the value to test against
     * @param b the value to test
     * @param [meta] an optional meta object that is passed through to all equality test calls
     * @returns are a and b equivalent in value
     */
    function comparator(a, b, meta) {
        if (a === b) {
            return true;
        }
        if (a && b && typeof a === 'object' && typeof b === 'object') {
            if (isPlainObject(a) && isPlainObject(b)) {
                return areObjectsEqual(a, b, isEqual, meta);
            }
            var aShape = Array.isArray(a);
            var bShape = Array.isArray(b);
            if (aShape || bShape) {
                return aShape === bShape && areArraysEqual(a, b, isEqual, meta);
            }
            aShape = a instanceof Date;
            bShape = b instanceof Date;
            if (aShape || bShape) {
                return (aShape === bShape && sameValueZeroEqual(a.getTime(), b.getTime()));
            }
            aShape = a instanceof RegExp;
            bShape = b instanceof RegExp;
            if (aShape || bShape) {
                return aShape === bShape && areRegExpsEqual(a, b);
            }
            if (isPromiseLike(a) || isPromiseLike(b)) {
                return a === b;
            }
            if (HAS_MAP_SUPPORT) {
                aShape = a instanceof Map;
                bShape = b instanceof Map;
                if (aShape || bShape) {
                    return aShape === bShape && areMapsEqual(a, b, isEqual, meta);
                }
            }
            if (HAS_SET_SUPPORT) {
                aShape = a instanceof Set;
                bShape = b instanceof Set;
                if (aShape || bShape) {
                    return aShape === bShape && areSetsEqual(a, b, isEqual, meta);
                }
            }
            return areObjectsEqual(a, b, isEqual, meta);
        }
        return a !== a && b !== b;
    }
    return comparator;
}

var deepEqual = createComparator();
var shallowEqual = createComparator(function () { return sameValueZeroEqual; });
createComparator(createCircularEqualCreator());
createComparator(createCircularEqualCreator(sameValueZeroEqual));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/**
 * @private
 *
 * @constant DEFAULT_OPTIONS
 */
var DEFAULT_OPTIONS = {
  isDeepEqual: false,
  isPromise: false,
  isReact: false,
  isSerialized: false,
  isShallowEqual: false,
  matchesArg: undefined,
  matchesKey: undefined,
  maxAge: undefined,
  maxArgs: undefined,
  maxSize: 1,
  onExpire: undefined,
  profileName: undefined,
  serializer: undefined,
  updateCacheForKey: undefined,
  transformArgs: undefined,
  updateExpire: false
};

/**
 * @private
 *
 * @description
 * method to combine functions and return a single function that fires them all
 *
 * @param functions the functions to compose
 * @returns the composed function
 */
function combine() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }

  return functions.reduce(function (f, g) {
    if (typeof f === 'function') {
      return typeof g === 'function' ? function () {
        f.apply(this, arguments);
        g.apply(this, arguments);
      } : f;
    }

    if (typeof g === 'function') {
      return g;
    }
  });
}
/**
 * @private
 *
 * @description
 * method to compose functions and return a single function
 *
 * @param functions the functions to compose
 * @returns the composed function
 */

function compose() {
  for (var _len2 = arguments.length, functions = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    functions[_key2] = arguments[_key2];
  }

  return functions.reduce(function (f, g) {
    if (typeof f === 'function') {
      return typeof g === 'function' ? function () {
        return f(g.apply(this, arguments));
      } : f;
    }

    if (typeof g === 'function') {
      return g;
    }
  });
}
/**
 * @private
 *
 * @description
 * find the index of the expiration based on the key
 *
 * @param expirations the list of expirations
 * @param key the key to match
 * @returns the index of the expiration
 */

function findExpirationIndex(expirations, key) {
  for (var index = 0; index < expirations.length; index++) {
    if (expirations[index].key === key) {
      return index;
    }
  }

  return -1;
}
/**
 * @private
 *
 * @description
 * create function that finds the index of the key in the list of cache keys
 *
 * @param isEqual the function to test individual argument equality
 * @param isMatchingKey the function to test full key equality
 * @returns the function that finds the index of the key
 */

function createFindKeyIndex(isEqual, isMatchingKey) {
  var areKeysEqual = typeof isMatchingKey === 'function' ? isMatchingKey : function (cacheKey, key) {
    for (var index = 0; index < key.length; index++) {
      if (!isEqual(cacheKey[index], key[index])) {
        return false;
      }
    }

    return true;
  };
  return function (keys, key) {
    for (var keysIndex = 0; keysIndex < keys.length; keysIndex++) {
      if (keys[keysIndex].length === key.length && areKeysEqual(keys[keysIndex], key)) {
        return keysIndex;
      }
    }

    return -1;
  };
}
/**
 * @private
 *
 * @description
 * merge two options objects, combining or composing functions as necessary
 *
 * @param originalOptions the options that already exist on the method
 * @param newOptions the new options to merge
 * @returns the merged options
 */

function mergeOptions(originalOptions, newOptions) {
  return !newOptions || newOptions === DEFAULT_OPTIONS ? originalOptions : _extends({}, originalOptions, newOptions, {
    onCacheAdd: combine(originalOptions.onCacheAdd, newOptions.onCacheAdd),
    onCacheChange: combine(originalOptions.onCacheChange, newOptions.onCacheChange),
    onCacheHit: combine(originalOptions.onCacheHit, newOptions.onCacheHit),
    transformArgs: compose(originalOptions.transformArgs, newOptions.transformArgs)
  });
}
function isMoized(fn) {
  return typeof fn === 'function' && fn.isMoized;
}
function setName(fn, originalFunctionName, profileName) {
  try {
    var name = profileName || originalFunctionName || 'anonymous';
    Object.defineProperty(fn, 'name', {
      configurable: true,
      enumerable: false,
      value: "moized(" + name + ")",
      writable: true
    });
  } catch (_unused) {// For engines where `function.name` is not configurable, do nothing.
  }
}

/**
 * @private
 *
 * @description
 * clear an active expiration and remove it from the list if applicable
 *
 * @param expirations the list of expirations
 * @param key the key to clear
 * @param shouldRemove should the expiration be removed from the list
 */

function clearExpiration(expirations, key, shouldRemove) {
  var expirationIndex = findExpirationIndex(expirations, key);

  if (expirationIndex !== -1) {
    clearTimeout(expirations[expirationIndex].timeoutId);

    if (shouldRemove) {
      expirations.splice(expirationIndex, 1);
    }
  }
}
/**
 * @private
 *
 * @description
 * Create the timeout for the given expiration method. If the ability to `unref`
 * exists, then apply it to avoid process locks in NodeJS.
 *
 * @param expirationMethod the method to fire upon expiration
 * @param maxAge the time to expire after
 * @returns the timeout ID
 */

function createTimeout(expirationMethod, maxAge) {
  var timeoutId = setTimeout(expirationMethod, maxAge);

  if (typeof timeoutId.unref === 'function') {
    timeoutId.unref();
  }

  return timeoutId;
}
/**
 * @private
 *
 * @description
 * create a function that, when an item is added to the cache, adds an expiration for it
 *
 * @param expirations the mutable expirations array
 * @param options the options passed on initialization
 * @param isEqual the function to check argument equality
 * @param isMatchingKey the function to check complete key equality
 * @returns the onCacheAdd function to handle expirations
 */

function createOnCacheAddSetExpiration(expirations, options, isEqual, isMatchingKey) {
  var maxAge = options.maxAge;
  return function onCacheAdd(cache, moizedOptions, moized) {
    var key = cache.keys[0];

    if (findExpirationIndex(expirations, key) === -1) {
      var expirationMethod = function expirationMethod() {
        var findKeyIndex = createFindKeyIndex(isEqual, isMatchingKey);
        var keyIndex = findKeyIndex(cache.keys, key);
        var value = cache.values[keyIndex];

        if (~keyIndex) {
          cache.keys.splice(keyIndex, 1);
          cache.values.splice(keyIndex, 1);

          if (typeof options.onCacheChange === 'function') {
            options.onCacheChange(cache, moizedOptions, moized);
          }
        }

        clearExpiration(expirations, key, true);

        if (typeof options.onExpire === 'function' && options.onExpire(key) === false) {
          cache.keys.unshift(key);
          cache.values.unshift(value);
          onCacheAdd(cache, moizedOptions, moized);

          if (typeof options.onCacheChange === 'function') {
            options.onCacheChange(cache, moizedOptions, moized);
          }
        }
      };

      expirations.push({
        expirationMethod: expirationMethod,
        key: key,
        timeoutId: createTimeout(expirationMethod, maxAge)
      });
    }
  };
}
/**
 * @private
 *
 * @description
 * creates a function that, when a cache item is hit, reset the expiration
 *
 * @param expirations the mutable expirations array
 * @param options the options passed on initialization
 * @returns the onCacheAdd function to handle expirations
 */

function createOnCacheHitResetExpiration(expirations, options) {
  return function onCacheHit(cache) {
    var key = cache.keys[0];
    var expirationIndex = findExpirationIndex(expirations, key);

    if (~expirationIndex) {
      clearExpiration(expirations, key, false);
      expirations[expirationIndex].timeoutId = createTimeout(expirations[expirationIndex].expirationMethod, options.maxAge);
    }
  };
}
/**
 * @private
 *
 * @description
 * get the micro-memoize options specific to the maxAge option
 *
 * @param expirations the expirations for the memoized function
 * @param options the options passed to the moizer
 * @param isEqual the function to test equality of the key on a per-argument basis
 * @param isMatchingKey the function to test equality of the whole key
 * @returns the object of options based on the entries passed
 */

function getMaxAgeOptions(expirations, options, isEqual, isMatchingKey) {
  var onCacheAdd = typeof options.maxAge === 'number' && isFinite(options.maxAge) ? createOnCacheAddSetExpiration(expirations, options, isEqual, isMatchingKey) : undefined;
  return {
    onCacheAdd: onCacheAdd,
    onCacheHit: onCacheAdd && options.updateExpire ? createOnCacheHitResetExpiration(expirations, options) : undefined
  };
}

var statsCache = {
  anonymousProfileNameCounter: 1,
  isCollectingStats: false,
  profiles: {}
};
var hasWarningDisplayed = false;
function clearStats(profileName) {
  if (profileName) {
    delete statsCache.profiles[profileName];
  } else {
    statsCache.profiles = {};
  }
}
/**
 * @private
 *
 * @description
 * activate stats collection
 *
 * @param isCollectingStats should stats be collected
 */

function collectStats(isCollectingStats) {
  if (isCollectingStats === void 0) {
    isCollectingStats = true;
  }

  statsCache.isCollectingStats = isCollectingStats;
}
/**
 * @private
 *
 * @description
 * create a function that increments the number of calls for the specific profile
 */

function createOnCacheAddIncrementCalls(options) {
  var profileName = options.profileName;
  return function () {
    if (profileName && !statsCache.profiles[profileName]) {
      statsCache.profiles[profileName] = {
        calls: 0,
        hits: 0
      };
    }

    statsCache.profiles[profileName].calls++;
  };
}
/**
 * @private
 *
 * @description
 * create a function that increments the number of calls and cache hits for the specific profile
 */

function createOnCacheHitIncrementCallsAndHits(options) {
  return function () {
    var profiles = statsCache.profiles;
    var profileName = options.profileName;

    if (!profiles[profileName]) {
      profiles[profileName] = {
        calls: 0,
        hits: 0
      };
    }

    profiles[profileName].calls++;
    profiles[profileName].hits++;
  };
}
/**
 * @private
 *
 * @description
 * get the profileName for the function when one is not provided
 *
 * @param fn the function to be memoized
 * @returns the derived profileName for the function
 */

function getDefaultProfileName(fn) {
  var stack = new Error().stack;
  var fnName = fn.displayName || fn.name || "Anonymous " + statsCache.anonymousProfileNameCounter++;

  if (!stack) {
    return fnName;
  }

  var lines = stack.split('\n').slice(3);
  var line;
  var profileNameLocation;

  for (var index = 0; index < lines.length; index++) {
    line = lines[index];

    if (line.indexOf('/moize/') === -1 && line.indexOf(' (native)') === -1 && line.indexOf(' Function.') === -1) {
      profileNameLocation = line.replace(/\n/g, '\\n').trim();
      break;
    }
  }

  return profileNameLocation ? fnName + " " + profileNameLocation : fnName;
}
/**
 * @private
 *
 * @description
 * get the usage percentage based on the number of hits and total calls
 *
 * @param calls the number of calls made
 * @param hits the number of cache hits when called
 * @returns the usage as a percentage string
 */

function getUsagePercentage(calls, hits) {
  return calls ? (hits / calls * 100).toFixed(4) + "%" : '0.0000%';
}
/**
 * @private
 *
 * @description
 * get the statistics for a given method or all methods
 *
 * @param [profileName] the profileName to get the statistics for (get all when not provided)
 * @returns the object with stats information
 */

function getStats(profileName) {
  if (!statsCache.isCollectingStats && !hasWarningDisplayed) {
    console.warn('Stats are not currently being collected, please run "collectStats" to enable them.'); // eslint-disable-line no-console

    hasWarningDisplayed = true;
  }

  var profiles = statsCache.profiles;

  if (profileName) {
    if (!profiles[profileName]) {
      return {
        calls: 0,
        hits: 0,
        usage: '0.0000%'
      };
    }

    var profile = profiles[profileName];
    return _extends({}, profile, {
      usage: getUsagePercentage(profile.calls, profile.hits)
    });
  }

  var completeStats = Object.keys(statsCache.profiles).reduce(function (completeProfiles, profileName) {
    completeProfiles.calls += profiles[profileName].calls;
    completeProfiles.hits += profiles[profileName].hits;
    return completeProfiles;
  }, {
    calls: 0,
    hits: 0
  });
  return _extends({}, completeStats, {
    profiles: Object.keys(profiles).reduce(function (computedProfiles, profileName) {
      computedProfiles[profileName] = getStats(profileName);
      return computedProfiles;
    }, {}),
    usage: getUsagePercentage(completeStats.calls, completeStats.hits)
  });
}
/**
 * @private
 *
 * @function getStatsOptions
 *
 * @description
 * get the options specific to storing statistics
 *
 * @param {Options} options the options passed to the moizer
 * @returns {Object} the options specific to keeping stats
 */

function getStatsOptions(options) {
  return statsCache.isCollectingStats ? {
    onCacheAdd: createOnCacheAddIncrementCalls(options),
    onCacheHit: createOnCacheHitIncrementCallsAndHits(options)
  } : {};
}

var ALWAYS_SKIPPED_PROPERTIES = {
  arguments: true,
  callee: true,
  caller: true,
  constructor: true,
  length: true,
  name: true,
  prototype: true
};
/**
 * @private
 *
 * @description
 * copy the static properties from the original function to the moized
 * function
 *
 * @param originalFn the function copying from
 * @param newFn the function copying to
 * @param skippedProperties the list of skipped properties, if any
 */

function copyStaticProperties(originalFn, newFn, skippedProperties) {
  if (skippedProperties === void 0) {
    skippedProperties = [];
  }

  Object.getOwnPropertyNames(originalFn).forEach(function (property) {
    if (!ALWAYS_SKIPPED_PROPERTIES[property] && skippedProperties.indexOf(property) === -1) {
      var descriptor = Object.getOwnPropertyDescriptor(originalFn, property);

      if (descriptor.get || descriptor.set) {
        Object.defineProperty(newFn, property, descriptor);
      } else {
        newFn[property] = originalFn[property];
      }
    }
  });
}
/**
 * @private
 *
 * @description
 * add methods to the moized fuction object that allow extra features
 *
 * @param memoized the memoized function from micro-memoize
 */

function addInstanceMethods(memoized, _ref) {
  var expirations = _ref.expirations;
  var options = memoized.options;
  var findKeyIndex = createFindKeyIndex(options.isEqual, options.isMatchingKey);
  var moized = memoized;

  moized.clear = function () {
    var onCacheChange = moized._microMemoizeOptions.onCacheChange,
        cache = moized.cache;
    cache.keys.length = 0;
    cache.values.length = 0;

    if (onCacheChange) {
      onCacheChange(cache, moized.options, moized);
    }

    return true;
  };

  moized.clearStats = function () {
    clearStats(moized.options.profileName);
  };

  moized.get = function (key) {
    var transformKey = moized._microMemoizeOptions.transformKey,
        cache = moized.cache;
    var cacheKey = transformKey ? transformKey(key) : key;
    var keyIndex = findKeyIndex(cache.keys, cacheKey);
    return keyIndex !== -1 ? moized.apply(this, key) : undefined;
  };

  moized.getStats = function () {
    return getStats(moized.options.profileName);
  };

  moized.has = function (key) {
    var transformKey = moized._microMemoizeOptions.transformKey;
    var cacheKey = transformKey ? transformKey(key) : key;
    return findKeyIndex(moized.cache.keys, cacheKey) !== -1;
  };

  moized.keys = function () {
    return moized.cacheSnapshot.keys;
  };

  moized.remove = function (key) {
    var _moized$_microMemoize = moized._microMemoizeOptions,
        onCacheChange = _moized$_microMemoize.onCacheChange,
        transformKey = _moized$_microMemoize.transformKey,
        cache = moized.cache;
    var keyIndex = findKeyIndex(cache.keys, transformKey ? transformKey(key) : key);

    if (keyIndex === -1) {
      return false;
    }

    var existingKey = cache.keys[keyIndex];
    cache.keys.splice(keyIndex, 1);
    cache.values.splice(keyIndex, 1);

    if (onCacheChange) {
      onCacheChange(cache, moized.options, moized);
    }

    clearExpiration(expirations, existingKey, true);
    return true;
  };

  moized.set = function (key, value) {
    var _microMemoizeOptions = moized._microMemoizeOptions,
        cache = moized.cache,
        options = moized.options;
    var onCacheAdd = _microMemoizeOptions.onCacheAdd,
        onCacheChange = _microMemoizeOptions.onCacheChange,
        transformKey = _microMemoizeOptions.transformKey;
    var cacheKey = transformKey ? transformKey(key) : key;
    var keyIndex = findKeyIndex(cache.keys, cacheKey);

    if (keyIndex === -1) {
      var cutoff = options.maxSize - 1;

      if (cache.size > cutoff) {
        cache.keys.length = cutoff;
        cache.values.length = cutoff;
      }

      cache.keys.unshift(cacheKey);
      cache.values.unshift(value);

      if (options.isPromise) {
        cache.updateAsyncCache(moized);
      }

      if (onCacheAdd) {
        onCacheAdd(cache, options, moized);
      }

      if (onCacheChange) {
        onCacheChange(cache, options, moized);
      }
    } else {
      var existingKey = cache.keys[keyIndex];
      cache.values[keyIndex] = value;

      if (keyIndex > 0) {
        cache.orderByLru(existingKey, value, keyIndex);
      }

      if (options.isPromise) {
        cache.updateAsyncCache(moized);
      }

      if (typeof onCacheChange === 'function') {
        onCacheChange(cache, options, moized);
      }
    }
  };

  moized.values = function () {
    return moized.cacheSnapshot.values;
  };
}
/**
 * @private
 *
 * @description
 * add propeties to the moized fuction object that surfaces extra information
 *
 * @param memoized the memoized function
 * @param expirations the list of expirations for cache items
 * @param options the options passed to the moizer
 * @param originalFunction the function that is being memoized
 */

function addInstanceProperties(memoized, _ref2) {
  var expirations = _ref2.expirations,
      moizeOptions = _ref2.options,
      originalFunction = _ref2.originalFunction;
  var microMemoizeOptions = memoized.options;
  Object.defineProperties(memoized, {
    _microMemoizeOptions: {
      configurable: true,
      get: function get() {
        return microMemoizeOptions;
      }
    },
    cacheSnapshot: {
      configurable: true,
      get: function get() {
        var currentCache = memoized.cache;
        return {
          keys: currentCache.keys.slice(0),
          size: currentCache.size,
          values: currentCache.values.slice(0)
        };
      }
    },
    expirations: {
      configurable: true,
      get: function get() {
        return expirations;
      }
    },
    expirationsSnapshot: {
      configurable: true,
      get: function get() {
        return expirations.slice(0);
      }
    },
    isMoized: {
      configurable: true,
      get: function get() {
        return true;
      }
    },
    options: {
      configurable: true,
      get: function get() {
        return moizeOptions;
      }
    },
    originalFunction: {
      configurable: true,
      get: function get() {
        return originalFunction;
      }
    }
  });
  var moized = memoized;
  copyStaticProperties(originalFunction, moized);
}
/**
 * @private
 *
 * @description
 * add methods and properties to the memoized function for more features
 *
 * @param memoized the memoized function
 * @param configuration the configuration object for the instance
 * @returns the memoized function passed
 */

function createMoizeInstance(memoized, configuration) {
  addInstanceMethods(memoized, configuration);
  addInstanceProperties(memoized, configuration);
  return memoized;
}

// a dependency on the React library itself.

var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for ? Symbol.for('react.element') : 0xeac7;
/**
 * @private
 *
 * @description
 * Create a component that memoizes based on `props` and legacy `context`
 * on a per-instance basis. This requires creating a component class to
 * store the memoized function. The cost is quite low, and avoids the
 * need to have access to the React dependency by basically re-creating
 * the basic essentials for a component class and the results of the
 * `createElement` function.
 *
 * @param moizer the top-level moize method
 * @param fn the component to memoize
 * @param options the memoization options
 * @returns the memoized component
 */

function createMoizedComponent(moizer, fn, options) {
  /**
   * This is a hack override setting the necessary options
   * for a React component to be memoized. In the main `moize`
   * method, if the `isReact` option is set it is short-circuited
   * to call this function, and these overrides allow the
   * necessary transformKey method to be derived.
   *
   * The order is based on:
   * 1) Set the necessary aspects of transformKey for React components.
   * 2) Allow setting of other options and overrides of those aspects
   *    if desired (for example, `isDeepEqual` will use deep equality).
   * 3) Always set `isReact` to false to prevent infinite loop.
   */
  var reactMoizer = moizer(_extends({
    maxArgs: 2,
    isShallowEqual: true
  }, options, {
    isReact: false
  }));

  if (!fn.displayName) {
    // @ts-ignore - allow setting of displayName
    fn.displayName = fn.name || 'Component';
  }

  function Moized(props, context, updater) {
    this.props = props;
    this.context = context;
    this.updater = updater;
    this.MoizedComponent = reactMoizer(fn);
  }

  Moized.prototype.isReactComponent = {};

  Moized.prototype.render = function () {
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type: this.MoizedComponent,
      props: this.props,
      ref: null,
      key: null,
      _owner: null
    };
  };

  copyStaticProperties(fn, Moized, ['contextType', 'contextTypes']);
  Moized.displayName = "Moized(" + (fn.displayName || fn.name || 'Component') + ")";
  setName(Moized, fn.name, options.profileName);
  return Moized;
}

function createGetInitialArgs(size) {
  /**
   * @private
   *
   * @description
   * take the first N number of items from the array (faster than slice)
   *
   * @param args the args to take from
   * @returns the shortened list of args as an array
   */
  return function (args) {
    if (size >= args.length) {
      return args;
    }

    if (size === 0) {
      return [];
    }

    if (size === 1) {
      return [args[0]];
    }

    if (size === 2) {
      return [args[0], args[1]];
    }

    if (size === 3) {
      return [args[0], args[1], args[2]];
    }

    var clone = [];

    for (var index = 0; index < size; index++) {
      clone[index] = args[index];
    }

    return clone;
  };
}

/**
 * @function getCutoff
 *
 * @description
 * faster `Array.prototype.indexOf` implementation build for slicing / splicing
 *
 * @param array the array to match the value in
 * @param value the value to match
 * @returns the matching index, or -1
 */
function getCutoff(array, value) {
  var length = array.length;

  for (var index = 0; index < length; ++index) {
    if (array[index] === value) {
      return index + 1;
    }
  }

  return 0;
}
/**
 * @private
 *
 * @description
 * custom replacer for the stringify function
 *
 * @returns if function then toString of it, else the value itself
 */


function createDefaultReplacer() {
  var cache = [];
  var keys = [];
  return function defaultReplacer(key, value) {
    var type = typeof value;

    if (type === 'function' || type === 'symbol') {
      return value.toString();
    }

    if (typeof value === 'object') {
      if (cache.length) {
        var thisCutoff = getCutoff(cache, this);

        if (thisCutoff === 0) {
          cache[cache.length] = this;
        } else {
          cache.splice(thisCutoff);
          keys.splice(thisCutoff);
        }

        keys[keys.length] = key;
        var valueCutoff = getCutoff(cache, value);

        if (valueCutoff !== 0) {
          return "[ref=" + (keys.slice(0, valueCutoff).join('.') || '.') + "]";
        }
      } else {
        cache[0] = value;
        keys[0] = key;
      }

      return value;
    }

    return '' + value;
  };
}
/**
 * @private
 *
 * @description
 * get the stringified version of the argument passed
 *
 * @param arg argument to stringify
 * @returns the stringified argument
 */

function getStringifiedArgument(arg) {
  var typeOfArg = typeof arg;
  return arg && (typeOfArg === 'object' || typeOfArg === 'function') ? JSON.stringify(arg, createDefaultReplacer()) : arg;
}
/**
 * @private
 *
 * @description
 * serialize the arguments passed
 *
 * @param options the options passed to the moizer
 * @param options.maxArgs the cap on the number of arguments used in serialization
 * @returns argument serialization method
 */

function defaultArgumentSerializer(args) {
  var key = '|';

  for (var index = 0; index < args.length; index++) {
    key += getStringifiedArgument(args[index]) + '|';
  }

  return [key];
}
/**
 * @private
 *
 * @description
 * based on the options passed, either use the serializer passed or generate the internal one
 *
 * @param options the options passed to the moized function
 * @returns the function to use in serializing the arguments
 */

function getSerializerFunction(options) {
  return typeof options.serializer === 'function' ? options.serializer : defaultArgumentSerializer;
}
/**
 * @private
 *
 * @description
 * are the serialized keys equal to one another
 *
 * @param cacheKey the cache key to compare
 * @param key the key to test
 * @returns are the keys equal
 */

function getIsSerializedKeyEqual(cacheKey, key) {
  return cacheKey[0] === key[0];
}

function createOnCacheOperation(fn) {
  if (typeof fn === 'function') {
    return function (_cacheIgnored, _microMemoizeOptionsIgnored, memoized) {
      return fn(memoized.cache, memoized.options, memoized);
    };
  }
}
/**
 * @private
 *
 * @description
 * get the isEqual method passed to micro-memoize
 *
 * @param options the options passed to the moizer
 * @returns the isEqual method to apply
 */

function getIsEqual(options) {
  return options.matchesArg || options.isDeepEqual && deepEqual || options.isShallowEqual && shallowEqual || sameValueZeroEqual;
}
/**
 * @private
 *
 * @description
 * get the isEqual method passed to micro-memoize
 *
 * @param options the options passed to the moizer
 * @returns the isEqual method to apply
 */

function getIsMatchingKey(options) {
  return options.matchesKey || options.isSerialized && getIsSerializedKeyEqual || undefined;
}
/**
 * @private
 *
 * @description
 * get the function that will transform the key based on the arguments passed
 *
 * @param options the options passed to the moizer
 * @returns the function to transform the key with
 */

function getTransformKey(options) {
  return compose(options.isSerialized && getSerializerFunction(options), typeof options.transformArgs === 'function' && options.transformArgs, typeof options.maxArgs === 'number' && createGetInitialArgs(options.maxArgs));
}

function createRefreshableMoized(moized) {
  var updateCacheForKey = moized.options.updateCacheForKey;
  /**
   * @private
   *
   * @description
   * Wrapper around already-`moize`d function which will intercept the memoization
   * and call the underlying function directly with the purpose of updating the cache
   * for the given key.
   *
   * Promise values use a tweak of the logic that exists at cache.updateAsyncCache, which
   * reverts to the original value if the promise is rejected and there was already a cached
   * value.
   */

  var refreshableMoized = function refreshableMoized() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (!updateCacheForKey(args)) {
      return moized.apply(this, args);
    }

    var result = moized.fn.apply(this, args);
    moized.set(args, result);
    return result;
  };

  copyStaticProperties(moized, refreshableMoized);
  return refreshableMoized;
}

var _excluded = ["matchesArg", "isDeepEqual", "isPromise", "isReact", "isSerialized", "isShallowEqual", "matchesKey", "maxAge", "maxArgs", "maxSize", "onCacheAdd", "onCacheChange", "onCacheHit", "onExpire", "profileName", "serializer", "updateCacheForKey", "transformArgs", "updateExpire"];
/**
 * @module moize
 */

/**
 * @description
 * memoize a function based its arguments passed, potentially improving runtime performance
 *
 * @example
 * import moize from 'moize';
 *
 * // standard implementation
 * const fn = (foo, bar) => `${foo} ${bar}`;
 * const memoizedFn = moize(fn);
 *
 * // implementation with options
 * const fn = async (id) => get(`http://foo.com/${id}`);
 * const memoizedFn = moize(fn, {isPromise: true, maxSize: 5});
 *
 * // implementation with convenience methods
 * const Foo = ({foo}) => <div>{foo}</div>;
 * const MemoizedFoo = moize.react(Foo);
 *
 * @param fn the function to memoized, or a list of options when currying
 * @param [options=DEFAULT_OPTIONS] the options to apply
 * @returns the memoized function
 */

var moize = function moize(fn, passedOptions) {
  var options = passedOptions || DEFAULT_OPTIONS;

  if (isMoized(fn)) {
    var moizeable = fn.originalFunction;
    var mergedOptions = mergeOptions(fn.options, options);
    return moize(moizeable, mergedOptions);
  }

  if (typeof fn === 'object') {
    return function (curriedFn, curriedOptions) {
      if (typeof curriedFn === 'function') {
        var _mergedOptions = mergeOptions(fn, curriedOptions);

        return moize(curriedFn, _mergedOptions);
      }

      var mergedOptions = mergeOptions(fn, curriedFn);
      return moize(mergedOptions);
    };
  }

  if (options.isReact) {
    return createMoizedComponent(moize, fn, options);
  }

  var coalescedOptions = _extends({}, DEFAULT_OPTIONS, options, {
    maxAge: typeof options.maxAge === 'number' && options.maxAge >= 0 ? options.maxAge : DEFAULT_OPTIONS.maxAge,
    maxArgs: typeof options.maxArgs === 'number' && options.maxArgs >= 0 ? options.maxArgs : DEFAULT_OPTIONS.maxArgs,
    maxSize: typeof options.maxSize === 'number' && options.maxSize >= 0 ? options.maxSize : DEFAULT_OPTIONS.maxSize,
    profileName: options.profileName || getDefaultProfileName(fn)
  });

  var expirations = [];

  coalescedOptions.matchesArg;
      coalescedOptions.isDeepEqual;
      var isPromise = coalescedOptions.isPromise;
      coalescedOptions.isReact;
      coalescedOptions.isSerialized;
      coalescedOptions.isShallowEqual;
      coalescedOptions.matchesKey;
      coalescedOptions.maxAge;
      coalescedOptions.maxArgs;
      var maxSize = coalescedOptions.maxSize,
      onCacheAdd = coalescedOptions.onCacheAdd,
      onCacheChange = coalescedOptions.onCacheChange,
      onCacheHit = coalescedOptions.onCacheHit;
      coalescedOptions.onExpire;
      coalescedOptions.profileName;
      coalescedOptions.serializer;
      var updateCacheForKey = coalescedOptions.updateCacheForKey;
      coalescedOptions.transformArgs;
      coalescedOptions.updateExpire;
      var customOptions = _objectWithoutPropertiesLoose(coalescedOptions, _excluded);

  var isEqual = getIsEqual(coalescedOptions);
  var isMatchingKey = getIsMatchingKey(coalescedOptions);
  var maxAgeOptions = getMaxAgeOptions(expirations, coalescedOptions, isEqual, isMatchingKey);
  var statsOptions = getStatsOptions(coalescedOptions);
  var transformKey = getTransformKey(coalescedOptions);

  var microMemoizeOptions = _extends({}, customOptions, {
    isEqual: isEqual,
    isMatchingKey: isMatchingKey,
    isPromise: isPromise,
    maxSize: maxSize,
    onCacheAdd: createOnCacheOperation(combine(onCacheAdd, maxAgeOptions.onCacheAdd, statsOptions.onCacheAdd)),
    onCacheChange: createOnCacheOperation(onCacheChange),
    onCacheHit: createOnCacheOperation(combine(onCacheHit, maxAgeOptions.onCacheHit, statsOptions.onCacheHit)),
    transformKey: transformKey
  });

  var memoized = createMemoizedFunction(fn, microMemoizeOptions);
  var moized = createMoizeInstance(memoized, {
    expirations: expirations,
    options: coalescedOptions,
    originalFunction: fn
  });

  if (updateCacheForKey) {
    moized = createRefreshableMoized(moized);
  }

  setName(moized, fn.name, options.profileName);
  return moized;
};
/**
 * @function
 * @name clearStats
 * @memberof module:moize
 * @alias moize.clearStats
 *
 * @description
 * clear all existing stats stored
 */


moize.clearStats = clearStats;
/**
 * @function
 * @name collectStats
 * @memberof module:moize
 * @alias moize.collectStats
 *
 * @description
 * start collecting statistics
 */

moize.collectStats = collectStats;
/**
 * @function
 * @name compose
 * @memberof module:moize
 * @alias moize.compose
 *
 * @description
 * method to compose moized methods and return a single moized function
 *
 * @param moized the functions to compose
 * @returns the composed function
 */

moize.compose = function () {
  return compose.apply(void 0, arguments) || moize;
};
/**
 * @function
 * @name deep
 * @memberof module:moize
 * @alias moize.deep
 *
 * @description
 * should deep equality check be used
 *
 * @returns the moizer function
 */


moize.deep = moize({
  isDeepEqual: true
});
/**
 * @function
 * @name getStats
 * @memberof module:moize
 * @alias moize.getStats
 *
 * @description
 * get the statistics of a given profile, or overall usage
 *
 * @returns statistics for a given profile or overall usage
 */

moize.getStats = getStats;
/**
 * @function
 * @name infinite
 * @memberof module:moize
 * @alias moize.infinite
 *
 * @description
 * a moized method that will remove all limits from the cache size
 *
 * @returns the moizer function
 */

moize.infinite = moize({
  maxSize: Infinity
});
/**
 * @function
 * @name isCollectingStats
 * @memberof module:moize
 * @alias moize.isCollectingStats
 *
 * @description
 * are stats being collected
 *
 * @returns are stats being collected
 */

moize.isCollectingStats = function isCollectingStats() {
  return statsCache.isCollectingStats;
};
/**
 * @function
 * @name isMoized
 * @memberof module:moize
 * @alias moize.isMoized
 *
 * @description
 * is the fn passed a moized function
 *
 * @param fn the object to test
 * @returns is fn a moized function
 */


moize.isMoized = function isMoized(fn) {
  return typeof fn === 'function' && !!fn.isMoized;
};
/**
 * @function
 * @name matchesArg
 * @memberof module:moize
 * @alias moize.matchesArg
 *
 * @description
 * a moized method where the arg matching method is the custom one passed
 *
 * @param keyMatcher the method to compare against those in cache
 * @returns the moizer function
 */


moize.matchesArg = function (argMatcher) {
  return moize({
    matchesArg: argMatcher
  });
};
/**
 * @function
 * @name matchesKey
 * @memberof module:moize
 * @alias moize.matchesKey
 *
 * @description
 * a moized method where the key matching method is the custom one passed
 *
 * @param keyMatcher the method to compare against those in cache
 * @returns the moizer function
 */


moize.matchesKey = function (keyMatcher) {
  return moize({
    matchesKey: keyMatcher
  });
};

function maxAge(maxAge, expireOptions) {
  if (expireOptions === true) {
    return moize({
      maxAge: maxAge,
      updateExpire: expireOptions
    });
  }

  if (typeof expireOptions === 'object') {
    var onExpire = expireOptions.onExpire,
        updateExpire = expireOptions.updateExpire;
    return moize({
      maxAge: maxAge,
      onExpire: onExpire,
      updateExpire: updateExpire
    });
  }

  if (typeof expireOptions === 'function') {
    return moize({
      maxAge: maxAge,
      onExpire: expireOptions,
      updateExpire: true
    });
  }

  return moize({
    maxAge: maxAge
  });
}
/**
 * @function
 * @name maxAge
 * @memberof module:moize
 * @alias moize.maxAge
 *
 * @description
 * a moized method where the age of the cache is limited to the number of milliseconds passed
 *
 * @param maxAge the TTL of the value in cache
 * @returns the moizer function
 */


moize.maxAge = maxAge;
/**
 * @function
 * @name maxArgs
 * @memberof module:moize
 * @alias moize.maxArgs
 *
 * @description
 * a moized method where the number of arguments used for determining cache is limited to the value passed
 *
 * @param maxArgs the number of args to base the key on
 * @returns the moizer function
 */

moize.maxArgs = function maxArgs(maxArgs) {
  return moize({
    maxArgs: maxArgs
  });
};
/**
 * @function
 * @name maxSize
 * @memberof module:moize
 * @alias moize.maxSize
 *
 * @description
 * a moized method where the total size of the cache is limited to the value passed
 *
 * @param maxSize the maximum size of the cache
 * @returns the moizer function
 */


moize.maxSize = function maxSize(maxSize) {
  return moize({
    maxSize: maxSize
  });
};
/**
 * @function
 * @name profile
 * @memberof module:moize
 * @alias moize.profile
 *
 * @description
 * a moized method with a profile name
 *
 * @returns the moizer function
 */


moize.profile = function (profileName) {
  return moize({
    profileName: profileName
  });
};
/**
 * @function
 * @name promise
 * @memberof module:moize
 * @alias moize.promise
 *
 * @description
 * a moized method specific to caching resolved promise / async values
 *
 * @returns the moizer function
 */


moize.promise = moize({
  isPromise: true,
  updateExpire: true
});
/**
 * @function
 * @name react
 * @memberof module:moize
 * @alias moize.react
 *
 * @description
 * a moized method specific to caching React element values
 *
 * @returns the moizer function
 */

moize.react = moize({
  isReact: true
});
/**
 * @function
 * @name serialize
 * @memberof module:moize
 * @alias moize.serialize
 *
 * @description
 * a moized method that will serialize the arguments passed to use as the cache key
 *
 * @returns the moizer function
 */

moize.serialize = moize({
  isSerialized: true
});
/**
 * @function
 * @name serializeWith
 * @memberof module:moize
 * @alias moize.serializeWith
 *
 * @description
 * a moized method that will serialize the arguments passed to use as the cache key
 * based on the serializer passed
 *
 * @returns the moizer function
 */

moize.serializeWith = function (serializer) {
  return moize({
    isSerialized: true,
    serializer: serializer
  });
};
/**
 * @function
 * @name shallow
 * @memberof module:moize
 * @alias moize.shallow
 *
 * @description
 * should shallow equality check be used
 *
 * @returns the moizer function
 */


moize.shallow = moize({
  isShallowEqual: true
});
/**
 * @function
 * @name transformArgs
 * @memberof module:moize
 * @alias moize.transformArgs
 *
 * @description
 * transform the args to allow for specific cache key comparison
 *
 * @param transformArgs the args transformer
 * @returns the moizer function
 */

moize.transformArgs = function (transformArgs) {
  return moize({
    transformArgs: transformArgs
  });
};
/**
 * @function
 * @name updateCacheForKey
 * @memberof module:moize
 * @alias moize.updateCacheForKey
 *
 * @description
 * update the cache for a given key when the method passed returns truthy
 *
 * @param updateCacheForKey the method to determine when to update cache
 * @returns the moizer function
 */


moize.updateCacheForKey = function (updateCacheForKey) {
  return moize({
    updateCacheForKey: updateCacheForKey
  });
}; // Add self-referring `default` property for edge-case cross-compatibility of mixed ESM/CommonJS usage.
// This property is frozen and non-enumerable to avoid visibility on iteration or accidental overrides.


Object.defineProperty(moize, 'default', {
  configurable: false,
  enumerable: false,
  value: moize,
  writable: false
});

const cellTransformerProgram = (app, numSides = 3) => app.createProgram(transformationGL, `
#version 300 es
precision highp float;
#define GLSLIFY 1
void main() {}
`, {
  transformFeedbackVaryings: [
    "transformedPoints",
    "transformedWeights",
    "lod"
  ]
});
const cellsTransformer = moize((app, cellPositions, cellWeights) => {
  const numCells = cellPositions.length;
  let positions = new Float32Array(flatten(flatten(cellPositions)));
  let weights = cellWeights ? new Float32Array(flatten(flatten(cellWeights))) : null;
  let pointsIn = app.createMatrixBuffer(PicoGL.FLOAT_MAT3x4, positions);
  let weightsIn = app.createMatrixBuffer(PicoGL.FLOAT_MAT3x4, weights ? weights : numCells * 4 * 3);
  let transformedPointsBuffer = app.createMatrixBuffer(PicoGL.FLOAT_MAT3x4, numCells * 12);
  let transformedWeightsBuffer = app.createMatrixBuffer(PicoGL.FLOAT_MAT3x4, numCells * 12);
  let lodBuffer = app.createVertexBuffer(PicoGL.FLOAT, 4, numCells);
  const vertexArray = app.createVertexArray().vertexAttributeBuffer(0, pointsIn).vertexAttributeBuffer(3, weightsIn);
  const transformFeedback = app.createTransformFeedback().feedbackBuffer(0, transformedPointsBuffer).feedbackBuffer(1, transformedWeightsBuffer).feedbackBuffer(2, lodBuffer);
  const transformer = cellTransformerProgram(app);
  const getTransformedPoints = bufferGetter(app.gl, transformedPointsBuffer.buffer);
  const getTransformedWeights = bufferGetter(app.gl, transformedWeightsBuffer.buffer);
  const getLODs = bufferGetter(app.gl, lodBuffer.buffer);
  const drawer = app.createDrawCall(transformer, vertexArray).primitive(PicoGL.POINTS).transformFeedback(transformFeedback).uniform("angle", Math.PI);
  return {
    drawer,
    transformedPointsBuffer,
    getTransformedPoints,
    transformedWeightsBuffer,
    getTransformedWeights,
    lodBuffer,
    getLODs,
    numCells
  };
});

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var ganja = {exports: {}};

/** Ganja.js - Geometric Algebra - Not Just Algebra.
  * @author Enki
  * @link   https://github.com/enkimute/ganja.js
  */

(function (module) {
/*********************************************************************************************************************/
//
// Ganja.js is an Algebra generator for javascript. It generates a wide variety of Algebra's and supports operator
// overloading, algebraic literals and a variety of graphing options.
//
// Ganja.js is designed with prototyping and educational purposes in mind. Clean mathematical syntax is the primary
// target.
//
// Ganja.js exports only one function called *Algebra*. This function is used to generate Algebra classes. (say complex
// numbers, minkowski or 3D CGA). The returned class can be used to create, add, multiply etc, but also to upgrade
// javascript functions with algebraic literals, operator overloading, vectors, matrices and much more.
//
// As a simple example, multiplying two complex numbers 3+2i and 1+4i could be done like this :
//
//  var complex = Algebra(0,1);
//  var a = new complex([3,2]);
//  var b = new complex([1,3]);
//  var result = a.Mul(b);
//
// But the same can be written using operator overloading and algebraic literals. (where scientific notation with
// lowercase e is overloaded to directly specify generators (e1, e2, e12, ...))
//
//   var result = Algebra(0,1,()=>(3+2e1)*(1+4e1));
//
// Please see github for user documentation and examples.
//
/*********************************************************************************************************************/

// Documentation below is for implementors. I'll assume you know about Clifford Algebra's, grades, its products, etc ..
// I'll also assume you are familiar with ES6. My style may feel a bith mathematical, advise is to read slow.

(function (name, context, definition) {
  if (module.exports) module.exports = definition();
  else context[name] = definition();
}('Algebra', commonjsGlobal, function () {

/** The Algebra class generator. Possible calling signatures :
  *   Algebra([func])                      => algebra with no dimensions, i.e. R. Optional function for the translator.
  *   Algebra(p,[func])                    => 'p' positive dimensions and an optional function to pass to the translator.
  *   Algebra(p,q,[func])                  => 'p' positive and 'q' negative dimensions and optional function.
  *   Algebra(p,q,r,[func])                => 'p' positive, 'q' negative and 'r' zero dimensions and optional function.
  *   Algebra({                            => for custom basis, cayley, mixing, etc pass in an object as first parameter.
  *     [p:p],                             => optional 'p' for # of positive dimensions
  *     [q:q],                             => optional 'q' for # of negative dimensions
  *     [r:r],                             => optional 'r' for # of zero dimensions
  *     [metric:array],                    => alternative for p,q,r. e.g. ([1,1,1,-1] for spacetime)
  *     [basis:array],                     => array of strings with basis names. (e.g. ['1','e1','e2','e12'])
  *     [Cayley:Cayley],                   => optional custom Cayley table (strings). (e.g. [['1','e1'],['e1','-1']])
  *     [mix:boolean],                     => Allows mixing of various algebras. (for space efficiency).
  *     [graded:boolean],                  => Use a graded algebra implementation. (automatic for +6D)
  *     [baseType:Float32Array]            => optional basetype to use. (only for flat generator)
  *   },[func])                            => optional function for the translator.
 **/
  return function Algebra(p,q,r) {
  // Resolve possible calling signatures so we know the numbers for p,q,r. Last argument can always be a function.
    var fu=arguments[arguments.length-1],options=p; if (options instanceof Object) {
      q = (p.q || (p.metric && p.metric.filter(x=>x==-1).length))| 0;
      r = (p.r || (p.metric && p.metric.filter(x=>x==0).length)) | 0;
      p = p.p === undefined ? (p.metric && p.metric.filter(x=>x==1).length) || 0 : p.p || 0;
    } else { options={}; p=p|0; r=r|0; q=q|0; }
  // Support for multi-dual-algebras
    if (options.dual || (p==0 && q==0 && r<0)) { r=options.dual=options.dual||-r; // Create a dual number algebra if r<0 (old) or options.dual set(new)
      options.basis  = [...Array(r+1)].map((a,i)=>i?'e0'+i:'1');  options.metric = [1,...Array(r)]; options.tot=r+1;
      options.Cayley = [...Array(r+1)].map((a,i)=>[...Array(r+1)].map((y,j)=>i*j==0?((i+j)?'e0'+(i+j):'1'):'0'));
    }
    if (options.over) options.baseType = Array;

  // Calculate the total number of dimensions.
    var tot = options.tot = (options.tot||(p||0)+(q||0)+(r||0)||(options.basis&&options.basis.length))|0;

  // Unless specified, generate a full set of Clifford basis names. We generate them as an array of strings by starting
  // from numbers in binary representation and changing the set bits into their relative position.
  // Basis names are ordered first per grade, then lexically (not cyclic!).
  // For 10 or more dimensions all names will be double digits ! 1e01 instead of 1e1 ..
    var basis=(options.basis&&(options.basis.length==2**tot||r<0||options.Cayley)&&options.basis)||[...Array(2**tot)]           // => [undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined]
              .map((x,xi)=>(((1<<30)+xi).toString(2)).slice(-tot||-1)                                                           // => ["000", "001", "010", "011", "100", "101", "110", "111"]  (index of array in base 2)
              .replace(/./g,(a,ai)=>a=='0'?'':String.fromCharCode(66+ai-(r!=0))))                                               // => ["", "3", "2", "23", "1", "13", "12", "123"] (1 bits replaced with their positions, 0's removed)
              .sort((a,b)=>(a.toString().length==b.toString().length)?(a>b?1:b>a?-1:0):a.toString().length-b.toString().length) // => ["", "1", "2", "3", "12", "13", "23", "123"] (sorted numerically)
              .map(x=>x&&'e'+(x.replace(/./g,x=>('0'+(x.charCodeAt(0)-65)).slice(tot>9?-2:-1) ))||'1');                          // => ["1", "e1", "e2", "e3", "e12", "e13", "e23", "e123"] (converted to commonly used basis names)

  // See if the basis names start from 0 or 1, store grade per component and lowest component per grade.
    var low=basis.length==1?1:basis[1].match(/\d+/g)[0]*1,
        grades=options.grades||(options.dual&&basis.map((x,i)=>i?1:0))||basis.map(x=>tot>9?(x.length-1)/2:x.length-1),
        grade_start=grades.map((a,b,c)=>c[b-1]!=a?b:-1).filter(x=>x+1).concat([basis.length]);

  // String-simplify a concatenation of two basis blades. (and supports custom basis names e.g. e21 instead of e12)
  // This is the function that implements e1e1 = +1/-1/0 and e1e2=-e2e1. The brm function creates the remap dictionary.
    var simplify = (s,p,q,r)=>{
          var sign=1,c,l,t=[],f=true,ss=s.match(tot>9?/(\d\d)/g:/(\d)/g);if (!ss) return s; s=ss; l=s.length;
          while (f) { f=false;
          // implement Ex*Ex = metric.
            for (var i=0; i<l;) if (s[i]===s[i+1]) { if (options.metric) sign*=options.metric[s[i]-basis[1][1]]; else if ((s[i]-low)>=(p+r)) sign*=-1; else if ((s[i]-low)<r) sign=0;i+=2; f=true; } else t.push(s[i++]);
          // implement Ex*Ey = -Ey*Ex while sorting basis vectors.
            for (var i=0; i<t.length-1; i++) if (t[i]>t[i+1]) { c=t[i];t[i]=t[i+1];t[i+1]=c;sign*=-1;f=true; break;} if (f) { s=t;t=[];l=s.length; }
          }
          var ret=(sign==0)?'0':((sign==1)?'':'-')+(t.length?'e'+t.join(''):'1'); return (brm&&brm[ret])||(brm&&brm['-'+ret]&&'-'+brm['-'+ret])||ret;
        },
        brm=(x=>{ var ret={}; for (var i in basis) ret[basis[i]=='1'?'1':simplify(basis[i],p,q,r)] = basis[i]; return ret; })();

  // As an alternative to the string fiddling, one can also bit-fiddle. In this case the basisvectors are represented by integers with 1 bit per generator set.
    var simplify_bits = (A,B,p2)=>{ var n=p2||(p+q+r),t=0,ab=A&B,res=A^B; if (ab&((1<<r)-1)) return [0,0]; while (n--) t^=(A=A>>1); t&=B; t^=ab>>(p+r); t^=t>>16; t^=t>>8; t^=t>>4; return [1-2*(27030>>(t&15)&1),res]; },
        bc = (v)=>{ v=v-((v>>1)& 0x55555555); v=(v&0x33333333)+((v>>2)&0x33333333); var c=((v+(v>>4)&0xF0F0F0F)*0x1010101)>>24; return c };

  if (!options.graded && tot <= 6 || options.graded===false || options.Cayley) {
  // Faster and degenerate-metric-resistant dualization. (a remapping table that maps items into their duals).
    var drm=basis.map((a,i)=>{ return {a:a,i:i} })
                 .sort((a,b)=>a.a.length>b.a.length?1:a.a.length<b.a.length?-1:(+a.a.slice(1).split('').sort().join(''))-(+b.a.slice(1).split('').sort().join('')) )
                 .map(x=>x.i).reverse(),
        drms=drm.map((x,i)=>(x==0||i==0)?1:simplify(basis[x]+basis[i])[0]=='-'?-1:1);

  /// Store the full metric (also for bivectors etc ..)
    var metric = options.Cayley&&options.Cayley.map((x,i)=>x[i]) || basis.map((x,xi)=>simplify(x+x,p,q,r)|0); metric[0]=1;

  /// Generate multiplication tables for the outer and geometric products.
    var mulTable   = options.Cayley||basis.map(x=>basis.map(y=>(x==1)?y:(y==1)?x:simplify(x+y,p,q,r)));

  // subalgebra support. (must be bit-order basis blades, does no error checking.)
    if (options.even) options.basis = basis.filter(x=>x.length%2==1);
    if (options.basis && !options.Cayley && r>=0 && options.basis.length != 2**tot) {
      metric = metric.filter((x,i)=>options.basis.indexOf(basis[i])!=-1);
      mulTable = mulTable.filter((x,i)=>options.basis.indexOf(basis[i])!=-1).map(x=>x.filter((x,i)=>options.basis.indexOf(basis[i])!=-1));
      basis  = options.basis;
    }

  /// Convert Cayley table to product matrices. The outer product selects the strict sum of the GP (but without metric), the inner product
  /// is the left contraction.
    var gp=basis.map(x=>basis.map(x=>'0')), cp=gp.map(x=>gp.map(x=>'0')), cps=gp.map(x=>gp.map(x=>'0')), op=gp.map(x=>gp.map(x=>'0')), gpo={};          // Storage for our product tables.
    basis.forEach((x,xi)=>basis.forEach((y,yi)=>{ var n = mulTable[xi][yi].replace(/^-/,''); if (!gpo[n]) gpo[n]=[]; gpo[n].push([xi,yi]); }));
    basis.forEach((o,oi)=>{
      gpo[o].forEach(([xi,yi])=>op[oi][xi]=(grades[oi]==grades[xi]+grades[yi])?((mulTable[xi][yi]=='0')?'0':((mulTable[xi][yi][0]!='-')?'':'-')+'b['+yi+']*this['+xi+']'):'0');
      gpo[o].forEach(([xi,yi])=>{
        gp[oi][xi] =((gp[oi][xi]=='0')?'':gp[oi][xi]+'+')   + ((mulTable[xi][yi]=='0')?'0':((mulTable[xi][yi][0]!='-')?'':'-')+'b['+yi+']*this['+xi+']');
        cp[oi][xi] =((cp[oi][xi]=='0')?'':cp[oi][xi]+'+')   + ((grades[oi]==grades[yi]-grades[xi])?gp[oi][xi]:'0');
        cps[oi][xi]=((cps[oi][xi]=='0')?'':cps[oi][xi]+'+') + ((grades[oi]==Math.abs(grades[yi]-grades[xi]))?gp[oi][xi]:'0');
      });
    });

  /// Flat Algebra Multivector Base Class.
    var generator = class MultiVector extends (options.baseType||Float32Array) {
    /// constructor - create a floating point array with the correct number of coefficients.
      constructor(a) { super(a||basis.length); return this; }

    /// grade selection - return a only the part of the input with the specified grade.
      Grade(grade,res) { res=res||new this.constructor(); for (var i=0,l=res.length; i<l; i++) if (grades[i]==grade) res[i]=this[i]; else res[i]=0; return res; }
      Even(res) { res=res||new this.constructor(); for (var i=0,l=res.length; i<l; i++) if (grades[i]%2==0) res[i]=this[i]; else res[i]=0; return res; }

    /// grade creation - convert array with just one grade to full multivector.
      nVector(grade,...args) { this.set(args,grade_start[grade]); return this; }

    /// Fill in coordinates (accepts sequence of index,value as arguments)
      Coeff() { for (var i=0,l=arguments.length; i<l; i+=2) this[arguments[i]]=arguments[i+1]; return this; }

    /// Negates specific grades (passed in as args)
      Map(res, ...a) { for (var i=0, l=res.length; i<l; i++) res[i] = (~a.indexOf(grades[i]))?-this[i]:this[i]; return res; }

    /// Returns the vector grade only.
      get Vector ()    { return this.slice(grade_start[1],grade_start[2]); };

      toString() { var res=[]; for (var i=0; i<basis.length; i++) if (Math.abs(this[i])>1e-10) res.push(((this[i]==1)&&i?'':((this[i]==-1)&&i)?'-':(this[i].toFixed(10)*1))+(i==0?'':tot==1&&q==1?'i':basis[i].replace('e','e_'))); return res.join('+').replace(/\+-/g,'-')||'0'; }

    /// Reversion, Involutions, Conjugation for any number of grades, component acces shortcuts.
      get Negative (){ var res = new this.constructor(); for (var i=0; i<this.length; i++) res[i]= -this[i]; return res; };
      get Reverse (){ var res = new this.constructor(); for (var i=0; i<this.length; i++) res[i]= this[i]*[1,1,-1,-1][grades[i]%4]; return res; };
      get Involute (){ var res = new this.constructor(); for (var i=0; i<this.length; i++) res[i]= this[i]*[1,-1,1,-1][grades[i]%4]; return res; };
      get Conjugate (){ var res = new this.constructor(); for (var i=0; i<this.length; i++) res[i]= this[i]*[1,-1,-1,1][grades[i]%4]; return res; };

    /// The Dual, Length, non-metric length and normalized getters.
      get Dual (){ if (r) return this.map((x,i,a)=>a[drm[i]]*drms[i]); var res = new this.constructor(); res[res.length-1]=1; return res.Mul(this); };
      get Length (){ return options.over?Math.sqrt(Math.abs(this.Mul(this.Conjugate).s.s)):Math.sqrt(Math.abs(this.Mul(this.Conjugate).s)); };
      get VLength (){ var res = 0; for (var i=0; i<this.length; i++) res += this[i]*this[i]; return Math.sqrt(res); };
      get Normalized (){ var res = new this.constructor(),l=this.Length; if (!l) return this; l=1/l; for (var i=0; i<this.length; i++) if (options.over) {res[i]=this[i].Scale(l);} else {res[i]=this[i]*l;} return res; };
    };

  /// Convert symbolic matrices to code. (skipping zero's on dot and wedge matrices).
  /// These all do straightforward string fiddling. If the 'mix' option is set they reference basis components using e.g. '.e1' instead of eg '[3]' .. so that
  /// it will work for elements of subalgebras etc.
    generator.prototype.Add   = new Function('b,res','res=res||new this.constructor();\n'+basis.map((x,xi)=>'res['+xi+']=b['+xi+']+this['+xi+']').join(';\n').replace(/(b|this)\[(.*?)\]/g,(a,b,c)=>options.mix?'('+b+'.'+(c|0?basis[c]:'s')+'||0)':a)+';\nreturn res');
    generator.prototype.Scale = new Function('b,res','res=res||new this.constructor();\n'+basis.map((x,xi)=>'res['+xi+']=b*this['+xi+']').join(';\n').replace(/(b|this)\[(.*?)\]/g,(a,b,c)=>options.mix?'('+b+'.'+(c|0?basis[c]:'s')+'||0)':a)+';\nreturn res');
    generator.prototype.Sub   = new Function('b,res','res=res||new this.constructor();\n'+basis.map((x,xi)=>'res['+xi+']=this['+xi+']-b['+xi+']').join(';\n').replace(/(b|this)\[(.*?)\]/g,(a,b,c)=>options.mix?'('+b+'.'+(c|0?basis[c]:'s')+'||0)':a)+';\nreturn res');
    generator.prototype.Mul   = new Function('b,res','res=res||new this.constructor();\n'+gp.map((r,ri)=>'res['+ri+']='+r.join('+').replace(/\+\-/g,'-').replace(/(\w*?)\[(.*?)\]/g,(a,b,c)=>options.mix?'('+b+'.'+(c|0?basis[c]:'s')+'||0)':a).replace(/\+0/g,'')+';').join('\n')+'\nreturn res;');
    generator.prototype.LDot  = new Function('b,res','res=res||new this.constructor();\n'+cp.map((r,ri)=>'res['+ri+']='+r.join('+').replace(/\+\-/g,'-').replace(/\+0/g,'').replace(/(\w*?)\[(.*?)\]/g,(a,b,c)=>options.mix?'('+b+'.'+(c|0?basis[c]:'s')+'||0)':a)+';').join('\n')+'\nreturn res;');
    generator.prototype.Dot   = new Function('b,res','res=res||new this.constructor();\n'+cps.map((r,ri)=>'res['+ri+']='+r.join('+').replace(/\+\-/g,'-').replace(/\+0/g,'').replace(/(\w*?)\[(.*?)\]/g,(a,b,c)=>options.mix?'('+b+'.'+(c|0?basis[c]:'s')+'||0)':a)+';').join('\n')+'\nreturn res;');
    generator.prototype.Wedge = new Function('b,res','res=res||new this.constructor();\n'+op.map((r,ri)=>'res['+ri+']='+r.join('+').replace(/\+\-/g,'-').replace(/\+0/g,'').replace(/(\w*?)\[(.*?)\]/g,(a,b,c)=>options.mix?'('+b+'.'+(c|0?basis[c]:'s')+'||0)':a)+';').join('\n')+'\nreturn res;');
//    generator.prototype.Vee   = new Function('b,res','res=res||new this.constructor();\n'+op.map((r,ri)=>'res['+drm[ri]+']='+r.map(x=>x.replace(/\[(.*?)\]/g,function(a,b){return '['+(drm[b|0])+']'})).join('+').replace(/\+\-/g,'-').replace(/\+0/g,'').replace(/(\w*?)\[(.*?)\]/g,(a,b,c)=>options.mix?'('+b+'.'+(c|0?basis[c]:'s')+'||0)':a)+';').join('\n')+'\nreturn res;');
  /// Conforms to the new Chapter 11 now.
    generator.prototype.Vee   = new Function('b,res',('res=res||new this.constructor();\n'+op.map((r,ri)=>'res['+drm[ri]+']='+drms[ri]+'*('+r.map(x=>x.replace(/\[(.*?)\]/g,function(a,b){return '['+(drm[b|0])+']'+(drms[b|0]>0?"":"*-1")})).join('+').replace(/\+\-/g,'-').replace(/\+0/g,'').replace(/(\w*?)\[(.*?)\]/g,(a,b,c)=>options.mix?'('+b+'.'+(c|0?basis[c]:'s')+'||0)':a)+');').join('\n')+'\nreturn res;').replace(/(b\[)|(this\[)/g,a=>a=='b['?'this[':'b['));

  /// Add getter and setters for the basis vectors/bivectors etc ..
    basis.forEach((b,i)=>Object.defineProperty(generator.prototype, i?b:'s', {
      configurable: true, get(){ return this[i] }, set(x){ this[i]=x; }
    }));

  /// Graded generator for high-dimensional algebras.
  } else {

  /// extra graded lookups.
    var basisg = grade_start.slice(0,grade_start.length-1).map((x,i)=>basis.slice(x,grade_start[i+1]));
    var counts = grade_start.map((x,i,a)=>i==a.length-1?0:a[i+1]-x).slice(0,tot+1);
    var basis_bits = basis.map(x=>x=='1'?0:x.slice(1).match(tot>9?/\d\d/g:/\d/g).reduce((a,b)=>a+(1<<(b-low)),0)),
        bits_basis = []; basis_bits.forEach((b,i)=>bits_basis[b]=i);
    var metric = basisg.map((x,xi)=>x.map((y,yi)=>simplify_bits(basis_bits[grade_start[xi]+yi],basis_bits[grade_start[xi]+yi])[0]));
    var drms   = basisg.map((x,xi)=>x.map((y,yi)=>simplify_bits(basis_bits[grade_start[xi]+yi],(~basis_bits[grade_start[xi]+yi])&((1<<tot)-1))[0]));

  /// Flat Algebra Multivector Base Class.
    var generator = class MultiVector extends Array {
    /// constructor - create a floating point array with the correct number of coefficients.
      constructor(a) { super(a||tot); return this; }

    /// grade selection - return a only the part of the input with the specified grade.
      Grade(grade,res) { res=new this.constructor(); res[grade] = this[grade]; return res; }

    /// grade creation - convert array with just one grade to full multivector.
      nVector(grade,...args) { this[grade]=args; return this; }

    /// Fill in coordinates (accepts sequence of index,value as arguments)
      Coeff() {
                for (var i=0,l=arguments.length; i<l; i+=2) if (arguments[i+1]) {
                 var gi = grades[arguments[i]];
                 if (this[gi]==undefined) this[gi]=[];
                 this[gi][arguments[i]-grade_start[gi]]=arguments[i+1];
                }
                return this;
              }

    /// Negates specific grades (passed in as args)
      Map(res, ...a) {  /* tbc */ }

    /// Returns the vector grade only.
      get Vector ()    { return this[1] };

    /// multivector addition, subtraction and scalar multiplication.
      Add(b,r) {
        r=r||new this.constructor();
        for (var i=0,l=Math.max(this.length,b.length);i<l;i++)
          if (!this[i] ^ !b[i]) r[i] = (!this[i]) ? b[i].slice():this[i].slice();
          else if (!(this[i]||b[i])) ;
          else { if (r[i]==undefined) r[i]=[]; for(var j=0,m=Math.max(this[i].length,b[i].length);j<m;j++)
          {
            if (typeof this[i][j]=="string" || typeof r[i][j]=="string" || typeof b[i][j]=="string") {
             if (!this[i][j]) r[i][j] = ""+b[i][j];
             else if (!b[i][j]) r[i][j] = ""+this[i][j];
             else r[i][j]="("+(this[i][j]||"0")+(b[i][j][0]=="-"?"":"+")+(b[i][j]||"0")+")";
            } else r[i][j]=(this[i][j]||0)+(b[i][j]||0);
          }}
        return r;
      }
      Sub(b,r) {
        r=r||new this.constructor();
        for (var i=0,l=Math.max(this.length,b.length);i<l;i++)
          if (!this[i] || !b[i]) r[i] = (!this[i]) ? (b[i]?b[i].map(x=>(typeof x=="string")?"-"+x:-x):undefined):this[i];
          else { if (r[i]==undefined) r[i]=[]; for(var j=0,m=Math.max(this[i].length,b[i].length);j<m;j++)
            if (typeof this[i][j]=="string" || typeof r[i][j]=="string" || typeof b[i][j]=="string") r[i][j]="("+(this[i][j]||"0")+"-"+(b[i][j]||"0")+")";
            else r[i][j]=(this[i][j]||0)-(b[i][j]||0);
          }
        return r;
      }
      Scale(s) { return this.map(x=>x&&x.map(y=>typeof y=="string"?y+"*"+s:y*s)); }

    // geometric product.
      Mul(b,r) {
        r=r||new this.constructor(); var gotstring=false;
        for (var i=0,x,gsx; gsx=grade_start[i],x=this[i],i<this.length; i++) if (x) for (var j=0,y,gsy;gsy=grade_start[j],y=b[j],j<b.length; j++) if (y) for (var a=0; a<x.length; a++) if (x[a]) for (var bb=0; bb<y.length; bb++) if (y[bb]) {
          if (i==j && a==bb) { r[0] = r[0]||(typeof x[0]=="string" || typeof y[bb]=="string"?[""]:[0]);
            if (typeof x[a]=="string" || typeof r[0][0]=="string" || typeof y[bb]=="string") {
            r[0][0] = (r[0][0]?(r[0][0]+(x[a][0]=="-"?"":"+")):"")+ x[a]+"*"+y[bb]+(metric[i][a]!=1?"*"+metric[i][a]:"");  gotstring=true;
            } else r[0][0] += x[a]*y[bb]*metric[i][a];
          } else {
             var rn=simplify_bits(basis_bits[gsx+a],basis_bits[gsy+bb]), g=bc(rn[1]), e=bits_basis[rn[1]]-grade_start[g];
             if (!r[g])r[g]=[];
               if (typeof r[g][e]=="string"||typeof x[a]=="string"||typeof y[bb]=="string") {
                 r[g][e] = (r[g][e]?r[g][e]+"+":"") + (rn[0]!=1?rn[0]==-1?"-":rn[0]+"*":"")+ x[a]+(y[bb]!=1?"*"+y[bb]:""); gotstring=true;
               } else r[g][e] = (r[g][e]||0) + rn[0]*x[a]*y[bb];
          }
        }
        if (gotstring) return r.map(g=>g.map(e=>e&&(!(e+'').match(/-{0,1}\w+/))?'('+e+')':e))
        return r;
      }
    // outer product.
      Wedge(b,r) {
        r=r||new this.constructor();
        for (var i=0,x,gsx; gsx=grade_start[i],x=this[i],i<this.length; i++) if (x) for (var j=0,y,gsy;gsy=grade_start[j],y=b[j],j<b.length; j++) if (y) for (var a=0; a<x.length; a++) if (x[a]) for (var bb=0; bb<y.length; bb++) if (y[bb]) {
          if (i!=j || a!=bb) {
             var n1=basis_bits[gsx+a], n2=basis_bits[gsy+bb], rn=simplify_bits(n1,n2,tot), g=bc(rn[1]), e=bits_basis[rn[1]]-grade_start[g];
             if (g == i+j) { if (!r[g]) r[g]=[]; r[g][e] = (r[g][e]||0) + rn[0]*x[a]*y[bb]; }
          }
        }
        return r;
      }
    // outer product glsl output.
      OPNS_GLSL(b,point_source) {
        var r='',count=0;
        for (var i=0,x,gsx; gsx=grade_start[i],x=this[i],i<this.length; i++) if (x) for (var j=0,y,gsy;gsy=grade_start[j],y=b[j],j<b.length; j++) if (y) for (var a=0; a<counts[i]; a++) for (var bb=0; bb<counts[j]; bb++) {
          if (i!=j || a!=bb) {
             var n1=basis_bits[gsx+a], n2=basis_bits[gsy+bb], rn=simplify_bits(n1,n2,tot), g=bc(rn[1]), e=bits_basis[rn[1]]-grade_start[g];
             if (g == i+j) { r += `res[${e}]${rn[0]=='1'?"+=":"-="}(${(point_source[a]+'').replace(/1([^.\d])|1$/g,"1.0$1")})*b[${bb}]; //${count++}\n`;  }
          }
        }
        r=r.split('\n').filter(x=>x).sort((a,b)=>((a.match(/\d+/)[0]|0)-(b.match(/\d+/)[0]|0))||((a.match(/\d+$/)[0]|0)-(b.match(/\d+$/)[0]|0))).map(x=>x.replace(/\/\/\d+$/,''));
        var r2 = 'float sum=0.0; float res=0.0;\n', g=0;
        r.forEach(x=>{
          var cg = x.match(/\d+/)[0]|0;
          if (cg != g) r2 += "sum += res*res;\nres = 0.0;\n";
          r2 += x.replace(/\[\d+\]/,'') + '\n';
          g=cg;
        });
        r2+= "sum += res*res;\n";
        return r2;
      }
    // Inner product glsl output.
      IPNS_GLSL(b,point_source) {
        var r='',count=0;
        for (var i=0,x,gsx; gsx=grade_start[i],x=this[i],i<this.length; i++) if (x) for (var j=0,y,gsy;gsy=grade_start[j],y=b[j],j<b.length; j++) if (y) for (var a=0; a<counts[i]; a++) for (var bb=0; bb<counts[j]; bb++) {
           var n1=basis_bits[gsx+a], n2=basis_bits[gsy+bb], rn=simplify_bits(n1,n2,tot), g=bc(rn[1]), e=bits_basis[rn[1]]-grade_start[g];
           if (g == Math.abs(i-j) && point_source[a]) { r += `res[${e}]${rn[0]=='1'?"+=":"-="}(${(point_source[a]+'').replace(/1([^.\d])|1$/g,"1.0$1")})*b[${bb}]; //${count++}\n`;  }
        }
        r=r.split('\n').filter(x=>x).sort((a,b)=>((a.match(/\d+/)[0]|0)-(b.match(/\d+/)[0]|0))||((a.match(/\d+$/)[0]|0)-(b.match(/\d+$/)[0]|0))).map(x=>x.replace(/\/\/\d+$/,''));
        var r2 = 'float sum=0.0; float res=0.0;\n', g=0;
        r.forEach(x=>{
          var cg = x.match(/\d+/)[0]|0;
          if (cg != g) r2 += "sum += res*res;\nres = 0.0;\n";
          r2 += x.replace(/\[\d+\]/,'') + '\n';
          g=cg;
        });
        r2+= "sum += res*res;\n";
        return r2;
      }
    // Left contraction.
      LDot(b,r) {
        r=r||new this.constructor();
        for (var i=0,x,gsx; gsx=grade_start[i],x=this[i],i<this.length; i++) if (x) for (var j=0,y,gsy;gsy=grade_start[j],y=b[j],j<b.length; j++) if (y) for (var a=0; a<x.length; a++) if (x[a]) for (var bb=0; bb<y.length; bb++) if (y[bb]) {
          if (i==j && a==bb) { r[0] = r[0]||[0]; r[0][0] += x[a]*y[bb]*metric[i][a]; }
          else {
             var rn=simplify_bits(basis_bits[gsx+a],basis_bits[gsy+bb]), g=bc(rn[1]), e=bits_basis[rn[1]]-grade_start[g];
             if (g == j-i) { if (!r[g])r[g]=[]; r[g][e] = (r[g][e]||0) + rn[0]*x[a]*y[bb]; }
          }
        }
        return r;
      }
    // Symmetric contraction.
      Dot(b,r) {
        r=r||new this.constructor();
        for (var i=0,x,gsx; gsx=grade_start[i],x=this[i],i<this.length; i++) if (x) for (var j=0,y,gsy;gsy=grade_start[j],y=b[j],j<b.length; j++) if (y) for (var a=0; a<x.length; a++) if (x[a]) for (var bb=0; bb<y.length; bb++) if (y[bb]) {
          if (i==j && a==bb) { r[0] = r[0]||[0]; r[0][0] += x[a]*y[bb]*metric[i][a]; }
          else {
             var rn=simplify_bits(basis_bits[gsx+a],basis_bits[gsy+bb]), g=bc(rn[1]), e=bits_basis[rn[1]]-grade_start[g];
             if (g == Math.abs(j-i)) { if (!r[g])r[g]=[]; r[g][e] = (r[g][e]||0) + rn[0]*x[a]*y[bb]; }
          }
        }
        return r;
      }
    // Should be optimized..
      Vee(b,r)          { return (this.Dual.Wedge(b.Dual)).Dual; }
    // Output, lengths, involutions, normalized, dual.
      toString()        { return [...this].map((g,gi)=>g&&g.map((c,ci)=>!c?undefined:((c+'').match(/[\+\-\*]/)?'('+c+')':c)+(gi==0?"":basisg[gi][ci])).filter(x=>x).join('+')).filter(x=>x).join('+').replace(/\+\-/g,'-')||"0"; }
      get s ()          { if (this[0]) return this[0][0]||0; return 0; }
      get Length ()     { var res=0; this.forEach((g,gi)=>g&&g.forEach((e,ei)=>res+=(e||0)**2*metric[gi][ei])); return Math.abs(res)**.5; }
      get VLength ()    { var res=0; this.forEach((g,gi)=>g&&g.forEach((e,ei)=>res+=(e||0)**2)); return Math.abs(res)**.5; }
      get Reverse ()    { var r=new this.constructor(); this.forEach((x,gi)=>x&&x.forEach((e,ei)=>{if(!r[gi])r[gi]=[]; r[gi][ei] = this[gi][ei]*[1,1,-1,-1][gi%4]; })); return r; }
      get Involute ()   { var r=new this.constructor(); this.forEach((x,gi)=>x&&x.forEach((e,ei)=>{if(!r[gi])r[gi]=[]; r[gi][ei] = this[gi][ei]*[1,-1,1,-1][gi%4]; })); return r; }
      get Conjugate ()  { var r=new this.constructor(); this.forEach((x,gi)=>x&&x.forEach((e,ei)=>{if(!r[gi])r[gi]=[]; r[gi][ei] = this[gi][ei]*[1,-1,-1,1][gi%4]; })); return r; }
      get Dual()        { var r=new this.constructor(); this.forEach((g,gi)=>{ if (!g) return; r[tot-gi]=[]; g.forEach((e,ei)=>r[tot-gi][counts[gi]-1-ei]=drms[gi][ei]*e); }); return r; }
      get Normalized () { return this.Scale(1/this.Length); }
    };


   // This generator is UNDER DEVELOPMENT - I'm publishing it so I can test on observable.
  }

  // Generate a new class for our algebra. It extends the javascript typed arrays (default float32 but can be specified in options).
    var res = class Element extends generator {

    // constructor - create a floating point array with the correct number of coefficients.
      constructor(a) { super(a); if (this.upgrade) this.upgrade(); return this; }

    // Grade selection. (implemented by parent class).
      Grade(grade,res) { res=res||new Element(); return super.Grade(grade,res); }

    // Right and Left divide - Defined on the elements, shortcuts to multiplying with the inverse.
      Div  (b,res) { return this.Mul(b.Inverse,res); }
      LDiv (b,res) { return b.Inverse.Mul(this,res); }

    // Taylor exp - for PGA bivectors in 2D and 3D closed form solution is used.
      Exp  ()      {
        if (options.dual) { var f=Math.exp(this.s); return this.map((x,i)=>i?x*f:f); }
        if (r==1 && tot<=4 && Math.abs(this[0])<1E-9 && !options.over) {
           var u = Math.sqrt(Math.abs(this.Dot(this).s)); if (Math.abs(u)<1E-5) return this.Add(Element.Scalar(1));
           var v = this.Wedge(this).Scale(-1/(2*u));
           var res2 = Element.Add(Element.Sub(Math.cos(u),v.Scale(Math.sin(u))),Element.Div(Element.Mul((Element.Add(Math.sin(u),v.Scale(Math.cos(u)))),this),(Element.Add(u,v))));
           return res2;
        }
        var res = Element.Scalar(1), y=1, M= this.Scale(1), N=this.Scale(1); for (var x=1; x<15; x++) { res=res.Add(M.Scale(1/y)); M=M.Mul(N); y=y*(x+1); } return res;
      }

    // Log - only for up to 3D PGA for now
      Log () {
        if (tot>5 || options.over) return;
        var b = this.Grade(2), bdb = Element.Dot(b,b).s;
        if (Math.abs(bdb)<=1E-5) return this.s<0?b.Scale(-1):b;
        var s = Math.sqrt(-bdb), bwb = Element.Wedge(b,b);
        if (Math.abs(bwb[bwb.length-1])<=1E-5 || Math.abs(this.s)<=1E-5) return b.Scale(Math.atan2(s,this.s)/s);
        var p = bwb.Scale(-1/(2*s));
        return Element.Mul(Element.Mul((Element.Add(Math.atan2(s,this.s),p.Scale(1/this.s))),b),Element.Sub(s,p)).Scale(1/(s*s));
      }

    // Helper for efficient inverses. (custom involutions - negates grades in arguments).
      Map () { var res=new Element(); return super.Map(res,...arguments); }

    // Factories - Make it easy to generate vectors, bivectors, etc when using the functional API. None of the examples use this but
    // users that have used other GA libraries will expect these calls. The Coeff() is used internally when translating algebraic literals.
      static Element()   { return new Element([...arguments]); };
      static Coeff()     { return (new Element()).Coeff(...arguments); }
      static Scalar(x)   { return (new Element()).Coeff(0,x); }
      static Vector()    { return (new Element()).nVector(1,...arguments); }
      static Bivector()  { return (new Element()).nVector(2,...arguments); }
      static Trivector() { return (new Element()).nVector(3,...arguments); }
      static nVector(n)  { return (new Element()).nVector(...arguments); }

    // Static operators. The parser will always translate operators to these static calls so that scalars, vectors, matrices and other non-multivectors can also be handled.
    // The static operators typically handle functions and matrices, calling through to element methods for multivectors. They are intended to be flexible and allow as many
    // types of arguments as possible. If performance is a consideration, one should use the generated element methods instead. (which only accept multivector arguments)
      static toEl(x)        { if (x instanceof Function) x=x(); if (!(x instanceof Element)) x=Element.Scalar(x); return x; }

    // Addition and subtraction. Subtraction with only one parameter is negation.
      static Add(a,b,res)   {
      // Resolve expressions passed in.
        while(a.call)a=a(); while(b.call)b=b(); if (a.Add && b.Add) return a.Add(b,res);
      // If either is a string, the result is a string.
        if ((typeof a=='string')||(typeof b=='string')) return a.toString()+b.toString();
      // If only one is an array, add the other element to each of the elements.
        if ((a instanceof Array && !a.Add)^(b instanceof Array && !b.Add)) return (a instanceof Array)?a.map(x=>Element.Add(x,b)):b.map(x=>Element.Add(a,x));
      // If both are equal length arrays, add elements one-by-one
        if ((a instanceof Array)&&(b instanceof Array)&&a.length==b.length) return a.map((x,xi)=>Element.Add(x,b[xi]));
      // If they're both not elements let javascript resolve it.
        if (!(a instanceof Element || b instanceof Element)) return a+b;
      // Here we're left with scalars and multivectors, call through to generated code.
        a=Element.toEl(a); b=Element.toEl(b); return a.Add(b,res);
      }

      static Sub(a,b,res)   {
      // Resolve expressions passed in.
        while(a.call)a=a(); while(b&&b.call) b=b(); if (a.Sub && b && b.Sub) return a.Sub(b,res);
      // If only one is an array, add the other element to each of the elements.
        if (b&&((a instanceof Array)^(b instanceof Array))) return (a instanceof Array)?a.map(x=>Element.Sub(x,b)):b.map(x=>Element.Sub(a,x));
      // If both are equal length arrays, add elements one-by-one
        if (b&&(a instanceof Array)&&(b instanceof Array)&&a.length==b.length) return a.map((x,xi)=>Element.Sub(x,b[xi]));
      // Negation
        if (arguments.length==1) return Element.Mul(a,-1);
      // If none are elements here, let js do it.
        if (!(a instanceof Element || b instanceof Element)) return a-b;
      // Here we're left with scalars and multivectors, call through to generated code.
        a=Element.toEl(a); b=Element.toEl(b); return a.Sub(b,res);
      }

    // The geometric product. (or matrix*matrix, matrix*vector, vector*vector product if called with 1D and 2D arrays)
      static Mul(a,b,res)   {
      // Resolve expressions
        while(a.call&&!a.length)a=a(); while(b.call&&!b.length)b=b(); if (a.Mul && b.Mul) return a.Mul(b,res);
      // still functions -> experimental curry style (dont use this.)
        if (a.call && b.call) return (ai,bi)=>Element.Mul(a(ai),b(bi));
      // scalar mul.
        if (Number.isFinite(a) && b.Scale) return b.Scale(a); else if (Number.isFinite(b) && a.Scale) return a.Scale(b);
      // Handle matrices and vectors.
        if ((a instanceof Array)&&(b instanceof Array)) {
        // vector times vector performs a dot product. (which internally uses the GP on each component)
          if((!(a[0] instanceof Array) || (a[0] instanceof Element)) &&(!(b[0] instanceof Array) || (b[0] instanceof Element))) { var r=tot?Element.Scalar(0):0; a.forEach((x,i)=>r=Element.Add(r,Element.Mul(x,b[i]),r)); return r; }
        // Array times vector
          if(!(b[0] instanceof Array)) return a.map((x,i)=>Element.Mul(a[i],b));
        // Array times Array
          var r=a.map((x,i)=>b[0].map((y,j)=>{ var r=tot?Element.Scalar(0):0; x.forEach((xa,k)=>r=Element.Add(r,Element.Mul(xa,b[k][j]))); return r; }));
        // Return resulting array or scalar if 1 by 1.
          if (r.length==1 && r[0].length==1) return r[0][0]; else return r;
        }
      // Only one is an array multiply each of its elements with the other.
        if ((a instanceof Array)^(b instanceof Array)) return (a instanceof Array)?a.map(x=>Element.Mul(x,b)):b.map(x=>Element.Mul(a,x));
      // Try js multiplication, else call through to geometric product.
        var r=a*b; if (!isNaN(r)) return r;
        a=Element.toEl(a); b=Element.toEl(b); return a.Mul(b,res);
      }

    // The inner product. (default is left contraction).
      static LDot(a,b,res)   {
      // Expressions
        while(a.call)a=a(); while(b.call)b=b(); //if (a.LDot) return a.LDot(b,res);
      // Map elements in array
        if (b instanceof Array && !(a instanceof Array)) return b.map(x=>Element.LDot(a,x));
        if (a instanceof Array && !(b instanceof Array)) return a.map(x=>Element.LDot(x,b));
      // js if numbers, else contraction product.
        if (!(a instanceof Element || b instanceof Element)) return a*b;
        a=Element.toEl(a);b=Element.toEl(b); return a.LDot(b,res);
      }

    // The symmetric inner product. (default is left contraction).
      static Dot(a,b,res)   {
      // Expressions
        while(a.call)a=a(); while(b.call)b=b(); //if (a.LDot) return a.LDot(b,res);
      // js if numbers, else contraction product.
        if (!(a instanceof Element || b instanceof Element)) return a|b;
        a=Element.toEl(a);b=Element.toEl(b); return a.Dot(b,res);
      }

    // The outer product. (Grassman product - no use of metric)
      static Wedge(a,b,res) {
      // normal behavior for booleans/numbers
        if (typeof a in {boolean:1,number:1} && typeof b in {boolean:1,number:1}) return a^b;
      // Expressions
        while(a.call)a=a(); while(b.call)b=b(); if (a.Wedge) return a.Wedge(Element.toEl(b),res);
      // The outer product of two vectors is a matrix .. internally Mul not Wedge !
        if (a instanceof Array && b instanceof Array) return a.map(xa=>b.map(xb=>Element.Mul(xa,xb)));
      // js, else generated wedge product.
        if (!(a instanceof Element || b instanceof Element)) return a*b;
        a=Element.toEl(a);b=Element.toEl(b); return a.Wedge(b,res);
      }

    // The regressive product. (Dual of the outer product of the duals).
      static Vee(a,b,res) {
      // normal behavior for booleans/numbers
        if (typeof a in {boolean:1,number:1} && typeof b in {boolean:1,number:1}) return a&b;
      // Expressions
        while(a.call)a=a(); while(b.call)b=b(); if (a.Vee) return a.Vee(Element.toEl(b),res);
      // js, else generated vee product. (shortcut for dual of wedge of duals)
        if (!(a instanceof Element || b instanceof Element)) return 0;
        a=Element.toEl(a);b=Element.toEl(b); return a.Vee(b,res);
      }

    // The sandwich product. Provided for convenience (>>> operator)
      static sw(a,b) {
      // Skip strings/colors
        if (typeof b == "string" || typeof b =="number") return b;
      // Expressions
        while(a.call)a=a(); while(b.call)b=b(); if (a.sw) return a.sw(b);
      // Map elements in array
        if (b instanceof Array && !b.Add) return b.map(x=>Element.sw(a,x));
      // Call through. no specific generated code for it so just perform the muls.
        a=Element.toEl(a); b=Element.toEl(b); return a.Mul(b).Mul(a.Reverse);
      }

    // Division - scalars or cal through to element method.
      static Div(a,b,res) {
      // Expressions
        while(a.call)a=a(); while(b.call)b=b();
      // For DDG experiments, I'll include a quick cholesky on matrices here. (vector/matrix)
        if ((a instanceof Array) && (b instanceof Array) && (b[0] instanceof Array)) {
          // factor
          var R = b.flat(), i, j, k, sum, i_n, j_n, n=b[0].length, s=new Array(n), x=new Array(n);
          for (i=0;i<n;i++) { i_n = i*n;
            for (j=0; j<i; j++) { j_n=j*n;
              s[j] = R[i_n+j];
              for (k=0;k<j;k++) s[j] -= s[k]*R[j_n+k];
              if (R[j_n+j] == 0) return null;
              R[i_n+j] = s[j]/R[j_n+j];
            }
            sum = R[i_n+i];
            for (k=0;k<i; k++)  sum -= s[k]*R[i_n+k];
            R[i_n+i] = sum;
          }
          // subst
          for (i=0; i<n; i++) for (x[i]=a[i],j=0;j<=i-1;j++) x[i]-=R[i*n+j]*x[j];
          for (i=n-1; i>=0; i--) for (x[i] /= R[i*n+i], j=i+1; j<n; j++) x[i] -= R[j*n+i]*x[j];
          return x;
        }
      // js or call through to element divide.
        if (!(a instanceof Element || b instanceof Element)) return a/b;
        a=Element.toEl(a);
        if (Number.isFinite(b)) { return a.Scale(1/b,res); }
        b=Element.toEl(b); return a.Div(b,res);
      }

    // Pow - needs obvious extensions for natural powers. (exponentiation by squaring)
      static Pow(a,b,res) {
      // Expressions
        while(a.call)a=a(); while(b.call)b=b(); if (a.Pow) return a.Pow(b,res);
      // Exponentiation.
        if (a===Math.E && b.Exp) return b.Exp();
      // Squaring
        if (b===2) return this.Mul(a,a,res);
      // No elements, call through to js
        if (!(a instanceof Element || b instanceof Element)) return a**b;
      // Inverse
        if (b===-1) return a.Inverse;
      // Call through to element pow.
        a=Element.toEl(a); return a.Pow(b);
      }

    // Handles scalars and calls through to element method.
      static exp(a) {
      // Expressions.
        while(a.call)a=a();
      // If it has an exp callthrough, use it, else call through to math.
        if (a.Exp) return a.Exp();
        return Math.exp(a);
      }

    // Dual, Involute, Reverse, Conjugate, Normalize and length, all direct call through. Conjugate handles matrices.
      static Dual(a)      { if (typeof a=='boolean' || typeof a=='number') return !a; return Element.toEl(a).Dual; };
      static Involute(a)  { return Element.toEl(a).Involute; };
      static Reverse(a)   { return Element.toEl(a).Reverse; };
      static Conjugate(a) { if (a.Conjugate) return a.Conjugate; if (a instanceof Array) return a[0].map((c,ci)=>a.map((r,ri)=>Element.Conjugate(a[ri][ci]))); return Element.toEl(a).Conjugate; }
      static Normalize(a) { return Element.toEl(a).Normalized; };
      static Length(a)    { return Element.toEl(a).Length };

    // Comparison operators always use length. Handle expressions, then js or length comparison
      static eq(a,b)  { if (!(a instanceof Element)||!(b instanceof Element)) return a==b; while(a.call)a=a(); while(b.call)b=b(); for (var i=0; i<a.length; i++) if (a[i]!=b[i]) return false; return true; }
      static neq(a,b) { if (!(a instanceof Element)||!(b instanceof Element)) return a!=b; while(a.call)a=a(); while(b.call)b=b(); for (var i=0; i<a.length; i++) if (a[i]!=b[i]) return true; return false; }
      static lt(a,b)  { while(a.call)a=a(); while(b.call)b=b(); return (a instanceof Element?a.Length:a)<(b instanceof Element?b.Length:b); }
      static gt(a,b)  { while(a.call)a=a(); while(b.call)b=b(); return (a instanceof Element?a.Length:a)>(b instanceof Element?b.Length:b); }
      static lte(a,b) { while(a.call)a=a(); while(b.call)b=b(); return (a instanceof Element?a.Length:a)<=(b instanceof Element?b.Length:b); }
      static gte(a,b) { while(a.call)a=a(); while(b.call)b=b(); return (a instanceof Element?a.Length:a)>=(b instanceof Element?b.Length:b); }

    // Debug output and printing multivectors.
      static describe(x) { if (x===true) console.log(`Basis\n${basis}\nMetric\n${metric.slice(1,1+tot)}\nCayley\n${mulTable.map(x=>(x.map(x=>('           '+x).slice(-2-tot)))).join('\n')}\nMatrix Form:\n`+gp.map(x=>x.map(x=>x.match(/(-*b\[\d+\])/)).map(x=>x&&((x[1].match(/-/)||' ')+String.fromCharCode(65+1*x[1].match(/\d+/)))||' 0')).join('\n')); return {basis:basisg||basis,metric,mulTable,matrix:gp.map(x=>x.map(x=>x.replace(/\*this\[.+\]/,'').replace(/b\[(\d+)\]/,(a,x)=>(metric[x]==-1||metric[x]==0&&grades[x]>1&&(-1)**grades[x]==(metric[basis.indexOf(basis[x].replace('0',''))]||(-1)**grades[x])?'-':'')+basis[x]).replace('--','')))} }

    // Direct sum of algebras - experimental
      static sum(B){
        var A = Element;
        // Get the multiplication tabe and basis.
        var T1 = A.describe().mulTable, T2 = B.describe().mulTable;
        var B1 = A.describe().basis, B2 = B.describe().basis;
        // Get the maximum index of T1, minimum of T2 and rename T2 if needed.
        var max_T1 = B1.filter(x=>x.match(/e/)).map(x=>x.match(/\d/g)).flat().map(x=>x|0).sort((a,b)=>b-a)[0];
        var max_T2 = B2.filter(x=>x.match(/e/)).map(x=>x.match(/\d/g)).flat().map(x=>x|0).sort((a,b)=>b-a)[0];
        B2.filter(x=>x.match(/e/)).map(x=>x.match(/\d/g)).flat().map(x=>x|0).sort((a,b)=>a-b)[0];
        // remapping ..
        T2 = T2.map(x=>x.map(y=>y.match(/e/)?y.replace(/(\d)/g,(x)=>(x|0)+max_T1):y.replace("1","e"+(1+max_T2+max_T1))));
        B2 = B2.map((y,i)=>i==0?y.replace("1","e"+(1+max_T2+max_T1)):y.replace(/(\d)/g,(x)=>(x|0)+max_T1));
        // Build the new basis and multable..
        var basis = [...B1,...B2];
        var Cayley = T1.map((x,i)=>[...x,...T2[0].map(x=>"0")]).concat(T2.map((x,i)=>[...T1[0].map(x=>"0"),...x]));
        // Build the new algebra.
        var grades = [...B1.map(x=>x=="1"?0:x.length-1),...B2.map((x,i)=>i?x.length-1:0)];
        var a = Algebra({basis,Cayley,grades,tot:Math.log2(B1.length)+Math.log2(B2.length)});
        // And patch up ..
        a.Scalar = function(x) {
          var res = new a();
          for (var i=0; i<res.length; i++) res[i] = basis[i] == Cayley[i][i] ? x:0;
          return res;
        };
        return a;
      }

    // The graphing function supports several modes. It can render 1D functions and 2D functions on canvas, and PGA2D, PGA3D and CGA2D functions using SVG.
    // It handles animation and interactivity.
    //   graph(function(x))     => function of 1 parameter will be called with that parameter from -1 to 1 and graphed on a canvas. Returned values should also be in the [-1 1] range
    //   graph(function(x,y))   => functions of 2 parameters will be called from -1 to 1 on both arguments. Returned values can be 0-1 for greyscale or an array of three RGB values.
    //   graph(array)           => array of algebraic elements (points, lines, circles, segments, texts, colors, ..) is graphed.
    //   graph(function=>array) => same as above, for animation scenario's this function is called each frame.
    // An optional second parameter is an options object { width, height, animate, camera, scale, grid, canvas }
      static graph(f,options) {
      // Store the original input
        if (!f) return; var origf=f;
      // generate default options.
        options=options||{}; options.scale=options.scale||1; options.camera=options.camera||(tot!=4?Element.Scalar(1): ( Element.Bivector(0,0,0,0,0,options.p||0).Exp() ).Mul( Element.Bivector(0,0,0,0,options.h||0,0).Exp()) );
        if (options.conformal && tot==4) var ni = options.ni||this.Coeff(4,1,3,1), no = options.no||this.Coeff(4,0.5,3,-0.5), minus_no = no.Scale(-1);
        var ww=options.width, hh=options.height, cvs=options.canvas, tpcam=new Element([0,0,0,0,0,0,0,0,0,0,0,-5,0,0,1,0]),tpy=this.Coeff(4,1);new Element();
      var // project 3D to 2D. This allows to render 3D and 2D PGA with the same code.
        project=(o)=>{ if (!o) return o; while (o.call) o=o();
//          if (o instanceof Element && o.length == 32) o = new Element([o[0],o[1],o[2],o[3],o[4],o[6],o[7],o[8],o[10],o[11],o[13],o[16],o[17],o[19],o[22],o[26]]);
          // Clip 3D lines so they don't go past infinity.
          if (o instanceof Element && o.length == 16 && o[8]**2+o[9]**2+o[10]**2>0.0001) {
            o = [[options.clip||2,1,0,0],[-(options.clip||2),1,0,0],[options.clip||2,0,1,0],[-(options.clip||2),0,1,0],[options.clip||2,0,0,1],[-(options.clip||2),0,0,1]].map(v=>{
              var r = Element.Vector(...v).Wedge(o); return r[14]?r.Scale(1/r[14], r):undefined;
            }).filter(x=>x && Math.abs(x[13])<= (options.clip||2)+0.001 && Math.abs(x[12]) <= (options.clip||2)+0.001 && Math.abs(x[11]) <= (options.clip||2) + 0.001);
            return o.map(o=>(tpcam).Vee(options.camera.Mul(o).Mul(options.camera.Conjugate)).Wedge(tpy));
          }
          // Convert 3D planes to polies.
          if (o instanceof Element && o.length == 16 && o.Grade(1).Length>0.01) {
            var m = Element.Add(1, Element.Mul(o.Normalized, Element.Coeff(3,1))).Normalized, e0 = 0;
            o=Element.sw(m,[[-1,-1],[-1,1],[1,1],[-1,-1],[1,1],[1,-1]].map(([x,z])=>Element.Trivector(x*o.Length,e0,z*o.Length,1)));
            return o.map(o=>(tpcam).Vee(options.camera.Mul(o).Mul(options.camera.Conjugate)).Wedge(tpy));
          }
          return (tot==4 && o instanceof Element && o.length==16)?(tpcam).Vee(options.camera.Mul(o).Mul(options.camera.Conjugate)).Wedge(tpy):(o.length==2**tot)?Element.sw(options.camera,o):o;
        };
      // gl escape.
        if (options.gl && !(tot==4 && options.conformal)) return Element.graphGL(f,options); if (options.up) return Element.graphGL2(f,options);
      // if we get an array or function without parameters, we render c2d or p2d SVG points/lines/circles/etc
        if (!(f instanceof Function) || f.length===0) {
        // Our current cursor, color, animation state and 2D mapping.
          var lx,ly,lr,color,res,anim=false,to2d=(tot==5)?[0, 8, 11, 13, 19, 17, 22, 26]:(tot==3)?[0,1,2,3,4,5,6,7]:[0,7,9,10,13,12,14,15];
        // Make sure we have an array of elements. (if its an object, convert to array with elements and names.)
          if (f instanceof Function) f=f(); if (!(f instanceof Array)) f=[].concat.apply([],Object.keys(f).map((k)=>typeof f[k]=='number'?[f[k]]:[f[k],k]));
        // The build function generates the actual SVG. It will be called everytime the user interacts or the anim flag is set.
          function build(f,or) {
          // Make sure we have an aray.
            if (or && f && f instanceof Function) f=f();
          // Reset position and color for cursor.
            lx=-2;ly=options.conformal?-1.85:1.85;lr=0;color='#444';
          // Create the svg element. (master template string till end of function)
            var svg=new DOMParser().parseFromString(`<SVG viewBox="-2 -${2*(hh/ww||1)} 4 ${4*(hh/ww||1)}" style="width:${ww||512}px; height:${hh||512}px; background-color:#eee; -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; user-select:none">
            ${// Add a grid (option)
              options.grid?(()=>{
                if (tot==4 && !options.conformal) {
                  const lines3d = (n,from,to,j,l=0, ox=0, oy=0, alpha=1)=>[`<G stroke-opacity="${alpha}" fill-opacity="${alpha}">`,...[...Array(n+1)].map((x,i)=>{
                    var f=from.map((x,i)=>x*(i==3?1:(options.gridSize||1))), t=to.map((x,i)=>x*(i==3?1:(options.gridSize||1))); f[j] = t[j] = (i-(n/2))/(n/2) * (options.gridSize||1);
                    var D3a = Element.Trivector(...f), D2a = project(D3a), D3b = Element.Trivector(...t), D2b = project(D3b);
                    var lx=options.scale*D2a[drm[2]]/D2a[drm[1]]; if (drm[1]==6||drm[1]==14) lx*=-1; var ly=-options.scale*D2a[drm[3]]/D2a[drm[1]];
                    var lx2=options.scale*D2b[drm[2]]/D2b[drm[1]]; if (drm[1]==6||drm[1]==14) lx2*=-1; var ly2=-options.scale*D2b[drm[3]]/D2b[drm[1]];
                    var r = `<line x1="${lx}" y1="${ly}" x2="${lx2}" y2="${ly2}" stroke="black" stroke-width="${i%10==0?0.005:i%5==0?0.002:0.0005}" />`;
                    if (l && i && i!= n) r += `<text text-anchor="middle" font-size="0.04" fill="black" x="${l==1?lx+ox:lx2+ox}" y="${oy+(l==1?ly:ly2)}" >${((from[j]<0?-1:1)*(i-(n/2))/(n/2)*(options.gridSize||1)).toFixed(1)}</text>`;
                    return r;
                  }),'</G>'];
                  var front = Element.sw(options.camera,Element.Trivector(1,0,0,0)).Dual.Dot(Element.Vector(0,0,0,1)).s, ff = front>0?1:-1;
                  var left  = Element.sw(options.camera,Element.Trivector(0,0,1,0)).Dual.Dot(Element.Vector(0,0,0,1)).s, ll = left>0?1:-1;
                  var fa = Math.max(0,Math.min(1,5*Math.abs(left))), la = Math.max(0,Math.min(1,5*Math.abs(front)));
                  return [
                    ...lines3d(20,[-1,-1,-1,1],[1,-1,1,1],2,options.labels?ff:0, 0, 0.05),
                    ...lines3d(20,[-1,-1,-1,1],[1,-1,1,1],0,options.labels?ll:0, 0, 0.05),
                    ...lines3d(20,[-1,-1,ll,1],[1,1,ll,1],0,0,0,0,fa),
                    ...lines3d(20,[-1,1,ll,1],[1,-1,ll,1],1,!options.labels?0:(ff!=-1)?1:2, ll*ff*-0.05, 0, fa),
                    ...lines3d(20,[ff,1,-1,1],[ff,-1,1,1],1,!options.labels?0:(ll!=-1)?1:2, ll*ff*0.05, 0, la),
                    ...lines3d(20,[ff,-1,-1,1],[ff,1,1,1],2,0,0,0,la),
                  ].join('');
                }
                const s = options.scale, n = (10/s)|0, cx = options.camera.e02, cy = options.camera.e01, alpha = Math.min(1,(s-0.2)*10); if (options.scale<0.1) return;
                const lines = (n,dir,space,width,color)=>[...Array(2*n+1)].map((x,xi)=>`<line x1="${dir?-10:((xi-n)*space-(tot<4?2*cy:0))*s}" y1="${dir?((xi-n)*space-(tot<4?2*cx:0))*s:-10}" x2="${dir?10:((xi-n)*space-(tot<4?2*cy:0))*s}" y2="${dir?((xi-n)*space-(tot<4?2*cx:0))*s:10}" stroke-width="${width}" stroke="${color}"/>`);
                return [`<G stroke-opacity='${alpha}' fill-opacity='${alpha}'>`,...lines(n*2,0,0.2,0.005,'#DDD'),...lines(n*2,1,0.2,0.005,'#DDD'),...lines(n,0,1,0.005,'#AAA'),...lines(n,1,1,0.005,'#AAA'),...lines(n,0,5,0.005,'#444'),...lines(n,1,5,0.005,'#444')]
                       .concat(options.labels?[...Array(4*n+1)].map((x,xi)=>(xi-n*2==0)?``:`<text text-anchor="middle" font-size="0.05" x="${((xi-n*2)*0.2-(tot<4?2*cy:0))*s}" y="0.06" >${((xi-n*2)*0.2).toFixed(1)}</text>`):[])
                       .concat(options.labels?[...Array(4*n+1)].map((x,xi)=>`<text text-anchor="end" font-size="0.05" y="${((xi-n*2)*0.2-(tot<4?2*cx:0))*s-0.01}" x="-0.01" >${((xi-n*2)*-0.2).toFixed(1)}</text>`):[]).join('')+'</G>';
            })():''}
            // Handle conformal 2D elements.
            ${options.conformal?f.map&&f.map((o,oidx)=>{
            // Optional animation handling.
              if((o==Element.graph && or!==false)||(oidx==0&&options.animate&&or!==false)) { anim=true; requestAnimationFrame(()=>{var r=build(origf,(!res)||(document.body.contains(res))).innerHTML; if (res) res.innerHTML=r; }); if (!options.animate) return; }
            // Resolve expressions passed in.
              while (o.call) o=o();
              if (options.ipns && o instanceof Element) o = o.Dual;
              var sc = options.scale;
              var lineWidth = options.lineWidth || 1;
              var pointRadius = options.pointRadius || 1;
              var dash_for_r2 = (r2, render_r, target_width) => {
                // imaginary circles are dotted
                if (r2 >= 0) return 'none';
                var half_circum = render_r*Math.PI;
                var width = half_circum / Math.max(Math.round(half_circum / target_width), 1);
                return `${width} ${width}`;
              };
            // Arrays are rendered as segments or polygons. (2 or more elements)
              if (o instanceof Array)  { lx=ly=lr=0; o=o.map(o=>{ while(o.call)o=o(); return o.Scale(-1/o.Dot(ni).s); }); o.forEach((o)=>{lx+=sc*(o.e1);ly+=sc*(-o.e2);});lx/=o.length;ly/=o.length; return o.length>2?`<POLYGON STYLE="pointer-events:none; fill:${color};opacity:0.7" points="${o.map(o=>(sc*o.e1+','+(-o.e2*sc)+' '))}"/>`:`<LINE style="pointer-events:none" x1=${o[0].e1*sc} y1=${-o[0].e2*sc} x2=${o[1].e1*sc} y2=${-o[1].e2*sc} stroke="${color||'#888'}"/>`; }
            // Allow insertion of literal svg strings.
              if (typeof o =='string' && o[0]=='<') { return o; }
            // Strings are rendered at the current cursor position.
              if (typeof o =='string') { var res2=(o[0]=='_')?'':`<text x="${lx}" y="${ly}" font-family="Verdana" font-size="${options.fontSize*0.1||0.1}" style="pointer-events:none" fill="${color||'#333'}" transform="rotate(${lr},${lx},${ly})">&nbsp;${o}&nbsp;</text>`; ly+=0.14; return res2; }
            // Numbers change the current color.
              if (typeof o =='number') { color='#'+(o+(1<<25)).toString(16).slice(-6); return ''; }            // All other elements are rendered ..
              var ni_part = o.Dot(no.Scale(-1));  // O_i + n_o O_oi
              var no_part = ni.Scale(-1).Dot(o);  // O_o + O_oi n_i
              if (ni_part.VLength * 1e-6 > no_part.VLength) {
                // direction or dual - nothing to render
                return "";
              }
              var no_ni_part = no_part.Dot(no.Scale(-1));  // O_oi
              var no_only_part = ni.Wedge(no_part).Dot(no.Scale(-1));  // O_o

              /* Note: making 1e-6 smaller increases the maximum circle radius before they are drawn as lines */
              if (no_ni_part.VLength * 1e-6 > no_only_part.VLength) {
                var is_flat = true;
                var direction = no_ni_part;
              }
              else {
                var is_flat = false;
                var direction = no_only_part;
              }
              // normalize to make the direction unitary
              var dl = direction.Length;
              o = o.Scale(1/dl);
              direction = direction.Scale(1/dl);

              var b0=direction.Grade(0).VLength>0.001,b1=direction.Grade(1).VLength>0.001,b2=direction.Grade(2).VLength>0.001;
              if (!is_flat && b0 && !b1 && !b2) {
                // Points
                if (direction.s < 0) { o = Element.Sub(o); }
                lx=sc*(o.e1); ly=sc*(-o.e2); lr=0; return res2=`<CIRCLE onmousedown="this.parentElement.sel=${oidx}" cx="${lx}" cy="${ly}" r="${pointRadius*0.03}" fill="${color||'green'}"/>`;
              } else if (is_flat && !b0 && b1 && !b2) {
                // Lines.
                var loc=minus_no.LDot(o).Div(o); ni.Dot(o);
                lx=sc*(-loc.e1); ly=sc*(loc.e2); lr=Math.atan2(-o[14],o[13])/Math.PI*180; return `<LINE style="pointer-events:none" x1=${lx-10} y1=${ly} x2=${lx+10} y2=${ly} stroke="${color||'#888'}" transform="rotate(${lr},${lx},${ly})"/>`;
              } else if (!is_flat && !b0 && !b1 && b2) {
                // Circles
                var loc=o.Div(ni.LDot(o)); lx=sc*(-loc.e1); ly=sc*(loc.e2);
                var r2=o.Mul(o.Conjugate).s;
                var r = Math.sqrt(Math.abs(r2))*sc;
                return `<CIRCLE onmousedown="this.parentElement.sel=${oidx}" cx="${lx}" cy="${ly}" r="${r}" fill="none" stroke="${color||'green'}" stroke-dasharray="${dash_for_r2(r2, r, lineWidth*0.020)}"/>`;
              } else if (!is_flat && !b0 && b1 && !b2) {
                // Point Pairs.
                lr=0; var ei=ni,eo=no, nix=o.Wedge(ei), sqr=o.LDot(o).s/nix.LDot(nix).s, r=Math.sqrt(Math.abs(sqr)), attitude=((ei.Wedge(eo)).LDot(nix)).Normalized.Mul(Element.Scalar(r)), pos=o.Div(nix); pos=pos.Div( pos.LDot(Element.Sub(ei)));
                if (nix==0) { pos = o.Dot(Element.Coeff(4,-1)); sqr=-1; }
                lx=sc*(pos.e1); ly=sc*(-pos.e2);
                if (sqr==0) return `<CIRCLE onmousedown="this.parentElement.sel=${oidx}" cx="${lx}" cy="${ly}" r="${pointRadius*0.03}" stroke-width="${lineWidth*0.01}" fill="none" stroke="${color||'green'}"/>`;
                // Draw imaginary pairs hollow
                if (sqr > 0) var fill = color||'green', stroke = 'none';
                else var fill = 'none', stroke = color||'green';
                lx=sc*(pos.e1+attitude.e1); ly=sc*(-pos.e2-attitude.e2);
                var res2=`<CIRCLE onmousedown="this.parentElement.sel=${oidx}" cx="${lx}" cy="${ly}" r="${pointRadius*0.03}" fill="${fill}" stroke-width="${lineWidth*0.01}" stroke="${stroke}" stroke-dasharray="${dash_for_r2(sqr, pointRadius*0.03, lineWidth*0.020)}" />`;
                lx=sc*(pos.e1-attitude.e1); ly=sc*(-pos.e2+attitude.e2);
                return res2+`<CIRCLE onmousedown="this.parentElement.sel=${oidx}" cx="${lx}" cy="${ly}" r="${pointRadius*0.03}" fill="${fill}" stroke-width="${lineWidth*0.01}" stroke="${stroke}" stroke-dasharray="${dash_for_r2(sqr, pointRadius*0.03, lineWidth*0.020)}" />`;
              } else {
                /* Unrecognized */
                return "";
              }
            // Handle projective 2D and 3D elements.
            }):f.map&&f.map((o,oidx)=>{  if((o==Element.graph && or!==false)||(oidx==0&&options.animate&&or!==false)) { anim=true; requestAnimationFrame(()=>{var r=build(origf,(!res)||(document.body.contains(res))).innerHTML; if (res) res.innerHTML=r; }); if (!options.animate) return; } while (o instanceof Function) o=o(); o=(o instanceof Array)?o.map(project):project(o); if (o===undefined) return;
            // dual option dualizes before render
              if (options.dual && o instanceof Element) o = o.Dual;
            // line segments and polygons
              if (o instanceof Array && o.length)  { lx=ly=lr=0; o.forEach((o)=>{while (o.call) o=o(); lx+=options.scale*((drm[1]==6||drm[1]==14)?-1:1)*o[drm[2]]/o[drm[1]];ly+=options.scale*o[drm[3]]/o[drm[1]];});lx/=o.length;ly/=o.length; return o.length>2?`<POLYGON STYLE="pointer-events:none; fill:${color};opacity:0.7" points="${o.map(o=>((drm[1]==6||drm[1]==14)?-1:1)*options.scale*o[drm[2]]/o[drm[1]]+','+(-options.scale)*o[drm[3]]/o[drm[1]]+' ')}"/>`:`<LINE style="pointer-events:none" x1=${options.scale*((drm[1]==6||drm[1]==14)?-1:1)*o[0][drm[2]]/o[0][drm[1]]} y1=${-options.scale*o[0][drm[3]]/o[0][drm[1]]} x2=${options.scale*((drm[1]==6||drm[1]==14)?-1:1)*o[1][drm[2]]/o[1][drm[1]]} y2=${-options.scale*o[1][drm[3]]/o[1][drm[1]]} stroke="${color||'#888'}"/>`; }
            // svg
              if (typeof o =='string' && o[0]=='<') { return o; }
            // Labels
              if (typeof o =='string') { var res2=(o[0]=='_')?'':`<text x="${lx}" y="${-ly}" font-family="Verdana" font-size="${options.fontSize*0.1||0.1}" style="pointer-events:none" fill="${color||'#333'}" transform="rotate(${-lr},0,0)">&nbsp;${o}&nbsp;</text>`; ly-=0.14; return res2; }
            // Colors
              if (typeof o =='number') { color='#'+(o+(1<<25)).toString(16).slice(-6); return ''; }            // Points
              if (o[to2d[6]]**2        >0.0001) { lx=options.scale*o[drm[2]]/o[drm[1]]; if (drm[1]==6||drm[1]==14) lx*=-1; ly=options.scale*o[drm[3]]/o[drm[1]]; lr=0;  var res2=`<CIRCLE onmousedown="this.parentElement.sel=${oidx}" cx="${lx}" cy="${-ly}" r="${options.pointRadius*0.03||0.03}" fill="${color||'green'}"/>`; ly+=0.05; lx-=0.1; return res2; }
            // Lines
              if (o[to2d[2]]**2+o[to2d[3]]**2>0.0001) { var l=Math.sqrt(o[to2d[2]]**2+o[to2d[3]]**2); o[to2d[2]]/=l; o[to2d[3]]/=l; o[to2d[1]]/=l; lx=0.5; ly=options.scale*((drm[1]==6)?-1:-1)*o[to2d[1]]; lr=-Math.atan2(o[to2d[2]],o[to2d[3]])/Math.PI*180; var res2=`<LINE style="pointer-events:none" x1=-10 y1=${-ly} x2=10 y2=${-ly} stroke="${color||'#888'}" transform="rotate(${-lr},0,0)"/>`; ly+=0.05; return res2; }
            // Vectors
              if (o[to2d[4]]**2+o[to2d[5]]**2>0.0001) { lr=0; ly+=0.05; lx+=0.1; var res2=`<LINE style="pointer-events:none" x1=${lx} y1=${-ly} x2=${lx-o.e02} y2=${-(ly+o.e01)} stroke="${color||'#888'}"/>`; ly=ly+o.e01/4*3-0.05; lx=lx-o.e02/4*3; return res2; }
            }).join()}`,'text/html').body;
          // return the inside of the created svg element.
            return svg.removeChild(svg.firstChild);
          }        // Create the initial svg and install the mousehandlers.
          res=build(f); res.value=f; res.options=options; res.setAttribute("stroke-width",options.lineWidth*0.005||0.005);
          //onmousedown="if(evt.target==this)this.sel=undefined"
          var mousex,mousey,cammove=false;
          res.onwheel=(e)=>{ e.preventDefault(); options.scale = Math.min(5,Math.max(0.1,(options.scale||1)-e.deltaY*0.0001)); if (!anim) {var r=build(origf,(!res)||(document.body.contains(res))).innerHTML; if (res) res.innerHTML=r; } };
          res.onmousedown=(e)=>{ if (e.target == res) res.sel=undefined; mousex = e.clientX; mousey = e.clientY; cammove = true;  };
          res.onmousemove=(e)=>{
            if (cammove && tot==4 && !options.conformal) {
              if (!e.buttons) { cammove=false; return; }              var [dx,dy] = [e.clientX - mousex, e.clientY - mousey];
              [mousex,mousey] = [e.clientX,e.clientY];
              if (res.sel && f[res.sel].set) {
                f[res.sel].set(   Element.sw(Element.sw(options.camera.Reverse,Element.Bivector(-dx/500,dy/500,0,0,0,0).Exp()),f[res.sel]) );
              } else {
                options.h = (options.h||0) + dx/300;
                options.p = (options.p||0) - dy/600;
                if (options.camera) options.camera.set( ( Element.Bivector(0,0,0,0,0,options.p).Exp() ).Mul( Element.Bivector(0,0,0,0,options.h,0).Exp() )/*.Mul(options.camera)*/ );
              }
              if (!anim) {var r=build(origf,(!res)||(document.body.contains(res))).innerHTML; if (res) res.innerHTML=r; }
              return;
            }
            if (res.sel===undefined || f[res.sel] == undefined || f[res.sel].set == undefined || !e.buttons) return;
            var resx=res.getBoundingClientRect().width,resy=res.getBoundingClientRect().height,
                x=((e.clientX-res.getBoundingClientRect().left)/(resx/4||128)-2)*(resx>resy?resx/resy:1),y=((e.clientY-res.getBoundingClientRect().top)/(resy/4||128)-2)*(resy>resx?resy/resx:1);
            x/=options.scale;y/=options.scale;
            if (options.conformal) { f[res.sel].set(this.Coeff(1,x,2,-y).Add(no).Add(ni.Scale(0.5*(x*x+y*y))) ); }
                              else { f[res.sel][drm[2]]=((drm[1]==6)?-x:x)-((tot<4)?2*options.camera.e01:0); f[res.sel][drm[3]]=-y+((tot<4)?2*options.camera.e02:0); f[res.sel][drm[1]]=1; f[res.sel].set(f[res.sel].Normalized);}
            if (!anim) {var r=build(origf,(!res)||(document.body.contains(res))).innerHTML; if (res) res.innerHTML=r; }
            res.dispatchEvent(new CustomEvent('input')); };
          return res;
        }
      // 1d and 2d functions are rendered on a canvas.
        cvs=cvs||document.createElement('canvas'); if(ww)cvs.width=ww; if(hh)cvs.height=hh; var w=cvs.width,h=cvs.height,context=cvs.getContext('2d'), data=context.getImageData(0,0,w,h);
      // Grid support for the canvas.
        const [x_from,x_to,y_from,y_to]=options.range||[-1,1,1,-1];
        function drawGrid() {
          const [X,Y]=[x=>(x-x_from)*w/(x_to-x_from),y=>(y-y_from)*h/(y_to-y_from)];
          context.strokeStyle = "#008800"; context.lineWidth = 1;
          // X and Y axis
          context.beginPath();
          context.moveTo(X(x_from), Y(0)); context.lineTo(X(x_to  ), Y(0)); context.stroke();
          context.moveTo(X(0), Y(y_from)); context.lineTo(X(0), Y(y_to  )); context.stroke();
          // Draw ticks
          context.strokeStyle = "#00FF00"; context.lineWidth = 2; context.font = "10px Arial"; context.fillStyle = "#448844";
          for (var i=x_from,j=y_from,ii=0; ii<=10; ++ii) {
              context.beginPath(); j+= (y_to-y_from)/10; i+=(x_to-x_from)/10;
              context.moveTo(X(i), Y(-(y_to - y_from)/200)); context.lineTo(X(i), Y((y_to - y_from)/200)); context.stroke();
              if(i.toFixed(1)!=0) context.fillText(i.toFixed(1), X(i-(x_to-x_from)/100), Y(-(y_to-y_from)/40));
              context.moveTo(X((x_to-x_from)/200), Y(j)); context.lineTo(X(-(x_to-x_from)/200), Y(j)); context.stroke();
              if(j.toFixed(1)!=0) context.fillText(j.toFixed(1), X((x_to-x_from)/100), Y(j));
          }
        }
      // two parameter functions .. evaluate for both and set resulting color.
        if (f.length==2) for (var px=0; px<w; px++) for (var py=0; py<h; py++) { var res=f(px/w*(x_to-x_from)+x_from, py/h*(y_to-y_from)+y_from); res=res.buffer?[].slice.call(res):res.slice?res:[res,res,res]; data.data.set(res.map(x=>x*255).concat([255]),py*w*4+px*4); }
      // one parameter function.. go over x range, use result as y.
        else if (f.length==1) for (var px=0; px<w; px++) { var res=f(px/w*(x_to-x_from)+x_from); res=Math.round((res/(y_to-y_from)+(-y_from/(y_to-y_from)))*h); if (res > 0 && res < h-1) data.data.set([0,0,0,255],res*w*4+px*4); }
        context.putImageData(data,0,0);
        if (f.length == 1 || f.length == 2) if (options.grid) drawGrid();
        return cvs;
      }

    // webGL2 Graphing function. (for OPNS/IPNS implicit 2D and 1D surfaces in 3D space).
      static graphGL2(f,options) {
      // Create canvas, get webGL2 context.
        var canvas=document.createElement('canvas'); canvas.style.width=options.width||''; canvas.style.height=options.height||''; canvas.style.backgroundColor='#EEE';
        if (options.width && options.width.match && options.width.match(/px/i)) canvas.width = parseFloat(options.width)*(options.devicePixelRatio||devicePixelRatio||1); if (options.height && options.height.match && options.height.match(/px/i)) canvas.height = parseFloat(options.height)*(options.devicePixelRatio||devicePixelRatio||1);
        var gl=canvas.getContext('webgl2',{alpha:options.alpha||false,preserveDrawingBuffer:true,antialias:true,powerPreference:'high-performance'});
        var gl2=!!gl; if (!gl) gl=canvas.getContext('webgl',{alpha:options.alpha||false,preserveDrawingBuffer:true,antialias:true,powerPreference:'high-performance'});
        gl.clearColor(240/255,240/255,240/255,1.0); gl.enable(gl.DEPTH_TEST); if (!gl2) { gl.getExtension("EXT_frag_depth"); gl.va = gl.getExtension('OES_vertex_array_object'); }
        else gl.va = { createVertexArrayOES : gl.createVertexArray.bind(gl), bindVertexArrayOES : gl.bindVertexArray.bind(gl), deleteVertexArrayOES : gl.deleteVertexArray.bind(gl)  };
      // Compile vertex and fragment shader, return program.
        var compile=(vs,fs)=>{
          var s=[gl.VERTEX_SHADER,gl.FRAGMENT_SHADER].map((t,i)=>{
            var r=gl.createShader(t); gl.shaderSource(r,[vs,fs][i]); gl.compileShader(r);
            return gl.getShaderParameter(r, gl.COMPILE_STATUS)&&r||console.error(gl.getShaderInfoLog(r));
          });
          var p = gl.createProgram(); gl.attachShader(p, s[0]); gl.attachShader(p, s[1]); gl.linkProgram(p);
          gl.getProgramParameter(p, gl.LINK_STATUS)||console.error(gl.getProgramInfoLog(p));
          return p;
        };
      // Create vertex array and buffers, upload vertices and optionally texture coordinates.
        var createVA=function(vtx) {
          var r = gl.va.createVertexArrayOES(); gl.va.bindVertexArrayOES(r);
          var b = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, b);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtx), gl.STATIC_DRAW);
          gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(0);
          return {r,b}
        },
      // Destroy Vertex array and delete buffers.
        destroyVA=function(va) {
          if (va.b) gl.deleteBuffer(va.b); if (va.r) gl.va.deleteVertexArrayOES(va.r);
        };
      // Drawing function
        var M=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,5,1];
        var draw=function(p, tp, vtx, color, color2, ratio, texc, va, b,color3,r,g){
            canvas.options.mv = M; const proj = canvas.options.proj = [5,0,0,0,0,5*(ratio||2),0,0,0,0,1,2,0,0,-1,0];
            gl.useProgram(p); gl.uniformMatrix4fv(gl.getUniformLocation(p, "mv"),false,M);
            gl.uniformMatrix4fv(gl.getUniformLocation(p, "p"),false, proj);
            gl.uniform3fv(gl.getUniformLocation(p, "color"),new Float32Array(color));
            gl.uniform3fv(gl.getUniformLocation(p, "color2"),new Float32Array(color2));
            if (color3) gl.uniform3fv(gl.getUniformLocation(p, "color3"),new Float32Array(color3));
            if (b) gl.uniform1fv(gl.getUniformLocation(p, "b"),(new Float32Array(counts[g])).map((x,i)=>b[g][i]||0));
            if (texc) gl.uniform1i(gl.getUniformLocation(p, "texc"),0);
            if (r) gl.uniform1f(gl.getUniformLocation(p,"ratio"),r);
            var v; if (!va) v = createVA(vtx); else gl.va.bindVertexArrayOESOES(va.r);
            gl.drawArrays(tp, 0, (va&&va.tcount)||vtx.length/3);
            if (v) destroyVA(v);
        };
      // Compile the OPNS renderer. (sphere tracing)
        var programs = [], genprog = grade=>compile(`${gl2?"#version 300 es":""}
             ${gl2?"in":"attribute"} vec4 position; ${gl2?"out":"varying"} vec4 Pos; uniform mat4 mv; uniform mat4 p;
             void main() { Pos=mv*position; gl_Position = p*Pos; }`,
            `${!gl2?"#extension GL_EXT_frag_depth : enable":"#version 300 es"}
             precision highp float;
             uniform vec3 color; uniform vec3 color2;
             uniform vec3 color3; uniform float b[${counts[grade]}];
             uniform float ratio; ${gl2?"out vec4 col;":""}
             ${gl2?"in":"varying"} vec4 Pos;
             float product_len (in float z, in float y, in float x, in float[${counts[grade]}] b) {
                ${this.nVector(options.up.length>tot?2:1,[])[options.IPNS?"IPNS_GLSL":"OPNS_GLSL"](this.nVector(grade,[]), options.up)}
                return sqrt(abs(sum));
             }
             vec3 find_root (in vec3 start, vec3 dir, in float thresh) {
                vec3 orig=start;
                float lastd = 1000.0;
                const int count=${(options.maxSteps||80)};
                for (int i=0; i<count; i++) {
                  float d = product_len(start[0],start[1],start[2],b);
                  float diff = ${(options.stepSize||0.0001)}*(1.0+2000.0*d);
                  if (d < thresh) return start + dir*(lastd-thresh)/(lastd-d)*diff;
                  lastd = d; start += dir*diff;
                }
                return orig;
             }
             void main() {
               vec3 dir = ((-Pos[0]/5.0)*color + color2 + vec3(0.0,Pos[1]/5.0*ratio,0.0));
               vec3 p = -5.0*normalize(color2) + dir+vec3(0.0,0.0,1.0); dir = normalize(dir);
               vec3 L = 5.0*normalize( -0.5*color + 0.85*color2 + vec3(0.0,-0.5,0.0) );
               vec3 d2 = find_root( p , dir, ${grade!=tot-1?(options.thresh||0.2):"0.0075"} );
               float dl2 = dot(d2-p,d2-p); const float h=0.0001;
               if (dl2>0.0) {
                 vec3 n = normalize(vec3(
                        product_len(d2[0]+h,d2[1],d2[2],b)-product_len(d2[0]-h,d2[1],d2[2],b),
                        product_len(d2[0],d2[1]+h,d2[2],b)-product_len(d2[0],d2[1]-h,d2[2],b),
                        product_len(d2[0],d2[1],d2[2]+h,b)-product_len(d2[0],d2[1],d2[2]-h,b)
                      ));
                 ${gl2?"gl_FragDepth":"gl_FragDepthEXT"} = dl2/50.0;
                 ${gl2?"col":"gl_FragColor"} = vec4(max(0.2,abs(dot(n,normalize(L-d2))))*color3 + pow(abs(dot(n,normalize(normalize(L-d2)+dir))),100.0),1.0);
               } else discard;
             }`),genprog2D = grade=>compile(`${gl2?"#version 300 es":""}
             ${gl2?"in":"attribute"} vec4 position; ${gl2?"out":"varying"} vec4 Pos; uniform mat4 mv; uniform mat4 p;
             void main() { Pos=mv*position; gl_Position = p*Pos; }`,
            `${!gl2?"#extension GL_EXT_frag_depth : enable":"#version 300 es"}
             precision highp float;
             uniform vec3 color; uniform vec3 color2;
             uniform vec3 color3; uniform float b[${counts[grade]}];
             uniform float ratio; ${gl2?"out vec4 col;":""}
             ${gl2?"in":"varying"} vec4 Pos;
             float product_len (in float z, in float y, in float x, in float[${counts[grade]}] b) {
                ${this.nVector(1,[])[options.IPNS?"IPNS_GLSL":"OPNS_GLSL"](this.nVector(grade,[]), options.up)}
                return sqrt(abs(sum));
             }
             void main() {
               vec3 p = -5.0*normalize(color2) -Pos[0]/5.0*color + color2 + vec3(0.0,Pos[1]/5.0*ratio,0.0);
               float d2 = 1.0 - 150.0*pow(product_len( p[0]*5.0, p[1]*5.0, p[2]*5.0, b),2.0);
               if (d2>0.0) {
                 ${gl2?"col":"gl_FragColor"} = vec4(color3,d2);
               } else discard;
             }`);
      // canvas update will (re)render the content.
        var armed=0;
        canvas.update = (x)=>{
        // Start by updating canvas size if needed and viewport.
          var s = getComputedStyle(canvas); if (s.width) { canvas.width = parseFloat(s.width)*(options.devicePixelRatio||devicePixelRatio||1); canvas.height = parseFloat(s.height)*(options.devicePixelRatio||devicePixelRatio||1); }
          gl.viewport(0,0, canvas.width|0,canvas.height|0); var r=canvas.width/canvas.height;
        // Defaults, resolve function input
          var c=[.5,.5,.5]; gl.clear(gl.COLOR_BUFFER_BIT+gl.DEPTH_BUFFER_BIT); while (x.call) x=x();
        // Loop over all items to render.
          for (var i=0,ll=x.length;i<ll;i++) {
            var e=x[i]; while (e&&e.call) e=e(); if (e==undefined) continue;
            if (typeof e == "number") { c[0]=((e>>>16)&0xff)/255; c[1]=((e>>>8)&0xff)/255; c[2]=(e&0xff)/255; }
            if (e instanceof Element){
              var tt = options.spin?-performance.now()*options.spin/1000:-options.h||0; tt+=Math.PI/2; var r = canvas.height/canvas.width;
              var g=tot-1; while(!e[g]&&g>1) g--;
              if (!programs[tot-1-g]) programs[tot-1-g] = (options.up.find(x=>x.match&&x.match("z")))?genprog(g):genprog2D(g);
              gl.enable(gl.BLEND); gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              draw(programs[tot-1-g],gl.TRIANGLES,[-2,-2,0,-2,2,0,2,-2,0,-2,2,0,2,-2,0,2,2,0],[Math.cos(tt),0,-Math.sin(tt)],[Math.sin(tt),0,Math.cos(tt)],undefined,undefined,undefined,e,c,r,g);
              gl.disable(gl.BLEND);
            }
          }
          // if we're no longer in the page .. stop doing the work.
          armed++; if (document.body.contains(canvas)) armed=0; if (armed==2) return;
          canvas.value=x; if (options&&!options.animate) canvas.dispatchEvent(new CustomEvent('input'));
          if (options&&options.animate) { requestAnimationFrame(canvas.update.bind(canvas,f,options)); }
          if (options&&options.still) { canvas.value=x; canvas.dispatchEvent(new CustomEvent('input')); canvas.im.width=canvas.width; canvas.im.height=canvas.height; canvas.im.src = canvas.toDataURL(); }
        };
        // Basic mouse interactivity. needs more love.
        var sel=-1; canvas.oncontextmenu = canvas.onmousedown = (e)=>{ e.preventDefault(); e.stopPropagation(); sel=-2;
          var rc = canvas.getBoundingClientRect(); (e.x-rc.left)/(rc.right-rc.left)*2-1; ((e.y-rc.top)/(rc.bottom-rc.top)*-4+2)*canvas.height/canvas.width;
          canvas.onwheel=e=>{e.preventDefault(); e.stopPropagation(); options.z = (options.z||5)+e.deltaY/100; if (!options.animate) requestAnimationFrame(canvas.update.bind(canvas,f,options));};
          canvas.onmouseup=e=>sel=-1; canvas.onmouseleave=e=>sel=-1;
          canvas.onmousemove=(e)=>{
            var rc = canvas.getBoundingClientRect();
            var mx =(e.movementX)/(rc.right-rc.left)*2; ((e.movementY)/(rc.bottom-rc.top)*-2)*canvas.height/canvas.width;
            if (sel==-2) { options.h =  (options.h||0)+mx; if (!options.animate) requestAnimationFrame(canvas.update.bind(canvas,f,options)); return; } if (sel < 0) return;
          };
        };
        canvas.value = f.call?f():f; canvas.options = options;
        if (options&&options.still) {
          var i=new Image(); canvas.im = i; return requestAnimationFrame(canvas.update.bind(canvas,f,options)),i;
        } else return requestAnimationFrame(canvas.update.bind(canvas,f,options)),canvas;

      }


    // webGL Graphing function. (for parametric defined objects)
      static graphGL(f,options) {
      // Create a canvas, webgl2 context and set some default GL options.
        var canvas=document.createElement('canvas'); canvas.style.width=options.width||''; canvas.style.height=options.height||''; canvas.style.backgroundColor='#EEE';
        if (options.width && options.width.match && options.width.match(/px/i)) canvas.width = parseFloat(options.width); if (options.height && options.height.match && options.height.match(/px/i)) canvas.height = parseFloat(options.height);
        var gl=canvas.getContext('webgl',{alpha:options.alpha||false,antialias:true,preserveDrawingBuffer:options.still||true,powerPreference:'high-performance'});
        gl.enable(gl.DEPTH_TEST); gl.depthFunc(gl.LEQUAL); if (!options.alpha) gl.clearColor(240/255,240/255,240/255,1.0); gl.getExtension("OES_standard_derivatives"); gl.va=gl.getExtension("OES_vertex_array_object");
      // Compile vertex and fragment shader, return program.
        var compile=(vs,fs)=>{
          var s=[gl.VERTEX_SHADER,gl.FRAGMENT_SHADER].map((t,i)=>{
            var r=gl.createShader(t); gl.shaderSource(r,[vs,fs][i]); gl.compileShader(r);
            return gl.getShaderParameter(r, gl.COMPILE_STATUS)&&r||console.error(gl.getShaderInfoLog(r));
          });
          var p = gl.createProgram(); gl.attachShader(p, s[0]); gl.attachShader(p, s[1]); gl.linkProgram(p);
          gl.getProgramParameter(p, gl.LINK_STATUS)||console.error(gl.getProgramInfoLog(p));
          return p;
        };
      // Create vertex array and buffers, upload vertices and optionally texture coordinates.
        var createVA=function(vtx, texc, idx, clr) {
              var r = gl.va.createVertexArrayOES(); gl.va.bindVertexArrayOES(r);
              var b = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, b);
              gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtx), gl.STATIC_DRAW);
              gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(0);
              if (texc){
                var b2=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, b2);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texc), gl.STATIC_DRAW);
                gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(1);
              }
              if (clr){
                var b3=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, b3);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(clr), gl.STATIC_DRAW);
                gl.vertexAttribPointer(texc?2:1, 3, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(texc?2:1);
              }
              if (idx) {
                var b4=gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, b4);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(idx), gl.STATIC_DRAW);
              }
              return {r,b,b2,b4,b3}
            },
      // Destroy Vertex array and delete buffers.
            destroyVA=function(va) {
              [va.b,va.b2,va.b4,va.b3].forEach(x=>{if(x) gl.deleteBuffer(x);}); if (va.r) gl.va.deleteVertexArrayOES(va.r);
            };
      // Default modelview matrix, convert camera to matrix (biquaternion->matrix)
        var M=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,5,1], mtx = (x,iscam=true)=>{ var t=options.spin?performance.now()*options.spin/1000:-options.h||0, t2=options.p||0;
          var ct = Math.cos(t), st= Math.sin(t), ct2 = Math.cos(t2), st2 = Math.sin(t2), xx=options.posx||0, y=options.posy||0, z=options.posz||0, zoom=options.z||5;
          if (tot==5) return [ct,st*-st2,st*ct2,0,0,ct2,st2,0,-st,ct*-st2,ct*ct2,0,xx*ct+z*-st,y*ct2+(xx*st+z*ct)*-st2,y*st2+xx*st+z*ct*ct2+zoom,1];
          x=x.Normalized; var y=x.Mul(x.Dual),X=x.e23,Y=-x.e13,Z=-x.e12,W=x.s;
          var xx = X*X, xy = X*Y, xz = X*Z, xw = X*W, yy = Y*Y, yz = Y*Z, yw = Y*W, zz = Z*Z, zw = Z*W;
          var mtx = [ 1-2*(yy+zz), 2*(xy+zw), 2*(xz-yw), 0, 2*(xy-zw), 1-2*(xx+zz), 2*(yz+xw), 0, 2*(xz+yw), 2*(yz-xw), 1-2*(xx+yy), 0, -2*y.e23, -2*y.e13, 2*y.e12+(iscam?5:0), 1];
          return mtx;
        };
      // Render the given vertices. (autocreates/destroys vertex array if not supplied).
        var draw=function(p, tp, vtx, color, color2, ratio, texc, va, cbuf){
          canvas.options.mv = M; const proj = canvas.options.proj = [5,0,0,0,0,5*(ratio||2),0,0,0,0,1,2,0,0,-1,0];
          gl.useProgram(p); gl.uniformMatrix4fv(gl.getUniformLocation(p, "mv"),false,M);
          gl.uniformMatrix4fv(gl.getUniformLocation(p, "p"),false, proj);
          gl.uniform3fv(gl.getUniformLocation(p, "color"),new Float32Array(color));
          gl.uniform3fv(gl.getUniformLocation(p, "color2"),new Float32Array(color2));
          //if (texc) gl.uniform1i(gl.getAttribLocation(p, "texc"),0);
          var v; if (!va) v = createVA(vtx, texc, undefined, cbuf); else gl.va.bindVertexArrayOES(va.r);
          if (va && va.b4) {
            gl.drawElements(tp, va.tcount, gl.UNSIGNED_SHORT, 0);
          } else {
            gl.drawArrays(tp, 0, (va&&va.tcount)||vtx.length/3);
          }
          if (v) destroyVA(v);
        };
      // Program for the geometry. Derivative based normals. Basic lambert shading.
        var program = compile(`attribute vec4 position; varying vec4 Pos; uniform mat4 mv; uniform mat4 p;
                 void main() { gl_PointSize=12.0; Pos=mv*position; gl_Position = p*Pos; }`,
                `#extension GL_OES_standard_derivatives : enable
                 precision highp float; uniform vec3 color; uniform vec3 color2; varying vec4 Pos;
                 void main() { vec3 ldir = normalize(Pos.xyz - vec3(2.0,2.0,-4.0));
                 vec3 normal = normalize(cross(dFdx(Pos.xyz), dFdy(Pos.xyz))); float l=dot(normal,ldir);
                 vec3 E = normalize(-Pos.xyz); vec3 R = normalize(reflect(ldir,normal));
                 gl_FragColor = vec4(max(0.0,l)*color+vec3(0.5*pow(max(dot(R,E),0.0),20.0))+color2, 1.0);  }`);
        var programPoint = compile(`attribute vec4 position; varying vec4 Pos; uniform mat4 mv; uniform mat4 p;
                 void main() { gl_PointSize=${((options.pointRadius||1)*(options.devicePixelRatio||devicePixelRatio||1)*8.0).toFixed(2)}; Pos=mv*position; gl_Position = p*Pos; }`,
                `precision highp float; uniform vec3 color; uniform vec3 color2; varying vec4 Pos;
                 void main() {  float distanceToCenter = length(gl_PointCoord - vec2(0.5)); if (distanceToCenter>0.5) discard;
                 gl_FragColor = vec4(color+color2, (distanceToCenter<0.5?1.0:0.0));  }`);
        var programline = compile(`
                 attribute vec4 position;  // current point.
                 attribute vec2 texc;      // x = +w or -w, alternating. y = opacity.
                 attribute vec4 col;       // next point. (extrapolated for end point)
                 uniform vec3 color;       // r=aspect g=thickness
                 uniform mat4 mv,p;        // modelview and projection matrix
                 varying vec2 tc;
                 void main() {
                 // Convert to clipspace.
                   vec4 cp = p*mv*vec4(position.xyz,1.0);
                   vec2 cs = cp.xy / abs(cp.w);
                   vec4 np = p*mv*vec4(col.xyz,1.0);
                   vec2 ns = np.xy / abs(np.w);
                 // compensate aspect
                   cs.x *= color.r;
                   ns.x *= color.r;
                 // clipspace line direction.
                   vec2 dir = normalize(cs-ns);
                 // Calculate screenspace normal.
                   vec2 normal = vec2( -dir.y, dir.x);
                 // Line scaling and aspect fix.
                   normal *= color.g * 5.0;
                   normal.x /= color.r;
                 // Pass through texture coordinates for edge softening
                   tc = vec2(texc.x / abs(texc.x), texc.y);
                   gl_Position = cp + vec4(normal*texc.x,0.0,0.0);
                 }`,
                `precision highp float;
                 uniform vec3 color2;
                 varying vec2 tc;
                 void main() {
                   gl_FragColor = vec4(color2,(1.0-pow(abs(tc.x),2.0))*tc.y);
                 }`);
        var programcol = compile(`attribute vec4 position; attribute vec3 col; varying vec3 Col; varying vec4 Pos; uniform mat4 mv; uniform mat4 p;
                 void main() { gl_PointSize=6.0; Pos=mv*position; gl_Position = p*Pos; Col=col; }`,
                `#extension GL_OES_standard_derivatives : enable
                 precision highp float; uniform vec3 color; uniform vec3 color2; varying vec4 Pos; varying vec3 Col;
                 void main() { vec3 ldir = normalize(Pos.xyz - vec3(1.0,1.0,2.0));
                 vec3 normal = normalize(cross(dFdx(Pos.xyz), dFdy(Pos.xyz))); float l=dot(normal,ldir);
                 vec3 E = normalize(-Pos.xyz); vec3 R = normalize(reflect(ldir,normal));
                 gl_FragColor = vec4(max(0.3,l)*Col+vec3(pow(max(dot(R,E),0.0),20.0))+color2, 1.0); ${options.shader||''}  }`);
        var programmot = compile(`attribute vec4 position; attribute vec2 texc; attribute vec3 col; varying vec3 Col; varying vec4 Pos; uniform mat4 mv; uniform mat4 p; uniform vec3 color2;
                 void main() { gl_PointSize=2.0; float blend=fract(color2.x+texc.r)*0.5; Pos=mv*(position*(1.0-blend) + (blend)*vec4(col,1.0)); gl_Position = p*Pos; Col=vec3(length(col-position.xyz)*1.); gl_PointSize = 8.0 -  Col.x; Col.y=sin(blend*2.*3.1415); }`,
                `precision highp float; uniform vec3 color; uniform vec3 color2; varying vec4 Pos; varying vec3 Col;
                 void main() {  float distanceToCenter = length(gl_PointCoord - vec2(0.5));gl_FragColor = vec4(1.0-pow(Col.x,2.0),0.0,0.0,(.6-Col.x*0.05)*(distanceToCenter<0.5?1.0:0.0)*Col.y);  }`);
        gl.lineWidth(options.lineWidth||1); // doesn't work yet (nobody supports it)
      // Create a font texture, lucida console or otherwise monospaced.
        var fw=33, font = Object.assign(document.createElement('canvas'),{width:(19+94)*fw,height:48}),
            ctx = Object.assign(font.getContext('2d'),{font:'bold 48px lucida console, monospace'}),
            ftx = gl.createTexture(); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, ftx);
            for (var i=33; i<127; i++) ctx.fillText(String.fromCharCode(i),(i-33)*fw,40);
            var specialChars = ""; specialChars.split('').forEach((x,i)=>ctx.fillText(x,(i-33+127)*fw,40));
            // 2.0 gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,94*fw,32,0,gl.RGBA,gl.UNSIGNED_BYTE,font);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, font);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      // Font rendering program. Renders billboarded fonts, transforms offset passed as color2.
        var program2 = compile(`attribute vec4 position; attribute vec2 texc; varying vec2 tex; varying vec4 Pos; uniform mat4 mv; uniform mat4 p; uniform vec3 color2;
                 void main() { tex=texc; gl_PointSize=6.0; vec4 o=mv*vec4(color2,0.0); Pos=(-1.0/(o.z-mv[3][2]))*position+vec4(mv[3][0],mv[3][1],mv[3][2],0.0)+o; gl_Position = p*Pos; }`,
                `precision highp float; uniform vec3 color; varying vec4 Pos; varying vec2 tex;
                 uniform sampler2D texm; void main() { vec4 c = texture2D(texm,tex); if (c.a<0.01) discard; gl_FragColor = vec4(color,c.a);}`);
      // Helpers for line drawing. Convert line segments to triangles.
        const line_to_tri  = ([ax,ay,az,bx,by,bz]) => [ax,ay,az,ax,ay,az,bx,by,bz,bx,by,bz,ax,ay,az,bx,by,bz];
        const line_to_tri2 = ([ax,ay,az,bx,by,bz]) => [bx,by,bz,bx,by,bz,2*bx-ax,2*by-ay,2*bz-az,2*bx-ax,2*by-ay,2*bz-az,bx,by,bz,2*bx-ax,2*by-ay,2*bz-az];
      // Conformal space needs a bit extra magic to extract euclidean parametric representations.
        if (tot==5 && options.conformal) var ni = Element.Coeff(4,1).Add(Element.Coeff(5,1)), no = Element.Coeff(4,0.5).Sub(Element.Coeff(5,0.5));
        var interprete = (x)=>{
          if (!(x instanceof Element)) return { tp:0 };
          if (options.ipns) x=x.Dual;
          // tp = { 0:unknown 1:point 2:line, 3:plane, 4:circle, 5:sphere
          var X2 = (x.Mul(x)).s, tp=0, weight2, opnix = ni.Wedge(x), ipnix = ni.LDot(x),
              attitude, pos, normal, tg,btg,epsilon = 0.000001/(options.scale||1), I3=Element.Coeff(16,-1);
          var x2zero = Math.abs(X2) < epsilon, ipnixzero = ipnix.VLength < epsilon, opnixzero = opnix.VLength < epsilon;
          if (opnixzero && ipnixzero) ; else if (opnixzero && !ipnixzero) {         // bound flat (lines)
            attitude = no.Wedge(ni).LDot(x);
            weight2 = Math.abs(attitude.LDot(attitude).s)**.5;
            pos = attitude.LDot(x.Reverse); //Inverse);
            pos = [-pos.e15/pos.e45,-pos.e25/pos.e45,-pos.e34/pos.e45];
            if (x.Grade(3).VLength) {
              normal = [attitude.e1/weight2,attitude.e2/weight2,attitude.e3/weight2]; tp=2;
            } else if (x.Grade(2).VLength) { // point pair with ni
              tp = 1;
            } else {
              normal = Element.LDot(Element.Mul(attitude,1/weight2),I3).Normalized;
              var r=normal.Mul(Element.Coeff(3,1)); if (r[0]==-1) r[0]=1; else {r[0]+=1; r=r.Normalized;}
              tg = [...r.Mul(Element.Coeff(1,1)).Mul(r.Conjugate)].slice(1,4);
              btg = [...r.Mul(Element.Coeff(2,1)).Mul(r.Conjugate)].slice(1,4);
              normal = [...normal.slice(1,4)]; tp=3;
            }
          } else if (!opnixzero && ipnixzero) ; else if (x2zero) {                          // bound vec,biv,tri (points)
            if (options.ipns) x=x.Dual;
            attitude = ni.Wedge(no).LDot(ni.Wedge(x));
            pos = [...(Element.LDot(1/(ni.LDot(x)).s,x)).slice(1,4)].map(x=>-x);
            tp=1;
          } else if (!x2zero) {                          // round (point pair,circle,sphere)
            tp = x.Grade(3).VLength?4:x.Grade(2).VLength?6:5;
            var nix  = ni.Wedge(x), nix2 = (nix.Mul(nix)).s;
            attitude = ni.Wedge(no).LDot(nix);
            pos = [...(x.Mul(ni).Mul(x)).slice(1,4)].map(x=>-x/(2.0*nix2));
            weight2 = Math.abs((x.LDot(x)).s / nix2)**.5;
            if (tp==4) {
              if (x.LDot(x).s < 0) { weight2 = -weight2; }
              normal = Element.LDot(Element.Mul(attitude,1/weight2),I3).Normalized;
              var r=normal.Mul(Element.Coeff(3,1)); if (r[0]==-1) r[0]=1; else {r[0]+=1; r=r.Normalized;}
              tg = [...r.Mul(Element.Coeff(1,1)).Mul(r.Conjugate)].slice(1,4);
              btg = [...r.Mul(Element.Coeff(2,1)).Mul(r.Conjugate)].slice(1,4);
              normal = [...normal.slice(1,4)];
            } else if (tp==6) {
              weight2 = (x.LDot(x).s < 0)?-(weight2):weight2;
              normal = Element.Mul(attitude.Normalized,weight2).slice(1,4);
            } else {
              normal = [...((Element.LDot(Element.Mul(attitude,1/weight2),I3)).Normalized).slice(1,4)];
            }
          }
          return {tp,pos:pos?pos.map(x=>x*(options.scale||1)):[0,0,0],normal,tg,btg,weight2:weight2*(options.scale||1)}
        };
      // canvas update will (re)render the content.
        var armed=0,sphere,e14 = Element.Coeff(14,1);
        canvas.update = (x)=>{
          if (!canvas.parentElement) return;
        // restore from still..
          if (options && !options.still && canvas.im && canvas.im.parentElement) { canvas.im.parentElement.insertBefore(canvas,canvas.im); canvas.im.parentElement.removeChild(canvas.im); }
        // Start by updating canvas size if needed and viewport.
          var s = getComputedStyle(canvas); if (s.width) { canvas.width = parseFloat(s.width)*(options.devicePixelRatio||devicePixelRatio||1); canvas.height = parseFloat(s.height)*(options.devicePixelRatio||devicePixelRatio||1); }
          gl.viewport(0,0, canvas.width|0,canvas.height|0); var r=canvas.width/canvas.height;
        // Defaults, resolve function input
          var a,p=[],l=[],t=[],c=[.5,.5,.5],alpha=0,lastpos=[-2,2,0.2,1]; gl.clear(gl.COLOR_BUFFER_BIT+gl.DEPTH_BUFFER_BIT); while (x.call) x=x();
        // Create default camera matrix and initial lastposition (contra-compensated for camera)
          M = mtx(options.camera); lastpos = options.camera.Conjugate.Mul(((a=new this()).set(lastpos,11),a)).Mul(options.camera).slice(11,14);
        // Grid.
          if (options.grid) {
            const gr = options.gridSize||1;
            if (!options.gridLines) { options.gridLines=[[],[],[]]; for (var i=-gr; i<=gr; i+=gr/10) {
                options.gridLines[0].push(i,-gr,gr, i,-gr,-gr, gr,-gr,i, -gr,-gr,i);
                options.gridLines[1].push(i,gr,gr, i,-gr,gr, gr,i,gr, -gr,i,gr);
                options.gridLines[2].push(-gr,i,gr, -gr,i,-gr, -gr,gr,i, -gr,-gr,i);
            }}
            var ltest = [], ltest2 = [], ttest = []; for (var j=0; j<3; ++j) for (var i=0; i<options.gridLines[j].length; i+=6) {
              ltest.push(...line_to_tri(options.gridLines[j].slice(i,i+6)));
              ltest2.push(...line_to_tri2(options.gridLines[j].slice(i,i+6)));
              var w = ((i/12)|0)%10 == 0 ? 2 : ((i/12)|0)%5 == 0 ?1.5:.75;
              ttest.push(w,.5,-w,.5,w,.5,w,.5,-w,.5,-w,.5);
            }
            gl.depthMask(false); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); gl.enable(gl.BLEND);
            draw(programline, gl.TRIANGLES, ltest, [canvas.width/canvas.height, .003, 0.0],  [0,0,0], canvas.width/canvas.height, ttest, undefined, ltest2);
            gl.depthMask(true); gl.disable(gl.BLEND);
          }
        // Z-buffer override.
          if (options.noZ) gl.depthMask(false);
        // Loop over all items to render.
          for (var i=0,ll=x.length;i<ll;i++) {
            var e=x[i]; while (e&&e.call&&e.length==0) e=e(); if (e==undefined) continue;
          // CGA
            if (tot==5 && options.conformal) {
              if (e instanceof Array && e.length==2) { e.forEach(x=>{ while (x.call) x=x.call(); x=interprete(x);l.push.apply(l,x.pos); });  var d = {tp:-1}; }
              else if (e instanceof Array && e.length==3) { e.forEach(x=>{ while (x.call) x=x.call(); x=interprete(x);t.push.apply(t,x.pos); });  var d = {tp:-1}; }
              else var d = interprete(e);
              if (d.tp) lastpos=d.pos;
              if (d.tp==1) p.push.apply(p,d.pos);
              if (d.tp==2) { l.push.apply(l,d.pos.map((x,i)=>x-d.normal[i]*10)); l.push.apply(l,d.pos.map((x,i)=>x+d.normal[i]*10)); }
              if (d.tp==3) { t.push.apply(t,d.pos.map((x,i)=>x+d.tg[i]+d.btg[i])); t.push.apply(t,d.pos.map((x,i)=>x-d.tg[i]+d.btg[i])); t.push.apply(t,d.pos.map((x,i)=>x+d.tg[i]-d.btg[i]));
                             t.push.apply(t,d.pos.map((x,i)=>x-d.tg[i]+d.btg[i])); t.push.apply(t,d.pos.map((x,i)=>x+d.tg[i]-d.btg[i])); t.push.apply(t,d.pos.map((x,i)=>x-d.tg[i]-d.btg[i])); }
              if (d.tp==4) {
                var ne=0,la=0;
                if (d.weight2<0) { c[0]=1;c[1]=0;c[2]=0; }
                for (var j=0; j<65; j++) {
                  ne = d.pos.map((x,i)=>x+Math.cos(j/32*Math.PI)*d.weight2*d.tg[i]+Math.sin(j/32*Math.PI)*d.weight2*d.btg[i]); if (ne&&la&&(d.weight2>0||j%2==0)) { l.push.apply(l,la); l.push.apply(l,ne); } la=ne;
                }
              }
              if (d.tp==6) {
                if (d.weight2<0) { c[0]=1;c[1]=0;c[2]=0; }
                if (options.useUnnaturalLineDisplayForPointPairs) {
                  l.push.apply(l,d.pos.map((x,i)=>x-d.normal[i]*(options.scale||1)));
                  l.push.apply(l,d.pos.map((x,i)=>x+d.normal[i]*(options.scale||1)));
                }
                p.push.apply(p,d.pos.map((x,i)=>x-d.normal[i]*(options.scale||1)));
                p.push.apply(p,d.pos.map((x,i)=>x+d.normal[i]*(options.scale||1)));
              }
              if (d.tp==5) {
                if (!sphere) {
                  var pnts = [], tris=[], S=Math.sin, C=Math.cos, pi=Math.PI, W=96, H=48;
                  for (var j=0; j<W+1; j++) for (var k=0; k<H; k++) {
                    pnts.push( [S(2*pi*j/W)*S(pi*k/(H-1)), C(2*pi*j/W)*S(pi*k/(H-1)), C(pi*k/(H-1))]);
                    if (j && k) {
                      tris.push.apply(tris, pnts[(j-1)*H+k-1]);tris.push.apply(tris, pnts[(j-1)*H+k]);tris.push.apply(tris, pnts[j*H+k-1]);
                      tris.push.apply(tris, pnts[j*H+k-1]); tris.push.apply(tris, pnts[(j-1)*H+k]); tris.push.apply(tris, pnts[j*H+k]);
                  }}
                  sphere = { va : createVA(tris,undefined) }; sphere.va.tcount = tris.length/3;
                }
                var oldM = M;
                M=[].concat.apply([],Element.Mul([[d.weight2,0,0,0],[0,d.weight2,0,0],[0,0,d.weight2,0],[d.pos[0],d.pos[1],d.pos[2],1]],[[M[0],M[1],M[2],M[3]],[M[4],M[5],M[6],M[7]],[M[8],M[9],M[10],M[11]],[M[12],M[13],M[14],M[15]]])).map(x=>x.s);
                gl.enable(gl.BLEND); gl.blendFunc(gl.CONSTANT_ALPHA, gl.ONE_MINUS_CONSTANT_ALPHA); gl.blendColor(1,1,1,0.5); gl.enable(gl.CULL_FACE);
                draw(program,gl.TRIANGLES,undefined,c,[0,0,0],r,undefined,sphere.va);
                gl.disable(gl.BLEND); gl.disable(gl.CULL_FACE);
                M = oldM;
              }
              if (i==ll-1 || d.tp==0) {
              // render triangles, lines, points.
                if (alpha) { gl.enable(gl.BLEND); gl.blendFunc(gl.CONSTANT_ALPHA, gl.ONE_MINUS_CONSTANT_ALPHA); gl.blendColor(1,1,1,1-alpha); }
                if (t.length) { draw(program,gl.TRIANGLES,t,c,[0,0,0],r); t.forEach((x,i)=>{ if (i%9==0) lastpos=[0,0,0]; lastpos[i%3]+=x/3; }); t=[];  }
                if (l.length) {
                  var ltest = [], ltest2 = [], ttest = []; for (var li=0; li<l.length; li+=6) {
                    ltest.push(...line_to_tri(l.slice(li,li+6)));
                    ltest2.push(...line_to_tri2(l.slice(li,li+6)));
                    var w = (options.lineWidth||1);
                    ttest.push(w,1-alpha,-w,1-alpha,w,1-alpha,w,1-alpha,-w,1-alpha,-w,1-alpha);
                  }
                  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); gl.enable(gl.BLEND);
                  draw(programline, gl.TRIANGLES, ltest, [canvas.width/canvas.height,.003,0.0], c, canvas.width/canvas.height, ttest, undefined, ltest2);
                  var l2=l.length-1; lastpos=[(l[l2-2]+l[l2-5])/2,(l[l2-1]+l[l2-4])/2+0.1,(l[l2]+l[l2-3])/2]; l=[];
                  gl.disable(gl.BLEND);
                }
                if (p.length) { gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); draw(programPoint,gl.POINTS,p,[0,0,0],c,r); lastpos = p.slice(-3); lastpos[0]-=0.075; lastpos[1]+=0.075; p=[]; gl.disable(gl.BLEND); }
                // Motor orbits
                  if ( e.call && e.length==2 && !e.va3) { var countx=e.dx||32,county=e.dy||32;
                    var temp=new Float32Array(3*countx*county),o=new Float32Array(3),et=[];
                    for (var pp=0,ii=0; ii<countx; ii++) for (var jj=0; jj<county; jj++,pp+=3)
                      temp.set(Element.sw(e(ii/(countx-1),jj/(county-1)),no).slice(1,4),pp);
                    for (ii=0; ii<countx-1; ii++) for (var jj=0; jj<county; jj++)
                      et.push((ii+0)*county+(jj+0),(ii+0)*county+(jj+1),(ii+1)*county+(jj+1),(ii+0)*county+(jj+0),(ii+1)*county+(jj+1),(ii+1)*county+(jj+0));
                    e.va3 = createVA(temp,undefined,et.map(x=>x%(countx*county))); e.va3.tcount = (countx-1)*county*2*3;
                  }
                  if ( e.call && e.length==1 && !e.va2) { var countx=e.dx||256;
                    var temp=new Float32Array(3*countx),o=new Float32Array(3),et=[];
                    for (var ii=0; ii<countx; ii++) { temp.set(Element.sw(e(ii/(countx-1)),no).slice(1,4),ii*3); if (ii) et.push(ii-1,ii); }
                    e.va2 = createVA(temp,undefined,et); e.va2.tcount = et.length;
                  }
                // Experimental display of motors using particle systems.
                  if (e instanceof Object && e.motor) {
                    if (!e.va || e.recalc) {
                       var seed = 1; function random() { var x = Math.sin(seed++) * 10000; return x - Math.floor(x); }
                       e.xRange = e.xRange === undefined ? 1:e.xRange; e.yRange = e.yRange === undefined ? 1:e.yRange; e.zRange = e.zRange === undefined ? 1:e.zRange;
                       var vtx=[], tx=[], vtx2=[];
                       for (var i=0; i<(e.zRange*e.xRange*e.yRange===0?2500:Math.pow(e.zRange*e.xRange*e.yRange,1/3)*6000); i++) {
                         var [x,y,z] = [random()*(2*e.xRange)-e.xRange,random()*2*e.yRange-e.yRange,random()*2*e.zRange-e.zRange];
                         var xyz = (x*x+y*y+z*z)*0.5;
                         var p  = Element.Vector(x,y,z,xyz-0.5,xyz+0.5);
                         var p2 = Element.sw(e.motor,p);
                         var d = p2[5]-p2[4]; p2[1]/=d; p2[2]/=d; p2[3]/=d;
                         tx.push(random(), random());
                         vtx.push(...p.slice(1,4)); vtx2.push(...p2.slice(1,4));
                       }
                       e.va = createVA(vtx,tx,undefined,vtx2); e.va.tcount = vtx.length/3;
                       e.recalc = false;
                    }
                    var time = performance.now()/1000;
                    gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); gl.disable(gl.DEPTH_TEST);
                    draw(programmot, gl.POINTS,t,c,[time%1,0,0],r,undefined,e.va);
                    gl.disable(gl.BLEND); gl.enable(gl.DEPTH_TEST);
                  }
                // we could also be an object with cached vertex array of triangles ..
                  else if (e.va || e.va2 || e.va3 || (e instanceof Object && e.data)) {
                    // Create the vertex array and store it for re-use.
                    if (!e.va3 && !e.va2) {
                      var et=[],et2=[],et3=[],lc=0,pc=0,tc=0; e.data.forEach(e=>{
                        if (e instanceof Array && e.length==3) { tc++; e.forEach(x=>{ while (x.call) x=x.call(); x=interprete(x);et3.push.apply(et3,x.pos); });  var d = {tp:-1}; }
                        else {
                          var d = interprete(e);
                          if (d.tp==1) { pc++; et.push(...d.pos);  }
                          if (d.tp==2) { lc++; et2.push(...d.pos.map((x,i)=>x-d.normal[i]*10),...d.pos.map((x,i)=>x+d.normal[i]*10)); }
                        }
                      });
                      e.va = createVA(et,undefined); e.va.tcount = pc;
                      e.va2 = createVA(et2,undefined); e.va2.tcount = lc*2;
                      e.va3 = createVA(et3,undefined); e.va3.tcount = tc*3;
                    }
                    // render the vertex array.
                    if (e.va  && e.va.tcount) { gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); draw(programPoint,gl.POINTS,undefined,[0,0,0],c,r,undefined,e.va); gl.disable(gl.BLEND); }                    if (e.va2 && e.va2.tcount) draw(program,gl.LINES,undefined,[0,0,0],c,r,undefined,e.va2);
                    if (e.va3 && e.va3.tcount) draw(program,gl.TRIANGLES,undefined,c,[0,0,0],r,undefined,e.va3);
                  }
                if (alpha) gl.disable(gl.BLEND); // no alpha for text printing.
              // setup a new color
                if (typeof e == "number") { alpha=((e>>>24)&0xff)/255; c[0]=((e>>>16)&0xff)/255; c[1]=((e>>>8)&0xff)/255; c[2]=(e&0xff)/255; }
                if (typeof(e)=='string') {
                  if (options.htmlText) {
                    if (!x['_'+i]) { console.log('creating div'); Object.defineProperty(x,'_'+i, {value: document.body.appendChild(document.createElement('div')), enumerable:false }); }                    var rc = canvas.getBoundingClientRect(), div = x['_'+i];
                    var pos2 = Element.Mul( [[M[0],M[4],M[8],M[12]],[M[1],M[5],M[9],M[13]],[M[2],M[6],M[10],M[14]],[M[3],M[7],M[11],M[15]]], [...lastpos,1]).map(x=>x.s);
                    pos2 = Element.Mul( [[5,0,0,0],[0,5*(r||2),0,0],[0,0,1,-1],[0,0,2,0]], pos2).map(x=>x.s).map((x,i,a)=>x/a[3]);
                    Object.assign(div.style,{position:'fixed',pointerEvents:'none',left:rc.left + (rc.right-rc.left)*(pos2[0]/2+0.5),top: rc.top + (rc.bottom-rc.top)*(-pos2[1]/2+0.5) - 20});
                    if (div.last != e) { div.innerHTML = e; div.last = e; if (self.renderMathInElement) self.renderMathInElement(div); }
                  } else {
                    gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
                    var fw = 113, mapChar = (x)=>{ var c = x.charCodeAt(0)-33; if (c>=94) c = 94+specialChars.indexOf(x); return c/fw; };
                    draw(program2,gl.TRIANGLES,
                         [...Array(e.length*6*3)].map((x,i)=>{ var x=0,z=-0.2, o=x+(i/18|0)*1.1; return (0.05*(options.z||5))*[o,-1,z,o+1.2,-1,z,o,1,z,o+1.2,-1,z,o+1.2,1,z,o,1,z][i%18]}),c,lastpos,r,
                         [...Array(e.length*6*2)].map((x,i)=>{ var o=mapChar(e[i/12|0]); return [o,1,o+1/fw,1,o,0,o+1/fw,1,o+1/fw,0,o,0][i%12]})); gl.disable(gl.BLEND); lastpos[1]-=0.18;
                  }
                }
              }
              continue;
            }
          // PGA
            if (options.dual && e instanceof Element) e = e.Dual;
          // Convert planes to polygons.
            if (e instanceof Element && e.Grade(1).Length > 0.001) {
              var m = Element.Add(1, Element.Mul(e.Normalized, Element.Coeff(3,1))).Normalized, e0 = 0;
              e=Element.sw(m,[[-1,-1],[-1,1],[1,1],[-1,-1],[1,1],[1,-1]].map(([x,z])=>Element.Trivector(x*e.Length,e0,z*e.Length,1)));
            }
          // Convert lines to line segments.
            if (e instanceof Element && e.Grade(2).Length)
               e=[e.LDot(e14).Wedge(e).Add(e.Wedge(Element.Coeff(1,1)).Mul(Element.Coeff(0,-500))),e.LDot(e14).Wedge(e).Add(e.Wedge(Element.Coeff(1,1)).Mul(Element.Coeff(0,500)))];
          // If euclidean point, store as point, store line segments and triangles.
            if (e.e123) p.push.apply(p,e.slice(11,14).map((y,i)=>(i<=1?1:-1)*y/e[14]).reverse());
            if (e instanceof Array && e.length==2) l=l.concat.apply(l,e.map(x=>[...x.slice(11,14).map((y,i)=>(i<=1?1:-1)*y/x[14]).reverse()]));
            if (e instanceof Array && e.length%3==0) t=t.concat.apply(t,e.map(x=>[...x.slice(11,14).map((y,i)=>(i<=1?1:-1)*y/x[14]).reverse()]));
          // Render orbits of parametrised motors, as well as lists of points..
            function sw_mot_orig(A,R){
              var a0=A[0],a1=A[5],a2=A[6],a3=A[7],a4=A[8],a5=A[9],a6=A[10],a7=A[15];
              R[2] = -2*(a0*a3+a4*a7-a6*a2-a5*a1);
              R[1] = -2*(a4*a1-a0*a2-a6*a3+a5*a7);
              R[0] =  2*(a0*a1+a4*a2+a5*a3+a6*a7);
              return R
            }
            if ( e.call && e.length==1) { var count=e.dx||64;
              for (var ismot,xx,o=new Float32Array(3),ii=0; ii<count; ii++) {
                if (ii>1) l.push(xx[0],xx[1],xx[2]);
                var m = e(ii/(count-1));
                if (ii==0) ismot = m[0]||m[5]||m[6]||m[7]||m[8]||m[9]||m[10];
                xx = ismot?sw_mot_orig(m,o):m.slice(11,14).map((y,i)=>(i<=1?1:-1)*y).reverse(); //Element.sw(e(ii/(count-1)),o);
                l.push(xx[0],xx[1],xx[2]);
              }
            }
            if ( e.call && e.length==2 && !e.va) { var countx=e.dx||64,county=e.dy||32;
              var temp=new Float32Array(3*countx*county),o=new Float32Array(3),et=[];
              for (var pp=0,ii=0; ii<countx; ii++) for (var jj=0; jj<county; jj++,pp+=3) temp.set(sw_mot_orig(e(ii/(countx-1),jj/(county-1)),o),pp);
              for (ii=0; ii<countx-1; ii++) for (var jj=0; jj<county; jj++) et.push((ii+0)*county+(jj+0),(ii+0)*county+(jj+1),(ii+1)*county+(jj+1),(ii+0)*county+(jj+0),(ii+1)*county+(jj+1),(ii+1)*county+(jj+0));
              e.va = createVA(temp,undefined,et.map(x=>x%(countx*county))); e.va.tcount = (countx-1)*county*2*3;
            }
          // Experimental display of motors using particle systems.
            if (e instanceof Object && e.motor) {
              if (!e.va || e.recalc) {
                 var seed = 1; function random() { var x = Math.sin(seed++) * 10000; return x - Math.floor(x); }
                 e.xRange = e.xRange === undefined ? 1:e.xRange; e.yRange = e.yRange === undefined ? 1:e.yRange; e.zRange = e.zRange === undefined ? 1:e.zRange;
                 var vtx=[], tx=[], vtx2=[];
                 for (var i=0; i<(e.zRange===0?5000:60000); i++) {
                   var p  = Element.Trivector(random()*(2*e.xRange)-e.xRange,random()*2*e.yRange-e.yRange,random()*2*e.zRange-e.zRange,1);
//                   var p2 = Element.sw(e.motor,p);
                   var p2 = e.motor.Mul(p).Mul(e.motor.Inverse);
                   tx.push(random(), random());
                   vtx.push(...p.slice(11,14).reverse()); vtx2.push(...p2.slice(11,14).reverse());
                 }
                 e.va = createVA(vtx,tx,undefined,vtx2); e.va.tcount = vtx.length/3;
                 e.recalc = false;
              }
              var time = performance.now()/1000;
              gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); gl.disable(gl.DEPTH_TEST);
              draw(programmot, gl.POINTS,t,c,[time%1,0,0],r,undefined,e.va);
              gl.disable(gl.BLEND); gl.enable(gl.DEPTH_TEST);
            }
          // we could also be an object with cached vertex array of triangles ..
            else if (e.va || (e instanceof Object && e.data)) {
              // Create the vertex array and store it for re-use.
              if (!e.va) {
                if (e.idx) {
                  var et = e.data.map(x=>[...x.slice(11,14).map((y,i)=>(i<=1?1:-1)*y/x[14]).reverse()]).flat();
                } else {
                  var et=[]; e.data.forEach(e=>{if (e instanceof Array && e.length==3) et=et.concat.apply(et,e.map(x=>[...x.slice(11,14).map((y,i)=>(i<=1?1:-1)*y/x[14]).reverse()]));});
                }
                e.va = createVA(et,undefined,e.idx,e.color?new Float32Array(e.color):undefined); e.va.tcount = (e.idx && e.idx.length)?e.idx.length:e.data.length*3;
              }
              // render the vertex array.
              var M5 = Element.Scalar(1).Add(Element.Coeff(7,2.5));
              if (e.transform) {
                  var M1 = mtx(e.transform, false);
                  var M2 = mtx(M5.Mul(options.camera), false);
                  M = Array(16).fill(0);
                  for (var ii=0; ii<4; ++ii) for (var jj=0; jj<4; ++jj) for (var kk=0; kk<4; ++kk) M[ii*4+kk] += M1[ii*4+jj] * M2[jj*4+kk];
               }
              if (alpha) { gl.enable(gl.BLEND); gl.blendFunc(gl.CONSTANT_ALPHA, gl.ONE_MINUS_CONSTANT_ALPHA); gl.blendColor(1,1,1,1-alpha); }
              draw(e.color?programcol:program,gl.TRIANGLES,t,c,[0,0,0],r,undefined,e.va);
              if (alpha) gl.disable(gl.BLEND);
              if (e.transform) { M=mtx(options.camera); }
            }
            // if we're a number (color), label or the last item, we output the collected items.
            else if (typeof e=='number' || i==ll-1 || typeof e == 'string') {
            // render triangles, lines, points.
              if (alpha) { gl.enable(gl.BLEND); gl.blendFunc(gl.CONSTANT_ALPHA, gl.ONE_MINUS_CONSTANT_ALPHA); gl.blendColor(1,1,1,1-alpha); }
              if (t.length) { draw(program,gl.TRIANGLES,t,c,[0,0,0],r); t.forEach((x,i)=>{ if (i%9==0) lastpos=[0,0,0]; lastpos[i%3]+=x/3; }); t=[];  }
              if (l.length) {
                var ltest = [], ltest2 = [], ttest = [],  w = (options.lineWidth||1); for (var li=0; li<l.length; li+=6) {
                  ltest.push(...line_to_tri(l.slice(li,li+6)));
                  ltest2.push(...line_to_tri2(l.slice(li,li+6)));
                  ttest.push(w,1-alpha,-w,1-alpha,w,1-alpha,w,1-alpha,-w,1-alpha,-w,1-alpha);
                }
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); gl.enable(gl.BLEND);
                draw(programline, gl.TRIANGLES, ltest, [canvas.width/canvas.height,.003,0.0], c, canvas.width/canvas.height, ttest, undefined, ltest2);
                var l2=l.length-1; lastpos=[(l[l2-2]+l[l2-5])/2,(l[l2-1]+l[l2-4])/2+0.1,(l[l2]+l[l2-3])/2]; l=[];
                gl.disable(gl.BLEND);
              }
              if (p.length) { gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); draw(programPoint,gl.POINTS,p,[0,0,0],c,r); lastpos = p.slice(-3); lastpos[0]-=0.075; lastpos[1]+=0.075; p=[];gl.disable(gl.BLEND); }
              if (alpha) gl.disable(gl.BLEND);
            // setup a new color
              if (typeof e == "number") { alpha=((e>>>24)&0xff)/255; c[0]=((e>>>16)&0xff)/255; c[1]=((e>>>8)&0xff)/255; c[2]=(e&0xff)/255; }
            // render a label
              if (typeof(e)=='string') {
                if (options.htmlText) {
                  if (!canvas['_'+i]) { console.log('creating div'); Object.defineProperty(canvas,'_'+i, {value: document.body.appendChild(document.createElement('div')), enumerable:false }); }                  var rc = canvas.getBoundingClientRect(), div = canvas['_'+i];
                  var pos2 = Element.Mul( [[M[0],M[4],M[8],M[12]],[M[1],M[5],M[9],M[13]],[M[2],M[6],M[10],M[14]],[M[3],M[7],M[11],M[15]]], [...lastpos,1]).map(x=>x.s);
                  pos2 = Element.Mul( [[5,0,0,0],[0,5*(r||2),0,0],[0,0,1,-1],[0,0,2,0]], pos2).map(x=>x.s).map((x,i,a)=>x/a[3]);
                  Object.assign(div.style,{position:'fixed',pointerEvents:'none',left:rc.left + (rc.right-rc.left)*(pos2[0]/2+0.5),top: rc.top + (rc.bottom-rc.top)*(-pos2[1]/2+0.5) - 20});
                  if (div.last != e) { div.innerHTML = e; div.last = e; if (self.renderMathInElement) self.renderMathInElement(div,{output:'html'});  }
                } else {
                  gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA); gl.disable(gl.DEPTH_TEST);
                  var fw = 113, mapChar = (x)=>{ var c = x.charCodeAt(0)-33; if (c>=94) c = 94+specialChars.indexOf(x); return c/fw; };
                  draw(program2,gl.TRIANGLES,
                       [...Array(e.length*6*3)].map((x,i)=>{ var x=0,z=-0.2, o=x+(i/18|0)*1.1; return 0.25*[o,-1,z,o+1.2,-1,z,o,1,z,o+1.2,-1,z,o+1.2,1,z,o,1,z][i%18]}),c,lastpos,r,
                       [...Array(e.length*6*2)].map((x,i)=>{ var o=mapChar(e[i/12|0]); return [o,1,o+1/fw,1,o,0,o+1/fw,1,o+1/fw,0,o,0][i%12]})); gl.disable(gl.BLEND); lastpos[1]-=0.18;
                  if (!options.noZ) gl.enable(gl.DEPTH_TEST);
                }
              }
            }
          }          // if we're no longer in the page .. stop doing the work.
          armed++; if (document.body.contains(canvas)) armed=0; if (armed==2) return;
          canvas.value=x; if (options&&!options.animate) canvas.dispatchEvent(new CustomEvent('input')); canvas.options=options;
          if (options&&options.animate) { requestAnimationFrame(canvas.update.bind(canvas,f,options)); }
          if (options&&options.still) { canvas.value=x; canvas.dispatchEvent(new CustomEvent('input')); canvas.im.style.width=canvas.style.width; canvas.im.style.height=canvas.style.height; canvas.im.src = canvas.toDataURL();
            var p=canvas.parentElement;  if (p) { p.insertBefore(canvas.im,canvas); p.removeChild(canvas); }
          }
        };
        // Basic mouse interactivity. needs more love.
        var sel=-1; canvas.oncontextmenu = canvas.onmousedown = (e)=>{e.preventDefault(); e.stopPropagation();  if (e.detail===0) return;
          var rc = canvas.getBoundingClientRect(), mx=(e.x-rc.left)/(rc.right-rc.left)*2-1, my=((e.y-rc.top)/(rc.bottom-rc.top)*4-2)*canvas.height/canvas.width;
          sel = (e.button==2)?-3:-2; canvas.value.forEach((x,i)=>{
            if (tot != 5) { if (x[14]) {
              var pos2 = Element.Mul( [[M[0],M[4],M[8],M[12]],[M[1],M[5],M[9],M[13]],[M[2],M[6],M[10],M[14]],[M[3],M[7],M[11],M[15]]], [-x[13]/x[14],-x[12]/x[14],x[11]/x[14],1]).map(x=>x.s);
              pos2 = Element.Mul( [[5,0,0,0],[0,5*(2),0,0],[0,0,1,-1],[0,0,2,0]], pos2).map(x=>x.s).map((x,i,a)=>x/a[3]);
              if ((mx-pos2[0])**2 + ((my)-pos2[1])**2 < 0.02) sel=i;
            }} else {
              x = interprete(x); if (x.tp==1) {
                var pos2 = Element.Mul( [[M[0],M[4],M[8],M[12]],[M[1],M[5],M[9],M[13]],[M[2],M[6],M[10],M[14]],[M[3],M[7],M[11],M[15]]], [...x.pos,1]).map(x=>x.s);
                pos2 = Element.Mul( [[5,0,0,0],[0,5*(r||2),0,0],[0,0,1,-1],[0,0,2,0]], pos2).map(x=>x.s).map((x,i,a)=>x/a[3]);
                if ((mx-pos2[0])**2 + ((-my)-pos2[1])**2 < 0.01) sel=i;
              }
            }
          });
          canvas.onwheel=e=>{e.preventDefault(); e.stopPropagation(); options.z = (options.z||5)+e.deltaY/100; if (!options.animate) requestAnimationFrame(canvas.update.bind(canvas,f,options));};
          canvas.onmouseup=e=>sel=-1; canvas.onmouseleave=e=>sel=-1;
          var tx,ty; canvas.ontouchstart = (e)=>{e.preventDefault();  canvas.focus(); var x = e.changedTouches[0].pageX, y = e.changedTouches[0].pageY; tx=x; ty=y; };
          canvas.ontouchmove = function (e) { e.preventDefault();
             var x = e.changedTouches[0].pageX, y = e.changedTouches[0].pageY, mx = (x-(tx||x))/1000, my = -(y-(ty||y))/1000; tx=x; ty=y;
             options.h = (options.h||0)+mx; options.p = Math.max(-Math.PI/2,Math.min(Math.PI/2, (options.p||0)+my)); if (!options.animate) requestAnimationFrame(canvas.update.bind(canvas,f,options)); return;
          };
          canvas.onmousemove=(e)=>{
            var rc = canvas.getBoundingClientRect(),x; if (sel>=0) { if (tot==5) x=interprete(canvas.value[sel]); else { x=canvas.value[sel]; x={pos:[-x[13]/x[14],-x[12]/x[14],x[11]/x[14]]};  }}
            var mx =(e.movementX)/(rc.right-rc.left)*2, my=((e.movementY)/(rc.bottom-rc.top)*2)*canvas.height/canvas.width;
            if (sel==-2) { options.h = (options.h||0)+(options.conformal?-1:1)*mx/2; options.p = Math.max(-Math.PI/2,Math.min(Math.PI/2, (options.p||0)-my/2)); if (options.camera) options.camera.set( ( Element.Bivector(0,0,0,0,0,options.p).Exp() ).Mul( Element.Bivector(0,0,0,0,options.h,0).Exp() )); if (!options.animate) requestAnimationFrame(canvas.update.bind(canvas,f,options)); return; }            if (sel==-3) { var ct = Math.cos(options.h||0), st= Math.sin(options.h||0), ct2 = Math.cos(options.p||0); Math.sin(options.p||0);
              if (e.shiftKey) { options.posy = (options.posy||0)+my; } else { options.posx = (options.posx||0)+mx*ct+my*st; options.posz = (options.posz||0)+mx*-st+my*ct*ct2; } if (!options.animate) requestAnimationFrame(canvas.update.bind(canvas,f,options));return; } if (sel < 0) return;
            if (tot==5) {
               x.pos[0] += (e.buttons!=2)?Math.cos((options.h||0))*mx:Math.sin(-(options.h||0))*-my; x.pos[1]+=(e.buttons!=2)?-my:0; x.pos[2]+=(e.buttons!=2)?Math.sin((options.h||0))*mx:Math.cos(-(options.h||0))*-my;
               canvas.value[sel].set(Element.Mul(ni,(x.pos[0]**2+x.pos[1]**2+x.pos[2]**2)*0.5).Sub(no)); canvas.value[sel].set(x.pos,1); }
            else if (x) {
               canvas.value[sel].set(   Element.sw(Element.sw(options.camera.Reverse,Element.Bivector(-mx/2,my/2,0,0,0,0).Exp()),canvas.value[sel]) );
            }
            if (!options.animate) requestAnimationFrame(canvas.update.bind(canvas,f,options));
          };
        };
        canvas.value = f.call?f():f; canvas.options=options;
        if (options&&options.still) {
          var i=new Image(); canvas.im = i; return requestAnimationFrame(canvas.update.bind(canvas,f,options)),canvas;
        } else return requestAnimationFrame(canvas.update.bind(canvas,f,options)),canvas;
      }

    // The inline function is a js to js translator that adds operator overloading and algebraic literals.
    // It can be called with a function, a string, or used as a template function.
      static inline(intxt) {
      // If we are called as a template function.
        if (arguments.length>1 || intxt instanceof Array) {
          var args=[].slice.call(arguments,1);
          return res.inline(new Function(args.map((x,i)=>'_template_'+i).join(),'return ('+intxt.map((x,i)=>(x||'')+(args[i]&&('_template_'+i)||'')).join('')+')')).apply(res,args);
        }
      // Get the source input text.
        var txt = (intxt instanceof Function)?intxt.toString():`function(){return (${intxt})}`;
      // Our tokenizer reads the text token by token and stores it in the tok array (as type/token tuples).
        var tok = [], resi=[], t, possibleRegex=false, c, tokens = [/^[\s\uFFFF]|^[\u000A\u000D\u2028\u2029]|^\/\/[^\n]*\n|^\/\*[\s\S]*?\*\//g,                 // 0: whitespace/comments
          /^\"\"|^\'\'|^\".*?[^\\]\"|^\'.*?[^\\]\'|^\`[\s\S]*?[^\\]\`/g,                                                                // 1: literal strings
          /^\d+[.]{0,1}\d*[ei][\+\-_]{0,1}\d*|^\.\d+[ei][\+\-_]{0,1}\d*|^e_\d*/g,                                                       // 2: literal numbers in scientific notation (with small hack for i and e_ asciimath)
          /^\d+[.]{0,1}\d*[E][+-]{0,1}\d*|^\.\d+[E][+-]{0,1}\d*|^0x\d+|^\d+[.]{0,1}\d*|^\.\d+/g,                                        // 3: literal hex, nonsci numbers
          /^\/.*?[^\\]\/[gmisuy]?/g,                                                                                                    // 4: regex
          /^(\.Normalized|\.Length|\.\.\.|>>>=|===|!==|>>>|<<=|>>=|=>|\|\||[<>\+\-\*%&|^\/!\=]=|\*\*|\+\+|\-\-|<<|>>|\&\&|\^\^|^[{}()\[\];.,<>\+\-\*%|&^!~?:=\/]{1})/g,   // 5: punctuator
          /^[$_\p{L}][$_\p{L}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\u200C\u200D]*/gu];                                                                 // 6: identifier
        while (txt.length) for (t in tokens) {
          if (t == 4 && !possibleRegex) continue;
          if (resi = txt.match(tokens[t])) {
            c = resi[0]; if (t!=0) {possibleRegex = c == '(' || c == '=' || c == '[' || c == ',' || c == ';';} tok.push([t | 0, c]); txt = txt.slice(c.length); break;
          }} // tokenise
      // Translate algebraic literals. (scientific e-notation to "this.Coeff"
        tok=tok.map(t=>(t[0]==2)?[2,'Element.Coeff('+basis.indexOf((!options.Cayley?simplify:(x)=>x)('e'+t[1].split(/e_|e|i/)[1]||1).replace('-',''))+','+(simplify(t[1].split(/e_|e|i/)[1]||1).match('-')?"-1*":"")+parseFloat(t[1][0]=='e'?1:t[1].split(/e_|e|i/)[0])+')']:t);
      // String templates (limited support - needs fundamental changes.).
        tok=tok.map(t=>(t[0]==1 && t[1][0]=='`')?[1,t[1].replace(/\$\{(.*?)\}/g,a=>"${"+Element.inline(a.slice(2,-1)).toString().match(/return \((.*)\)/)[1]+"}")]:t);
      // We support two syntaxes, standard js or if you pass in a text, asciimath.
        var syntax = (intxt instanceof Function)?[[['.Normalized','Normalize',2],['.Length','Length',2]],[['~','Conjugate',1],['!','Dual',1]],[['**','Pow',0,1]],[['^','Wedge'],['&','Vee'],['<<','LDot']],[['*','Mul'],['/','Div']],[['|','Dot']],[['>>>','sw',0,1]],[['-','Sub'],['+','Add']],[['%','%']],[['==','eq'],['!=','neq'],['<','lt'],['>','gt'],['<=','lte'],['>=','gte']]]
                                                :[[['pi','Math.PI'],['sin','Math.sin']],[['ddot','this.Reverse'],['tilde','this.Involute'],['hat','this.Conjugate'],['bar','this.Dual']],[['^','Pow',0,1]],[['^^','Wedge'],['*','LDot']],[['**','Mul'],['/','Div']],[['-','Sub'],['+','Add']],[['<','lt'],['>','gt'],['<=','lte'],['>=','gte']]];
      // For asciimath, some fixed translations apply (like pi->Math.PI) etc ..
        tok=tok.map(t=>(t[0]!=6)?t:[].concat.apply([],syntax).filter(x=>x[0]==t[1]).length?[6,[].concat.apply([],syntax).filter(x=>x[0]==t[1])[0][1]]:t);
      // Now the token-stream is translated recursively.
        function translate(tokens) {
          // helpers : first token to the left of x that is not of a type in the skip list.
          var left = (x=ti-1,skip=[0])=>{ while(x>=0&&~skip.indexOf(tokens[x][0])) x--; return x; },
          // first token to the right of x that is not of a type in the skip list.
              right= (x=ti+1,skip=[0])=>{ while(x<tokens.length&&~skip.indexOf(tokens[x][0])) x++; return x; },
          // glue from x to y as new type, optionally replace the substring with sub.
              glue = (x,y,tp=6,sub)=>{tokens.splice(x,y-x+1,[tp,...(sub||tokens.slice(x,y+1))]);},
          // match O-C pairs. returns the 'matching bracket' position
              match = (O="(",C=")")=>{var o=1,x=ti+1; while(o){if(tokens[x][1]==O)o++;if(tokens[x][1]==C)o--; x++;} return x-1;};
          // grouping (resolving brackets).
          for (var ti=0,t,si;t=tokens[ti];ti++) if (t[1]=="(") glue(ti,si=match(),7,[[5,"("],...translate(tokens.slice(ti+1,si)),[5,")"]]);
          // [] dot call and new
          for (var ti=0,t,si; t=tokens[ti];ti++) {
            if (t[1]=="[") { glue(ti,si=match("[","]"),7,[[5,"["],...translate(tokens.slice(ti+1,si)),[5,"]"]]); if (ti)ti--;}    // matching []
            else if (t[1]==".") { glue(left(),right()); ti--; }                                                                   // dot operator
            else if (t[0]==7 && ti && left()>=0 && tokens[left()][0]>=6 && tokens[left()][1]!="return") { glue(left(),ti--); }     // collate ( and [
            else if (t[1]=='new') { glue(ti,right()); }          }
          // ++ and --
          for (var ti=0,t; t=tokens[ti];ti++) if (t[1]=="++" || t[1]=="--") glue(left(),ti);
          // unary - and + are handled separately from syntax ..
          for (var ti=0,t,si; t=tokens[ti];ti++)
            if (t[1]=="-" && (left()<0 || (tokens[left()]||[5])[0]==5)) glue(ti,right(),6,["Element.Sub(",tokens[right()],")"]);   // unary minus works on all types.
            else if (t[1]=="+" && (tokens[left()]||[0])[0]==5 && (tokens[left()]||[0])[1][0]!=".") glue(ti,ti+1);                   // unary plus is glued, only on scalars.
          // now process all operators in the syntax list ..
          for (var si=0,s; s=syntax[si]; si++) for (var ti=s[0][3]?tokens.length-1:0,t; t=tokens[ti];s[0][3]?ti--:ti++) for (var opi=0,op; op=s[opi]; opi++) if (t[1]==op[0]) {
            // exception case .. ".Normalized" and ".Length" properties are re-routed (so they work on scalars etc ..)
                  if (op[2]==2) { var arg=tokens[left()]; glue(ti-1,ti,6,["Element."+op[1],"(",arg,")"]); }
            // unary operators (all are to the left)
              else if (op[2])    { var arg=tokens[right()]; glue(ti, right(), 6, ["Element."+op[1],"(",arg,")"]); }
            // binary operators
                            else { var l=left(),r=right(),a1=tokens[l],a2=tokens[r]; if (op[0]==op[1]) glue(l,r,6,[a1,op[1],a2]); else glue(l,r,6,["Element."+op[1],"(",a1,",",a2,")"]); ti--; }
          }
          return tokens;
      }
      // Glue all back together and return as bound function.
        return eval( ('('+(function f(t){return t.map(t=>t instanceof Array?f(t):typeof t == "string"?t:"").join('');})(translate(tok))+')') );
      }
    };

    if ((p==2 || p==3) && (r==1)) {
      res.arrow = res.inline(( from_point, to_point, w=0.03, aspect=0.8 )=>{
        from_point = from_point/(-from_point|!1e0); to_point = to_point/(-to_point|!1e0);
        var line = ( to_point & from_point ), l = line.Length;
        var shape = [[0,w],[l-5*w,w],[l-5*w,aspect*5*w],[l,0],[l-5*w,-aspect*5*w],[l-5*w,-w],[0,-w]].map(([x,y])=>!(1e0+x*1e1+y*1e2));
        return (1+from_point/!1e0).Normalized*(1+(((to_point) - from_point) & !1e0).Normalized/(!1e1 & !1e0)).Normalized >>> shape;
      });
    }

    if (options.dual) {
      Object.defineProperty(res.prototype, 'Inverse', {configurable:true, get(){ var s = 1/this.s**2; return this.map((x,i)=>i?-x*s:1/x ); }});
    } else {
    // Matrix-free inverses up to 5D. Should translate this to an inline call for readability.
    // http://repository.essex.ac.uk/17282/1/TechReport_CES-534.pdf
      Object.defineProperty(res.prototype, 'Inverse', {configurable: true, get(){
        // Shirokov inverse ..
        if (tot > 5) {
          for (var N=2**(((tot+1)/2)|0), Uk=this.Scale(1), k=1; k<N; ++k) {
            var adjU = Uk.Sub(this.constructor.Scalar((N/k) * Uk.s));
            Uk = this.Mul(adjU);
          }
          return Uk.s == 0 ? 0:adjU.Scale( 1/Uk.s );
        }
        return (tot==0)?new this.constructor.Scalar([1/this[0]]):
               (tot==1)?this.Involute.Mul(this.constructor.Scalar(1/this.Mul(this.Involute)[0])):
               (tot==2)?this.Conjugate.Mul(this.constructor.Scalar(1/this.Mul(this.Conjugate)[0])):
               (tot==3)?this.Reverse.Mul(this.Involute).Mul(this.Conjugate).Mul( this.constructor.Scalar(1/this.Mul(this.Conjugate).Mul(this.Involute).Mul(this.Reverse)[0])):
               (tot==4)?this.Conjugate.Mul(this.Mul(this.Conjugate).Map(3,4)).Mul( this.constructor.Scalar(1/this.Mul(this.Conjugate).Mul(this.Mul(this.Conjugate).Map(3,4))[0])):
                        this.Conjugate.Mul(this.Involute).Mul(this.Reverse).Mul(this.Mul(this.Conjugate).Mul(this.Involute).Mul(this.Reverse).Map(1,4)).Mul(this.constructor.Scalar(1/this.Mul(this.Conjugate).Mul(this.Involute).Mul(this.Reverse).Mul(this.Mul(this.Conjugate).Mul(this.Involute).Mul(this.Reverse).Map(1,4))[0]));
      }});
    }

    if (options.over) {
     // experimental. do not use.
      res.over = options.over;
      ["Mul","Add","Sub","Scale","Dot","Wedge","LDot","Vee"].forEach(x=>res.prototype[x] = options.over.inline(res.prototype[x]));
      res.prototype.Coeff   = function() { for (var i=0,l=arguments.length; i<l; i+=2) this[arguments[i]]=(arguments[i+1] instanceof options.over)?arguments[i+1]:options.over.Scalar(arguments[i+1]); return this; };
      res.prototype.upgrade = function () { for (var i=0; i<this.length; i++) this[i] = options.over.Scalar(0); };
      Object.defineProperty(res.prototype, 'Conjugate', {configurable:true,get(){var res = new this.constructor(); for (var i=0; i<this.length; i++) res[i]= this[i].slice().Scale([1,-1,-1,1][grades[i]%4]); return res; }});
      Object.defineProperty(res.prototype, 'Reverse',   {configurable:true,get(){var res = new this.constructor(); for (var i=0; i<this.length; i++) res[i]= this[i].slice().Scale([1,1,-1,-1][grades[i]%4]); return res; }});
      Object.defineProperty(res.prototype, 'Involute',  {configurable:true,get(){var res = new this.constructor(); for (var i=0; i<this.length; i++) res[i]= this[i].slice().Scale([1,-1,1,-1][grades[i]%4]); return res; }});
      Object.defineProperty(res.prototype, 'Inverse', {configurable: true, get(){
        return (tot==0)?new this.constructor.Scalar([this[0].Inverse]):
               (tot==1)?this.Involute.Mul(this.constructor.Scalar(this.Mul(this.Involute)[0].Inverse)):
               (tot==2)?this.Conjugate.Mul(this.constructor.Scalar(this.Mul(this.Conjugate)[0].Inverse)):
               (tot==3)?this.Reverse.Mul(this.Involute).Mul(this.Conjugate).Mul( this.constructor.Scalar(this.Mul(this.Conjugate).Mul(this.Involute).Mul(this.Reverse)[0].Inverse)):
               (tot==4)?this.Conjugate.Mul(this.Mul(this.Conjugate).Map(3,4)).Mul( this.constructor.Scalar(this.Mul(this.Conjugate).Mul(this.Mul(this.Conjugate).Map(3,4))[0].Inverse)):
                        this.Conjugate.Mul(this.Involute).Mul(this.Reverse).Mul(this.Mul(this.Conjugate).Mul(this.Involute).Mul(this.Reverse).Map(1,4)).Mul(this.constructor.Scalar(this.Mul(this.Conjugate).Mul(this.Involute).Mul(this.Reverse).Mul(this.Mul(this.Conjugate).Mul(this.Involute).Mul(this.Reverse).Map(1,4))[0].Inverse));
      }});
      res.prototype.toString = function() { return [...this].map((x,i)=>x==0?undefined:(i?'('+x+')'+basis[i]:x.toString())).filter(x=>x).join(' + '); };
    }

  // Experimental differential operator.
    var _D, _DT, _DA, totd = basis.length;
    function makeD(transpose=false){
      _DA = _DA || Algebra({ p:p,q:q,r:r,basis:options.basis,even:options.even,over:Algebra({dual:totd})}); // same algebra, but over dual numbers.
      return (func)=>{
        var dfunc = _DA.inline(func);                                                                       // convert input function to dual algebra
        return (val,...args)=>{                                                                             // return a new function (the derivative w.r.t 1st param)
          if (!(val instanceof res)) val = res.Scalar(val);                                                 // allow to be called with scalars.
          args = args.map(x=>{ var r = _DA.Scalar(0); for (var i=0; i<totd; i++) r[i][0]=x[i]; return r;}); // upcast args.
          for (var dval=_DA.Scalar(0),i=0; i<totd; i++) { dval[i][0] = val[i]; dval[i][1+i] = 1; }          var rval = dfunc(dval,...args); var r = [...Array(totd)].map(x=>val.slice());                     // call the function in the dual algebra.
          if (transpose) for (var i=0; i<totd; i++) for (var j=0; j<totd; j++) { r[i][j] = rval[i][j+1]; }  // downcast transpose from dual algebra to Jacobian vector.
          else for (var i=0; i<totd; i++) for (var j=0; j<totd; j++) { r[j][i] = rval[i][j+1]; }            // downcast from dual algebra to Jacobian vector.
          return r.length<=2?r[0]:r;                                                                        // return derivative or jacobian.
        }
      }
    }
    Object.defineProperty(res, 'D',  {configurable:true,get(){ if (_D) return _D; _D = makeD(false); return _D }});
    Object.defineProperty(res, 'Dt', {configurable:true,get(){ if (_DT) return _DT; _DT = makeD(true); return _DT }});

  // If a function was passed in, translate, call and return its result. Else just return the Algebra.
    if (fu instanceof Function) return res.inline(fu)(); else return res;
  }
}));
}(ganja));

var Algebra = ganja.exports;

var triangleVertexGL = "#version 300 es\nprecision highp float;\n#define GLSLIFY 1\n// for some reason `require` only works at top level\n// common functions and utilities\n// CGA3.glsl\nconst int Idx_CGA3_scalar = 0;\nconst int Idx_CGA3_e1 = 1;\nconst int Idx_CGA3_e2 = 2;\nconst int Idx_CGA3_e3 = 3;\nconst int Idx_CGA3_e4 = 4;\nconst int Idx_CGA3_e5 = 5;\nconst int Idx_CGA3_e12 = 6;\nconst int Idx_CGA3_e13 = 7;\nconst int Idx_CGA3_e14 = 8;\nconst int Idx_CGA3_e15 = 9;\nconst int Idx_CGA3_e23 = 10;\nconst int Idx_CGA3_e24 = 11;\nconst int Idx_CGA3_e25 = 12;\nconst int Idx_CGA3_e34 = 13;\nconst int Idx_CGA3_e35 = 14;\nconst int Idx_CGA3_e45 = 15;\nconst int Idx_CGA3_e123 = 16;\nconst int Idx_CGA3_e124 = 17;\nconst int Idx_CGA3_e125 = 18;\nconst int Idx_CGA3_e134 = 19;\nconst int Idx_CGA3_e135 = 20;\nconst int Idx_CGA3_e145 = 21;\nconst int Idx_CGA3_e234 = 22;\nconst int Idx_CGA3_e235 = 23;\nconst int Idx_CGA3_e245 = 24;\nconst int Idx_CGA3_e345 = 25;\nconst int Idx_CGA3_e1234 = 26;\nconst int Idx_CGA3_e1235 = 27;\nconst int Idx_CGA3_e1245 = 28;\nconst int Idx_CGA3_e1345 = 29;\nconst int Idx_CGA3_e2345 = 30;\nconst int Idx_CGA3_e12345 = 31;\n\nstruct CGA3 {\n    float scalar;\n    float e1;\n    float e2;\n    float e3;\n    float e4;\n    float e5;\n    float e12;\n    float e13;\n    float e14;\n    float e15;\n    float e23;\n    float e24;\n    float e25;\n    float e34;\n    float e35;\n    float e45;\n    float e123;\n    float e124;\n    float e125;\n    float e134;\n    float e135;\n    float e145;\n    float e234;\n    float e235;\n    float e245;\n    float e345;\n    float e1234;\n    float e1235;\n    float e1245;\n    float e1345;\n    float e2345;\n    float e12345;\n};\n\nCGA3 fromArray(float X[32]){\n    return CGA3(X[0], X[1], X[2], X[3], X[4], X[5], X[6], X[7], X[8], X[9], X[10], X[11], X[12], X[13], X[14], X[15], X[16], X[17], X[18], X[19], X[20], X[21], X[22], X[23], X[24], X[25], X[26], X[27], X[28], X[29], X[30], X[31]);\n}\n\nvoid toArray(CGA3 X, inout float X_ary[32]){\n    X_ary[0] = X.scalar;\n    X_ary[1] = X.e1;\n    X_ary[2] = X.e2;\n    X_ary[3] = X.e3;\n    X_ary[4] = X.e4;\n    X_ary[5] = X.e5;\n    X_ary[6] = X.e12;\n    X_ary[7] = X.e13;\n    X_ary[8] = X.e14;\n    X_ary[9] = X.e15;\n    X_ary[10] = X.e23;\n    X_ary[11] = X.e24;\n    X_ary[12] = X.e25;\n    X_ary[13] = X.e34;\n    X_ary[14] = X.e35;\n    X_ary[15] = X.e45;\n    X_ary[16] = X.e123;\n    X_ary[17] = X.e124;\n    X_ary[18] = X.e125;\n    X_ary[19] = X.e134;\n    X_ary[20] = X.e135;\n    X_ary[21] = X.e145;\n    X_ary[22] = X.e234;\n    X_ary[23] = X.e235;\n    X_ary[24] = X.e245;\n    X_ary[25] = X.e345;\n    X_ary[26] = X.e1234;\n    X_ary[27] = X.e1235;\n    X_ary[28] = X.e1245;\n    X_ary[29] = X.e1345;\n    X_ary[30] = X.e2345;\n    X_ary[31] = X.e12345;\n}\n\nvoid zero(inout float X[32]){\n    X[0] = 0.0;\n    X[1] = 0.0;\n    X[2] = 0.0;\n    X[3] = 0.0;\n    X[4] = 0.0;\n    X[5] = 0.0;\n    X[6] = 0.0;\n    X[7] = 0.0;\n    X[8] = 0.0;\n    X[9] = 0.0;\n    X[10] = 0.0;\n    X[11] = 0.0;\n    X[12] = 0.0;\n    X[13] = 0.0;\n    X[14] = 0.0;\n    X[15] = 0.0;\n    X[16] = 0.0;\n    X[17] = 0.0;\n    X[18] = 0.0;\n    X[19] = 0.0;\n    X[20] = 0.0;\n    X[21] = 0.0;\n    X[22] = 0.0;\n    X[23] = 0.0;\n    X[24] = 0.0;\n    X[25] = 0.0;\n    X[26] = 0.0;\n    X[27] = 0.0;\n    X[28] = 0.0;\n    X[29] = 0.0;\n    X[30] = 0.0;\n    X[31] = 0.0;\n}\n\nCGA3 add(CGA3 X, CGA3 Y){\n    return CGA3(X.scalar + Y.scalar, X.e1 + Y.e1, X.e2 + Y.e2, X.e3 + Y.e3, X.e4 + Y.e4, X.e5 + Y.e5, X.e12 + Y.e12, X.e13 + Y.e13, X.e14 + Y.e14, X.e15 + Y.e15, X.e23 + Y.e23, X.e24 + Y.e24, X.e25 + Y.e25, X.e34 + Y.e34, X.e35 + Y.e35, X.e45 + Y.e45, X.e123 + Y.e123, X.e124 + Y.e124, X.e125 + Y.e125, X.e134 + Y.e134, X.e135 + Y.e135, X.e145 + Y.e145, X.e234 + Y.e234, X.e235 + Y.e235, X.e245 + Y.e245, X.e345 + Y.e345, X.e1234 + Y.e1234, X.e1235 + Y.e1235, X.e1245 + Y.e1245, X.e1345 + Y.e1345, X.e2345 + Y.e2345, X.e12345 + Y.e12345);\n}\n\nCGA3 add(CGA3 X, CGA3 Y, CGA3 Z){\n    return add(add(X, Y), Z);\n}\n\nCGA3 add(CGA3 X, CGA3 Y, CGA3 Z, CGA3 P){\n    return add(add(add(X, Y), Z), P);\n}\n\n#define ONE_CGA3 CGA3(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\nCGA3 mul(float a, CGA3 X){\n    return CGA3(X.scalar*a, X.e1*a, X.e2*a, X.e3*a, X.e4*a, X.e5*a, X.e12*a, X.e13*a, X.e14*a, X.e15*a, X.e23*a, X.e24*a, X.e25*a, X.e34*a, X.e35*a, X.e45*a, X.e123*a, X.e124*a, X.e125*a, X.e134*a, X.e135*a, X.e145*a, X.e234*a, X.e235*a, X.e245*a, X.e345*a, X.e1234*a, X.e1235*a, X.e1245*a, X.e1345*a, X.e2345*a, X.e12345*a);\n}\n\nCGA3 sub(CGA3 X, CGA3 Y){\n    return CGA3(X.scalar - Y.scalar, X.e1 - Y.e1, X.e2 - Y.e2, X.e3 - Y.e3, X.e4 - Y.e4, X.e5 - Y.e5, X.e12 - Y.e12, X.e13 - Y.e13, X.e14 - Y.e14, X.e15 - Y.e15, X.e23 - Y.e23, X.e24 - Y.e24, X.e25 - Y.e25, X.e34 - Y.e34, X.e35 - Y.e35, X.e45 - Y.e45, X.e123 - Y.e123, X.e124 - Y.e124, X.e125 - Y.e125, X.e134 - Y.e134, X.e135 - Y.e135, X.e145 - Y.e145, X.e234 - Y.e234, X.e235 - Y.e235, X.e245 - Y.e245, X.e345 - Y.e345, X.e1234 - Y.e1234, X.e1235 - Y.e1235, X.e1245 - Y.e1245, X.e1345 - Y.e1345, X.e2345 - Y.e2345, X.e12345 - Y.e12345);\n}\n\n#define ZERO_CGA3 CGA3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\nCGA3 mul(int a, CGA3 X){\n    return mul(float(a), X);\n}\n\nCGA3 mul(CGA3 X, CGA3 Y){\n    return CGA3(X.e1*Y.e1 - X.e12*Y.e12 - X.e123*Y.e123 + X.e1234*Y.e1234 - X.e12345*Y.e12345 - X.e1235*Y.e1235 - X.e124*Y.e124 - X.e1245*Y.e1245 + X.e125*Y.e125 - X.e13*Y.e13 - X.e134*Y.e134 - X.e1345*Y.e1345 + X.e135*Y.e135 - X.e14*Y.e14 + X.e145*Y.e145 + X.e15*Y.e15 + X.e2*Y.e2 - X.e23*Y.e23 - X.e234*Y.e234 - X.e2345*Y.e2345 + X.e235*Y.e235 - X.e24*Y.e24 + X.e245*Y.e245 + X.e25*Y.e25 + X.e3*Y.e3 - X.e34*Y.e34 + X.e345*Y.e345 + X.e35*Y.e35 + X.e4*Y.e4 + X.e45*Y.e45 - X.e5*Y.e5 + X.scalar*Y.scalar, X.e1*Y.scalar + X.e12*Y.e2 - X.e123*Y.e23 - X.e1234*Y.e234 - X.e12345*Y.e2345 + X.e1235*Y.e235 - X.e124*Y.e24 + X.e1245*Y.e245 + X.e125*Y.e25 + X.e13*Y.e3 - X.e134*Y.e34 + X.e1345*Y.e345 + X.e135*Y.e35 + X.e14*Y.e4 + X.e145*Y.e45 - X.e15*Y.e5 - X.e2*Y.e12 - X.e23*Y.e123 + X.e234*Y.e1234 - X.e2345*Y.e12345 - X.e235*Y.e1235 - X.e24*Y.e124 - X.e245*Y.e1245 + X.e25*Y.e125 - X.e3*Y.e13 - X.e34*Y.e134 - X.e345*Y.e1345 + X.e35*Y.e135 - X.e4*Y.e14 + X.e45*Y.e145 + X.e5*Y.e15 + X.scalar*Y.e1, X.e1*Y.e12 - X.e12*Y.e1 + X.e123*Y.e13 + X.e1234*Y.e134 + X.e12345*Y.e1345 - X.e1235*Y.e135 + X.e124*Y.e14 - X.e1245*Y.e145 - X.e125*Y.e15 + X.e13*Y.e123 - X.e134*Y.e1234 + X.e1345*Y.e12345 + X.e135*Y.e1235 + X.e14*Y.e124 + X.e145*Y.e1245 - X.e15*Y.e125 + X.e2*Y.scalar + X.e23*Y.e3 - X.e234*Y.e34 + X.e2345*Y.e345 + X.e235*Y.e35 + X.e24*Y.e4 + X.e245*Y.e45 - X.e25*Y.e5 - X.e3*Y.e23 - X.e34*Y.e234 - X.e345*Y.e2345 + X.e35*Y.e235 - X.e4*Y.e24 + X.e45*Y.e245 + X.e5*Y.e25 + X.scalar*Y.e2, X.e1*Y.e13 - X.e12*Y.e123 - X.e123*Y.e12 - X.e1234*Y.e124 - X.e12345*Y.e1245 + X.e1235*Y.e125 + X.e124*Y.e1234 - X.e1245*Y.e12345 - X.e125*Y.e1235 - X.e13*Y.e1 + X.e134*Y.e14 - X.e1345*Y.e145 - X.e135*Y.e15 + X.e14*Y.e134 + X.e145*Y.e1345 - X.e15*Y.e135 + X.e2*Y.e23 - X.e23*Y.e2 + X.e234*Y.e24 - X.e2345*Y.e245 - X.e235*Y.e25 + X.e24*Y.e234 + X.e245*Y.e2345 - X.e25*Y.e235 + X.e3*Y.scalar + X.e34*Y.e4 + X.e345*Y.e45 - X.e35*Y.e5 - X.e4*Y.e34 + X.e45*Y.e345 + X.e5*Y.e35 + X.scalar*Y.e3, X.e1*Y.e14 - X.e12*Y.e124 - X.e123*Y.e1234 + X.e1234*Y.e123 + X.e12345*Y.e1235 + X.e1235*Y.e12345 - X.e124*Y.e12 + X.e1245*Y.e125 - X.e125*Y.e1245 - X.e13*Y.e134 - X.e134*Y.e13 + X.e1345*Y.e135 - X.e135*Y.e1345 - X.e14*Y.e1 - X.e145*Y.e15 - X.e15*Y.e145 + X.e2*Y.e24 - X.e23*Y.e234 - X.e234*Y.e23 + X.e2345*Y.e235 - X.e235*Y.e2345 - X.e24*Y.e2 - X.e245*Y.e25 - X.e25*Y.e245 + X.e3*Y.e34 - X.e34*Y.e3 - X.e345*Y.e35 - X.e35*Y.e345 + X.e4*Y.scalar - X.e45*Y.e5 + X.e5*Y.e45 + X.scalar*Y.e4, X.e1*Y.e15 - X.e12*Y.e125 - X.e123*Y.e1235 + X.e1234*Y.e12345 + X.e12345*Y.e1234 + X.e1235*Y.e123 - X.e124*Y.e1245 + X.e1245*Y.e124 - X.e125*Y.e12 - X.e13*Y.e135 - X.e134*Y.e1345 + X.e1345*Y.e134 - X.e135*Y.e13 - X.e14*Y.e145 - X.e145*Y.e14 - X.e15*Y.e1 + X.e2*Y.e25 - X.e23*Y.e235 - X.e234*Y.e2345 + X.e2345*Y.e234 - X.e235*Y.e23 - X.e24*Y.e245 - X.e245*Y.e24 - X.e25*Y.e2 + X.e3*Y.e35 - X.e34*Y.e345 - X.e345*Y.e34 - X.e35*Y.e3 + X.e4*Y.e45 - X.e45*Y.e4 + X.e5*Y.scalar + X.scalar*Y.e5, X.e1*Y.e2 + X.e12*Y.scalar + X.e123*Y.e3 - X.e1234*Y.e34 + X.e12345*Y.e345 + X.e1235*Y.e35 + X.e124*Y.e4 + X.e1245*Y.e45 - X.e125*Y.e5 - X.e13*Y.e23 - X.e134*Y.e234 - X.e1345*Y.e2345 + X.e135*Y.e235 - X.e14*Y.e24 + X.e145*Y.e245 + X.e15*Y.e25 - X.e2*Y.e1 + X.e23*Y.e13 + X.e234*Y.e134 + X.e2345*Y.e1345 - X.e235*Y.e135 + X.e24*Y.e14 - X.e245*Y.e145 - X.e25*Y.e15 + X.e3*Y.e123 - X.e34*Y.e1234 + X.e345*Y.e12345 + X.e35*Y.e1235 + X.e4*Y.e124 + X.e45*Y.e1245 - X.e5*Y.e125 + X.scalar*Y.e12, X.e1*Y.e3 + X.e12*Y.e23 - X.e123*Y.e2 + X.e1234*Y.e24 - X.e12345*Y.e245 - X.e1235*Y.e25 + X.e124*Y.e234 + X.e1245*Y.e2345 - X.e125*Y.e235 + X.e13*Y.scalar + X.e134*Y.e4 + X.e1345*Y.e45 - X.e135*Y.e5 - X.e14*Y.e34 + X.e145*Y.e345 + X.e15*Y.e35 - X.e2*Y.e123 - X.e23*Y.e12 - X.e234*Y.e124 - X.e2345*Y.e1245 + X.e235*Y.e125 + X.e24*Y.e1234 - X.e245*Y.e12345 - X.e25*Y.e1235 - X.e3*Y.e1 + X.e34*Y.e14 - X.e345*Y.e145 - X.e35*Y.e15 + X.e4*Y.e134 + X.e45*Y.e1345 - X.e5*Y.e135 + X.scalar*Y.e13, X.e1*Y.e4 + X.e12*Y.e24 - X.e123*Y.e234 - X.e1234*Y.e23 + X.e12345*Y.e235 - X.e1235*Y.e2345 - X.e124*Y.e2 - X.e1245*Y.e25 - X.e125*Y.e245 + X.e13*Y.e34 - X.e134*Y.e3 - X.e1345*Y.e35 - X.e135*Y.e345 + X.e14*Y.scalar - X.e145*Y.e5 + X.e15*Y.e45 - X.e2*Y.e124 - X.e23*Y.e1234 + X.e234*Y.e123 + X.e2345*Y.e1235 + X.e235*Y.e12345 - X.e24*Y.e12 + X.e245*Y.e125 - X.e25*Y.e1245 - X.e3*Y.e134 - X.e34*Y.e13 + X.e345*Y.e135 - X.e35*Y.e1345 - X.e4*Y.e1 - X.e45*Y.e15 - X.e5*Y.e145 + X.scalar*Y.e14, X.e1*Y.e5 + X.e12*Y.e25 - X.e123*Y.e235 - X.e1234*Y.e2345 + X.e12345*Y.e234 - X.e1235*Y.e23 - X.e124*Y.e245 - X.e1245*Y.e24 - X.e125*Y.e2 + X.e13*Y.e35 - X.e134*Y.e345 - X.e1345*Y.e34 - X.e135*Y.e3 + X.e14*Y.e45 - X.e145*Y.e4 + X.e15*Y.scalar - X.e2*Y.e125 - X.e23*Y.e1235 + X.e234*Y.e12345 + X.e2345*Y.e1234 + X.e235*Y.e123 - X.e24*Y.e1245 + X.e245*Y.e124 - X.e25*Y.e12 - X.e3*Y.e135 - X.e34*Y.e1345 + X.e345*Y.e134 - X.e35*Y.e13 - X.e4*Y.e145 - X.e45*Y.e14 - X.e5*Y.e1 + X.scalar*Y.e15, X.e1*Y.e123 - X.e12*Y.e13 + X.e123*Y.e1 - X.e1234*Y.e14 + X.e12345*Y.e145 + X.e1235*Y.e15 - X.e124*Y.e134 - X.e1245*Y.e1345 + X.e125*Y.e135 + X.e13*Y.e12 + X.e134*Y.e124 + X.e1345*Y.e1245 - X.e135*Y.e125 - X.e14*Y.e1234 + X.e145*Y.e12345 + X.e15*Y.e1235 + X.e2*Y.e3 + X.e23*Y.scalar + X.e234*Y.e4 + X.e2345*Y.e45 - X.e235*Y.e5 - X.e24*Y.e34 + X.e245*Y.e345 + X.e25*Y.e35 - X.e3*Y.e2 + X.e34*Y.e24 - X.e345*Y.e245 - X.e35*Y.e25 + X.e4*Y.e234 + X.e45*Y.e2345 - X.e5*Y.e235 + X.scalar*Y.e23, X.e1*Y.e124 - X.e12*Y.e14 + X.e123*Y.e134 + X.e1234*Y.e13 - X.e12345*Y.e135 + X.e1235*Y.e1345 + X.e124*Y.e1 + X.e1245*Y.e15 + X.e125*Y.e145 + X.e13*Y.e1234 - X.e134*Y.e123 - X.e1345*Y.e1235 - X.e135*Y.e12345 + X.e14*Y.e12 - X.e145*Y.e125 + X.e15*Y.e1245 + X.e2*Y.e4 + X.e23*Y.e34 - X.e234*Y.e3 - X.e2345*Y.e35 - X.e235*Y.e345 + X.e24*Y.scalar - X.e245*Y.e5 + X.e25*Y.e45 - X.e3*Y.e234 - X.e34*Y.e23 + X.e345*Y.e235 - X.e35*Y.e2345 - X.e4*Y.e2 - X.e45*Y.e25 - X.e5*Y.e245 + X.scalar*Y.e24, X.e1*Y.e125 - X.e12*Y.e15 + X.e123*Y.e135 + X.e1234*Y.e1345 - X.e12345*Y.e134 + X.e1235*Y.e13 + X.e124*Y.e145 + X.e1245*Y.e14 + X.e125*Y.e1 + X.e13*Y.e1235 - X.e134*Y.e12345 - X.e1345*Y.e1234 - X.e135*Y.e123 + X.e14*Y.e1245 - X.e145*Y.e124 + X.e15*Y.e12 + X.e2*Y.e5 + X.e23*Y.e35 - X.e234*Y.e345 - X.e2345*Y.e34 - X.e235*Y.e3 + X.e24*Y.e45 - X.e245*Y.e4 + X.e25*Y.scalar - X.e3*Y.e235 - X.e34*Y.e2345 + X.e345*Y.e234 - X.e35*Y.e23 - X.e4*Y.e245 - X.e45*Y.e24 - X.e5*Y.e2 + X.scalar*Y.e25, X.e1*Y.e134 - X.e12*Y.e1234 - X.e123*Y.e124 - X.e1234*Y.e12 + X.e12345*Y.e125 - X.e1235*Y.e1245 + X.e124*Y.e123 + X.e1245*Y.e1235 + X.e125*Y.e12345 - X.e13*Y.e14 + X.e134*Y.e1 + X.e1345*Y.e15 + X.e135*Y.e145 + X.e14*Y.e13 - X.e145*Y.e135 + X.e15*Y.e1345 + X.e2*Y.e234 - X.e23*Y.e24 + X.e234*Y.e2 + X.e2345*Y.e25 + X.e235*Y.e245 + X.e24*Y.e23 - X.e245*Y.e235 + X.e25*Y.e2345 + X.e3*Y.e4 + X.e34*Y.scalar - X.e345*Y.e5 + X.e35*Y.e45 - X.e4*Y.e3 - X.e45*Y.e35 - X.e5*Y.e345 + X.scalar*Y.e34, X.e1*Y.e135 - X.e12*Y.e1235 - X.e123*Y.e125 - X.e1234*Y.e1245 + X.e12345*Y.e124 - X.e1235*Y.e12 + X.e124*Y.e12345 + X.e1245*Y.e1234 + X.e125*Y.e123 - X.e13*Y.e15 + X.e134*Y.e145 + X.e1345*Y.e14 + X.e135*Y.e1 + X.e14*Y.e1345 - X.e145*Y.e134 + X.e15*Y.e13 + X.e2*Y.e235 - X.e23*Y.e25 + X.e234*Y.e245 + X.e2345*Y.e24 + X.e235*Y.e2 + X.e24*Y.e2345 - X.e245*Y.e234 + X.e25*Y.e23 + X.e3*Y.e5 + X.e34*Y.e45 - X.e345*Y.e4 + X.e35*Y.scalar - X.e4*Y.e345 - X.e45*Y.e34 - X.e5*Y.e3 + X.scalar*Y.e35, X.e1*Y.e145 - X.e12*Y.e1245 - X.e123*Y.e12345 + X.e1234*Y.e1235 - X.e12345*Y.e123 - X.e1235*Y.e1234 - X.e124*Y.e125 - X.e1245*Y.e12 + X.e125*Y.e124 - X.e13*Y.e1345 - X.e134*Y.e135 - X.e1345*Y.e13 + X.e135*Y.e134 - X.e14*Y.e15 + X.e145*Y.e1 + X.e15*Y.e14 + X.e2*Y.e245 - X.e23*Y.e2345 - X.e234*Y.e235 - X.e2345*Y.e23 + X.e235*Y.e234 - X.e24*Y.e25 + X.e245*Y.e2 + X.e25*Y.e24 + X.e3*Y.e345 - X.e34*Y.e35 + X.e345*Y.e3 + X.e35*Y.e34 + X.e4*Y.e5 + X.e45*Y.scalar - X.e5*Y.e4 + X.scalar*Y.e45, X.e1*Y.e23 + X.e12*Y.e3 + X.e123*Y.scalar + X.e1234*Y.e4 + X.e12345*Y.e45 - X.e1235*Y.e5 - X.e124*Y.e34 + X.e1245*Y.e345 + X.e125*Y.e35 - X.e13*Y.e2 + X.e134*Y.e24 - X.e1345*Y.e245 - X.e135*Y.e25 + X.e14*Y.e234 + X.e145*Y.e2345 - X.e15*Y.e235 - X.e2*Y.e13 + X.e23*Y.e1 - X.e234*Y.e14 + X.e2345*Y.e145 + X.e235*Y.e15 - X.e24*Y.e134 - X.e245*Y.e1345 + X.e25*Y.e135 + X.e3*Y.e12 + X.e34*Y.e124 + X.e345*Y.e1245 - X.e35*Y.e125 - X.e4*Y.e1234 + X.e45*Y.e12345 + X.e5*Y.e1235 + X.scalar*Y.e123, X.e1*Y.e24 + X.e12*Y.e4 + X.e123*Y.e34 - X.e1234*Y.e3 - X.e12345*Y.e35 - X.e1235*Y.e345 + X.e124*Y.scalar - X.e1245*Y.e5 + X.e125*Y.e45 - X.e13*Y.e234 - X.e134*Y.e23 + X.e1345*Y.e235 - X.e135*Y.e2345 - X.e14*Y.e2 - X.e145*Y.e25 - X.e15*Y.e245 - X.e2*Y.e14 + X.e23*Y.e134 + X.e234*Y.e13 - X.e2345*Y.e135 + X.e235*Y.e1345 + X.e24*Y.e1 + X.e245*Y.e15 + X.e25*Y.e145 + X.e3*Y.e1234 - X.e34*Y.e123 - X.e345*Y.e1235 - X.e35*Y.e12345 + X.e4*Y.e12 - X.e45*Y.e125 + X.e5*Y.e1245 + X.scalar*Y.e124, X.e1*Y.e25 + X.e12*Y.e5 + X.e123*Y.e35 - X.e1234*Y.e345 - X.e12345*Y.e34 - X.e1235*Y.e3 + X.e124*Y.e45 - X.e1245*Y.e4 + X.e125*Y.scalar - X.e13*Y.e235 - X.e134*Y.e2345 + X.e1345*Y.e234 - X.e135*Y.e23 - X.e14*Y.e245 - X.e145*Y.e24 - X.e15*Y.e2 - X.e2*Y.e15 + X.e23*Y.e135 + X.e234*Y.e1345 - X.e2345*Y.e134 + X.e235*Y.e13 + X.e24*Y.e145 + X.e245*Y.e14 + X.e25*Y.e1 + X.e3*Y.e1235 - X.e34*Y.e12345 - X.e345*Y.e1234 - X.e35*Y.e123 + X.e4*Y.e1245 - X.e45*Y.e124 + X.e5*Y.e12 + X.scalar*Y.e125, X.e1*Y.e34 + X.e12*Y.e234 - X.e123*Y.e24 + X.e1234*Y.e2 + X.e12345*Y.e25 + X.e1235*Y.e245 + X.e124*Y.e23 - X.e1245*Y.e235 + X.e125*Y.e2345 + X.e13*Y.e4 + X.e134*Y.scalar - X.e1345*Y.e5 + X.e135*Y.e45 - X.e14*Y.e3 - X.e145*Y.e35 - X.e15*Y.e345 - X.e2*Y.e1234 - X.e23*Y.e124 - X.e234*Y.e12 + X.e2345*Y.e125 - X.e235*Y.e1245 + X.e24*Y.e123 + X.e245*Y.e1235 + X.e25*Y.e12345 - X.e3*Y.e14 + X.e34*Y.e1 + X.e345*Y.e15 + X.e35*Y.e145 + X.e4*Y.e13 - X.e45*Y.e135 + X.e5*Y.e1345 + X.scalar*Y.e134, X.e1*Y.e35 + X.e12*Y.e235 - X.e123*Y.e25 + X.e1234*Y.e245 + X.e12345*Y.e24 + X.e1235*Y.e2 + X.e124*Y.e2345 - X.e1245*Y.e234 + X.e125*Y.e23 + X.e13*Y.e5 + X.e134*Y.e45 - X.e1345*Y.e4 + X.e135*Y.scalar - X.e14*Y.e345 - X.e145*Y.e34 - X.e15*Y.e3 - X.e2*Y.e1235 - X.e23*Y.e125 - X.e234*Y.e1245 + X.e2345*Y.e124 - X.e235*Y.e12 + X.e24*Y.e12345 + X.e245*Y.e1234 + X.e25*Y.e123 - X.e3*Y.e15 + X.e34*Y.e145 + X.e345*Y.e14 + X.e35*Y.e1 + X.e4*Y.e1345 - X.e45*Y.e134 + X.e5*Y.e13 + X.scalar*Y.e135, X.e1*Y.e45 + X.e12*Y.e245 - X.e123*Y.e2345 - X.e1234*Y.e235 - X.e12345*Y.e23 + X.e1235*Y.e234 - X.e124*Y.e25 + X.e1245*Y.e2 + X.e125*Y.e24 + X.e13*Y.e345 - X.e134*Y.e35 + X.e1345*Y.e3 + X.e135*Y.e34 + X.e14*Y.e5 + X.e145*Y.scalar - X.e15*Y.e4 - X.e2*Y.e1245 - X.e23*Y.e12345 + X.e234*Y.e1235 - X.e2345*Y.e123 - X.e235*Y.e1234 - X.e24*Y.e125 - X.e245*Y.e12 + X.e25*Y.e124 - X.e3*Y.e1345 - X.e34*Y.e135 - X.e345*Y.e13 + X.e35*Y.e134 - X.e4*Y.e15 + X.e45*Y.e1 + X.e5*Y.e14 + X.scalar*Y.e145, X.e1*Y.e1234 - X.e12*Y.e134 + X.e123*Y.e14 - X.e1234*Y.e1 - X.e12345*Y.e15 - X.e1235*Y.e145 - X.e124*Y.e13 + X.e1245*Y.e135 - X.e125*Y.e1345 + X.e13*Y.e124 + X.e134*Y.e12 - X.e1345*Y.e125 + X.e135*Y.e1245 - X.e14*Y.e123 - X.e145*Y.e1235 - X.e15*Y.e12345 + X.e2*Y.e34 + X.e23*Y.e4 + X.e234*Y.scalar - X.e2345*Y.e5 + X.e235*Y.e45 - X.e24*Y.e3 - X.e245*Y.e35 - X.e25*Y.e345 - X.e3*Y.e24 + X.e34*Y.e2 + X.e345*Y.e25 + X.e35*Y.e245 + X.e4*Y.e23 - X.e45*Y.e235 + X.e5*Y.e2345 + X.scalar*Y.e234, X.e1*Y.e1235 - X.e12*Y.e135 + X.e123*Y.e15 - X.e1234*Y.e145 - X.e12345*Y.e14 - X.e1235*Y.e1 - X.e124*Y.e1345 + X.e1245*Y.e134 - X.e125*Y.e13 + X.e13*Y.e125 + X.e134*Y.e1245 - X.e1345*Y.e124 + X.e135*Y.e12 - X.e14*Y.e12345 - X.e145*Y.e1234 - X.e15*Y.e123 + X.e2*Y.e35 + X.e23*Y.e5 + X.e234*Y.e45 - X.e2345*Y.e4 + X.e235*Y.scalar - X.e24*Y.e345 - X.e245*Y.e34 - X.e25*Y.e3 - X.e3*Y.e25 + X.e34*Y.e245 + X.e345*Y.e24 + X.e35*Y.e2 + X.e4*Y.e2345 - X.e45*Y.e234 + X.e5*Y.e23 + X.scalar*Y.e235, X.e1*Y.e1245 - X.e12*Y.e145 + X.e123*Y.e1345 + X.e1234*Y.e135 + X.e12345*Y.e13 - X.e1235*Y.e134 + X.e124*Y.e15 - X.e1245*Y.e1 - X.e125*Y.e14 + X.e13*Y.e12345 - X.e134*Y.e1235 + X.e1345*Y.e123 + X.e135*Y.e1234 + X.e14*Y.e125 + X.e145*Y.e12 - X.e15*Y.e124 + X.e2*Y.e45 + X.e23*Y.e345 - X.e234*Y.e35 + X.e2345*Y.e3 + X.e235*Y.e34 + X.e24*Y.e5 + X.e245*Y.scalar - X.e25*Y.e4 - X.e3*Y.e2345 - X.e34*Y.e235 - X.e345*Y.e23 + X.e35*Y.e234 - X.e4*Y.e25 + X.e45*Y.e2 + X.e5*Y.e24 + X.scalar*Y.e245, X.e1*Y.e1345 - X.e12*Y.e12345 - X.e123*Y.e1245 - X.e1234*Y.e125 - X.e12345*Y.e12 + X.e1235*Y.e124 + X.e124*Y.e1235 - X.e1245*Y.e123 - X.e125*Y.e1234 - X.e13*Y.e145 + X.e134*Y.e15 - X.e1345*Y.e1 - X.e135*Y.e14 + X.e14*Y.e135 + X.e145*Y.e13 - X.e15*Y.e134 + X.e2*Y.e2345 - X.e23*Y.e245 + X.e234*Y.e25 - X.e2345*Y.e2 - X.e235*Y.e24 + X.e24*Y.e235 + X.e245*Y.e23 - X.e25*Y.e234 + X.e3*Y.e45 + X.e34*Y.e5 + X.e345*Y.scalar - X.e35*Y.e4 - X.e4*Y.e35 + X.e45*Y.e3 + X.e5*Y.e34 + X.scalar*Y.e345, X.e1*Y.e234 + X.e12*Y.e34 + X.e123*Y.e4 + X.e1234*Y.scalar - X.e12345*Y.e5 + X.e1235*Y.e45 - X.e124*Y.e3 - X.e1245*Y.e35 - X.e125*Y.e345 - X.e13*Y.e24 + X.e134*Y.e2 + X.e1345*Y.e25 + X.e135*Y.e245 + X.e14*Y.e23 - X.e145*Y.e235 + X.e15*Y.e2345 - X.e2*Y.e134 + X.e23*Y.e14 - X.e234*Y.e1 - X.e2345*Y.e15 - X.e235*Y.e145 - X.e24*Y.e13 + X.e245*Y.e135 - X.e25*Y.e1345 + X.e3*Y.e124 + X.e34*Y.e12 - X.e345*Y.e125 + X.e35*Y.e1245 - X.e4*Y.e123 - X.e45*Y.e1235 - X.e5*Y.e12345 + X.scalar*Y.e1234, X.e1*Y.e235 + X.e12*Y.e35 + X.e123*Y.e5 + X.e1234*Y.e45 - X.e12345*Y.e4 + X.e1235*Y.scalar - X.e124*Y.e345 - X.e1245*Y.e34 - X.e125*Y.e3 - X.e13*Y.e25 + X.e134*Y.e245 + X.e1345*Y.e24 + X.e135*Y.e2 + X.e14*Y.e2345 - X.e145*Y.e234 + X.e15*Y.e23 - X.e2*Y.e135 + X.e23*Y.e15 - X.e234*Y.e145 - X.e2345*Y.e14 - X.e235*Y.e1 - X.e24*Y.e1345 + X.e245*Y.e134 - X.e25*Y.e13 + X.e3*Y.e125 + X.e34*Y.e1245 - X.e345*Y.e124 + X.e35*Y.e12 - X.e4*Y.e12345 - X.e45*Y.e1234 - X.e5*Y.e123 + X.scalar*Y.e1235, X.e1*Y.e245 + X.e12*Y.e45 + X.e123*Y.e345 - X.e1234*Y.e35 + X.e12345*Y.e3 + X.e1235*Y.e34 + X.e124*Y.e5 + X.e1245*Y.scalar - X.e125*Y.e4 - X.e13*Y.e2345 - X.e134*Y.e235 - X.e1345*Y.e23 + X.e135*Y.e234 - X.e14*Y.e25 + X.e145*Y.e2 + X.e15*Y.e24 - X.e2*Y.e145 + X.e23*Y.e1345 + X.e234*Y.e135 + X.e2345*Y.e13 - X.e235*Y.e134 + X.e24*Y.e15 - X.e245*Y.e1 - X.e25*Y.e14 + X.e3*Y.e12345 - X.e34*Y.e1235 + X.e345*Y.e123 + X.e35*Y.e1234 + X.e4*Y.e125 + X.e45*Y.e12 - X.e5*Y.e124 + X.scalar*Y.e1245, X.e1*Y.e345 + X.e12*Y.e2345 - X.e123*Y.e245 + X.e1234*Y.e25 - X.e12345*Y.e2 - X.e1235*Y.e24 + X.e124*Y.e235 + X.e1245*Y.e23 - X.e125*Y.e234 + X.e13*Y.e45 + X.e134*Y.e5 + X.e1345*Y.scalar - X.e135*Y.e4 - X.e14*Y.e35 + X.e145*Y.e3 + X.e15*Y.e34 - X.e2*Y.e12345 - X.e23*Y.e1245 - X.e234*Y.e125 - X.e2345*Y.e12 + X.e235*Y.e124 + X.e24*Y.e1235 - X.e245*Y.e123 - X.e25*Y.e1234 - X.e3*Y.e145 + X.e34*Y.e15 - X.e345*Y.e1 - X.e35*Y.e14 + X.e4*Y.e135 + X.e45*Y.e13 - X.e5*Y.e134 + X.scalar*Y.e1345, X.e1*Y.e12345 - X.e12*Y.e1345 + X.e123*Y.e145 - X.e1234*Y.e15 + X.e12345*Y.e1 + X.e1235*Y.e14 - X.e124*Y.e135 - X.e1245*Y.e13 + X.e125*Y.e134 + X.e13*Y.e1245 + X.e134*Y.e125 + X.e1345*Y.e12 - X.e135*Y.e124 - X.e14*Y.e1235 + X.e145*Y.e123 + X.e15*Y.e1234 + X.e2*Y.e345 + X.e23*Y.e45 + X.e234*Y.e5 + X.e2345*Y.scalar - X.e235*Y.e4 - X.e24*Y.e35 + X.e245*Y.e3 + X.e25*Y.e34 - X.e3*Y.e245 + X.e34*Y.e25 - X.e345*Y.e2 - X.e35*Y.e24 + X.e4*Y.e235 + X.e45*Y.e23 - X.e5*Y.e234 + X.scalar*Y.e2345, X.e1*Y.e2345 + X.e12*Y.e345 + X.e123*Y.e45 + X.e1234*Y.e5 + X.e12345*Y.scalar - X.e1235*Y.e4 - X.e124*Y.e35 + X.e1245*Y.e3 + X.e125*Y.e34 - X.e13*Y.e245 + X.e134*Y.e25 - X.e1345*Y.e2 - X.e135*Y.e24 + X.e14*Y.e235 + X.e145*Y.e23 - X.e15*Y.e234 - X.e2*Y.e1345 + X.e23*Y.e145 - X.e234*Y.e15 + X.e2345*Y.e1 + X.e235*Y.e14 - X.e24*Y.e135 - X.e245*Y.e13 + X.e25*Y.e134 + X.e3*Y.e1245 + X.e34*Y.e125 + X.e345*Y.e12 - X.e35*Y.e124 - X.e4*Y.e1235 + X.e45*Y.e123 + X.e5*Y.e1234 + X.scalar*Y.e12345);\n}\n\nCGA3 scalar_CGA3(float a){\n    return mul(a, ONE_CGA3);\n}\n\nCGA3 mul(CGA3 X, CGA3 Y, CGA3 Z){\n    return mul(mul(X, Y), Z);\n}\n\nCGA3 involve(CGA3 X){\n    return CGA3(X.scalar, -X.e1, -X.e2, -X.e3, -X.e4, -X.e5, X.e12, X.e13, X.e14, X.e15, X.e23, X.e24, X.e25, X.e34, X.e35, X.e45, -X.e123, -X.e124, -X.e125, -X.e134, -X.e135, -X.e145, -X.e234, -X.e235, -X.e245, -X.e345, X.e1234, X.e1235, X.e1245, X.e1345, X.e2345, -X.e12345);\n}\n\nCGA3 inner(CGA3 X, CGA3 Y){\n    return CGA3(X.e1*Y.e1 - X.e12*Y.e12 - X.e123*Y.e123 + X.e1234*Y.e1234 - X.e12345*Y.e12345 - X.e1235*Y.e1235 - X.e124*Y.e124 - X.e1245*Y.e1245 + X.e125*Y.e125 - X.e13*Y.e13 - X.e134*Y.e134 - X.e1345*Y.e1345 + X.e135*Y.e135 - X.e14*Y.e14 + X.e145*Y.e145 + X.e15*Y.e15 + X.e2*Y.e2 - X.e23*Y.e23 - X.e234*Y.e234 - X.e2345*Y.e2345 + X.e235*Y.e235 - X.e24*Y.e24 + X.e245*Y.e245 + X.e25*Y.e25 + X.e3*Y.e3 - X.e34*Y.e34 + X.e345*Y.e345 + X.e35*Y.e35 + X.e4*Y.e4 + X.e45*Y.e45 - X.e5*Y.e5, X.e12*Y.e2 - X.e123*Y.e23 - X.e1234*Y.e234 - X.e12345*Y.e2345 + X.e1235*Y.e235 - X.e124*Y.e24 + X.e1245*Y.e245 + X.e125*Y.e25 + X.e13*Y.e3 - X.e134*Y.e34 + X.e1345*Y.e345 + X.e135*Y.e35 + X.e14*Y.e4 + X.e145*Y.e45 - X.e15*Y.e5 - X.e2*Y.e12 - X.e23*Y.e123 + X.e234*Y.e1234 - X.e2345*Y.e12345 - X.e235*Y.e1235 - X.e24*Y.e124 - X.e245*Y.e1245 + X.e25*Y.e125 - X.e3*Y.e13 - X.e34*Y.e134 - X.e345*Y.e1345 + X.e35*Y.e135 - X.e4*Y.e14 + X.e45*Y.e145 + X.e5*Y.e15, X.e1*Y.e12 - X.e12*Y.e1 + X.e123*Y.e13 + X.e1234*Y.e134 + X.e12345*Y.e1345 - X.e1235*Y.e135 + X.e124*Y.e14 - X.e1245*Y.e145 - X.e125*Y.e15 + X.e13*Y.e123 - X.e134*Y.e1234 + X.e1345*Y.e12345 + X.e135*Y.e1235 + X.e14*Y.e124 + X.e145*Y.e1245 - X.e15*Y.e125 + X.e23*Y.e3 - X.e234*Y.e34 + X.e2345*Y.e345 + X.e235*Y.e35 + X.e24*Y.e4 + X.e245*Y.e45 - X.e25*Y.e5 - X.e3*Y.e23 - X.e34*Y.e234 - X.e345*Y.e2345 + X.e35*Y.e235 - X.e4*Y.e24 + X.e45*Y.e245 + X.e5*Y.e25, X.e1*Y.e13 - X.e12*Y.e123 - X.e123*Y.e12 - X.e1234*Y.e124 - X.e12345*Y.e1245 + X.e1235*Y.e125 + X.e124*Y.e1234 - X.e1245*Y.e12345 - X.e125*Y.e1235 - X.e13*Y.e1 + X.e134*Y.e14 - X.e1345*Y.e145 - X.e135*Y.e15 + X.e14*Y.e134 + X.e145*Y.e1345 - X.e15*Y.e135 + X.e2*Y.e23 - X.e23*Y.e2 + X.e234*Y.e24 - X.e2345*Y.e245 - X.e235*Y.e25 + X.e24*Y.e234 + X.e245*Y.e2345 - X.e25*Y.e235 + X.e34*Y.e4 + X.e345*Y.e45 - X.e35*Y.e5 - X.e4*Y.e34 + X.e45*Y.e345 + X.e5*Y.e35, X.e1*Y.e14 - X.e12*Y.e124 - X.e123*Y.e1234 + X.e1234*Y.e123 + X.e12345*Y.e1235 + X.e1235*Y.e12345 - X.e124*Y.e12 + X.e1245*Y.e125 - X.e125*Y.e1245 - X.e13*Y.e134 - X.e134*Y.e13 + X.e1345*Y.e135 - X.e135*Y.e1345 - X.e14*Y.e1 - X.e145*Y.e15 - X.e15*Y.e145 + X.e2*Y.e24 - X.e23*Y.e234 - X.e234*Y.e23 + X.e2345*Y.e235 - X.e235*Y.e2345 - X.e24*Y.e2 - X.e245*Y.e25 - X.e25*Y.e245 + X.e3*Y.e34 - X.e34*Y.e3 - X.e345*Y.e35 - X.e35*Y.e345 - X.e45*Y.e5 + X.e5*Y.e45, X.e1*Y.e15 - X.e12*Y.e125 - X.e123*Y.e1235 + X.e1234*Y.e12345 + X.e12345*Y.e1234 + X.e1235*Y.e123 - X.e124*Y.e1245 + X.e1245*Y.e124 - X.e125*Y.e12 - X.e13*Y.e135 - X.e134*Y.e1345 + X.e1345*Y.e134 - X.e135*Y.e13 - X.e14*Y.e145 - X.e145*Y.e14 - X.e15*Y.e1 + X.e2*Y.e25 - X.e23*Y.e235 - X.e234*Y.e2345 + X.e2345*Y.e234 - X.e235*Y.e23 - X.e24*Y.e245 - X.e245*Y.e24 - X.e25*Y.e2 + X.e3*Y.e35 - X.e34*Y.e345 - X.e345*Y.e34 - X.e35*Y.e3 + X.e4*Y.e45 - X.e45*Y.e4, X.e123*Y.e3 - X.e1234*Y.e34 + X.e12345*Y.e345 + X.e1235*Y.e35 + X.e124*Y.e4 + X.e1245*Y.e45 - X.e125*Y.e5 + X.e3*Y.e123 - X.e34*Y.e1234 + X.e345*Y.e12345 + X.e35*Y.e1235 + X.e4*Y.e124 + X.e45*Y.e1245 - X.e5*Y.e125, -X.e123*Y.e2 + X.e1234*Y.e24 - X.e12345*Y.e245 - X.e1235*Y.e25 + X.e134*Y.e4 + X.e1345*Y.e45 - X.e135*Y.e5 - X.e2*Y.e123 + X.e24*Y.e1234 - X.e245*Y.e12345 - X.e25*Y.e1235 + X.e4*Y.e134 + X.e45*Y.e1345 - X.e5*Y.e135, -X.e1234*Y.e23 + X.e12345*Y.e235 - X.e124*Y.e2 - X.e1245*Y.e25 - X.e134*Y.e3 - X.e1345*Y.e35 - X.e145*Y.e5 - X.e2*Y.e124 - X.e23*Y.e1234 + X.e235*Y.e12345 - X.e25*Y.e1245 - X.e3*Y.e134 - X.e35*Y.e1345 - X.e5*Y.e145, X.e12345*Y.e234 - X.e1235*Y.e23 - X.e1245*Y.e24 - X.e125*Y.e2 - X.e1345*Y.e34 - X.e135*Y.e3 - X.e145*Y.e4 - X.e2*Y.e125 - X.e23*Y.e1235 + X.e234*Y.e12345 - X.e24*Y.e1245 - X.e3*Y.e135 - X.e34*Y.e1345 - X.e4*Y.e145, X.e1*Y.e123 + X.e123*Y.e1 - X.e1234*Y.e14 + X.e12345*Y.e145 + X.e1235*Y.e15 - X.e14*Y.e1234 + X.e145*Y.e12345 + X.e15*Y.e1235 + X.e234*Y.e4 + X.e2345*Y.e45 - X.e235*Y.e5 + X.e4*Y.e234 + X.e45*Y.e2345 - X.e5*Y.e235, X.e1*Y.e124 + X.e1234*Y.e13 - X.e12345*Y.e135 + X.e124*Y.e1 + X.e1245*Y.e15 + X.e13*Y.e1234 - X.e135*Y.e12345 + X.e15*Y.e1245 - X.e234*Y.e3 - X.e2345*Y.e35 - X.e245*Y.e5 - X.e3*Y.e234 - X.e35*Y.e2345 - X.e5*Y.e245, X.e1*Y.e125 - X.e12345*Y.e134 + X.e1235*Y.e13 + X.e1245*Y.e14 + X.e125*Y.e1 + X.e13*Y.e1235 - X.e134*Y.e12345 + X.e14*Y.e1245 - X.e2345*Y.e34 - X.e235*Y.e3 - X.e245*Y.e4 - X.e3*Y.e235 - X.e34*Y.e2345 - X.e4*Y.e245, X.e1*Y.e134 - X.e12*Y.e1234 - X.e1234*Y.e12 + X.e12345*Y.e125 + X.e125*Y.e12345 + X.e134*Y.e1 + X.e1345*Y.e15 + X.e15*Y.e1345 + X.e2*Y.e234 + X.e234*Y.e2 + X.e2345*Y.e25 + X.e25*Y.e2345 - X.e345*Y.e5 - X.e5*Y.e345, X.e1*Y.e135 - X.e12*Y.e1235 + X.e12345*Y.e124 - X.e1235*Y.e12 + X.e124*Y.e12345 + X.e1345*Y.e14 + X.e135*Y.e1 + X.e14*Y.e1345 + X.e2*Y.e235 + X.e2345*Y.e24 + X.e235*Y.e2 + X.e24*Y.e2345 - X.e345*Y.e4 - X.e4*Y.e345, X.e1*Y.e145 - X.e12*Y.e1245 - X.e123*Y.e12345 - X.e12345*Y.e123 - X.e1245*Y.e12 - X.e13*Y.e1345 - X.e1345*Y.e13 + X.e145*Y.e1 + X.e2*Y.e245 - X.e23*Y.e2345 - X.e2345*Y.e23 + X.e245*Y.e2 + X.e3*Y.e345 + X.e345*Y.e3, X.e1234*Y.e4 + X.e12345*Y.e45 - X.e1235*Y.e5 - X.e4*Y.e1234 + X.e45*Y.e12345 + X.e5*Y.e1235, -X.e1234*Y.e3 - X.e12345*Y.e35 - X.e1245*Y.e5 + X.e3*Y.e1234 - X.e35*Y.e12345 + X.e5*Y.e1245, -X.e12345*Y.e34 - X.e1235*Y.e3 - X.e1245*Y.e4 + X.e3*Y.e1235 - X.e34*Y.e12345 + X.e4*Y.e1245, X.e1234*Y.e2 + X.e12345*Y.e25 - X.e1345*Y.e5 - X.e2*Y.e1234 + X.e25*Y.e12345 + X.e5*Y.e1345, X.e12345*Y.e24 + X.e1235*Y.e2 - X.e1345*Y.e4 - X.e2*Y.e1235 + X.e24*Y.e12345 + X.e4*Y.e1345, -X.e12345*Y.e23 + X.e1245*Y.e2 + X.e1345*Y.e3 - X.e2*Y.e1245 - X.e23*Y.e12345 - X.e3*Y.e1345, X.e1*Y.e1234 - X.e1234*Y.e1 - X.e12345*Y.e15 - X.e15*Y.e12345 - X.e2345*Y.e5 + X.e5*Y.e2345, X.e1*Y.e1235 - X.e12345*Y.e14 - X.e1235*Y.e1 - X.e14*Y.e12345 - X.e2345*Y.e4 + X.e4*Y.e2345, X.e1*Y.e1245 + X.e12345*Y.e13 - X.e1245*Y.e1 + X.e13*Y.e12345 + X.e2345*Y.e3 - X.e3*Y.e2345, X.e1*Y.e1345 - X.e12*Y.e12345 - X.e12345*Y.e12 - X.e1345*Y.e1 + X.e2*Y.e2345 - X.e2345*Y.e2, -X.e12345*Y.e5 - X.e5*Y.e12345, -X.e12345*Y.e4 - X.e4*Y.e12345, X.e12345*Y.e3 + X.e3*Y.e12345, -X.e12345*Y.e2 - X.e2*Y.e12345, X.e1*Y.e12345 + X.e12345*Y.e1, 0.0);\n}\n\nCGA3 lcontract(CGA3 X, CGA3 Y){\n    return CGA3(X.e1*Y.e1 - X.e12*Y.e12 - X.e123*Y.e123 + X.e1234*Y.e1234 - X.e12345*Y.e12345 - X.e1235*Y.e1235 - X.e124*Y.e124 - X.e1245*Y.e1245 + X.e125*Y.e125 - X.e13*Y.e13 - X.e134*Y.e134 - X.e1345*Y.e1345 + X.e135*Y.e135 - X.e14*Y.e14 + X.e145*Y.e145 + X.e15*Y.e15 + X.e2*Y.e2 - X.e23*Y.e23 - X.e234*Y.e234 - X.e2345*Y.e2345 + X.e235*Y.e235 - X.e24*Y.e24 + X.e245*Y.e245 + X.e25*Y.e25 + X.e3*Y.e3 - X.e34*Y.e34 + X.e345*Y.e345 + X.e35*Y.e35 + X.e4*Y.e4 + X.e45*Y.e45 - X.e5*Y.e5 + X.scalar*Y.scalar, -X.e2*Y.e12 - X.e23*Y.e123 + X.e234*Y.e1234 - X.e2345*Y.e12345 - X.e235*Y.e1235 - X.e24*Y.e124 - X.e245*Y.e1245 + X.e25*Y.e125 - X.e3*Y.e13 - X.e34*Y.e134 - X.e345*Y.e1345 + X.e35*Y.e135 - X.e4*Y.e14 + X.e45*Y.e145 + X.e5*Y.e15 + X.scalar*Y.e1, X.e1*Y.e12 + X.e13*Y.e123 - X.e134*Y.e1234 + X.e1345*Y.e12345 + X.e135*Y.e1235 + X.e14*Y.e124 + X.e145*Y.e1245 - X.e15*Y.e125 - X.e3*Y.e23 - X.e34*Y.e234 - X.e345*Y.e2345 + X.e35*Y.e235 - X.e4*Y.e24 + X.e45*Y.e245 + X.e5*Y.e25 + X.scalar*Y.e2, X.e1*Y.e13 - X.e12*Y.e123 + X.e124*Y.e1234 - X.e1245*Y.e12345 - X.e125*Y.e1235 + X.e14*Y.e134 + X.e145*Y.e1345 - X.e15*Y.e135 + X.e2*Y.e23 + X.e24*Y.e234 + X.e245*Y.e2345 - X.e25*Y.e235 - X.e4*Y.e34 + X.e45*Y.e345 + X.e5*Y.e35 + X.scalar*Y.e3, X.e1*Y.e14 - X.e12*Y.e124 - X.e123*Y.e1234 + X.e1235*Y.e12345 - X.e125*Y.e1245 - X.e13*Y.e134 - X.e135*Y.e1345 - X.e15*Y.e145 + X.e2*Y.e24 - X.e23*Y.e234 - X.e235*Y.e2345 - X.e25*Y.e245 + X.e3*Y.e34 - X.e35*Y.e345 + X.e5*Y.e45 + X.scalar*Y.e4, X.e1*Y.e15 - X.e12*Y.e125 - X.e123*Y.e1235 + X.e1234*Y.e12345 - X.e124*Y.e1245 - X.e13*Y.e135 - X.e134*Y.e1345 - X.e14*Y.e145 + X.e2*Y.e25 - X.e23*Y.e235 - X.e234*Y.e2345 - X.e24*Y.e245 + X.e3*Y.e35 - X.e34*Y.e345 + X.e4*Y.e45 + X.scalar*Y.e5, X.e3*Y.e123 - X.e34*Y.e1234 + X.e345*Y.e12345 + X.e35*Y.e1235 + X.e4*Y.e124 + X.e45*Y.e1245 - X.e5*Y.e125 + X.scalar*Y.e12, -X.e2*Y.e123 + X.e24*Y.e1234 - X.e245*Y.e12345 - X.e25*Y.e1235 + X.e4*Y.e134 + X.e45*Y.e1345 - X.e5*Y.e135 + X.scalar*Y.e13, -X.e2*Y.e124 - X.e23*Y.e1234 + X.e235*Y.e12345 - X.e25*Y.e1245 - X.e3*Y.e134 - X.e35*Y.e1345 - X.e5*Y.e145 + X.scalar*Y.e14, -X.e2*Y.e125 - X.e23*Y.e1235 + X.e234*Y.e12345 - X.e24*Y.e1245 - X.e3*Y.e135 - X.e34*Y.e1345 - X.e4*Y.e145 + X.scalar*Y.e15, X.e1*Y.e123 - X.e14*Y.e1234 + X.e145*Y.e12345 + X.e15*Y.e1235 + X.e4*Y.e234 + X.e45*Y.e2345 - X.e5*Y.e235 + X.scalar*Y.e23, X.e1*Y.e124 + X.e13*Y.e1234 - X.e135*Y.e12345 + X.e15*Y.e1245 - X.e3*Y.e234 - X.e35*Y.e2345 - X.e5*Y.e245 + X.scalar*Y.e24, X.e1*Y.e125 + X.e13*Y.e1235 - X.e134*Y.e12345 + X.e14*Y.e1245 - X.e3*Y.e235 - X.e34*Y.e2345 - X.e4*Y.e245 + X.scalar*Y.e25, X.e1*Y.e134 - X.e12*Y.e1234 + X.e125*Y.e12345 + X.e15*Y.e1345 + X.e2*Y.e234 + X.e25*Y.e2345 - X.e5*Y.e345 + X.scalar*Y.e34, X.e1*Y.e135 - X.e12*Y.e1235 + X.e124*Y.e12345 + X.e14*Y.e1345 + X.e2*Y.e235 + X.e24*Y.e2345 - X.e4*Y.e345 + X.scalar*Y.e35, X.e1*Y.e145 - X.e12*Y.e1245 - X.e123*Y.e12345 - X.e13*Y.e1345 + X.e2*Y.e245 - X.e23*Y.e2345 + X.e3*Y.e345 + X.scalar*Y.e45, -X.e4*Y.e1234 + X.e45*Y.e12345 + X.e5*Y.e1235 + X.scalar*Y.e123, X.e3*Y.e1234 - X.e35*Y.e12345 + X.e5*Y.e1245 + X.scalar*Y.e124, X.e3*Y.e1235 - X.e34*Y.e12345 + X.e4*Y.e1245 + X.scalar*Y.e125, -X.e2*Y.e1234 + X.e25*Y.e12345 + X.e5*Y.e1345 + X.scalar*Y.e134, -X.e2*Y.e1235 + X.e24*Y.e12345 + X.e4*Y.e1345 + X.scalar*Y.e135, -X.e2*Y.e1245 - X.e23*Y.e12345 - X.e3*Y.e1345 + X.scalar*Y.e145, X.e1*Y.e1234 - X.e15*Y.e12345 + X.e5*Y.e2345 + X.scalar*Y.e234, X.e1*Y.e1235 - X.e14*Y.e12345 + X.e4*Y.e2345 + X.scalar*Y.e235, X.e1*Y.e1245 + X.e13*Y.e12345 - X.e3*Y.e2345 + X.scalar*Y.e245, X.e1*Y.e1345 - X.e12*Y.e12345 + X.e2*Y.e2345 + X.scalar*Y.e345, -X.e5*Y.e12345 + X.scalar*Y.e1234, -X.e4*Y.e12345 + X.scalar*Y.e1235, X.e3*Y.e12345 + X.scalar*Y.e1245, -X.e2*Y.e12345 + X.scalar*Y.e1345, X.e1*Y.e12345 + X.scalar*Y.e2345, X.scalar*Y.e12345);\n}\n\nCGA3 outer(CGA3 X, CGA3 Y){\n    return CGA3(X.scalar*Y.scalar, X.e1*Y.scalar + X.scalar*Y.e1, X.e2*Y.scalar + X.scalar*Y.e2, X.e3*Y.scalar + X.scalar*Y.e3, X.e4*Y.scalar + X.scalar*Y.e4, X.e5*Y.scalar + X.scalar*Y.e5, X.e1*Y.e2 + X.e12*Y.scalar - X.e2*Y.e1 + X.scalar*Y.e12, X.e1*Y.e3 + X.e13*Y.scalar - X.e3*Y.e1 + X.scalar*Y.e13, X.e1*Y.e4 + X.e14*Y.scalar - X.e4*Y.e1 + X.scalar*Y.e14, X.e1*Y.e5 + X.e15*Y.scalar - X.e5*Y.e1 + X.scalar*Y.e15, X.e2*Y.e3 + X.e23*Y.scalar - X.e3*Y.e2 + X.scalar*Y.e23, X.e2*Y.e4 + X.e24*Y.scalar - X.e4*Y.e2 + X.scalar*Y.e24, X.e2*Y.e5 + X.e25*Y.scalar - X.e5*Y.e2 + X.scalar*Y.e25, X.e3*Y.e4 + X.e34*Y.scalar - X.e4*Y.e3 + X.scalar*Y.e34, X.e3*Y.e5 + X.e35*Y.scalar - X.e5*Y.e3 + X.scalar*Y.e35, X.e4*Y.e5 + X.e45*Y.scalar - X.e5*Y.e4 + X.scalar*Y.e45, X.e1*Y.e23 + X.e12*Y.e3 + X.e123*Y.scalar - X.e13*Y.e2 - X.e2*Y.e13 + X.e23*Y.e1 + X.e3*Y.e12 + X.scalar*Y.e123, X.e1*Y.e24 + X.e12*Y.e4 + X.e124*Y.scalar - X.e14*Y.e2 - X.e2*Y.e14 + X.e24*Y.e1 + X.e4*Y.e12 + X.scalar*Y.e124, X.e1*Y.e25 + X.e12*Y.e5 + X.e125*Y.scalar - X.e15*Y.e2 - X.e2*Y.e15 + X.e25*Y.e1 + X.e5*Y.e12 + X.scalar*Y.e125, X.e1*Y.e34 + X.e13*Y.e4 + X.e134*Y.scalar - X.e14*Y.e3 - X.e3*Y.e14 + X.e34*Y.e1 + X.e4*Y.e13 + X.scalar*Y.e134, X.e1*Y.e35 + X.e13*Y.e5 + X.e135*Y.scalar - X.e15*Y.e3 - X.e3*Y.e15 + X.e35*Y.e1 + X.e5*Y.e13 + X.scalar*Y.e135, X.e1*Y.e45 + X.e14*Y.e5 + X.e145*Y.scalar - X.e15*Y.e4 - X.e4*Y.e15 + X.e45*Y.e1 + X.e5*Y.e14 + X.scalar*Y.e145, X.e2*Y.e34 + X.e23*Y.e4 + X.e234*Y.scalar - X.e24*Y.e3 - X.e3*Y.e24 + X.e34*Y.e2 + X.e4*Y.e23 + X.scalar*Y.e234, X.e2*Y.e35 + X.e23*Y.e5 + X.e235*Y.scalar - X.e25*Y.e3 - X.e3*Y.e25 + X.e35*Y.e2 + X.e5*Y.e23 + X.scalar*Y.e235, X.e2*Y.e45 + X.e24*Y.e5 + X.e245*Y.scalar - X.e25*Y.e4 - X.e4*Y.e25 + X.e45*Y.e2 + X.e5*Y.e24 + X.scalar*Y.e245, X.e3*Y.e45 + X.e34*Y.e5 + X.e345*Y.scalar - X.e35*Y.e4 - X.e4*Y.e35 + X.e45*Y.e3 + X.e5*Y.e34 + X.scalar*Y.e345, X.e1*Y.e234 + X.e12*Y.e34 + X.e123*Y.e4 + X.e1234*Y.scalar - X.e124*Y.e3 - X.e13*Y.e24 + X.e134*Y.e2 + X.e14*Y.e23 - X.e2*Y.e134 + X.e23*Y.e14 - X.e234*Y.e1 - X.e24*Y.e13 + X.e3*Y.e124 + X.e34*Y.e12 - X.e4*Y.e123 + X.scalar*Y.e1234, X.e1*Y.e235 + X.e12*Y.e35 + X.e123*Y.e5 + X.e1235*Y.scalar - X.e125*Y.e3 - X.e13*Y.e25 + X.e135*Y.e2 + X.e15*Y.e23 - X.e2*Y.e135 + X.e23*Y.e15 - X.e235*Y.e1 - X.e25*Y.e13 + X.e3*Y.e125 + X.e35*Y.e12 - X.e5*Y.e123 + X.scalar*Y.e1235, X.e1*Y.e245 + X.e12*Y.e45 + X.e124*Y.e5 + X.e1245*Y.scalar - X.e125*Y.e4 - X.e14*Y.e25 + X.e145*Y.e2 + X.e15*Y.e24 - X.e2*Y.e145 + X.e24*Y.e15 - X.e245*Y.e1 - X.e25*Y.e14 + X.e4*Y.e125 + X.e45*Y.e12 - X.e5*Y.e124 + X.scalar*Y.e1245, X.e1*Y.e345 + X.e13*Y.e45 + X.e134*Y.e5 + X.e1345*Y.scalar - X.e135*Y.e4 - X.e14*Y.e35 + X.e145*Y.e3 + X.e15*Y.e34 - X.e3*Y.e145 + X.e34*Y.e15 - X.e345*Y.e1 - X.e35*Y.e14 + X.e4*Y.e135 + X.e45*Y.e13 - X.e5*Y.e134 + X.scalar*Y.e1345, X.e2*Y.e345 + X.e23*Y.e45 + X.e234*Y.e5 + X.e2345*Y.scalar - X.e235*Y.e4 - X.e24*Y.e35 + X.e245*Y.e3 + X.e25*Y.e34 - X.e3*Y.e245 + X.e34*Y.e25 - X.e345*Y.e2 - X.e35*Y.e24 + X.e4*Y.e235 + X.e45*Y.e23 - X.e5*Y.e234 + X.scalar*Y.e2345, X.e1*Y.e2345 + X.e12*Y.e345 + X.e123*Y.e45 + X.e1234*Y.e5 + X.e12345*Y.scalar - X.e1235*Y.e4 - X.e124*Y.e35 + X.e1245*Y.e3 + X.e125*Y.e34 - X.e13*Y.e245 + X.e134*Y.e25 - X.e1345*Y.e2 - X.e135*Y.e24 + X.e14*Y.e235 + X.e145*Y.e23 - X.e15*Y.e234 - X.e2*Y.e1345 + X.e23*Y.e145 - X.e234*Y.e15 + X.e2345*Y.e1 + X.e235*Y.e14 - X.e24*Y.e135 - X.e245*Y.e13 + X.e25*Y.e134 + X.e3*Y.e1245 + X.e34*Y.e125 + X.e345*Y.e12 - X.e35*Y.e124 - X.e4*Y.e1235 + X.e45*Y.e123 + X.e5*Y.e1234 + X.scalar*Y.e12345);\n}\n\n#define I_CGA3 CGA3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)\n\nCGA3 rcontract(CGA3 X, CGA3 Y){\n    return CGA3(X.e1*Y.e1 - X.e12*Y.e12 - X.e123*Y.e123 + X.e1234*Y.e1234 - X.e12345*Y.e12345 - X.e1235*Y.e1235 - X.e124*Y.e124 - X.e1245*Y.e1245 + X.e125*Y.e125 - X.e13*Y.e13 - X.e134*Y.e134 - X.e1345*Y.e1345 + X.e135*Y.e135 - X.e14*Y.e14 + X.e145*Y.e145 + X.e15*Y.e15 + X.e2*Y.e2 - X.e23*Y.e23 - X.e234*Y.e234 - X.e2345*Y.e2345 + X.e235*Y.e235 - X.e24*Y.e24 + X.e245*Y.e245 + X.e25*Y.e25 + X.e3*Y.e3 - X.e34*Y.e34 + X.e345*Y.e345 + X.e35*Y.e35 + X.e4*Y.e4 + X.e45*Y.e45 - X.e5*Y.e5 + X.scalar*Y.scalar, X.e1*Y.scalar + X.e12*Y.e2 - X.e123*Y.e23 - X.e1234*Y.e234 - X.e12345*Y.e2345 + X.e1235*Y.e235 - X.e124*Y.e24 + X.e1245*Y.e245 + X.e125*Y.e25 + X.e13*Y.e3 - X.e134*Y.e34 + X.e1345*Y.e345 + X.e135*Y.e35 + X.e14*Y.e4 + X.e145*Y.e45 - X.e15*Y.e5, -X.e12*Y.e1 + X.e123*Y.e13 + X.e1234*Y.e134 + X.e12345*Y.e1345 - X.e1235*Y.e135 + X.e124*Y.e14 - X.e1245*Y.e145 - X.e125*Y.e15 + X.e2*Y.scalar + X.e23*Y.e3 - X.e234*Y.e34 + X.e2345*Y.e345 + X.e235*Y.e35 + X.e24*Y.e4 + X.e245*Y.e45 - X.e25*Y.e5, -X.e123*Y.e12 - X.e1234*Y.e124 - X.e12345*Y.e1245 + X.e1235*Y.e125 - X.e13*Y.e1 + X.e134*Y.e14 - X.e1345*Y.e145 - X.e135*Y.e15 - X.e23*Y.e2 + X.e234*Y.e24 - X.e2345*Y.e245 - X.e235*Y.e25 + X.e3*Y.scalar + X.e34*Y.e4 + X.e345*Y.e45 - X.e35*Y.e5, X.e1234*Y.e123 + X.e12345*Y.e1235 - X.e124*Y.e12 + X.e1245*Y.e125 - X.e134*Y.e13 + X.e1345*Y.e135 - X.e14*Y.e1 - X.e145*Y.e15 - X.e234*Y.e23 + X.e2345*Y.e235 - X.e24*Y.e2 - X.e245*Y.e25 - X.e34*Y.e3 - X.e345*Y.e35 + X.e4*Y.scalar - X.e45*Y.e5, X.e12345*Y.e1234 + X.e1235*Y.e123 + X.e1245*Y.e124 - X.e125*Y.e12 + X.e1345*Y.e134 - X.e135*Y.e13 - X.e145*Y.e14 - X.e15*Y.e1 + X.e2345*Y.e234 - X.e235*Y.e23 - X.e245*Y.e24 - X.e25*Y.e2 - X.e345*Y.e34 - X.e35*Y.e3 - X.e45*Y.e4 + X.e5*Y.scalar, X.e12*Y.scalar + X.e123*Y.e3 - X.e1234*Y.e34 + X.e12345*Y.e345 + X.e1235*Y.e35 + X.e124*Y.e4 + X.e1245*Y.e45 - X.e125*Y.e5, -X.e123*Y.e2 + X.e1234*Y.e24 - X.e12345*Y.e245 - X.e1235*Y.e25 + X.e13*Y.scalar + X.e134*Y.e4 + X.e1345*Y.e45 - X.e135*Y.e5, -X.e1234*Y.e23 + X.e12345*Y.e235 - X.e124*Y.e2 - X.e1245*Y.e25 - X.e134*Y.e3 - X.e1345*Y.e35 + X.e14*Y.scalar - X.e145*Y.e5, X.e12345*Y.e234 - X.e1235*Y.e23 - X.e1245*Y.e24 - X.e125*Y.e2 - X.e1345*Y.e34 - X.e135*Y.e3 - X.e145*Y.e4 + X.e15*Y.scalar, X.e123*Y.e1 - X.e1234*Y.e14 + X.e12345*Y.e145 + X.e1235*Y.e15 + X.e23*Y.scalar + X.e234*Y.e4 + X.e2345*Y.e45 - X.e235*Y.e5, X.e1234*Y.e13 - X.e12345*Y.e135 + X.e124*Y.e1 + X.e1245*Y.e15 - X.e234*Y.e3 - X.e2345*Y.e35 + X.e24*Y.scalar - X.e245*Y.e5, -X.e12345*Y.e134 + X.e1235*Y.e13 + X.e1245*Y.e14 + X.e125*Y.e1 - X.e2345*Y.e34 - X.e235*Y.e3 - X.e245*Y.e4 + X.e25*Y.scalar, -X.e1234*Y.e12 + X.e12345*Y.e125 + X.e134*Y.e1 + X.e1345*Y.e15 + X.e234*Y.e2 + X.e2345*Y.e25 + X.e34*Y.scalar - X.e345*Y.e5, X.e12345*Y.e124 - X.e1235*Y.e12 + X.e1345*Y.e14 + X.e135*Y.e1 + X.e2345*Y.e24 + X.e235*Y.e2 - X.e345*Y.e4 + X.e35*Y.scalar, -X.e12345*Y.e123 - X.e1245*Y.e12 - X.e1345*Y.e13 + X.e145*Y.e1 - X.e2345*Y.e23 + X.e245*Y.e2 + X.e345*Y.e3 + X.e45*Y.scalar, X.e123*Y.scalar + X.e1234*Y.e4 + X.e12345*Y.e45 - X.e1235*Y.e5, -X.e1234*Y.e3 - X.e12345*Y.e35 + X.e124*Y.scalar - X.e1245*Y.e5, -X.e12345*Y.e34 - X.e1235*Y.e3 - X.e1245*Y.e4 + X.e125*Y.scalar, X.e1234*Y.e2 + X.e12345*Y.e25 + X.e134*Y.scalar - X.e1345*Y.e5, X.e12345*Y.e24 + X.e1235*Y.e2 - X.e1345*Y.e4 + X.e135*Y.scalar, -X.e12345*Y.e23 + X.e1245*Y.e2 + X.e1345*Y.e3 + X.e145*Y.scalar, -X.e1234*Y.e1 - X.e12345*Y.e15 + X.e234*Y.scalar - X.e2345*Y.e5, -X.e12345*Y.e14 - X.e1235*Y.e1 - X.e2345*Y.e4 + X.e235*Y.scalar, X.e12345*Y.e13 - X.e1245*Y.e1 + X.e2345*Y.e3 + X.e245*Y.scalar, -X.e12345*Y.e12 - X.e1345*Y.e1 - X.e2345*Y.e2 + X.e345*Y.scalar, X.e1234*Y.scalar - X.e12345*Y.e5, -X.e12345*Y.e4 + X.e1235*Y.scalar, X.e12345*Y.e3 + X.e1245*Y.scalar, -X.e12345*Y.e2 + X.e1345*Y.scalar, X.e12345*Y.e1 + X.e2345*Y.scalar, X.e12345*Y.scalar);\n}\n\nCGA3 reverse(CGA3 X){\n    return CGA3(X.scalar, X.e1, X.e2, X.e3, X.e4, X.e5, -X.e12, -X.e13, -X.e14, -X.e15, -X.e23, -X.e24, -X.e25, -X.e34, -X.e35, -X.e45, -X.e123, -X.e124, -X.e125, -X.e134, -X.e135, -X.e145, -X.e234, -X.e235, -X.e245, -X.e345, X.e1234, X.e1235, X.e1245, X.e1345, X.e2345, X.e12345);\n}\n\nCGA3 conjugate(CGA3 X){\n    return reverse(involve(X));\n}\n\nCGA3 outer(CGA3 X, CGA3 Y, CGA3 Z){\n    return outer(outer(X, Y), Z);\n}\n\nCGA3 invert(CGA3 X){\n    return mul(1.0/lcontract(X,conjugate(X)).scalar, conjugate(X));\n}\n\nCGA3 div(CGA3 X, CGA3 Y){\n    return mul(X, invert(Y));\n}\n\nCGA3 dual(CGA3 X){\n    return div(X, I_CGA3);\n}\n\n// H.glsl\nconst int Idx_H_real = 0;\nconst int Idx_H_i = 1;\nconst int Idx_H_j = 2;\nconst int Idx_H_k = 3;\n\nstruct H {\n    float real;\n    float i;\n    float j;\n    float k;\n};\n\nH fromArray(float X[4]){\n    return H(X[0], X[1], X[2], X[3]);\n}\n\nvoid toArray(H X, inout float X_ary[4]){\n    X_ary[0] = X.real;\n    X_ary[1] = X.i;\n    X_ary[2] = X.j;\n    X_ary[3] = X.k;\n}\n\nvoid zero(inout float X[4]){\n    X[0] = 0.0;\n    X[1] = 0.0;\n    X[2] = 0.0;\n    X[3] = 0.0;\n}\n\nH add(H X, H Y){\n    return H(X.real + Y.real, X.i + Y.i, X.j + Y.j, X.k + Y.k);\n}\n\nH add(H X, H Y, H Z){\n    return add(add(X, Y), Z);\n}\n\nH add(H X, H Y, H Z, H P){\n    return add(add(add(X, Y), Z), P);\n}\n\n#define ONE_H H(1.0, 0.0, 0.0, 0.0)\n\nH mul(float a, H X){\n    return H(X.real*a, X.i*a, X.j*a, X.k*a);\n}\n\nH sub(H X, H Y){\n    return H(X.real - Y.real, X.i - Y.i, X.j - Y.j, X.k - Y.k);\n}\n\n#define ZERO_H H(0.0, 0.0, 0.0, 0.0)\n\nH mul(int a, H X){\n    return mul(float(a), X);\n}\n\nH mul(H X, H Y){\n    return H(-X.i*Y.i - X.j*Y.j - X.k*Y.k + X.real*Y.real, X.i*Y.real + X.j*Y.k - X.k*Y.j + X.real*Y.i, -X.i*Y.k + X.j*Y.real + X.k*Y.i + X.real*Y.j, X.i*Y.j - X.j*Y.i + X.k*Y.real + X.real*Y.k);\n}\n\nH scalar_H(float a){\n    return mul(a, ONE_H);\n}\n\nH mul(H X, H Y, H Z){\n    return mul(mul(X, Y), Z);\n}\n\nH involve(H X){\n    return H(X.real, -X.i, -X.j, X.k);\n}\n\nH inner(H X, H Y){\n    return H(-X.i*Y.i - X.j*Y.j - X.k*Y.k, X.j*Y.k - X.k*Y.j, -X.i*Y.k + X.k*Y.i, 0.0);\n}\n\nH lcontract(H X, H Y){\n    return H(-X.i*Y.i - X.j*Y.j - X.k*Y.k + X.real*Y.real, X.j*Y.k + X.real*Y.i, -X.i*Y.k + X.real*Y.j, X.real*Y.k);\n}\n\nH outer(H X, H Y){\n    return H(X.real*Y.real, X.i*Y.real + X.real*Y.i, X.j*Y.real + X.real*Y.j, X.i*Y.j - X.j*Y.i + X.k*Y.real + X.real*Y.k);\n}\n\n#define I_H H(0.0, 0.0, 0.0, 1.0)\n\nH rcontract(H X, H Y){\n    return H(-X.i*Y.i - X.j*Y.j - X.k*Y.k + X.real*Y.real, X.i*Y.real - X.k*Y.j, X.j*Y.real + X.k*Y.i, X.k*Y.real);\n}\n\nH reverse(H X){\n    return H(X.real, X.i, X.j, -X.k);\n}\n\nH conjugate(H X){\n    return reverse(involve(X));\n}\n\nH outer(H X, H Y, H Z){\n    return outer(outer(X, Y), Z);\n}\n\nH invert(H X){\n    return mul(1.0/lcontract(X,conjugate(X)).real, conjugate(X));\n}\n\nH div(H X, H Y){\n    return mul(X, invert(Y));\n}\n\nH dual(H X){\n    return div(X, I_H);\n}\n\nCGA3 vecToCGA(vec3 v){\n    CGA3 X = ZERO_CGA3;\n    X.e1 = v.x;\n    X.e2 = v.y;\n    X.e3 = v.z;\n    return X;\n}\n\nCGA3 vecToCGA(vec4 v){\n    CGA3 X = ZERO_CGA3;\n    X.scalar = v.x;\n    X.e1 = v.y;\n    X.e2 = v.z;\n    X.e3 = v.w;\n    return X;\n}\n\nCGA3 weightVecToCGA(vec3 v){\n    CGA3 X = ZERO_CGA3;\n    X.e12 = -v.x;\n    X.e23 = v.y;\n    X.e13 = -v.z;\n    return X;\n}\n\nCGA3 weightVecToCGA(vec4 v){\n    CGA3 X = ZERO_CGA3;\n    X.scalar = v.x;\n    X.e23 = -v.y;\n    X.e13 = v.z;\n    X.e12 = -v.w;\n    return X;\n}\n\nvoid toVec(out vec3 x, CGA3 X) {\n    x = vec3(X.e1, X.e2, X.e3);\n}\n\nH vecToH(vec3 v){\n    H X = ZERO_H;\n    X.real = 1.0;\n    X.i = v.x;\n    X.j = v.y;\n    X.k = v.z;\n    return X;\n}\n\nH vecToH(vec4 v){\n    H X = ZERO_H;\n    X.real = v.x;\n    X.i = v.y;\n    X.j = v.z;\n    X.k = v.w;\n    return X;\n}\n\nvoid toVec(H X, inout vec4 x) {\n    x.x = X.real;\n    x.y = X.i;\n    x.z = X.j;\n    x.w = X.k;\n}\n\n// CGA3 point(vec3 x){\n//     return point(vecToCGA(x));\n// }\n\n// vec3 vecFromPoint(CGA3 x) {\n//     x = point_coords(x);\n//     return vec3(x.e1, x.e2, x.e3);\n// }\n\nCGA3 outer(CGA3 p, CGA3 q, CGA3 r, CGA3 s){\n    return outer(outer(p,q,r),s);\n}\n\nCGA3 mul(CGA3 p, CGA3 q, CGA3 r, CGA3 s){\n    return mul(mul(p,q,r),s);\n}\n\n// replace this stuff with IPNS sphere stuff\n// CGA3 sphere(vec3 a, vec3 b, vec3 c, vec3 d) {\n//     return outer(point(a), point(b), point(c), point(d));\n// }\n\n// vec3 sphere_center(vec3 a, vec3 b, vec3 c, vec3 d){\n//     CGA3 sphere = sphere(a,b,c,d);\n//     return vecFromPoint(mul(sphere, INF(), sphere));\n// }\n\n// vec3 reflect_glsl(vec3 x, CGA3 R){\n//     return vecFromPoint(mul(R,point(x),R));\n// }\n\n// float sphere_radius(vec3 a, vec3 b, vec3 c, vec3 d){\n//     CGA2 circ = sphere(a,b,c,d);\n//     return circle_radius(circ);\n// }\n\n// CGA3 dual_sphere(vec3 x){\n//     float y[3];\n//     y[0] = x[0];\n//     y[1] = x[1];\n//     y[2] = x[2];\n//     return dual_sphere(injectOneBlade(zero(), y));\n// }\n\nH fromVec(vec4 w) {\n  return vecToH(w);\n}\n\nH fromVec(vec3 w) {\n  return vecToH(w);\n}\n\nH weight(vec3 w) {\n  return fromVec(w);\n  // return invert(fromVec(normalize(w)));\n}\n\nH weight(vec4 w) {\n  return fromVec(w);\n  // return invert(fromVec(normalize(w)));\n}\n\nH weight(H w) {\n  return w;\n  // return invert(mul(sqrt(lcontract(w, w).real), w));\n}\n\nstruct Patch {\n  vec4 vertex;\n  vec3 normal;\n};\n\nfloat eps = 0.01;\n\nPatch bilinearQuad(H point0, H point1, H point2, H point3, H weight0, H weight1, H weight2, H weight3, float u, float v) {\n  H W0 = mul((1.0 - u) * (1.0 - v), weight0); // 0, 0\n  H W1 = mul(u * (1.0 - v), weight1); // 1, 0\n  H W2 = mul((1.0 - u) * v, weight2); // 0, 1\n  H W3 = mul(u * v, weight3); // 1, 1\n\n  H top = add(mul(point0, W0), mul(point1, W1), mul(point2, W2), mul(point3, W3));\n\n  float uu = u + eps;\n  H W0_uu = mul((1.0 - uu) * (1.0 - v), weight0); // 0, 0\n  H W1_uu = mul((uu) * (1.0 - v), weight1); // 1, 0\n  H W2_uu = mul((1.0 - uu) * v, weight2); // 0, 1\n  H W3_uu = mul((uu) * v, weight3); // 1, 1\n  H top_uu = add(mul(point0, W0_uu), mul(point1, W1_uu), mul(point2, W2_uu), mul(point3, W3_uu));\n\n  float vv = v + eps;\n  H W0_vv = mul((1.0 - u) * (1.0 - vv), weight0); // 0, 0\n  H W1_vv = mul(u * (1.0 - vv), weight1); // 1, 0\n  H W2_vv = mul((1.0 - u) * (vv), weight2); // 0, 1\n  H W3_vv = mul(u * (vv), weight3); // 1, 1\n\n  H top_vv = add(mul(point0, W0_vv), mul(point1, W1_vv), mul(point2, W2_vv), mul(point3, W3_vv));\n\n  H bottom = add(W0, W1, W2, W3);\n\n  H X = div(top, bottom);\n  H X_uu = div(top_uu, bottom);\n  H X_vv = div(top_vv, bottom);\n  vec4 x = vec4(X.i, X.j, X.k, X.real);\n  vec3 x_uu = vec3(X_uu.i, X_uu.j, X_uu.k) - x.xyz;\n  vec3 x_vv = vec3(X_vv.i, X_vv.j, X_vv.k) - x.xyz;\n  vec3 crossed = cross(x_uu, x_vv);\n  vec3 normal = normalize(crossed);\n  return Patch(x, normal);\n}\n\nPatch bilinearQuad(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec4 w0, vec4 w1, vec4 w2, vec4 w3, float u, float v) {\n  return bilinearQuad(fromVec(p0), fromVec(p1), fromVec(p2), fromVec(p3), weight(w0), weight(w1), weight(w2), weight(w3), u, v);\n}\n\nPatch bilinearQuad(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 w0, vec3 w1, vec3 w2, vec3 w3, float u, float v) {\n  return bilinearQuad(fromVec(p0), fromVec(p1), fromVec(p2), fromVec(p3), weight(w0), weight(w1), weight(w2), weight(w3), u, v);\n}\n\nPatch bilinearQuad(vec3 p0, vec3 p1, vec3 p2, vec3 p3, H w0, H w1, H w2, H w3, float u, float v) {\n  return bilinearQuad(fromVec(p0), fromVec(p1), fromVec(p2), fromVec(p3), weight(w0), weight(w1), weight(w2), weight(w3), u, v);\n}\n\nPatch bilinearTri(H point0, H point1, H point2, H weight0, H weight1, H weight2, float u, float v) {\n  H W0 = mul((1.0 - u - v), weight0); // 0, 0\n  H W1 = mul(u, weight1); // 1, 0\n  H W2 = mul(v, weight2); // 0, 1\n\n  H top = add(mul(point0, W0), mul(point1, W1), mul(point2, W2));\n\n  float uu = u + eps;\n  H W0_uu = mul((1.0 - uu - v), weight0); // 0, 0\n  H W1_uu = mul(uu, weight1); // 1, 0\n  H W2_uu = mul(v, weight2); // 0, 1\n  H top_uu = add(mul(point0, W0_uu), mul(point1, W1_uu), mul(point2, W2_uu));\n\n  float vv = v + eps;\n  H W0_vv = mul((1.0 - u - vv), weight0); // 0, 0\n  H W1_vv = mul(u, weight1); // 1, 0\n  H W2_vv = mul(vv, weight2); // 0, 1\n\n  H top_vv = add(mul(point0, W0_vv), mul(point1, W1_vv), mul(point2, W2_vv));\n\n  H bottom = add(W0, W1, W2);\n\n  H X = div(top, bottom);\n  H X_uu = div(top_uu, bottom);\n  H X_vv = div(top_vv, bottom);\n  vec4 x = vec4(X.i, X.j, X.k, X.real);\n  vec3 x_uu = vec3(X_uu.i, X_uu.j, X_uu.k) - x.xyz;\n  vec3 x_vv = vec3(X_vv.i, X_vv.j, X_vv.k) - x.xyz;\n  vec3 crossed = cross(x_uu, x_vv);\n  vec3 normal = normalize(crossed);\n  return Patch(x, normal);\n}\n\nPatch bilinearTri(vec4 p0, vec4 p1, vec4 p2, vec4 w0, vec4 w1, vec4 w2, float u, float v) {\n  return bilinearTri(fromVec(p0), fromVec(p1), fromVec(p2), weight(w0), weight(w1), weight(w2), u, v);\n}\n\nPatch bilinearTri(vec3 p0, vec3 p1, vec3 p2, vec3 w0, vec3 w1, vec3 w2, float u, float v) {\n  return bilinearTri(fromVec(p0), fromVec(p1), fromVec(p2), weight(w0), weight(w1), weight(w2), u, v);\n}\n\nPatch bilinearTri(vec3 p0, vec3 p1, vec3 p2, H w0, H w1, H w2, float u, float v) {\n  return bilinearTri(fromVec(p0), fromVec(p1), fromVec(p2), weight(w0), weight(w1), weight(w2), u, v);\n}\nlayout(location = 0) in vec3 position;\nlayout(location = 1) in mat3x4 points;\nlayout(location = 4) in mat3x4 weights;\n\nuniform mat4 projection, view;\nuniform vec3 offset;\n\nout vec3 n;\nout vec2 uv;\nout vec4 eye;\n\nvoid main() {\n\n  Patch p = bilinearTri(points[0], points[1], points[2], weights[0], weights[1],\n                        weights[2], position.x, position.y);\n\n  n = p.normal;\n  uv = vec2(position.x, position.y);\n  gl_Position = projection * view * vec4(p.vertex.xyz, 1.0);\n  eye = view * vec4(1,0,0,0);\n  // gl_Position = vec4(position, 1.0);\n}"; // eslint-disable-line

const isArray = Array.isArray;

const isArrayLike = (x) => x != null && typeof x !== "function" && x.length !== undefined;

const defError = (prefix, suffix = (msg) => (msg !== undefined ? ": " + msg : "")) => class extends Error {
    constructor(msg) {
        super(prefix(msg) + suffix(msg));
    }
};

const IllegalArgumentError = defError(() => "illegal argument(s)");
const illegalArgs = (msg) => {
    throw new IllegalArgumentError(msg);
};

/**
 * Attempts to obtain an iterator from `x` and throws error if `x` is
 * not iterable.
 *
 * @param x -
 */
const ensureIterable = (x) => {
    (x == null || !x[Symbol.iterator]) &&
        illegalArgs(`value is not iterable: ${x}`);
    return x;
};

/**
 * Helper function to avoid unnecessary copying if `x` is already an
 * array.
 *
 * @remarks
 * First checks if `x` is an array and if so returns it. Else attempts
 * to obtain an iterator from `x` and if successful collects it as array
 * and returns it. Throws error if `x` isn't iterable.
 *
 * @param x -
 */
const ensureArray = (x) => isArray(x) ? x : [...ensureIterable(x)];

const compare = (a, b) => {
    if (a === b) {
        return 0;
    }
    if (a == null) {
        return b == null ? 0 : -1;
    }
    if (b == null) {
        return a == null ? 0 : 1;
    }
    if (typeof a.compare === "function") {
        return a.compare(b);
    }
    if (typeof b.compare === "function") {
        return -b.compare(a);
    }
    return a < b ? -1 : a > b ? 1 : 0;
};

const OBJP = Object.getPrototypeOf({});
const FN$1 = "function";
const STR = "string";
const equiv = (a, b) => {
    let proto;
    if (a === b) {
        return true;
    }
    if (a != null) {
        if (typeof a.equiv === FN$1) {
            return a.equiv(b);
        }
    }
    else {
        return a == b;
    }
    if (b != null) {
        if (typeof b.equiv === FN$1) {
            return b.equiv(a);
        }
    }
    else {
        return a == b;
    }
    if (typeof a === STR || typeof b === STR) {
        return false;
    }
    if (((proto = Object.getPrototypeOf(a)), proto == null || proto === OBJP) &&
        ((proto = Object.getPrototypeOf(b)), proto == null || proto === OBJP)) {
        return equivObject(a, b);
    }
    if (typeof a !== FN$1 &&
        a.length !== undefined &&
        typeof b !== FN$1 &&
        b.length !== undefined) {
        return equivArrayLike(a, b);
    }
    if (a instanceof Set && b instanceof Set) {
        return equivSet(a, b);
    }
    if (a instanceof Map && b instanceof Map) {
        return equivMap(a, b);
    }
    if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
    }
    if (a instanceof RegExp && b instanceof RegExp) {
        return a.toString() === b.toString();
    }
    // NaN
    return a !== a && b !== b;
};
const equivArrayLike = (a, b, _equiv = equiv) => {
    let l = a.length;
    if (l === b.length) {
        while (l-- > 0 && _equiv(a[l], b[l]))
            ;
    }
    return l < 0;
};
const equivSet = (a, b, _equiv = equiv) => a.size === b.size && _equiv([...a.keys()].sort(), [...b.keys()].sort());
const equivMap = (a, b, _equiv = equiv) => a.size === b.size && _equiv([...a].sort(), [...b].sort());
const equivObject = (a, b, _equiv = equiv) => {
    if (Object.keys(a).length !== Object.keys(b).length) {
        return false;
    }
    for (let k in a) {
        if (!b.hasOwnProperty(k) || !_equiv(a[k], b[k])) {
            return false;
        }
    }
    return true;
};

/**
 * Generic binary heap / priority queue with customizable ordering via
 * user-supplied comparator. By default, implements min-heap ordering
 * and uses @thi.ng/compare.
 *
 * @example
 * ```ts
 * h = new Heap([20, 5, 10]);
 * h.push(15);
 *
 * h.pop(); // 5
 * h.pop(); // 10
 * h.pop(); // 15
 * h.pop(); // 20
 * h.pop(); // undefined
 * ```
 */
class Heap$1 {
    constructor(values, opts) {
        opts = { compare, equiv, ...opts };
        this.compare = opts.compare;
        this.equiv = opts.equiv;
        this.values = [];
        if (values) {
            this.into(values);
        }
    }
    static parentIndex(idx) {
        return idx > 0 ? (idx - 1) >> 1 : -1;
    }
    static childIndex(idx) {
        return idx >= 0 ? (idx << 1) + 1 : -1;
    }
    *[Symbol.iterator]() {
        yield* this.min();
    }
    get length() {
        return this.values.length;
    }
    copy() {
        const h = this.empty();
        h.values = this.values.slice();
        return h;
    }
    clear() {
        this.values.length = 0;
    }
    empty() {
        return new Heap$1(null, { compare: this.compare });
    }
    peek() {
        return this.values[0];
    }
    push(val) {
        this.values.push(val);
        this.percolateUp(this.values.length - 1);
        return this;
    }
    pop() {
        const vals = this.values;
        const tail = vals.pop();
        let res;
        if (vals.length > 0) {
            res = vals[0];
            vals[0] = tail;
            this.percolateDown(0);
        }
        else {
            res = tail;
        }
        return res;
    }
    pushPop(val, vals = this.values) {
        const head = vals[0];
        if (vals.length > 0 && this.compare(head, val) <= 0) {
            vals[0] = val;
            val = head;
            this.percolateDown(0, vals);
        }
        return val;
    }
    into(vals) {
        for (let v of vals) {
            this.push(v);
        }
        return this;
    }
    /**
     * Calls {@link Heap.pushPop} for each given value in `vals` and
     * returns last result (i.e. the smallest value in heap after
     * processing all `vals`).
     *
     * @param vals - values to insert
     */
    pushPopAll(vals) {
        let res;
        for (let v of vals) {
            res = this.pushPop(v);
        }
        return res;
    }
    replaceHead(val) {
        const res = this.values[0];
        this.values[0] = val;
        this.percolateDown(0);
        return res;
    }
    remove(val) {
        const { values, equiv } = this;
        for (let i = values.length; i-- > 0;) {
            if (equiv(values[i], val)) {
                this.values.splice(i, 1);
                this.heapify();
                return true;
            }
        }
        return false;
    }
    find(val) {
        const { values, equiv } = this;
        for (let i = values.length; i-- > 0;) {
            if (equiv(values[i], val)) {
                return values[i];
            }
        }
    }
    findWith(pred) {
        const values = this.values;
        for (let i = values.length; i-- > 0;) {
            if (pred(values[i]))
                return values[i];
        }
    }
    has(val) {
        return this.find(val) !== undefined;
    }
    heapify(vals = this.values) {
        for (let i = (vals.length - 1) >> 1; i >= 0; i--) {
            this.percolateDown(i, vals);
        }
    }
    /**
     * Returns the largest `n` values (or less) in heap, based on
     * comparator ordering.
     *
     * @param n - number of values
     */
    max(n = this.values.length) {
        const { compare, values } = this;
        const res = values.slice(0, n);
        if (!n) {
            return res;
        }
        this.heapify(res);
        for (let m = values.length; n < m; n++) {
            this.pushPop(values[n], res);
        }
        return res.sort((a, b) => compare(b, a));
    }
    /**
     * Returns the smallest `n` values (or less) in heap, based on
     * comparator ordering.
     *
     * @param n - number of values
     */
    min(n = this.values.length) {
        const { compare, values } = this;
        const res = values.slice(0, n).sort(compare);
        if (!n) {
            return res;
        }
        let x = res[n - 1], y;
        for (let i = n, m = values.length; i < m; i++) {
            y = values[i];
            if (compare(y, x) < 0) {
                res.splice(binarySearch(y, res, 0, n, compare), 0, y);
                res.pop();
                x = res[n - 1];
            }
        }
        return res;
    }
    parent(n) {
        n = Heap$1.parentIndex(n);
        return n >= 0 ? this.values[n] : undefined;
    }
    children(n) {
        n = Heap$1.childIndex(n);
        const vals = this.values;
        const m = vals.length;
        if (n >= m)
            return;
        if (n === m - 1)
            return [vals[n]];
        return [vals[n], vals[n + 1]];
    }
    leaves() {
        const vals = this.values;
        if (!vals.length) {
            return [];
        }
        return vals.slice(Heap$1.parentIndex(vals.length - 1) + 1);
    }
    percolateUp(i, vals = this.values) {
        const node = vals[i];
        const cmp = this.compare;
        while (i > 0) {
            const pi = (i - 1) >> 1;
            const parent = vals[pi];
            if (cmp(node, parent) >= 0) {
                break;
            }
            vals[pi] = node;
            vals[i] = parent;
            i = pi;
        }
    }
    percolateDown(i, vals = this.values) {
        const n = vals.length;
        const node = vals[i];
        const cmp = this.compare;
        let child = (i << 1) + 1;
        while (child < n) {
            const next = child + 1;
            if (next < n && cmp(vals[child], vals[next]) >= 0) {
                child = next;
            }
            if (cmp(vals[child], node) < 0) {
                vals[i] = vals[child];
            }
            else {
                break;
            }
            i = child;
            child = (i << 1) + 1;
        }
        vals[i] = node;
    }
}
const binarySearch = (x, vals, lo, hi, cmp) => {
    let m;
    while (lo < hi) {
        m = (lo + hi) >>> 1;
        if (cmp(x, vals[m]) < 0) {
            hi = m;
        }
        else {
            lo = m + 1;
        }
    }
    return lo;
};

let EPS = 1e-6;

const isIterable = (x) => x != null && typeof x[Symbol.iterator] === "function";

/**
 * Reducer composition helper, internally used by various transducers
 * during initialization. Takes existing reducer `rfn` (a 3-tuple) and a
 * reducing function `fn`. Returns a new reducer tuple.
 *
 * @remarks
 * `rfn[2]` reduces values of type `B` into an accumulator of type `A`.
 * `fn` accepts values of type `C` and produces interim results of type
 * `B`, which are then (possibly) passed to the "inner" `rfn[2]`
 * function. Therefore the resulting reducer takes inputs of `C` and an
 * accumulator of type `A`.
 *
 * It is assumed that `fn` internally calls `rfn[2]` to pass its own
 * results for further processing by the nested reducer `rfn`.
 *
 * @example
 * ```ts
 * compR(rfn, fn)
 * // [rfn[0], rfn[1], fn]
 * ```
 *
 * @param rfn -
 * @param fn -
 */
const compR = (rfn, fn) => [rfn[0], rfn[1], fn];

/**
 * Internal use only. **Do NOT use in user land code!**
 *
 * @internal
 */
const SEMAPHORE = Symbol();
/**
 * No-effect placeholder function.
 */
const NO_OP = () => { };

const implementsFunction = (x, fn) => x != null && typeof x[fn] === "function";

const ensureTransducer = (x) => implementsFunction(x, "xform") ? x.xform() : x;

const IllegalArityError = defError(() => "illegal arity");
const illegalArity = (n) => {
    throw new IllegalArityError(n);
};

class Reduced {
    constructor(val) {
        this.value = val;
    }
    deref() {
        return this.value;
    }
}
const reduced = (x) => new Reduced(x);
const isReduced = (x) => x instanceof Reduced;
const ensureReduced = (x) => x instanceof Reduced ? x : new Reduced(x);
const unreduced = (x) => (x instanceof Reduced ? x.deref() : x);

const parseArgs = (args) => args.length === 2
    ? [undefined, args[1]]
    : args.length === 3
        ? [args[1], args[2]]
        : illegalArity(args.length);
function reduce$1(...args) {
    const rfn = args[0];
    const init = rfn[0];
    const complete = rfn[1];
    const reduce = rfn[2];
    args = parseArgs(args);
    const acc = args[0] == null ? init() : args[0];
    const xs = args[1];
    return unreduced(complete(implementsFunction(xs, "$reduce")
        ? xs.$reduce(reduce, acc)
        : isArrayLike(xs)
            ? reduceArray(reduce, acc, xs)
            : reduceIterable(reduce, acc, xs)));
}
const reduceArray = (rfn, acc, xs) => {
    for (let i = 0, n = xs.length; i < n; i++) {
        acc = rfn(acc, xs[i]);
        if (isReduced(acc)) {
            acc = acc.deref();
            break;
        }
    }
    return acc;
};
const reduceIterable = (rfn, acc, xs) => {
    for (let x of xs) {
        acc = rfn(acc, x);
        if (isReduced(acc)) {
            acc = acc.deref();
            break;
        }
    }
    return acc;
};
/**
 * Convenience helper for building a full {@link Reducer} using the identity
 * function (i.e. `(x) => x`) as completion step (true for 90% of all
 * bundled transducers).
 *
 * @param init - init step of reducer
 * @param rfn - reduction step of reducer
 */
const reducer = (init, rfn) => [init, (acc) => acc, rfn];

function push(xs) {
    return xs
        ? [...xs]
        : reducer(() => [], (acc, x) => (acc.push(x), acc));
}

/**
 * Takes a transducer and input iterable. Returns iterator of
 * transformed results.
 *
 * @param xform -
 * @param xs -
 */
function* iterator(xform, xs) {
    const rfn = ensureTransducer(xform)(push());
    const complete = rfn[1];
    const reduce = rfn[2];
    for (let x of xs) {
        const y = reduce([], x);
        if (isReduced(y)) {
            yield* unreduced(complete(y.deref()));
            return;
        }
        if (y.length) {
            yield* y;
        }
    }
    yield* unreduced(complete([]));
}
/**
 * Optimized version of {@link iterator} for transducers which are
 * guaranteed to:
 *
 * 1) Only produce none or a single result per input
 * 2) Do not require a `completion` reduction step
 *
 * @param xform -
 * @param xs -
 */
function* iterator1(xform, xs) {
    const reduce = (ensureTransducer(xform)([NO_OP, NO_OP, (_, x) => x]))[2];
    for (let x of xs) {
        let y = reduce(SEMAPHORE, x);
        if (isReduced(y)) {
            y = unreduced(y.deref());
            if (y !== SEMAPHORE) {
                yield y;
            }
            return;
        }
        if (y !== SEMAPHORE) {
            yield y;
        }
    }
}
/**
 * Helper function used by various transducers to wrap themselves as
 * transforming iterators. Delegates to {@link iterator1} by default.
 *
 * @param xform -
 * @param args -
 * @param impl -
 *
 * @internal
 */
const __iter = (xform, args, impl = iterator1) => {
    const n = args.length - 1;
    return isIterable(args[n])
        ? args.length > 1
            ? impl(xform.apply(null, args.slice(0, n)), args[n])
            : impl(xform(), args[0])
        : undefined;
};

function map(fn, src) {
    return isIterable(src)
        ? iterator1(map(fn), src)
        : (rfn) => {
            const r = rfn[2];
            return compR(rfn, (acc, x) => r(acc, fn(x)));
        };
}

function comp$1(...fns) {
    let [a, b, c, d, e, f, g, h, i, j] = fns;
    switch (fns.length) {
        case 0:
            illegalArity(0);
        case 1:
            return a;
        case 2:
            return (...xs) => a(b(...xs));
        case 3:
            return (...xs) => a(b(c(...xs)));
        case 4:
            return (...xs) => a(b(c(d(...xs))));
        case 5:
            return (...xs) => a(b(c(d(e(...xs)))));
        case 6:
            return (...xs) => a(b(c(d(e(f(...xs))))));
        case 7:
            return (...xs) => a(b(c(d(e(f(g(...xs)))))));
        case 8:
            return (...xs) => a(b(c(d(e(f(g(h(...xs))))))));
        case 9:
            return (...xs) => a(b(c(d(e(f(g(h(i(...xs)))))))));
        case 10:
        default:
            const fn = (...xs) => a(b(c(d(e(f(g(h(i(j(...xs))))))))));
            return fns.length === 10 ? fn : comp$1(fn, ...fns.slice(10));
    }
}

function comp(...fns) {
    fns = fns.map(ensureTransducer);
    return comp$1.apply(null, fns);
}

function mapIndexed(...args) {
    return (__iter(mapIndexed, args) ||
        ((rfn) => {
            const r = rfn[2];
            const fn = args[0];
            let i = args[1] || 0;
            return compR(rfn, (acc, x) => r(acc, fn(i++, x)));
        }));
}

function range(from, to, step) {
    return new Range(from, to, step);
}
/**
 * Simple class wrapper around given range interval and implementing
 * `Iterable` and {@link IReducible} interfaces, the latter is used to
 * accelerate use with {@link (reduce:1)}.
 */
class Range {
    constructor(from, to, step) {
        if (from === undefined) {
            from = 0;
            to = Infinity;
        }
        else if (to === undefined) {
            to = from;
            from = 0;
        }
        step = step === undefined ? (from < to ? 1 : -1) : step;
        this.from = from;
        this.to = to;
        this.step = step;
    }
    *[Symbol.iterator]() {
        let { from, to, step } = this;
        if (step > 0) {
            while (from < to) {
                yield from;
                from += step;
            }
        }
        else if (step < 0) {
            while (from > to) {
                yield from;
                from += step;
            }
        }
    }
    $reduce(rfn, acc) {
        const step = this.step;
        if (step > 0) {
            for (let i = this.from, n = this.to; i < n && !isReduced(acc); i += step) {
                acc = rfn(acc, i);
            }
        }
        else {
            for (let i = this.from, n = this.to; i > n && !isReduced(acc); i += step) {
                acc = rfn(acc, i);
            }
        }
        return acc;
    }
}

function str$1(sep, xs) {
    sep = sep || "";
    let first = true;
    return xs
        ? [...xs].join(sep)
        : reducer(() => "", (acc, x) => ((acc = first ? acc + x : acc + sep + x), (first = false), acc));
}

function take(n, src) {
    return isIterable(src)
        ? iterator(take(n), src)
        : (rfn) => {
            const r = rfn[2];
            let m = n;
            return compR(rfn, (acc, x) => --m > 0
                ? r(acc, x)
                : m === 0
                    ? ensureReduced(r(acc, x))
                    : reduced(acc));
        };
}

function transduce(...args) {
    return $transduce(transduce, reduce$1, args);
}
const $transduce = (tfn, rfn, args) => {
    let acc, xs;
    switch (args.length) {
        case 4:
            xs = args[3];
            acc = args[2];
            break;
        case 3:
            xs = args[2];
            break;
        case 2:
            return map((x) => tfn(args[0], args[1], x));
        default:
            illegalArity(args.length);
    }
    return rfn(ensureTransducer(args[0])(args[1]), acc, xs);
};

function* zip(...src) {
    const iters = src.map((s) => s[Symbol.iterator]());
    while (true) {
        const tuple = [];
        for (let i of iters) {
            let v = i.next();
            if (v.done) {
                return;
            }
            tuple.push(v.value);
        }
        yield tuple;
    }
}

const UnsupportedOperationError = defError(() => "unsupported operation");
const unsupported = (msg) => {
    throw new UnsupportedOperationError(msg);
};

/**
 * Specialized / optimized version of {@link @thi.ng/defmulti# | @thi.ng/defmulti} for
 * vector operations. Uses simplified logic to dispatch on length
 * (vector size) of `dispatch` argument.
 *
 * @param dispatch - arg index
 */
const vop = (dispatch = 0) => {
    const impls = new Array(5);
    let fallback;
    const fn = (...args) => {
        const g = impls[args[dispatch].length] || fallback;
        return g
            ? g(...args)
            : unsupported(`no impl for vec size ${args[dispatch].length}`);
    };
    fn.add = (dim, fn) => (impls[dim] = fn);
    fn.default = (fn) => (fallback = fn);
    fn.impl = (dim) => impls[dim] || fallback;
    // fn.impls = impls;
    return fn;
};

/** @internal */
const ARGS_V = "o,a";
/** @internal */
const ARGS_VV = "o,a,b";
/** @internal */
const ARGS_VN = "o,a,n";
/** @internal */
const NEW_OUT = "!o&&(o=[]);";
/** @internal */
const NEW_OUT_A = "!a&&(a=[]);";
/** @internal */
// prettier-ignore
const MATH = (op) => ([o, a, b]) => `${o}=${a}${op}${b};`;
/** @internal */
// prettier-ignore
const MATH_N = (op) => ([o, a]) => `${o}=${a}${op}n;`;
/** @internal */
// prettier-ignore
const FN = (op = "op") => ([o, a]) => `${o}=${op}(${a});`;
/** @internal */
const SET = ([o, a]) => `${o}=${a};`;

/**
 * HOF array index lookup gen to provide optimized versions of:
 *
 * @example
 * ```ts
 * lookup("a")(0) // a[ia]
 * lookup("a")(1) // a[ia * sa]
 * lookup("a")(2) // a[ia + 2 * sa]
 * ```
 *
 * @param sym -
 */
const lookup$1 = (sym) => (i) => i > 1
    ? `${sym}[i${sym}+${i}*s${sym}]`
    : i == 1
        ? `${sym}[i${sym}+s${sym}]`
        : `${sym}[i${sym}]`;
/**
 * Infinite iterator of strided index lookups for `sym`.
 *
 * @param sym -
 */
const indicesStrided = (sym) => map(lookup$1(sym), range());
/**
 * Infinite iterator of simple (non-strided) index lookups for `sym`.
 *
 * @param sym -
 */
const indices = (sym) => map((i) => `${sym}[${i}]`, range());
/**
 * Code generator for loop-unrolled vector operations. Takes a vector
 * size `dim`, a code template function `tpl` and an array of symbol
 * names participating in the template. For each symbol, creates
 * iterator of index lookups (e.g. `a[0]` or `a[ia+k*sa]`), forms them
 * into tuples and passes them to template to generate code and joins
 * generated result with `opJoin` separator (default:
 * `""`).
 *
 * If the optional `ret` arg is not `null` (default `"a"`), appends a
 * `return` statement to the result array, using `ret` as return value.
 * Returns array of source code lines.
 *
 * The optional `pre` and `post` strings can be used to wrap the
 * generated code. `post` will be injected **before** the generated
 * return statement (if not suppressed).
 *
 * @param dim -
 * @param tpl -
 * @param syms -
 * @param ret -
 * @param opJoin -
 * @param pre -
 * @param post -
 * @param strided -
 */
const assemble = (dim, tpl, syms, ret = "a", opJoin = "", pre = "", post = "", strided = false) => [
    pre,
    transduce(comp(take(dim), mapIndexed((i, x) => tpl(x, i))), str$1(opJoin), (zip.apply(null, syms.split(",").map(strided ? indicesStrided : indices)))),
    post,
    ret !== "" ? `return ${ret};` : "",
];
const assembleG = (tpl, syms, ret = "a", pre, post, strided = false) => [
    pre,
    "for(let i=a.length;--i>=0;) {",
    tpl(syms
        .split(",")
        .map(strided ? (x) => `${x}[i${x}+i*s${x}]` : (x) => `${x}[i]`)),
    "}",
    post,
    ret !== null ? `return ${ret};` : "",
];
/** @internal */
const defaultOut = (o, args) => `!${o} && (${o}=${args.split(",")[1]});`;
/** @internal */
const compile$3 = (dim, tpl, args, syms = args, ret = "a", opJoin, pre, post, strided = false) => (new Function(args, assemble(dim, tpl, syms, ret, opJoin, pre, post, strided).join("")));
/** @internal */
const compileHOF = (dim, fns, tpl, hofArgs, args, syms = args, ret = "a", opJoin = "", pre, post, strided = false) => {
    return new Function(hofArgs, `return (${args})=>{${assemble(dim, tpl, syms, ret, opJoin, pre, post, strided).join("")}}`)(...fns);
};
/** @internal */
const compileG = (tpl, args, syms = args, ret = "a", pre, post, strided = false) => (new Function(args, assembleG(tpl, syms, ret, pre, post, strided).join("")));
/** @internal */
const compileGHOF = (fns, tpl, hofArgs, args, syms = args, ret = "a", pre, post, strided = false) => (new Function(hofArgs, `return (${args})=>{${assembleG(tpl, syms, ret, pre, post, strided).join("")}}`)(...fns));
const defOp = (tpl, args = ARGS_VV, syms, ret = "o", dispatch = 1, pre) => {
    syms = syms || args;
    pre = pre != null ? pre : defaultOut(ret, args);
    const fn = vop(dispatch);
    const $ = (dim) => fn.add(dim, compile$3(dim, tpl, args, syms, ret, "", pre));
    fn.default(compileG(tpl, args, syms, ret, pre));
    return [fn, $(2), $(3), $(4)];
};
const defHofOp = (op, tpl, args = ARGS_V, syms, ret = "o", dispatch = 1, pre) => {
    const _tpl = tpl || FN("op");
    syms = syms || args;
    pre = pre != null ? pre : defaultOut(ret, args);
    const fn = vop(dispatch);
    const $ = (dim) => fn.add(dim, compileHOF(dim, [op], _tpl, "op", args, syms, ret, "", pre));
    fn.default(compileGHOF([op], _tpl, "op", args, syms, ret, pre));
    return [fn, $(2), $(3), $(4)];
};
const defMathOp = (op) => defOp(MATH(op));
const defMathOpN = (op) => defOp(MATH_N(op), ARGS_VN);

const tpl = ([a, b]) => `t=${a}-${b};s+=t*t;`;
const pre = "let t,s=0;";
const $$1 = (dim) => distSq.add(dim, compile$3(dim, tpl, "a,b", undefined, "s", "", pre));
const distSq = vop();
distSq.default(compileG(tpl, "a,b", undefined, "s", pre));
$$1(2);
$$1(3);
$$1(4);

/** @internal */
const CMP = (a, b) => b[0] - a[0];
/** @internal */
const addResults = (fn, sel, acc) => {
    for (let n = sel.sort(CMP).length; n-- > 0;) {
        const s = sel[n][1];
        s && acc.push(fn(s));
    }
    return acc;
};
/**
 * Shared `into()` impl for spatial map types.
 *
 * @param map -
 * @param pairs -
 * @param eps -
 *
 * @internal
 */
const into = (map, pairs, eps) => {
    let ok = true;
    for (let p of pairs) {
        ok = map.set(p[0], p[1], eps) && ok;
    }
    return ok;
};

class KdNode {
    constructor(parent, dim, key, val) {
        this.parent = parent;
        this.d = dim;
        this.k = key;
        this.v = val;
    }
    get height() {
        return (1 + Math.max(this.l ? this.l.height : 0, this.r ? this.r.height : 0));
    }
}
/**
 * {@link https://en.wikipedia.org/wiki/K-d_tree}
 *
 * Partially based on:
 * {@link https://github.com/ubilabs/kd-tree-javascript}
 *
 */
class KdTreeMap {
    constructor(dim, pairs) {
        this.dim = dim;
        this._size = 0;
        this.root = pairs ? this.buildTree(ensureArray(pairs), 0) : undefined;
    }
    *[Symbol.iterator]() {
        let queue = this.root ? [this.root] : [];
        while (queue.length) {
            const n = queue.pop();
            if (n) {
                yield [n.k, n.v];
                queue.push(n.r, n.l);
            }
        }
    }
    *keys() {
        let queue = this.root ? [this.root] : [];
        while (queue.length) {
            const n = queue.pop();
            if (n) {
                yield n.k;
                queue.push(n.r, n.l);
            }
        }
    }
    values() {
        return map((p) => p[1], this);
    }
    get size() {
        return this._size;
    }
    get height() {
        return this.root ? this.root.height : 0;
    }
    get ratio() {
        return this._size ? this.height / Math.log2(this._size) : 0;
    }
    copy() {
        return new KdTreeMap(this.dim, this);
    }
    clear() {
        delete this.root;
        this._size = 0;
    }
    empty() {
        return new KdTreeMap(this.dim);
    }
    set(key, val, eps = EPS) {
        eps = Math.max(0, eps);
        eps *= eps;
        const search = (node, parent) => node
            ? search(key[node.d] < node.k[node.d] ? node.l : node.r, node)
            : parent;
        let parent;
        if (this.root) {
            parent = nearest1(key, [eps, undefined], this.dim, this.root)[1];
            if (parent) {
                parent.v = val;
                return false;
            }
            parent = search(this.root, undefined);
            const dim = parent.d;
            parent[key[dim] < parent.k[dim] ? "l" : "r"] = new KdNode(parent, (dim + 1) % this.dim, key, val);
        }
        else {
            this.root = new KdNode(undefined, 0, key, val);
        }
        this._size++;
        return true;
    }
    into(pairs, eps = EPS) {
        return into(this, pairs, eps);
    }
    remove(key) {
        const node = find(key, this.root, 0);
        if (node) {
            remove(node) && (this.root = undefined);
            this._size--;
            return true;
        }
        return false;
    }
    has(key, eps = EPS) {
        return (!!this.root &&
            !!nearest1(key, [eps * eps, undefined], this.dim, this.root)[1]);
    }
    get(key, eps = EPS) {
        if (this.root) {
            const node = nearest1(key, [eps * eps, undefined], this.dim, this.root)[1];
            return node ? node.v : undefined;
        }
    }
    query(q, maxDist, limit, acc) {
        return this.doSelect(q, (x) => [x.k, x.v], maxDist, limit, acc);
    }
    queryKeys(q, maxDist, limit, acc) {
        return this.doSelect(q, (x) => x.k, maxDist, limit, acc);
    }
    queryValues(q, maxDist, limit, acc) {
        return this.doSelect(q, (x) => x.v, maxDist, limit, acc);
    }
    doSelect(q, f, maxDist, maxNum = 1, acc = []) {
        if (!this.root)
            return [];
        maxDist *= maxDist;
        if (maxNum === 1) {
            const sel = nearest1(q, [maxDist, undefined], this.dim, this.root)[1];
            sel && acc.push(f(sel));
        }
        else {
            const nodes = new Heap$1([[maxDist, undefined]], {
                compare: CMP,
            });
            nearest(q, nodes, this.dim, maxNum, this.root);
            return addResults(f, nodes.values, acc);
        }
        return acc;
    }
    buildTree(points, depth, parent) {
        const n = points.length;
        if (n === 0) {
            return;
        }
        this._size++;
        let dim = depth % this.dim;
        if (n === 1) {
            return new KdNode(parent, dim, ...points[0]);
        }
        points.sort((a, b) => a[0][dim] - b[0][dim]);
        const med = n >>> 1;
        const node = new KdNode(parent, dim, ...points[med]);
        node.l = this.buildTree(points.slice(0, med), depth + 1, node);
        node.r = this.buildTree(points.slice(med + 1), depth + 1, node);
        return node;
    }
}
/**
 * Returns node for point or `undefined` if none found.
 *
 * @param p - point
 * @param node - tree node
 * @param epsSq - squared epsilon / tolerance
 */
const find = (p, node, epsSq) => {
    if (!node)
        return;
    return distSq(p, node.k) <= epsSq
        ? node
        : find(p, p[node.d] < node.k[node.d] ? node.l : node.r, epsSq);
};
const findMin = (node, dim) => {
    if (!node)
        return;
    if (node.d === dim) {
        return node.l ? findMin(node.l, dim) : node;
    }
    const q = node.k[dim];
    const l = findMin(node.l, dim);
    const r = findMin(node.r, dim);
    let min = node;
    if (l && l.k[dim] < q) {
        min = l;
    }
    if (r && r.k[dim] < min.k[dim]) {
        min = r;
    }
    return min;
};
/**
 * Returns true if root is to be deleted.
 *
 * @param node - tree node
 */
const remove = (node) => {
    if (!node.l && !node.r) {
        if (!node.parent) {
            return true;
        }
        const parent = node.parent;
        const pdim = parent.d;
        parent[node.k[pdim] < parent.k[pdim] ? "l" : "r"] = undefined;
        return;
    }
    let next;
    let nextP;
    if (node.r) {
        next = findMin(node.r, node.d);
        nextP = next.k;
        remove(next);
        node.k = nextP;
    }
    else {
        next = findMin(node.l, node.d);
        nextP = next.k;
        remove(next);
        node.r = node.l;
        node.l = undefined;
        node.k = nextP;
    }
};
const nearest = (q, acc, dims, maxNum, node) => {
    const p = node.k;
    const ndist = distSq(p, q);
    if (!node.l && !node.r) {
        collect(acc, maxNum, node, ndist);
        return;
    }
    const tdist = nodeDist(node, dims, q, p);
    let best = bestChild(node, q);
    nearest(q, acc, dims, maxNum, best);
    collect(acc, maxNum, node, ndist);
    if (tdist < acc.values[0][0]) {
        best = best === node.l ? node.r : node.l;
        best && nearest(q, acc, dims, maxNum, best);
    }
};
/**
 * Optimized version of {@link nearest} for single closest point search.
 *
 * @param q - search point
 * @param acc - accumulator
 * @param dims - dimensions
 * @param node - tree node
 */
const nearest1 = (q, acc, dims, node) => {
    const p = node.k;
    const ndist = distSq(p, q);
    if (!node.l && !node.r) {
        collect1(acc, node, ndist);
        return acc;
    }
    const tdist = nodeDist(node, dims, q, p);
    let best = bestChild(node, q);
    nearest1(q, acc, dims, best);
    collect1(acc, node, ndist);
    if (tdist < acc[0]) {
        best = best === node.l ? node.r : node.l;
        best && nearest1(q, acc, dims, best);
    }
    return acc;
};
const bestChild = (node, q) => {
    const d = node.d;
    return !node.r
        ? node.l
        : !node.l
            ? node.r
            : q[d] < node.k[d]
                ? node.l
                : node.r;
};
const collect = (acc, maxNum, node, ndist) => (!acc.length || ndist < acc.peek()[0]) &&
    (acc.length >= maxNum
        ? acc.pushPop([ndist, node])
        : acc.push([ndist, node]));
const collect1 = (acc, node, ndist) => ndist < acc[0] && ((acc[0] = ndist), (acc[1] = node));
const TMP = [];
const nodeDist = (node, dims, q, p) => {
    for (let i = dims, d = node.d; i-- > 0;) {
        TMP[i] = i === d ? q[i] : p[i];
    }
    return distSq(TMP, p);
};

class KdTreeSet {
    constructor(dim, keys) {
        this.tree = new KdTreeMap(dim);
        keys && this.into(keys);
    }
    [Symbol.iterator]() {
        return this.tree.keys();
    }
    keys() {
        return this.tree.keys();
    }
    values() {
        return this.tree.keys();
    }
    get size() {
        return this.tree.size;
    }
    get height() {
        return this.tree.height;
    }
    get ratio() {
        return this.tree.ratio;
    }
    copy() {
        return new KdTreeSet(this.tree.dim, this);
    }
    clear() {
        this.tree.clear();
    }
    empty() {
        return new KdTreeSet(this.tree.dim);
    }
    add(key, eps) {
        return this.tree.set(key, key, eps);
    }
    into(ks, eps) {
        let ok = true;
        for (let k of ks) {
            ok = this.tree.set(k, k, eps) && ok;
        }
        return ok;
    }
    remove(key) {
        return this.tree.remove(key);
    }
    has(key, eps) {
        return this.tree.has(key, eps);
    }
    get(key, eps) {
        return this.tree.get(key, eps);
    }
    query(q, maxDist, limit, acc) {
        return this.tree.query(q, maxDist, limit, acc);
    }
    queryKeys(q, maxDist, limit, acc) {
        return this.tree.queryKeys(q, maxDist, limit, acc);
    }
    queryValues(q, maxDist, limit, acc) {
        return this.tree.queryKeys(q, maxDist, limit, acc);
    }
}

const dist$2 = (a, b) => Math.sqrt(distSq(a, b));

const $ = (dim) => magSq.add(dim, compile$3(dim, ([a]) => `${a}*${a}`, "a", "a", "", "+", "return ", ";"));
const magSq = vop();
magSq.default(compileG(([a]) => `sum+=${a}*${a};`, "a", undefined, "sum", "let sum=0;"));
$(2);
$(3);
$(4);

const [set$2, set2, set3, set4] = defOp(SET, "o,a", undefined, "o", 1, NEW_OUT);

const [mulN, mulN2, mulN3, mulN4] = defMathOpN("*");

const isNumber = (x) => typeof x === "number";

const INV_MAX = 1 / (2 ** 32);
class ARandom {
    float(norm = 1) {
        return this.int() * INV_MAX * norm;
    }
    norm(norm = 1) {
        return (this.int() * INV_MAX - 0.5) * 2 * norm;
    }
    minmax(min, max) {
        return this.float() * (max - min) + min;
    }
}

const random$3 = Math.random;
/**
 * A `Math.random()` based {@link IRandom} implementation. Also @see
 * {@link SYSTEM}.
 */
class SystemRandom extends ARandom {
    int() {
        return (random$3() * 4294967296) /* 2**32 */ >>> 0;
    }
    float(norm = 1) {
        return random$3() * norm;
    }
    norm(norm = 1) {
        return (random$3() - 0.5) * 2 * norm;
    }
}
/**
 * Used as default PRNG throughout most other thi.ng projects, though usually is
 * configurable.
 */
const SYSTEM = new SystemRandom();

const [add$2, add2, add3, add4] = defMathOp("+");

/**
 * HOF. Returns zero-arg function, yielding values with normal distribution
 * for given `bias` and standard deviation `sigma`.
 *
 * @remarks
 * Also see {@link gaussian} for alternative implementation.
 *
 * @param rnd -
 * @param bias -
 * @param sigma -
 */
const normal = (rnd = SYSTEM, bias = 0, sigma = 1) => {
    let a;
    let b;
    let r;
    return () => {
        if (a != null) {
            b = a;
            a = null;
        }
        else {
            do {
                a = rnd.norm();
                b = rnd.norm();
                r = a * a + b * b;
            } while (r > 1 || r === 0);
        }
        return bias + sigma * b * Math.sqrt((-2 * Math.log(r)) / r);
    };
};

const mag = (v) => Math.sqrt(magSq(v));

/**
 * Normalizes vector to given (optional) length (default: 1). If `out`
 * is null, modifies `v` in place.
 *
 * @param out -
 * @param v -
 * @param n -
 */
const normalize$3 = (out, v, n = 1) => {
    !out && (out = v);
    const m = mag(v);
    return m >= EPS ? mulN(out, v, n / m) : out !== v ? set$2(out, v) : out;
};

const [divN, divN2, divN3, divN4] = defMathOpN("/");

/**
 * Sets `v` to random vector, with each component in interval `[n..m)`. If no
 * `rnd` instance is given, uses {@link @thi.ng/random#SYSTEM}, i.e.
 * `Math.random`. Creates new vector if `v` is null.
 *
 * @remarks
 * The non-fixed sized version of this function can ONLY be used if `v` is given
 * and initialized to the desired size/length.
 *
 * @param v -
 * @param n - default -1
 * @param m - default 1
 * @param rnd -
 */
const [random$2, random2, random3, random4] = defHofOp(SYSTEM, ([a]) => `${a}=rnd.minmax(n,m);`, "a,n=-1,m=1,rnd=op", "a", "a", 0, NEW_OUT_A);
/**
 * Sets `v` to random vector, with each component drawn from given random
 * distribution function (default: gaussian/normal distribution) and scaled to
 * `n` (default: 1). Creates new vector if `v` is null.
 *
 * @remarks
 * The non-fixed sized version of this function can ONLY be used if `v` is given
 * and initialized to the desired size/length.
 *
 * References:
 * - https://docs.thi.ng/umbrella/random/#random-distributions
 * - https://docs.thi.ng/umbrella/random/modules.html#normal
 *
 * @param v -
 * @param rnd -
 * @param n - default 1
 */
defHofOp(normal, ([a]) => `${a}=rnd()*n;`, "a,rnd=op(),n=1", "a", "a", 0, NEW_OUT_A);
const $norm = (random) => (v, n = 1, rnd = SYSTEM) => normalize$3(null, random(v, -1, 1, rnd), n);
/**
 * Sets `v` to a random vector (using {@link random}), normalized to length `n`
 * (default: 1). If no `rnd` instance is given, uses
 * {@link @thi.ng/random#SYSTEM}, i.e. `Math.random`.
 *
 * @remarks
 * The non-fixed sized version of this function can ONLY be used if `v` is given
 * and initialized to the desired size/length.
 *
 * @param v -
 * @param n -
 * @param rnd -
 */
const randNorm = $norm(random$2);
/**
 * Sets `out` to random vector with each component in the semi-open
 * interval defined by [min,max).
 *
 * @param out -
 * @param min -
 * @param max -
 * @param rnd -
 */
defHofOp(SYSTEM, ([o, a, b]) => `${o}=rnd.minmax(${a},${b});`, "o,a,b,rnd=op", "o,a,b");

const jitter = (out, a, n = 1, rnd = SYSTEM) => add$2(out, a, randNorm(new Array(a.length), n, rnd));

/**
 * Produces a number of Poisson-disk samples based on given
 * configuration.
 *
 * @param opts -
 */
const samplePoisson = (_opts) => {
    const opts = {
        rnd: SYSTEM,
        iter: 1,
        jitter: 1,
        quality: 500,
        ..._opts,
    };
    const { points, index, rnd, jitter: jitter$1, quality, density: _d } = opts;
    const density = isNumber(_d) ? () => _d : _d;
    const iter = Math.max(opts.iter, 1);
    const samples = [];
    let failed = 0;
    let pos;
    let d;
    let i;
    outer: for (let num = opts.max; num > 0;) {
        pos = points(rnd);
        d = density(pos);
        i = iter;
        while (i-- > 0) {
            if (!index.has(pos, d)) {
                index.add(pos, 0);
                samples.push(pos);
                failed = 0;
                num--;
                continue outer;
            }
            jitter(null, pos, jitter$1, rnd);
        }
        if (++failed > quality) {
            break;
        }
    }
    return samples;
};

var linsolve = {exports: {}};

var robustDeterminant = {exports: {}};

var twoProduct_1 = twoProduct$1;

var SPLITTER = +(Math.pow(2, 27) + 1.0);

function twoProduct$1(a, b, result) {
  var x = a * b;

  var c = SPLITTER * a;
  var abig = c - a;
  var ahi = c - abig;
  var alo = a - ahi;

  var d = SPLITTER * b;
  var bbig = d - b;
  var bhi = d - bbig;
  var blo = b - bhi;

  var err1 = x - (ahi * bhi);
  var err2 = err1 - (alo * bhi);
  var err3 = err2 - (ahi * blo);

  var y = alo * blo - err3;

  if(result) {
    result[0] = y;
    result[1] = x;
    return result
  }

  return [ y, x ]
}

var robustSum = linearExpansionSum;

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b;
  var bv = x - a;
  var av = x - bv;
  var br = b - bv;
  var ar = a - av;
  var y = ar + br;
  if(y) {
    return [y, x]
  }
  return [x]
}

function linearExpansionSum(e, f) {
  var ne = e.length|0;
  var nf = f.length|0;
  if(ne === 1 && nf === 1) {
    return scalarScalar(e[0], f[0])
  }
  var n = ne + nf;
  var g = new Array(n);
  var count = 0;
  var eptr = 0;
  var fptr = 0;
  var abs = Math.abs;
  var ei = e[eptr];
  var ea = abs(ei);
  var fi = f[fptr];
  var fa = abs(fi);
  var a, b;
  if(ea < fa) {
    b = ei;
    eptr += 1;
    if(eptr < ne) {
      ei = e[eptr];
      ea = abs(ei);
    }
  } else {
    b = fi;
    fptr += 1;
    if(fptr < nf) {
      fi = f[fptr];
      fa = abs(fi);
    }
  }
  if((eptr < ne && ea < fa) || (fptr >= nf)) {
    a = ei;
    eptr += 1;
    if(eptr < ne) {
      ei = e[eptr];
      ea = abs(ei);
    }
  } else {
    a = fi;
    fptr += 1;
    if(fptr < nf) {
      fi = f[fptr];
      fa = abs(fi);
    }
  }
  var x = a + b;
  var bv = x - a;
  var y = b - bv;
  var q0 = y;
  var q1 = x;
  var _x, _bv, _av, _br, _ar;
  while(eptr < ne && fptr < nf) {
    if(ea < fa) {
      a = ei;
      eptr += 1;
      if(eptr < ne) {
        ei = e[eptr];
        ea = abs(ei);
      }
    } else {
      a = fi;
      fptr += 1;
      if(fptr < nf) {
        fi = f[fptr];
        fa = abs(fi);
      }
    }
    b = q0;
    x = a + b;
    bv = x - a;
    y = b - bv;
    if(y) {
      g[count++] = y;
    }
    _x = q1 + x;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
  }
  while(eptr < ne) {
    a = ei;
    b = q0;
    x = a + b;
    bv = x - a;
    y = b - bv;
    if(y) {
      g[count++] = y;
    }
    _x = q1 + x;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
    eptr += 1;
    if(eptr < ne) {
      ei = e[eptr];
    }
  }
  while(fptr < nf) {
    a = fi;
    b = q0;
    x = a + b;
    bv = x - a;
    y = b - bv;
    if(y) {
      g[count++] = y;
    } 
    _x = q1 + x;
    _bv = _x - q1;
    _av = _x - _bv;
    _br = x - _bv;
    _ar = q1 - _av;
    q0 = _ar + _br;
    q1 = _x;
    fptr += 1;
    if(fptr < nf) {
      fi = f[fptr];
    }
  }
  if(q0) {
    g[count++] = q0;
  }
  if(q1) {
    g[count++] = q1;
  }
  if(!count) {
    g[count++] = 0.0;  
  }
  g.length = count;
  return g
}

var twoSum$1 = fastTwoSum;

function fastTwoSum(a, b, result) {
	var x = a + b;
	var bv = x - a;
	var av = x - bv;
	var br = b - bv;
	var ar = a - av;
	if(result) {
		result[0] = ar + br;
		result[1] = x;
		return result
	}
	return [ar+br, x]
}

var twoProduct = twoProduct_1;
var twoSum = twoSum$1;

var robustScale = scaleLinearExpansion;

function scaleLinearExpansion(e, scale) {
  var n = e.length;
  if(n === 1) {
    var ts = twoProduct(e[0], scale);
    if(ts[0]) {
      return ts
    }
    return [ ts[1] ]
  }
  var g = new Array(2 * n);
  var q = [0.1, 0.1];
  var t = [0.1, 0.1];
  var count = 0;
  twoProduct(e[0], scale, q);
  if(q[0]) {
    g[count++] = q[0];
  }
  for(var i=1; i<n; ++i) {
    twoProduct(e[i], scale, t);
    var pq = q[1];
    twoSum(pq, t[0], q);
    if(q[0]) {
      g[count++] = q[0];
    }
    var a = t[1];
    var b = q[1];
    var x = a + b;
    var bv = x - a;
    var y = b - bv;
    q[1] = x;
    if(y) {
      g[count++] = y;
    }
  }
  if(q[1]) {
    g[count++] = q[1];
  }
  if(count === 0) {
    g[count++] = 0.0;
  }
  g.length = count;
  return g
}

var compress = compressExpansion;

function compressExpansion(e) {
  var m = e.length;
  var Q = e[e.length-1];
  var bottom = m;
  for(var i=m-2; i>=0; --i) {
    var a = Q;
    var b = e[i];
    Q = a + b;
    var bv = Q - a;
    var q = b - bv;
    if(q) {
      e[--bottom] = Q;
      Q = q;
    }
  }
  var top = 0;
  for(var i=bottom; i<m; ++i) {
    var a = e[i];
    var b = Q;
    Q = a + b;
    var bv = Q - a;
    var q = b - bv;
    if(q) {
      e[top++] = q;
    }
  }
  e[top++] = Q;
  e.length = top;
  return e
}

(function (module) {

var twoProduct = twoProduct_1;
var robustSum$1 = robustSum;
var robustScale$1 = robustScale;
var compress$1 = compress;

var NUM_EXPANDED = 6;

function cofactor(m, c) {
  var result = new Array(m.length-1);
  for(var i=1; i<m.length; ++i) {
    var r = result[i-1] = new Array(m.length-1);
    for(var j=0,k=0; j<m.length; ++j) {
      if(j === c) {
        continue
      }
      r[k++] = m[i][j];
    }
  }
  return result
}

function matrix(n) {
  var result = new Array(n);
  for(var i=0; i<n; ++i) {
    result[i] = new Array(n);
    for(var j=0; j<n; ++j) {
      result[i][j] = ["m[", i, "][", j, "]"].join("");
    }
  }
  return result
}

function sign(n) {
  if(n & 1) {
    return "-"
  }
  return ""
}

function generateSum(expr) {
  if(expr.length === 1) {
    return expr[0]
  } else if(expr.length === 2) {
    return ["sum(", expr[0], ",", expr[1], ")"].join("")
  } else {
    var m = expr.length>>1;
    return ["sum(", generateSum(expr.slice(0, m)), ",", generateSum(expr.slice(m)), ")"].join("")
  }
}

function determinant(m) {
  if(m.length === 2) {
    return ["sum(prod(", m[0][0], ",", m[1][1], "),prod(-", m[0][1], ",", m[1][0], "))"].join("")
  } else {
    var expr = [];
    for(var i=0; i<m.length; ++i) {
      expr.push(["scale(", determinant(cofactor(m, i)), ",", sign(i), m[0][i], ")"].join(""));
    }
    return generateSum(expr)
  }
}

function compileDeterminant(n) {
  var proc = new Function("sum", "scale", "prod", "compress", [
    "function robustDeterminant",n, "(m){return compress(", 
      determinant(matrix(n)),
    ")};return robustDeterminant", n].join(""));
  return proc(robustSum$1, robustScale$1, twoProduct, compress$1)
}

var CACHE = [
  function robustDeterminant0() { return [0] },
  function robustDeterminant1(m) { return [m[0][0]] }
];

function generateDispatch() {
  while(CACHE.length < NUM_EXPANDED) {
    CACHE.push(compileDeterminant(CACHE.length));
  }
  var procArgs = [];
  var code = ["function robustDeterminant(m){switch(m.length){"];
  for(var i=0; i<NUM_EXPANDED; ++i) {
    procArgs.push("det" + i);
    code.push("case ", i, ":return det", i, "(m);");
  }
  code.push("}\
var det=CACHE[m.length];\
if(!det)\
det=CACHE[m.length]=gen(m.length);\
return det(m);\
}\
return robustDeterminant");
  procArgs.push("CACHE", "gen", code.join(""));
  var proc = Function.apply(undefined, procArgs);
  module.exports = proc.apply(undefined, CACHE.concat([CACHE, compileDeterminant]));
  for(var i=0; i<CACHE.length; ++i) {
    module.exports[i] = CACHE[i];
  }
}

generateDispatch();
}(robustDeterminant));

(function (module) {

var determinant = robustDeterminant.exports;

var NUM_EXPAND = 6;

function generateSolver(n) {
  var funcName = "robustLinearSolve" + n + "d";
  var code = ["function ", funcName, "(A,b){return ["];
  for(var i=0; i<n; ++i) {
    code.push("det([");
    for(var j=0; j<n; ++j) {
      if(j > 0) {
        code.push(",");
      }
      code.push("[");
      for(var k=0; k<n; ++k) {
        if(k > 0) {
          code.push(",");
        }
        if(k === i) {
          code.push("+b[", j, "]");
        } else {
          code.push("+A[", j, "][", k, "]");
        }
      }
      code.push("]");
    }
    code.push("]),");
  }
  code.push("det(A)]}return ", funcName);
  var proc = new Function("det", code.join(""));
  if(n < 6) {
    return proc(determinant[n])
  }
  return proc(determinant)
}

function robustLinearSolve0d() {
  return [ 0 ]
}

function robustLinearSolve1d(A, b) {
  return [ [ b[0] ], [ A[0][0] ] ]
}

var CACHE = [
  robustLinearSolve0d,
  robustLinearSolve1d
];

function generateDispatch() {
  while(CACHE.length < NUM_EXPAND) {
    CACHE.push(generateSolver(CACHE.length));
  }
  var procArgs = [];
  var code = ["function dispatchLinearSolve(A,b){switch(A.length){"];
  for(var i=0; i<NUM_EXPAND; ++i) {
    procArgs.push("s" + i);
    code.push("case ", i, ":return s", i, "(A,b);");
  }
  code.push("}var s=CACHE[A.length];if(!s)s=CACHE[A.length]=g(A.length);return s(A,b)}return dispatchLinearSolve");
  procArgs.push("CACHE", "g", code.join(""));
  var proc = Function.apply(undefined, procArgs);
  module.exports = proc.apply(undefined, CACHE.concat([CACHE, generateSolver]));
  for(var i=0; i<NUM_EXPAND; ++i) {
    module.exports[i] = CACHE[i];
  }
}

generateDispatch();
}(linsolve));

var barycentric_1 = barycentric;

var solve$2 = linsolve.exports;

function reduce(x) {
  var r = 0;
  for(var i=0; i<x.length; ++i) {
    r += x[i];
  }
  return r
}

function barycentric(simplex, point) {
  var d = point.length;
  var A = new Array(d+1);
  for(var i=0; i<d; ++i) {
    var row = new Array(d+1);
    for(var j=0; j<=d; ++j) {
      row[j] = simplex[j][i];
    }
    A[i] = row;
  }
  A[d] = new Array(d+1);
  for(var i=0; i<=d; ++i) {
    A[d][i] = 1;
  }

  var b = new Array(d+1);
  for(var i=0; i<d; ++i) {
    b[i] = point[i];
  }
  b[d] = 1.0;

  var x = solve$2(A, b);
  var w = reduce(x[d+1]);
  
  if(w === 0) {
    w = 1.0;
  }
  var y = new Array(d+1);
  for(var i=0; i<=d; ++i) {
    y[i] = reduce(x[i]) / w;
  }
  return y
}

const epsilon$1 = 1.1102230246251565e-16;
const splitter = 134217729;
const resulterrbound = (3 + 8 * epsilon$1) * epsilon$1;

// fast_expansion_sum_zeroelim routine from oritinal code
function sum(elen, e, flen, f, h) {
    let Q, Qnew, hh, bvirt;
    let enow = e[0];
    let fnow = f[0];
    let eindex = 0;
    let findex = 0;
    if ((fnow > enow) === (fnow > -enow)) {
        Q = enow;
        enow = e[++eindex];
    } else {
        Q = fnow;
        fnow = f[++findex];
    }
    let hindex = 0;
    if (eindex < elen && findex < flen) {
        if ((fnow > enow) === (fnow > -enow)) {
            Qnew = enow + Q;
            hh = Q - (Qnew - enow);
            enow = e[++eindex];
        } else {
            Qnew = fnow + Q;
            hh = Q - (Qnew - fnow);
            fnow = f[++findex];
        }
        Q = Qnew;
        if (hh !== 0) {
            h[hindex++] = hh;
        }
        while (eindex < elen && findex < flen) {
            if ((fnow > enow) === (fnow > -enow)) {
                Qnew = Q + enow;
                bvirt = Qnew - Q;
                hh = Q - (Qnew - bvirt) + (enow - bvirt);
                enow = e[++eindex];
            } else {
                Qnew = Q + fnow;
                bvirt = Qnew - Q;
                hh = Q - (Qnew - bvirt) + (fnow - bvirt);
                fnow = f[++findex];
            }
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
    }
    while (eindex < elen) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
        Q = Qnew;
        if (hh !== 0) {
            h[hindex++] = hh;
        }
    }
    while (findex < flen) {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
        Q = Qnew;
        if (hh !== 0) {
            h[hindex++] = hh;
        }
    }
    if (Q !== 0 || hindex === 0) {
        h[hindex++] = Q;
    }
    return hindex;
}

function estimate(elen, e) {
    let Q = e[0];
    for (let i = 1; i < elen; i++) Q += e[i];
    return Q;
}

function vec$1(n) {
    return new Float64Array(n);
}

const ccwerrboundA = (3 + 16 * epsilon$1) * epsilon$1;
const ccwerrboundB = (2 + 12 * epsilon$1) * epsilon$1;
const ccwerrboundC = (9 + 64 * epsilon$1) * epsilon$1 * epsilon$1;

const B = vec$1(4);
const C1 = vec$1(8);
const C2 = vec$1(12);
const D = vec$1(16);
const u = vec$1(4);

function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
    let acxtail, acytail, bcxtail, bcytail;
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;

    const acx = ax - cx;
    const bcx = bx - cx;
    const acy = ay - cy;
    const bcy = by - cy;

    s1 = acx * bcy;
    c = splitter * acx;
    ahi = c - (c - acx);
    alo = acx - ahi;
    c = splitter * bcy;
    bhi = c - (c - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acy * bcx;
    c = splitter * acy;
    ahi = c - (c - acy);
    alo = acy - ahi;
    c = splitter * bcx;
    bhi = c - (c - bcx);
    blo = bcx - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    B[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    B[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    B[2] = _j - (u3 - bvirt) + (_i - bvirt);
    B[3] = u3;

    let det = estimate(4, B);
    let errbound = ccwerrboundB * detsum;
    if (det >= errbound || -det >= errbound) {
        return det;
    }

    bvirt = ax - acx;
    acxtail = ax - (acx + bvirt) + (bvirt - cx);
    bvirt = bx - bcx;
    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
    bvirt = ay - acy;
    acytail = ay - (acy + bvirt) + (bvirt - cy);
    bvirt = by - bcy;
    bcytail = by - (bcy + bvirt) + (bvirt - cy);

    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
        return det;
    }

    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);
    if (det >= errbound || -det >= errbound) return det;

    s1 = acxtail * bcy;
    c = splitter * acxtail;
    ahi = c - (c - acxtail);
    alo = acxtail - ahi;
    c = splitter * bcy;
    bhi = c - (c - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acytail * bcx;
    c = splitter * acytail;
    ahi = c - (c - acytail);
    alo = acytail - ahi;
    c = splitter * bcx;
    bhi = c - (c - bcx);
    blo = bcx - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const C1len = sum(4, B, 4, u, C1);

    s1 = acx * bcytail;
    c = splitter * acx;
    ahi = c - (c - acx);
    alo = acx - ahi;
    c = splitter * bcytail;
    bhi = c - (c - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acy * bcxtail;
    c = splitter * acy;
    ahi = c - (c - acy);
    alo = acy - ahi;
    c = splitter * bcxtail;
    bhi = c - (c - bcxtail);
    blo = bcxtail - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const C2len = sum(C1len, C1, 4, u, C2);

    s1 = acxtail * bcytail;
    c = splitter * acxtail;
    ahi = c - (c - acxtail);
    alo = acxtail - ahi;
    c = splitter * bcytail;
    bhi = c - (c - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acytail * bcxtail;
    c = splitter * acytail;
    ahi = c - (c - acytail);
    alo = acytail - ahi;
    c = splitter * bcxtail;
    bhi = c - (c - bcxtail);
    blo = bcxtail - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const Dlen = sum(C2len, C2, 4, u, D);

    return D[Dlen - 1];
}

function orient2d(ax, ay, bx, by, cx, cy) {
    const detleft = (ay - cy) * (bx - cx);
    const detright = (ax - cx) * (by - cy);
    const det = detleft - detright;

    if (detleft === 0 || detright === 0 || (detleft > 0) !== (detright > 0)) return det;

    const detsum = Math.abs(detleft + detright);
    if (Math.abs(det) >= ccwerrboundA * detsum) return det;

    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}

const EPSILON$1 = Math.pow(2, -52);
const EDGE_STACK = new Uint32Array(512);

class Delaunator {

    static from(points, getX = defaultGetX, getY = defaultGetY) {
        const n = points.length;
        const coords = new Float64Array(n * 2);

        for (let i = 0; i < n; i++) {
            const p = points[i];
            coords[2 * i] = getX(p);
            coords[2 * i + 1] = getY(p);
        }

        return new Delaunator(coords);
    }

    constructor(coords) {
        const n = coords.length >> 1;
        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

        this.coords = coords;

        // arrays that will store the triangulation graph
        const maxTriangles = Math.max(2 * n - 5, 0);
        this._triangles = new Uint32Array(maxTriangles * 3);
        this._halfedges = new Int32Array(maxTriangles * 3);

        // temporary arrays for tracking the edges of the advancing convex hull
        this._hashSize = Math.ceil(Math.sqrt(n));
        this._hullPrev = new Uint32Array(n); // edge to prev edge
        this._hullNext = new Uint32Array(n); // edge to next edge
        this._hullTri = new Uint32Array(n); // edge to adjacent triangle
        this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash

        // temporary arrays for sorting points
        this._ids = new Uint32Array(n);
        this._dists = new Float64Array(n);

        this.update();
    }

    update() {
        const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;
        const n = coords.length >> 1;

        // populate an array of point indices; calculate input data bbox
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;

        for (let i = 0; i < n; i++) {
            const x = coords[2 * i];
            const y = coords[2 * i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            this._ids[i] = i;
        }
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;

        let minDist = Infinity;
        let i0, i1, i2;

        // pick a seed point close to the center
        for (let i = 0; i < n; i++) {
            const d = dist$1(cx, cy, coords[2 * i], coords[2 * i + 1]);
            if (d < minDist) {
                i0 = i;
                minDist = d;
            }
        }
        const i0x = coords[2 * i0];
        const i0y = coords[2 * i0 + 1];

        minDist = Infinity;

        // find the point closest to the seed
        for (let i = 0; i < n; i++) {
            if (i === i0) continue;
            const d = dist$1(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
            if (d < minDist && d > 0) {
                i1 = i;
                minDist = d;
            }
        }
        let i1x = coords[2 * i1];
        let i1y = coords[2 * i1 + 1];

        let minRadius = Infinity;

        // find the third point which forms the smallest circumcircle with the first two
        for (let i = 0; i < n; i++) {
            if (i === i0 || i === i1) continue;
            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
            if (r < minRadius) {
                i2 = i;
                minRadius = r;
            }
        }
        let i2x = coords[2 * i2];
        let i2y = coords[2 * i2 + 1];

        if (minRadius === Infinity) {
            // order collinear points by dx (or dy if all x are identical)
            // and return the list as a hull
            for (let i = 0; i < n; i++) {
                this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
            }
            quicksort(this._ids, this._dists, 0, n - 1);
            const hull = new Uint32Array(n);
            let j = 0;
            for (let i = 0, d0 = -Infinity; i < n; i++) {
                const id = this._ids[i];
                if (this._dists[id] > d0) {
                    hull[j++] = id;
                    d0 = this._dists[id];
                }
            }
            this.hull = hull.subarray(0, j);
            this.triangles = new Uint32Array(0);
            this.halfedges = new Uint32Array(0);
            return;
        }

        // swap the order of the seed points for counter-clockwise orientation
        if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
            const i = i1;
            const x = i1x;
            const y = i1y;
            i1 = i2;
            i1x = i2x;
            i1y = i2y;
            i2 = i;
            i2x = x;
            i2y = y;
        }

        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
        this._cx = center.x;
        this._cy = center.y;

        for (let i = 0; i < n; i++) {
            this._dists[i] = dist$1(coords[2 * i], coords[2 * i + 1], center.x, center.y);
        }

        // sort the points by distance from the seed triangle circumcenter
        quicksort(this._ids, this._dists, 0, n - 1);

        // set up the seed triangle as the starting hull
        this._hullStart = i0;
        let hullSize = 3;

        hullNext[i0] = hullPrev[i2] = i1;
        hullNext[i1] = hullPrev[i0] = i2;
        hullNext[i2] = hullPrev[i1] = i0;

        hullTri[i0] = 0;
        hullTri[i1] = 1;
        hullTri[i2] = 2;

        hullHash.fill(-1);
        hullHash[this._hashKey(i0x, i0y)] = i0;
        hullHash[this._hashKey(i1x, i1y)] = i1;
        hullHash[this._hashKey(i2x, i2y)] = i2;

        this.trianglesLen = 0;
        this._addTriangle(i0, i1, i2, -1, -1, -1);

        for (let k = 0, xp, yp; k < this._ids.length; k++) {
            const i = this._ids[k];
            const x = coords[2 * i];
            const y = coords[2 * i + 1];

            // skip near-duplicate points
            if (k > 0 && Math.abs(x - xp) <= EPSILON$1 && Math.abs(y - yp) <= EPSILON$1) continue;
            xp = x;
            yp = y;

            // skip seed triangle points
            if (i === i0 || i === i1 || i === i2) continue;

            // find a visible edge on the convex hull using edge hash
            let start = 0;
            for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
                start = hullHash[(key + j) % this._hashSize];
                if (start !== -1 && start !== hullNext[start]) break;
            }

            start = hullPrev[start];
            let e = start, q;
            while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
                e = q;
                if (e === start) {
                    e = -1;
                    break;
                }
            }
            if (e === -1) continue; // likely a near-duplicate point; skip it

            // add the first triangle from the point
            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);

            // recursively flip triangles from the point until they satisfy the Delaunay condition
            hullTri[i] = this._legalize(t + 2);
            hullTri[e] = t; // keep track of boundary triangles on the hull
            hullSize++;

            // walk forward through the hull, adding more triangles and flipping recursively
            let n = hullNext[e];
            while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                hullTri[i] = this._legalize(t + 2);
                hullNext[n] = n; // mark as removed
                hullSize--;
                n = q;
            }

            // walk backward from the other side, adding more triangles and flipping
            if (e === start) {
                while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                    this._legalize(t + 2);
                    hullTri[q] = t;
                    hullNext[e] = e; // mark as removed
                    hullSize--;
                    e = q;
                }
            }

            // update the hull indices
            this._hullStart = hullPrev[i] = e;
            hullNext[e] = hullPrev[n] = i;
            hullNext[i] = n;

            // save the two new edges in the hash table
            hullHash[this._hashKey(x, y)] = i;
            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
        }

        this.hull = new Uint32Array(hullSize);
        for (let i = 0, e = this._hullStart; i < hullSize; i++) {
            this.hull[i] = e;
            e = hullNext[e];
        }

        // trim typed triangle mesh arrays
        this.triangles = this._triangles.subarray(0, this.trianglesLen);
        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
    }

    _hashKey(x, y) {
        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
    }

    _legalize(a) {
        const {_triangles: triangles, _halfedges: halfedges, coords} = this;

        let i = 0;
        let ar = 0;

        // recursion eliminated with a fixed-size stack
        while (true) {
            const b = halfedges[a];

            /* if the pair of triangles doesn't satisfy the Delaunay condition
             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
             * then do the same check/flip recursively for the new pair of triangles
             *
             *           pl                    pl
             *          /||\                  /  \
             *       al/ || \bl            al/    \a
             *        /  ||  \              /      \
             *       /  a||b  \    flip    /___ar___\
             *     p0\   ||   /p1   =>   p0\---bl---/p1
             *        \  ||  /              \      /
             *       ar\ || /br             b\    /br
             *          \||/                  \  /
             *           pr                    pr
             */
            const a0 = a - a % 3;
            ar = a0 + (a + 2) % 3;

            if (b === -1) { // convex hull edge
                if (i === 0) break;
                a = EDGE_STACK[--i];
                continue;
            }

            const b0 = b - b % 3;
            const al = a0 + (a + 1) % 3;
            const bl = b0 + (b + 2) % 3;

            const p0 = triangles[ar];
            const pr = triangles[a];
            const pl = triangles[al];
            const p1 = triangles[bl];

            const illegal = inCircle(
                coords[2 * p0], coords[2 * p0 + 1],
                coords[2 * pr], coords[2 * pr + 1],
                coords[2 * pl], coords[2 * pl + 1],
                coords[2 * p1], coords[2 * p1 + 1]);

            if (illegal) {
                triangles[a] = p1;
                triangles[b] = p0;

                const hbl = halfedges[bl];

                // edge swapped on the other side of the hull (rare); fix the halfedge reference
                if (hbl === -1) {
                    let e = this._hullStart;
                    do {
                        if (this._hullTri[e] === bl) {
                            this._hullTri[e] = a;
                            break;
                        }
                        e = this._hullPrev[e];
                    } while (e !== this._hullStart);
                }
                this._link(a, hbl);
                this._link(b, halfedges[ar]);
                this._link(ar, bl);

                const br = b0 + (b + 1) % 3;

                // don't worry about hitting the cap: it can only happen on extremely degenerate input
                if (i < EDGE_STACK.length) {
                    EDGE_STACK[i++] = br;
                }
            } else {
                if (i === 0) break;
                a = EDGE_STACK[--i];
            }
        }

        return ar;
    }

    _link(a, b) {
        this._halfedges[a] = b;
        if (b !== -1) this._halfedges[b] = a;
    }

    // add a new triangle given vertex indices and adjacent half-edge ids
    _addTriangle(i0, i1, i2, a, b, c) {
        const t = this.trianglesLen;

        this._triangles[t] = i0;
        this._triangles[t + 1] = i1;
        this._triangles[t + 2] = i2;

        this._link(t, a);
        this._link(t + 1, b);
        this._link(t + 2, c);

        this.trianglesLen += 3;

        return t;
    }
}

// monotonically increases with real angle, but doesn't need expensive trigonometry
function pseudoAngle(dx, dy) {
    const p = dx / (Math.abs(dx) + Math.abs(dy));
    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
}

function dist$1(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx * dx + dy * dy;
}

function inCircle(ax, ay, bx, by, cx, cy, px, py) {
    const dx = ax - px;
    const dy = ay - py;
    const ex = bx - px;
    const ey = by - py;
    const fx = cx - px;
    const fy = cy - py;

    const ap = dx * dx + dy * dy;
    const bp = ex * ex + ey * ey;
    const cp = fx * fx + fy * fy;

    return dx * (ey * cp - bp * fy) -
           dy * (ex * cp - bp * fx) +
           ap * (ex * fy - ey * fx) < 0;
}

function circumradius(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;

    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);

    const x = (ey * bl - dy * cl) * d;
    const y = (dx * cl - ex * bl) * d;

    return x * x + y * y;
}

function circumcenter(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;

    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);

    const x = ax + (ey * bl - dy * cl) * d;
    const y = ay + (dx * cl - ex * bl) * d;

    return {x, y};
}

function quicksort(ids, dists, left, right) {
    if (right - left <= 20) {
        for (let i = left + 1; i <= right; i++) {
            const temp = ids[i];
            const tempDist = dists[temp];
            let j = i - 1;
            while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
            ids[j + 1] = temp;
        }
    } else {
        const median = (left + right) >> 1;
        let i = left + 1;
        let j = right;
        swap(ids, median, i);
        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);

        const temp = ids[i];
        const tempDist = dists[temp];
        while (true) {
            do i++; while (dists[ids[i]] < tempDist);
            do j--; while (dists[ids[j]] > tempDist);
            if (j < i) break;
            swap(ids, i, j);
        }
        ids[left + 1] = ids[j];
        ids[j] = temp;

        if (right - i + 1 >= j - left) {
            quicksort(ids, dists, i, right);
            quicksort(ids, dists, left, j - 1);
        } else {
            quicksort(ids, dists, left, j - 1);
            quicksort(ids, dists, i, right);
        }
    }
}

function swap(arr, i, j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultGetX(p) {
    return p[0];
}
function defaultGetY(p) {
    return p[1];
}

var angleNormals_1 = angleNormals;

function hypot(x, y, z) {
  return Math.sqrt(Math.pow(x,2) + Math.pow(y,2) + Math.pow(z,2))
}

function weight(s, r, a) {
  return Math.atan2(r, (s - a))
}

function mulAdd(dest, s, x, y, z) {
  dest[0] += s * x;
  dest[1] += s * y;
  dest[2] += s * z;
}

function angleNormals(cells, positions) {
  var numVerts = positions.length;
  var numCells = cells.length;

  //Allocate normal array
  var normals = new Array(numVerts);
  for(var i=0; i<numVerts; ++i) {
    normals[i] = [0,0,0];
  }

  //Scan cells, and
  for(var i=0; i<numCells; ++i) {
    var cell = cells[i];
    var a = positions[cell[0]];
    var b = positions[cell[1]];
    var c = positions[cell[2]];

    var abx = a[0] - b[0];
    var aby = a[1] - b[1];
    var abz = a[2] - b[2];
    var ab = hypot(abx, aby, abz);

    var bcx = b[0] - c[0];
    var bcy = b[1] - c[1];
    var bcz = b[2] - c[2];
    var bc = hypot(bcx, bcy, bcz);

    var cax = c[0] - a[0];
    var cay = c[1] - a[1];
    var caz = c[2] - a[2];
    var ca = hypot(cax, cay, caz);

    if(Math.min(ab, bc, ca) < 1e-6) {
      continue
    }

    var s = 0.5 * (ab + bc + ca);
    var r = Math.sqrt((s - ab)*(s - bc)*(s - ca)/s);

    var nx = aby * bcz - abz * bcy;
    var ny = abz * bcx - abx * bcz;
    var nz = abx * bcy - aby * bcx;
    var nl = hypot(nx, ny, nz);
    nx /= nl;
    ny /= nl;
    nz /= nl;

    mulAdd(normals[cell[0]], weight(s, r, bc), nx, ny, nz);
    mulAdd(normals[cell[1]], weight(s, r, ca), nx, ny, nz);
    mulAdd(normals[cell[2]], weight(s, r, ab), nx, ny, nz);
  }

  //Normalize all the normals
  for(var i=0; i<numVerts; ++i) {
    var n = normals[i];
    var l = Math.sqrt(
      Math.pow(n[0], 2) +
      Math.pow(n[1], 2) +
      Math.pow(n[2], 2));
    if(l < 1e-8) {
      n[0] = 1;
      n[1] = 0;
      n[2] = 0;
      continue
    }
    n[0] /= l;
    n[1] /= l;
    n[2] /= l;
  }

  return normals
}

const product = (...a) => a.reduce((a2, b) => a2.flatMap((d) => b.map((e) => [d, e].flat())));
const uvGrid = (uResolution, vResolution = null) => product([...range$2(0, 1, 1 / uResolution), 1], [...range$2(0, 1, 1 / (vResolution || uResolution)), 1]);
const quadEdgeWeightInterpolator = (A, B, C, D, n = 1) => ([x, y]) => {
  const z = 1 - x;
  const w = 1 - y;
  const e0 = y * z * w;
  const e1 = x * z * w;
  const e2 = x * y * w;
  const e3 = x * y * z;
  const sum = e0 + e1 + e2 + e3;
  const c0 = A;
  const c1 = B;
  const c2 = C;
  const c3 = D;
  return ((e0 * c0) ** n + (e1 * c1) ** n + (e2 * c2) ** n + e3 * c3) / sum ** n;
};
const triEdgeWeightInterpolator = (A, B, C, n = 1) => ([x, y, z]) => {
  const e0 = y * z;
  const e1 = x * z;
  const e2 = x * y;
  const sum = e0 + e1 + e2;
  const c0 = A;
  const c1 = B;
  const c2 = C;
  return ((e0 * c0) ** n + (e1 * c1) ** n + (e2 * c2) ** n) / sum ** n;
};
const cartesian = (bc, corners) => [
  bc[0] * corners[0][0] + bc[1] * corners[1][0] + bc[2] * corners[2][0],
  bc[0] * corners[0][1] + bc[1] * corners[1][1] + bc[2] * corners[2][1]
];
const sampleTriangle = (corners) => () => {
  const u = [Math.random(), Math.random()];
  const su0 = Math.sqrt(u[0]);
  const b0 = 1 - su0;
  const b1 = u[1] * su0;
  const pt = cartesian([b0, b1, 1 - b0 - b1], corners);
  return pt;
};
const getRadiusTri = (triangle, weights) => (pt) => {
  let bary = barycentric_1(triangle, pt);
  const D = dist$2([0, 0], [0.5, 0.5]);
  bary = [
    divN2(null, bary[0], 1),
    divN2(null, bary[1], D),
    divN2(null, bary[2], D)
  ];
  const x = triEdgeWeightInterpolator(weights[0], weights[1], weights[2])(bary);
  return 1 / x;
};
const defaultOptions = {
  iter: 1,
  jitter: 1e-5,
  max: 3e6,
  quality: 150
};
const quadPatch = (resA, resB, resC, resD, opts = null) => {
  opts = { ...defaultOptions, ...opts || {} };
  const index = new KdTreeSet(2);
  for (let a = 0; a <= 1; a += 1 / resA) {
    index.add([0, a]);
  }
  for (let b = 0; b <= 1; b += 1 / resB) {
    index.add([b, 0]);
  }
  for (let c = 0; c <= 1; c += 1 / resC) {
    index.add([1, c]);
  }
  for (let d = 0; d <= 1; d += 1 / resD) {
    index.add([d, 1]);
  }
  const interpolation = (x) => 1 / quadEdgeWeightInterpolator(resA, resB, resC, resD)(x);
  const sample = () => {
    const points2 = () => [Math.random(), Math.random()];
    const density = interpolation;
    return samplePoisson({
      index,
      points: points2,
      density,
      max: 0,
      ...opts
    });
  };
  const boundaryPoints = index.keys();
  const points = [
    ...boundaryPoints,
    ...sample()
  ];
  return { points, index };
};
const triPatch = (resA, resB, resC, opts = null) => {
  opts = { ...defaultOptions, ...opts || {} };
  const corners = [
    [0, 1],
    [1, 0],
    [0, 0]
  ];
  const index = new KdTreeSet(2);
  for (let a = 0; a <= 1; a += 1 / resA) {
    index.add([a, 0]);
  }
  for (let b = 0; b <= 1; b += 1 / resB) {
    index.add([0, b]);
  }
  for (let c = 0; c <= 1; c += 1 / resC) {
    index.add([1 - c, c]);
  }
  const interpolation = getRadiusTri(corners, [resA, resB, resC]);
  const sampleTri = (corners2, weights) => {
    const points2 = sampleTriangle(corners2);
    return samplePoisson({
      index,
      points: points2,
      density: interpolation,
      max: 0,
      ...opts
    });
  };
  const boundaryPoints = index.keys();
  const points = [
    ...boundaryPoints,
    ...sampleTri(corners)
  ];
  return { points, index };
};
const tessellation = moize((sideLODs = 8) => {
  let points;
  if (Array.isArray(sideLODs)) {
    sideLODs = sideLODs;
    points = (sideLODs.length === 4 ? quadPatch(...sideLODs) : triPatch(...sideLODs)).points;
  } else {
    points = triPatch(sideLODs, sideLODs, sideLODs).points;
  }
  return Delaunator.from(points);
});
const prepareMesh$1 = moize((grid) => {
  let mesh = {};
  mesh.cells = chunk(grid.triangles, 3);
  mesh.positions = chunk(grid.coords, 2).map(([u, v]) => [
    u,
    v,
    0
  ]);
  mesh.normals = angleNormals_1(mesh.cells, mesh.positions);
  mesh.cellPositions = mesh.cells.map((indices) => indices.map((i) => mesh.positions[i]));
  mesh.cellNormals = mesh.cells.map((indices) => indices.map((i) => mesh.normals[i]));
  return mesh;
}, { maxSize: 40 });
const tesselationMesh = moize((sideLODs) => prepareMesh$1(tessellation(sideLODs)), { maxSize: 40 });

const drawCornerHints = `
        if (uv.x > 0.9) {
          fragColor = vec4(0,1,0,1);
        }
        if (uv.y > 0.9) {
          fragColor = vec4(0,0,1,1);
        }
        if (1.0 - uv.y - uv.x > 0.9) {
          fragColor = vec4(1,0,0,1);
        }`;
const vs = triangleVertexGL;
const fs = (debugCorners) => `
      #version 300 es
      precision highp float;
#define GLSLIFY 1

      vec2 matcap(vec3 eye, vec3 normal) {
  vec3 reflected = reflect(eye, normal);
  float m = 2.8284271247461903 * sqrt( reflected.z+1.0 );
  return reflected.xy / m + 0.5;
}

      uniform sampler2D matcapTexture;
      uniform sampler2D colorTexture;
      in vec4 eye;
      in vec3 n;
      in vec2 uv;
      out vec4 fragColor;
      void main () {
        vec4 color = texture(colorTexture, uv);
        // vec2 mat_uv = matcap(normalize(eye), vec3(color.r*n.x, color.g*n.y, color.b*n.z));
        vec2 mat_uv = matcap(normalize(eye.xyz), n);

        fragColor = vec4(texture(
          matcapTexture, mat_uv
        ));

        ${debugCorners ? drawCornerHints : ""}

        // fragColor = vec4(texture(
        //   matcapTexture, mat_uv
        // ).rgb, color.r);

        // fragColor = color;
        // gl_FragColor = vec4(0,1,1,1);
      }`;
const patchProgram = moize((app, debugCorners) => app.createProgram(vs, fs(debugCorners)), {
  maxAge: Infinity,
  maxSize: Infinity
});
const meshVertexArray = moize.infinite((mesh, app) => {
  const positionBuffer = app.createVertexBuffer(PicoGL.FLOAT, 3, new Float32Array(flatten(flatten(mesh.cellPositions))));
  app.createIndexBuffer(PicoGL.UNSIGNED_SHORT, new Uint32Array(flatten(mesh.cells)));
  app.createVertexBuffer(PicoGL.FLOAT, 3, new Float32Array(flatten(mesh.normals)));
  const vertexArray = app.createVertexArray().vertexAttributeBuffer(0, positionBuffer);
  return vertexArray;
});
const patchDrawCall = (app, sideLODs, pointsBuffer, weightsBuffer, cornerColors = false) => {
  const mesh = tesselationMesh(sideLODs);
  const vertexArray = meshVertexArray(mesh, app).instanceAttributeBuffer(1, pointsBuffer).instanceAttributeBuffer(4, weightsBuffer);
  return {
    patchDraw: app.createDrawCall(patchProgram(app, cornerColors), vertexArray).uniform("eye", new Float32Array([0, 0, 1])),
    tessellation: mesh
  };
};

var humanFormat$1 = {exports: {}};

(function (module, exports) {
// UMD: https://github.com/umdjs/umd/blob/master/returnExports.js
(function (root, factory) {
  /* global define: false */
  {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  }
})(commonjsGlobal, function () {

  // =================================================================

  function assign(dst, src) {
    var i, n, prop;
    for (i = 1, n = arguments.length; i < n; ++i) {
      src = arguments[i];
      if (src != null) {
        for (prop in src) {
          if (has(src, prop)) {
            dst[prop] = src[prop];
          }
        }
      }
    }
    return dst;
  }

  function compareLongestFirst(a, b) {
    return b.length - a.length;
  }

  function compareSmallestFactorFirst(a, b) {
    return a.factor - b.factor;
  }

  // https://www.npmjs.org/package/escape-regexp
  function escapeRegexp(str) {
    return str.replace(/([.*+?=^!:${}()|[\]/\\])/g, "\\$1");
  }

  function forEach(arr, iterator) {
    var i, n;
    for (i = 0, n = arr.length; i < n; ++i) {
      iterator(arr[i], i);
    }
  }

  function forOwn(obj, iterator) {
    var prop;
    for (prop in obj) {
      if (has(obj, prop)) {
        iterator(obj[prop], prop);
      }
    }
  }

  var has = (function (hasOwnProperty) {
    return function has(obj, prop) {
      return obj != null && hasOwnProperty.call(obj, prop);
    };
  })(Object.prototype.hasOwnProperty);

  function resolve(container, entry) {
    while (typeof entry === "string") {
      entry = container[entry];
    }
    return entry;
  }

  // =================================================================

  function Scale(prefixes) {
    this._prefixes = prefixes;

    var escapedPrefixes = [];
    var list = [];
    forOwn(prefixes, function (factor, prefix) {
      escapedPrefixes.push(escapeRegexp(prefix));

      list.push({
        factor: factor,
        prefix: prefix,
      });
    });

    // Adds lower cased prefixes for case insensitive fallback.
    var lcPrefixes = (this._lcPrefixes = {});
    forOwn(prefixes, function (factor, prefix) {
      var lcPrefix = prefix.toLowerCase();
      if (!has(prefixes, lcPrefix)) {
        lcPrefixes[lcPrefix] = prefix;
      }
    });

    list.sort(compareSmallestFactorFirst);
    this._list = list;

    escapedPrefixes.sort(compareLongestFirst);
    this._regexp = new RegExp(
      "^\\s*(-)?\\s*(\\d+(?:\\.\\d+)?)\\s*(" +
        escapedPrefixes.join("|") +
        ")\\s*(.*)\\s*?$",
      "i"
    );
  }

  Scale.create = function Scale$create(prefixesList, base, initExp) {
    var prefixes = {};
    if (initExp === undefined) {
      initExp = 0;
    }
    forEach(prefixesList, function (prefix, i) {
      prefixes[prefix] = Math.pow(base, i + initExp);
    });

    return new Scale(prefixes);
  };

  // Binary search to find the greatest index which has a value <=.
  Scale.prototype.findPrefix = function Scale$findPrefix(value) {
    var list = this._list;
    var low = 0;
    var high = list.length - 1;

    var mid, current;
    while (low !== high) {
      mid = (low + high + 1) >> 1;
      current = list[mid].factor;

      if (current > value) {
        high = mid - 1;
      } else {
        low = mid;
      }
    }

    return list[low];
  };

  Scale.prototype.parse = function Scale$parse(str, strict) {
    var matches = str.match(this._regexp);

    if (matches === null) {
      return;
    }

    var prefix = matches[3];
    var factor;

    if (has(this._prefixes, prefix)) {
      factor = this._prefixes[prefix];
    } else if (
      !strict &&
      ((prefix = prefix.toLowerCase()), has(this._lcPrefixes, prefix))
    ) {
      prefix = this._lcPrefixes[prefix];
      factor = this._prefixes[prefix];
    } else {
      return;
    }

    var value = +matches[2];
    if (matches[1] !== undefined) {
      value = -value;
    }

    return {
      factor: factor,
      prefix: prefix,
      unit: matches[4],
      value: value,
    };
  };

  // =================================================================

  var scales = {
    // https://en.wikipedia.org/wiki/Binary_prefix
    binary: Scale.create(",Ki,Mi,Gi,Ti,Pi,Ei,Zi,Yi".split(","), 1024),

    // https://en.wikipedia.org/wiki/Metric_prefix
    //
    // Not all prefixes are present, only those which are multiple of
    // 1000, because humans usually prefer to see close numbers using
    // the same unit to ease the comparison.
    SI: Scale.create("y,z,a,f,p,n,,m,,k,M,G,T,P,E,Z,Y".split(","), 1000, -8),
  };

  var defaults = {
    // Decimal digits for formatting.
    maxDecimals: 2,

    // separator to use between value and units
    separator: " ",

    // Unit to use for formatting.
    unit: "",
  };
  var rawDefaults = {
    scale: "SI",

    // Strict mode prevents parsing of incorrectly cased prefixes.
    strict: false,
  };

  function humanFormat(value, opts) {
    opts = assign({}, defaults, opts);

    var decimals = opts.decimals;
    if (decimals !== undefined) {
      // humanFormat$raw should not round when using decimals option
      delete opts.maxDecimals;
    }

    var info = humanFormat$raw(value, opts);
    value =
      decimals !== undefined
        ? info.value.toFixed(decimals)
        : String(info.value);
    var suffix = info.prefix + opts.unit;
    return suffix === "" ? value : value + opts.separator + suffix;
  }

  var humanFormat$bytes$opts = { scale: "binary", unit: "B" };
  function humanFormat$bytes(value, opts) {
    return humanFormat(
      value,
      opts === undefined
        ? humanFormat$bytes$opts
        : assign({}, humanFormat$bytes$opts, opts)
    );
  }

  function humanFormat$parse(str, opts) {
    var info = humanFormat$parse$raw(str, opts);

    return info.value * info.factor;
  }

  function humanFormat$parse$raw(str, opts) {
    if (typeof str !== "string") {
      throw new TypeError("str must be a string");
    }

    // Merge default options.
    opts = assign({}, rawDefaults, opts);

    // Get current scale.
    var scale = resolve(scales, opts.scale);
    if (scale === undefined) {
      throw new Error("missing scale");
    }

    // TODO: the unit should be checked: it might be absent but it
    // should not differ from the one expected.
    //
    // TODO: if multiple units are specified, at least must match and
    // the returned value should be: { value: <value>, unit: matchedUnit }

    var info = scale.parse(str, opts.strict);
    if (info === undefined) {
      throw new Error("cannot parse str");
    }

    return info;
  }

  function humanFormat$raw(value, opts) {
    // Zero is a special case, it never has any prefix.
    if (value === 0) {
      return {
        value: 0,
        prefix: "",
      };
    } else if (value < 0) {
      var result = humanFormat$raw(-value, opts);
      result.value = -result.value;
      return result;
    }

    if (typeof value !== "number" || Number.isNaN(value)) {
      throw new TypeError("value must be a number");
    }

    // Merge default options.
    opts = assign({}, rawDefaults, opts);

    // Get current scale.
    var scale = resolve(scales, opts.scale);
    if (scale === undefined) {
      throw new Error("missing scale");
    }

    var power;
    var maxDecimals = opts.maxDecimals;
    var autoMaxDecimals = maxDecimals === "auto";
    if (autoMaxDecimals) {
      power = 10;
    } else if (maxDecimals !== undefined) {
      power = Math.pow(10, maxDecimals);
    }

    var prefix = opts.prefix;
    var factor;
    if (prefix !== undefined) {
      if (!has(scale._prefixes, prefix)) {
        throw new Error("invalid prefix");
      }

      factor = scale._prefixes[prefix];
    } else {
      var _ref = scale.findPrefix(value);
      if (power !== undefined) {
        do {
          factor = _ref.factor;

          // factor is usually >> power, therefore it's better to
          // divide factor by power than the other way to limit
          // numerical error
          var r = factor / power;

          value = Math.round(value / r) * r;
        } while ((_ref = scale.findPrefix(value)).factor !== factor);
      } else {
        factor = _ref.factor;
      }

      prefix = _ref.prefix;
    }
    value =
      power === undefined
        ? value / factor
        : Math.round((value * power) / factor) / power;

    if (autoMaxDecimals && Math.abs(value) >= 10) {
      value = Math.round(value);
    }

    return {
      prefix: prefix,
      value: value,
    };
  }

  humanFormat.bytes = humanFormat$bytes;
  humanFormat.parse = humanFormat$parse;
  humanFormat$parse.raw = humanFormat$parse$raw;
  humanFormat.raw = humanFormat$raw;
  humanFormat.Scale = Scale;

  return humanFormat;
});
}(humanFormat$1));

var humanFormat = humanFormat$1.exports;

function createCube(sx, sy, sz, nx, ny, nz) {
    if (sx === undefined) sx = 1.0;
    if (sy === undefined) sy = sx;
    if (sz === undefined) sz = sx;

    if (nx === undefined) nx = 1.0;
    if (ny === undefined) ny = nx;
    if (nz === undefined) nz = nx;

    var vertexIndex = 0;
    var positions = [];
    var normals = [];
    var uvs = [];
    var cells = [];

    function makePlane(u, v, w, su, sv, nu, nv, pw, flipu, flipv) {
        var vertShift = vertexIndex;
        for(var j=0; j<=nv; j++) {
            for(var i=0; i<=nu; i++) {
                var vert = positions[vertexIndex] = [0,0,0];
                vert[u] = (-su/2 + i*su/nu) * flipu;
                vert[v] = (-sv/2 + j*sv/nv) * flipv;
                vert[w] = pw;

                var normal = normals[vertexIndex] = [0,0,0];
                normal[u] = 0;
                normal[v] = 0;
                normal[w] = pw/Math.abs(pw);

                var texCoord = uvs[vertexIndex] = [0,0];
                texCoord[0] = i/nu;
                texCoord[1] = 1.0 - j/nv;

                ++vertexIndex;
            }
        }

        for(var j=0; j<nv; j++) {
            for(var i=0; i<nu; i++) {
                var n = vertShift + j * (nu + 1) + i;
                cells.push([n, n + nu  + 1, n + nu + 2]);
                cells.push([n, n + nu + 2, n + 1]);
            }
        }
    }

     makePlane(0, 1, 2, sx, sy, nx, ny,  sz/2,  1, -1); //front
     makePlane(0, 1, 2, sx, sy, nx, ny, -sz/2, -1, -1); //back
     makePlane(2, 1, 0, sz, sy, nz, ny, -sx/2,  1, -1); //left
     makePlane(2, 1, 0, sz, sy, nz, ny,  sx/2, -1, -1); //right
     makePlane(0, 2, 1, sx, sz, nx, nz,  sy/2,  1,  1); //top
     makePlane(0, 2, 1, sx, sz, nx, nz, -sy/2,  1, -1); //bottom

    return {
        positions: positions,
        normals: normals,
        uvs: uvs,
        cells: cells
    }
}

var primitiveCube = createCube;

var bunny = {};

bunny.positions=[[1.301895,0.122622,2.550061],[1.045326,0.139058,2.835156],[0.569251,0.155925,2.805125],[0.251886,0.144145,2.82928],[0.063033,0.131726,3.01408],[-0.277753,0.135892,3.10716],[-0.441048,0.277064,2.594331],[-1.010956,0.095285,2.668983],[-1.317639,0.069897,2.325448],[-0.751691,0.264681,2.381496],[0.684137,0.31134,2.364574],[1.347931,0.302882,2.201434],[-1.736903,0.029894,1.724111],[-1.319986,0.11998,0.912925],[1.538077,0.157372,0.481711],[1.951975,0.081742,1.1641],[1.834768,0.095832,1.602682],[2.446122,0.091817,1.37558],[2.617615,0.078644,0.742801],[-1.609748,0.04973,-0.238721],[-1.281973,0.230984,-0.180916],[-1.074501,0.248204,0.034007],[-1.201734,0.058499,0.402234],[-1.444454,0.054783,0.149579],[-4.694605,5.075882,1.043427],[-3.95963,7.767394,0.758447],[-4.753339,5.339817,0.665061],[-1.150325,9.133327,-0.368552],[-4.316107,2.893611,0.44399],[-0.809202,9.312575,-0.466061],[0.085626,5.963693,1.685666],[-1.314853,9.00142,-0.1339],[-4.364182,3.072556,1.436712],[-2.022074,7.323396,0.678657],[1.990887,6.13023,0.479643],[-3.295525,7.878917,1.409353],[0.571308,6.197569,0.670657],[0.89661,6.20018,0.337056],[0.331851,6.162372,1.186371],[-4.840066,5.599874,2.296069],[2.138989,6.031291,0.228335],[0.678923,6.026173,1.894052],[-0.781682,5.601573,1.836738],[1.181315,6.239007,0.393293],[-3.606308,7.376476,2.661452],[-0.579059,4.042511,-1.540883],[-3.064069,8.630253,-2.597539],[-2.157271,6.837012,0.300191],[-2.966013,7.821581,-1.13697],[-2.34426,8.122965,0.409043],[-0.951684,5.874251,1.415119],[-2.834853,7.748319,0.182406],[-3.242493,7.820096,0.373674],[-0.208532,5.992846,1.252084],[-3.048085,8.431527,-2.129795],[1.413245,5.806324,2.243906],[-0.051222,6.064901,0.696093],[-4.204306,2.700062,0.713875],[-4.610997,6.343405,0.344272],[-3.291336,9.30531,-3.340445],[-3.27211,7.559239,-2.324016],[-4.23882,6.498344,3.18452],[-3.945317,6.377804,3.38625],[-4.906378,5.472265,1.315193],[-3.580131,7.846717,0.709666],[-1.995504,6.645459,0.688487],[-2.595651,7.86054,0.793351],[-0.008849,0.305871,0.184484],[-0.029011,0.314116,-0.257312],[-2.522424,7.565392,1.804212],[-1.022993,8.650826,-0.855609],[-3.831265,6.595426,3.266783],[-4.042525,6.855724,3.060663],[-4.17126,7.404742,2.391387],[3.904526,3.767693,0.092179],[0.268076,6.086802,1.469223],[-3.320456,8.753222,-2.08969],[1.203048,6.26925,0.612407],[-4.406479,2.985974,0.853691],[-3.226889,6.615215,-0.404243],[0.346326,1.60211,3.509858],[-3.955476,7.253323,2.722392],[-1.23204,0.068935,1.68794],[0.625436,6.196455,1.333156],[4.469132,2.165298,1.70525],[0.950053,6.262899,0.922441],[-2.980404,5.25474,-0.663155],[-4.859043,6.28741,1.537081],[-3.077453,4.641475,-0.892167],[-0.44002,8.222503,-0.771454],[-4.034112,7.639786,0.389935],[-3.696045,6.242042,3.394679],[-1.221806,7.783617,0.196451],[0.71461,6.149895,1.656636],[-4.713539,6.163154,0.495369],[-1.509869,0.913044,-0.832413],[-1.547249,2.066753,-0.852669],[-3.757734,5.793742,3.455794],[-0.831911,0.199296,1.718536],[-3.062763,7.52718,-1.550559],[0.938688,6.103354,1.820958],[-4.037033,2.412311,0.988026],[-4.130746,2.571806,1.101689],[-0.693664,9.174283,-0.952323],[-1.286742,1.079679,-0.751219],[1.543185,1.408925,3.483132],[1.535973,2.047979,3.655029],[0.93844,5.84101,2.195219],[-0.684401,5.918492,1.20109],[1.28844,2.008676,3.710781],[-3.586722,7.435506,-1.454737],[-0.129975,4.384192,2.930593],[-1.030531,0.281374,3.214273],[-3.058751,8.137238,-3.227714],[3.649524,4.592226,1.340021],[-3.354828,7.322425,-1.412086],[0.936449,6.209237,1.512693],[-1.001832,3.590411,-1.545892],[-3.770486,4.593242,2.477056],[-0.971925,0.067797,0.921384],[-4.639832,6.865407,2.311791],[-0.441014,8.093595,-0.595999],[-2.004852,6.37142,1.635383],[4.759591,1.92818,0.328328],[3.748064,1.224074,2.140484],[-0.703601,5.285476,2.251988],[0.59532,6.21893,0.981004],[0.980799,6.257026,1.24223],[1.574697,6.204981,0.381628],[1.149594,6.173608,1.660763],[-3.501963,5.895989,3.456576],[1.071122,5.424198,2.588717],[-0.774693,8.473335,-0.276957],[3.849959,4.15542,0.396742],[-0.801715,4.973149,-1.068582],[-2.927676,0.625112,2.326393],[2.669682,4.045542,2.971184],[-4.391324,4.74086,0.343463],[1.520129,6.270031,0.775471],[1.837586,6.084731,0.109188],[1.271475,5.975024,2.032355],[-3.487968,4.513249,2.605871],[-1.32234,1.517264,-0.691879],[-1.080301,1.648226,-0.805526],[-3.365703,6.910166,-0.454902],[1.36034,0.432238,3.075004],[-3.305013,5.774685,3.39142],[3.88432,0.654141,0.12574],[3.57254,0.377934,0.302501],[4.196136,0.807999,0.212229],[3.932997,0.543123,0.380579],[4.023704,3.286125,0.537597],[1.864455,4.916544,2.691677],[-4.775427,6.499498,1.440153],[-3.464928,3.68234,2.766356],[3.648972,1.751262,2.157485],[1.179111,3.238846,3.774796],[-0.171164,0.299126,-0.592669],[-4.502912,3.316656,0.875188],[-0.948454,9.214025,-0.679508],[1.237665,6.288593,1.046],[1.523423,6.268963,1.139544],[1.436519,6.140608,1.739316],[3.723607,1.504355,2.136762],[2.009495,4.045514,3.22053],[-1.921944,7.249905,0.213973],[1.254068,1.205518,3.474709],[-0.317087,5.996269,0.525872],[-2.996914,3.934607,2.900178],[-3.316873,4.028154,2.785696],[-3.400267,4.280157,2.689268],[-3.134842,4.564875,2.697192],[1.480563,4.692567,2.834068],[0.873682,1.315452,3.541585],[1.599355,0.91622,3.246769],[-3.292102,7.125914,2.768515],[3.74296,4.511299,0.616539],[4.698935,1.55336,0.26921],[-3.274387,3.299421,2.823946],[-2.88809,3.410699,2.955248],[1.171407,1.76905,3.688472],[1.430276,3.92483,3.473666],[3.916941,2.553308,0.018941],[0.701632,2.442372,3.778639],[1.562657,2.302778,3.660957],[4.476622,1.152407,0.182131],[-0.61136,5.761367,1.598838],[-3.102154,3.691687,2.903738],[1.816012,5.546167,2.380308],[3.853928,4.25066,0.750017],[1.234681,3.581665,3.673723],[1.862271,1.361863,3.355209],[1.346844,4.146995,3.327877],[1.70672,4.080043,3.274307],[0.897242,1.908983,3.6969],[-0.587022,9.191132,-0.565301],[-0.217426,5.674606,2.019968],[0.278925,6.120777,0.485403],[1.463328,3.578742,-2.001464],[-3.072985,4.264581,2.789502],[3.62353,4.673843,0.383452],[-3.053491,8.752377,-2.908434],[-2.628687,4.505072,2.755601],[0.891047,5.113781,2.748272],[-2.923732,3.06515,2.866368],[0.848008,4.754252,2.896972],[-3.319184,8.811641,-2.327412],[0.12864,8.814781,-1.334456],[1.549501,4.549331,-1.28243],[1.647161,3.738973,3.507719],[1.250888,0.945599,3.348739],[3.809662,4.038822,0.053142],[1.483166,0.673327,3.09156],[0.829726,3.635921,3.713103],[1.352914,5.226651,2.668113],[2.237352,4.37414,3.016386],[4.507929,0.889447,0.744249],[4.57304,1.010981,0.496588],[3.931422,1.720989,2.088175],[-0.463177,5.989835,0.834346],[-2.811236,3.745023,2.969587],[-2.805135,4.219721,2.841108],[-2.836842,4.802543,2.60826],[1.776716,2.084611,3.568638],[4.046881,1.463478,2.106273],[0.316265,5.944313,1.892785],[-2.86347,2.776049,2.77242],[-2.673644,3.116508,2.907104],[-2.621149,4.018502,2.903409],[-2.573447,5.198013,2.477481],[1.104039,2.278985,3.722469],[-4.602743,4.306413,0.902296],[-2.684878,1.510731,0.535039],[0.092036,8.473269,-0.99413],[-1.280472,5.602393,1.928105],[-1.0279,4.121582,-1.403103],[-2.461081,3.304477,2.957317],[-2.375929,3.659383,2.953233],[1.417579,2.715389,3.718767],[0.819727,2.948823,3.810639],[1.329962,0.761779,3.203724],[1.73952,5.295229,2.537725],[0.952523,3.945016,3.548229],[-2.569498,0.633669,2.84818],[-2.276676,0.757013,2.780717],[-2.013147,7.354429,-0.003202],[0.93143,1.565913,3.600325],[1.249014,1.550556,3.585842],[2.287252,4.072353,3.124544],[-4.7349,7.006244,1.690653],[-3.500602,8.80386,-2.009196],[-0.582629,5.549138,2.000923],[-1.865297,6.356066,1.313593],[-3.212154,2.376143,-0.565593],[2.092889,3.493536,-1.727931],[-2.528501,2.784531,2.833758],[-2.565697,4.893154,2.559605],[-2.153366,5.04584,2.465215],[1.631311,2.568241,3.681445],[2.150193,4.699227,2.807505],[0.507599,5.01813,2.775892],[4.129862,1.863698,2.015101],[3.578279,4.50766,-0.009598],[3.491023,4.806749,1.549265],[0.619485,1.625336,3.605125],[1.107499,2.932557,3.790061],[-2.082292,6.99321,0.742601],[4.839909,1.379279,0.945274],[3.591328,4.322645,-0.259497],[1.055245,0.710686,3.16553],[-3.026494,7.842227,1.624553],[0.146569,6.119214,0.981673],[-2.043687,2.614509,2.785526],[-2.302242,3.047775,2.936355],[-2.245686,4.100424,2.87794],[2.116148,5.063507,2.572204],[-1.448406,7.64559,0.251692],[2.550717,4.9268,2.517526],[-2.955456,7.80293,-1.782407],[1.882995,4.637167,2.895436],[-2.014924,3.398262,2.954896],[-2.273654,4.771227,2.611418],[-2.162723,7.876761,0.702473],[-0.198659,5.823062,1.739272],[-1.280908,2.133189,-0.921241],[2.039932,4.251568,3.136579],[1.477815,4.354333,3.108325],[0.560504,3.744128,3.6913],[-2.234018,1.054373,2.352782],[-3.189156,7.686661,-2.514955],[-3.744736,7.69963,2.116973],[-2.283366,2.878365,2.87882],[-2.153786,4.457481,2.743529],[4.933978,1.677287,0.713773],[3.502146,0.535336,1.752511],[1.825169,4.419253,3.081198],[3.072331,0.280979,0.106534],[-0.508381,1.220392,2.878049],[-3.138824,8.445394,-1.659711],[-2.056425,2.954815,2.897241],[-2.035343,5.398477,2.215842],[-3.239915,7.126798,-0.712547],[-1.867923,7.989805,0.526518],[1.23405,6.248973,1.387189],[-0.216492,8.320933,-0.862495],[-2.079659,3.755709,2.928563],[-1.78595,4.300374,2.805295],[-1.856589,5.10678,2.386572],[-1.714362,5.544778,2.004623],[1.722403,4.200291,-1.408161],[0.195386,0.086928,-1.318006],[1.393693,3.013404,3.710686],[-0.415307,8.508471,-0.996883],[-1.853777,0.755635,2.757275],[-1.724057,3.64533,2.884251],[-1.884511,4.927802,2.530885],[-1.017174,7.783908,-0.227078],[-1.7798,2.342513,2.741749],[-1.841329,3.943996,2.88436],[1.430388,5.468067,2.503467],[-2.030296,0.940028,2.611088],[-1.677028,1.215666,2.607771],[-1.74092,2.832564,2.827295],[4.144673,0.631374,0.503358],[4.238811,0.653992,0.762436],[-1.847016,2.082815,2.642674],[4.045764,3.194073,0.852117],[-1.563989,8.112739,0.303102],[-1.781627,1.794836,2.602338],[-1.493749,2.533799,2.797251],[-1.934496,4.690689,2.658999],[-1.499174,5.777946,1.747498],[-2.387409,0.851291,1.500524],[-1.872211,8.269987,0.392533],[-4.647726,6.765771,0.833653],[-3.157482,0.341958,-0.20671],[-1.725766,3.24703,2.883579],[-1.458199,4.079031,2.836325],[-1.621548,4.515869,2.719266],[-1.607292,4.918914,2.505881],[-1.494661,5.556239,1.991599],[-1.727269,7.423769,0.012337],[-1.382497,1.161322,2.640222],[-1.52129,4.681714,2.615467],[-4.247127,2.792812,1.250843],[-1.576338,0.742947,2.769799],[-1.499257,2.172763,2.743142],[-1.480392,3.103261,2.862262],[1.049137,2.625836,3.775384],[-1.368063,1.791587,2.695516],[-1.307839,2.344534,2.767575],[-1.336758,5.092221,2.355225],[-1.5617,5.301749,2.21625],[-1.483362,8.537704,0.196752],[-1.517348,8.773614,0.074053],[-1.474302,1.492731,2.641433],[2.48718,0.644247,-0.920226],[0.818091,0.422682,3.171218],[-3.623398,6.930094,3.033045],[1.676333,3.531039,3.591591],[1.199939,5.683873,2.365623],[-1.223851,8.841201,0.025414],[-1.286307,3.847643,2.918044],[-1.25857,4.810831,2.543605],[2.603662,5.572146,1.991854],[0.138984,5.779724,2.077834],[-1.267039,3.175169,2.890889],[-1.293616,3.454612,2.911774],[-2.60112,1.277184,0.07724],[2.552779,3.649877,3.163643],[-1.038983,1.248011,2.605933],[-1.288709,4.390967,2.761214],[-1.034218,5.485963,2.011467],[-1.185576,1.464842,2.624335],[-1.045682,2.54896,2.761102],[4.259176,1.660627,2.018096],[-0.961707,1.717183,2.598342],[-1.044603,3.147464,2.855335],[-0.891998,4.685429,2.669696],[-1.027561,5.081672,2.377939],[4.386506,0.832434,0.510074],[-1.014225,9.064991,-0.175352],[-1.218752,2.895443,2.823785],[-0.972075,4.432669,2.788005],[-2.714986,0.52425,1.509798],[-0.699248,1.517219,2.645738],[-1.161581,2.078852,2.722795],[-0.845249,3.286247,2.996471],[1.068329,4.443444,2.993863],[3.98132,3.715557,1.027775],[1.658097,3.982428,-1.651688],[-4.053701,2.449888,0.734746],[-0.910935,2.214149,2.702393],[0.087824,3.96165,3.439344],[-0.779714,3.724134,2.993429],[-1.051093,3.810797,2.941957],[-0.644941,4.3859,2.870863],[-2.98403,8.666895,-3.691888],[-0.754304,2.508325,2.812999],[-4.635524,3.662891,0.913005],[-0.983299,4.125978,2.915378],[4.916497,1.905209,0.621315],[4.874983,1.728429,0.468521],[2.33127,5.181957,2.441697],[-0.653711,2.253387,2.7949],[-3.623744,8.978795,-2.46192],[-4.555927,6.160279,0.215755],[-4.940628,5.806712,1.18383],[3.308506,2.40326,-0.910776],[0.58835,5.251928,-0.992886],[2.152215,5.449733,2.331679],[-0.712755,0.766765,3.280375],[-0.741771,1.9716,2.657235],[-4.828957,5.566946,2.635623],[-3.474788,8.696771,-1.776121],[1.770417,6.205561,1.331627],[-0.620626,4.064721,2.968972],[-1.499187,2.307735,-0.978901],[4.098793,2.330245,1.667951],[1.940444,6.167057,0.935904],[-2.314436,1.104995,1.681277],[-2.733629,7.742793,1.7705],[-0.452248,4.719868,2.740834],[-0.649143,4.951713,2.541296],[-0.479417,9.43959,-0.676324],[-2.251853,6.559275,0.046819],[0.033531,8.316907,-0.789939],[-0.513125,0.995673,3.125462],[-2.637602,1.039747,0.602434],[1.527513,6.230089,1.430903],[4.036124,2.609846,1.506498],[-3.559828,7.877892,1.228076],[-4.570736,4.960193,0.838201],[-0.432121,5.157731,2.467518],[-1.206735,4.562511,-1.237054],[-0.823768,3.788746,-1.567481],[-3.095544,7.353613,-1.024577],[-4.056088,7.631119,2.062001],[-0.289385,5.382261,2.329421],[1.69752,6.136483,1.667037],[-0.168758,5.061138,2.617453],[2.853576,1.605528,-1.229958],[-4.514319,6.586675,0.352756],[-2.558081,7.741151,1.29295],[1.61116,5.92358,2.071534],[3.936921,3.354857,0.091755],[-0.1633,1.119272,3.147975],[0.067551,1.593475,3.38212],[-1.303239,2.328184,-1.011672],[-0.438093,0.73423,3.398384],[-4.62767,3.898187,0.849573],[0.286853,4.165281,3.284834],[-2.968052,8.492812,-3.493693],[-0.111896,3.696111,3.53791],[-3.808245,8.451731,-1.574742],[0.053416,5.558764,2.31107],[3.956269,3.012071,0.11121],[-0.710956,8.106561,-0.665154],[0.234725,2.717326,3.722379],[-0.031594,2.76411,3.657347],[-0.017371,4.700633,2.81911],[0.215064,5.034859,2.721426],[-0.111151,8.480333,-0.649399],[3.97942,3.575478,0.362219],[0.392962,4.735392,2.874321],[4.17015,2.085087,1.865999],[0.169054,1.244786,3.337709],[0.020049,3.165818,3.721736],[0.248212,3.595518,3.698376],[0.130706,5.295541,2.540034],[-4.541357,4.798332,1.026866],[-1.277485,1.289518,-0.667272],[3.892133,3.54263,-0.078056],[4.057379,3.03669,0.997913],[0.287719,0.884758,3.251787],[0.535771,1.144701,3.400096],[0.585303,1.399362,3.505353],[0.191551,2.076246,3.549355],[0.328656,2.394576,3.649623],[0.413124,3.240728,3.771515],[0.630361,4.501549,2.963623],[0.529441,5.854392,2.120225],[3.805796,3.769958,-0.162079],[3.447279,4.344846,-0.467276],[0.377618,5.551116,2.426017],[0.409355,1.821269,3.606333],[0.719959,2.194726,3.703851],[0.495922,3.501519,3.755661],[0.603408,5.354097,2.603088],[-4.605056,7.531978,1.19579],[0.907972,0.973128,3.356513],[0.750134,3.356137,3.765847],[0.4496,3.993244,3.504544],[-3.030738,7.48947,-1.259169],[0.707505,5.602005,2.43476],[0.668944,0.654891,3.213797],[0.593244,2.700978,3.791427],[1.467759,3.30327,3.71035],[3.316249,2.436388,2.581175],[3.26138,1.724425,2.539028],[-1.231292,7.968263,0.281414],[-0.108773,8.712307,-0.790607],[4.445684,1.819442,1.896988],[1.998959,2.281499,3.49447],[2.162269,2.113817,3.365449],[4.363397,1.406731,1.922714],[4.808,2.225842,0.611127],[2.735919,0.771812,-0.701142],[1.897735,2.878428,3.583482],[-3.31616,5.331985,3.212394],[-3.3314,6.018137,3.313018],[-3.503183,6.480103,3.222216],[-1.904453,5.750392,1.913324],[-1.339735,3.559592,-1.421817],[-1.044242,8.22539,0.037414],[1.643492,3.110676,3.647424],[3.992832,3.686244,0.710946],[1.774207,1.71842,3.475768],[-3.438842,5.5713,3.427818],[4.602447,1.2583,1.619528],[-0.925516,7.930042,0.072336],[-1.252093,3.846565,-1.420761],[-3.426857,5.072419,2.97806],[-3.160408,6.152629,3.061869],[3.739931,3.367082,2.041273],[1.027419,4.235891,3.251253],[4.777703,1.887452,1.560409],[-3.318528,6.733796,2.982968],[2.929265,4.962579,2.271079],[3.449761,2.838629,2.474576],[-3.280159,5.029875,2.787514],[4.068939,2.993629,0.741567],[0.303312,8.70927,-1.121972],[0.229852,8.981322,-1.186075],[-0.011045,9.148156,-1.047057],[-2.942683,5.579613,2.929297],[-3.145409,5.698727,3.205778],[-3.019089,6.30887,2.794323],[-3.217135,6.468191,2.970032],[-3.048298,6.993641,2.623378],[-3.07429,6.660982,2.702434],[3.612011,2.5574,2.25349],[2.54516,4.553967,2.75884],[-1.683759,7.400787,0.250868],[-1.756066,7.463557,0.448031],[-3.023761,5.149697,2.673539],[3.112376,2.677218,2.782378],[2.835327,4.581196,2.567146],[-2.973799,7.225458,2.506988],[-0.591645,8.740662,-0.505845],[3.782861,2.04337,2.03066],[3.331604,3.36343,2.605047],[2.966866,1.205497,2.537432],[0.002669,9.654748,-1.355559],[2.632801,0.58497,2.540311],[-2.819398,5.087372,2.521098],[2.616193,5.332961,2.194288],[-3.193973,4.925634,2.607924],[-3.12618,5.27524,2.944544],[-0.426003,8.516354,-0.501528],[2.802717,1.387643,2.751649],[-3.120597,7.889111,-2.75431],[2.636648,1.71702,2.991302],[-2.853151,6.711792,2.430276],[-2.843836,6.962865,2.400842],[1.9696,3.199023,3.504514],[-2.461751,0.386352,3.008994],[1.64127,0.495758,3.02958],[-4.330472,5.409831,0.025287],[-2.912387,5.980416,2.844261],[-2.490069,0.211078,2.985391],[3.581816,4.809118,0.733728],[2.693199,2.647213,3.126709],[-0.182964,8.184108,-0.638459],[-2.226855,0.444711,2.946552],[-0.720175,8.115055,0.017689],[2.645302,4.316212,2.850139],[-0.232764,9.329503,-0.918639],[4.852365,1.471901,0.65275],[2.76229,2.014994,2.957755],[-2.808374,5.354301,2.644695],[-2.790967,6.406963,2.547985],[-1.342684,0.418488,-1.669183],[2.690675,5.593587,-0.041236],[4.660146,1.6318,1.713314],[2.775667,3.007229,3.111332],[-0.396696,8.963432,-0.706202],[2.446707,2.740617,3.321433],[-4.803209,5.884634,2.603672],[-2.652003,1.6541,1.5078],[3.932327,3.972874,0.831924],[2.135906,0.955587,2.986608],[2.486131,2.053802,3.124115],[-0.386706,8.115753,-0.37565],[-2.720727,7.325044,2.224878],[-1.396946,7.638016,-0.16486],[-0.62083,7.989771,-0.144413],[-2.653272,5.729684,2.667679],[3.038188,4.65835,2.364142],[2.381721,0.739472,2.788992],[-2.345829,5.474929,2.380633],[-2.518983,6.080562,2.479383],[-2.615793,6.839622,2.186116],[-2.286566,0.143752,2.766848],[-4.771219,6.508766,1.070797],[3.717308,2.905019,2.097994],[2.50521,3.016743,3.295898],[2.208448,1.56029,3.216806],[3.346783,1.01254,2.119951],[2.653503,3.26122,3.175738],[-2.359636,5.827519,2.402297],[-1.952693,0.558102,2.853307],[-0.321562,9.414885,-1.187501],[3.138923,1.405072,2.520765],[1.493728,1.780051,3.621969],[3.01817,0.907291,2.336909],[3.183548,1.185297,2.352175],[1.608619,5.006753,2.695131],[-4.723919,6.836107,1.095288],[-1.017586,8.865429,-0.149328],[4.730762,1.214014,0.64008],[-2.135182,6.647907,1.495471],[-2.420382,6.546114,2.108209],[-2.458053,7.186346,1.896623],[3.437124,0.275798,1.138203],[0.095925,8.725832,-0.926481],[2.417376,2.429869,3.287659],[2.279951,1.200317,3.049994],[2.674753,2.326926,3.044059],[-2.328123,6.849164,1.75751],[-3.418616,7.853407,0.126248],[-3.151587,7.77543,-0.110889],[2.349144,5.653242,2.05869],[-2.273236,6.085631,2.242888],[-4.560601,4.525342,1.261241],[2.866334,3.796067,2.934717],[-2.17493,6.505518,1.791367],[3.12059,3.283157,2.818869],[3.037703,3.562356,2.866653],[0.066233,9.488418,-1.248237],[2.749941,0.975018,2.573371],[-2.155749,5.801033,2.204009],[-2.162778,6.261889,2.028596],[1.936874,0.459142,2.956718],[3.176249,4.335541,2.440447],[4.356599,1.029423,1.700589],[3.873502,3.082678,1.80431],[2.895489,4.243034,2.735259],[-0.095774,9.468195,-1.07451],[-1.124982,7.886808,-0.480851],[3.032304,3.065454,2.897927],[3.692687,4.5961,0.957858],[-3.013045,3.807235,-1.098381],[-0.790012,8.92912,-0.367572],[1.905793,0.73179,2.996728],[3.530396,3.426233,2.356583],[2.12299,0.624933,2.929167],[-2.069196,6.039284,2.01251],[-3.565623,7.182525,2.850039],[2.959264,2.376337,2.829242],[2.949071,1.822483,2.793933],[4.036142,0.763803,1.703744],[-1.993527,6.180318,1.804936],[-0.030987,0.766389,3.344766],[-0.549683,8.225193,-0.189341],[-0.765469,8.272246,-0.127174],[-2.947047,7.541648,-0.414113],[-3.050327,9.10114,-3.435619],[3.488566,2.231807,2.399836],[3.352283,4.727851,1.946438],[4.741011,2.162773,1.499574],[-1.815093,6.072079,1.580722],[-3.720969,8.267927,-0.984713],[1.932826,3.714052,3.427488],[3.323617,4.438961,2.20732],[0.254111,9.26364,-1.373244],[-1.493384,7.868585,-0.450051],[-0.841901,0.776135,-1.619467],[0.243537,6.027668,0.091687],[0.303057,0.313022,-0.531105],[-0.435273,0.474098,3.481552],[2.121507,2.622389,3.486293],[1.96194,1.101753,3.159584],[3.937991,3.407551,1.551392],[0.070906,0.295753,1.377185],[-1.93588,7.631764,0.651674],[-2.523531,0.744818,-0.30985],[2.891496,3.319875,2.983079],[4.781765,1.547061,1.523129],[-2.256064,7.571251,0.973716],[3.244861,3.058249,2.724392],[-0.145855,0.437775,3.433662],[1.586296,5.658538,2.358487],[3.658336,3.774921,2.071837],[2.840463,4.817098,2.46376],[-1.219464,8.122542,-0.672808],[-2.520906,2.664486,-1.034346],[-1.315417,8.471365,-0.709557],[3.429165,3.74686,2.446169],[3.074579,3.840758,2.767409],[3.569443,3.166337,2.333647],[2.294337,3.280051,3.359346],[2.21816,3.66578,3.269222],[2.158662,4.151444,-1.357919],[1.13862,4.380986,-1.404565],[3.388382,2.749931,-0.840949],[3.059892,5.084848,2.026066],[3.204739,2.075145,2.640706],[3.387065,1.42617,2.305275],[3.910398,2.670742,1.750179],[3.471512,1.945821,2.395881],[4.08082,1.070654,1.960171],[-1.057861,0.133036,2.146707],[-0.151749,5.53551,-0.624323],[3.233099,4.003778,2.571172],[2.611726,5.319199,-0.499388],[2.682909,1.094499,-1.206247],[-1.22823,7.656887,0.041409],[-2.293247,7.259189,0.013844],[0.081315,0.202174,3.286381],[-1.002038,5.794454,-0.187194],[3.448856,4.08091,2.258325],[0.287883,9.006888,-1.550641],[-3.851019,4.059839,-0.646922],[3.610966,4.205438,1.913129],[2.239042,2.950872,3.449959],[0.216305,0.442843,3.328052],[1.87141,2.470745,3.574559],[3.811378,2.768718,-0.228364],[2.511081,1.362724,2.969349],[-1.59813,7.866506,0.440184],[-3.307975,2.851072,-0.894978],[-0.107011,8.90573,-0.884399],[-3.855315,2.842597,-0.434541],[2.517853,1.090768,2.799687],[3.791709,2.36685,2.002703],[4.06294,2.773922,0.452723],[-2.973289,7.61703,-0.623653],[-2.95509,8.924462,-3.446319],[2.861402,0.562592,2.184397],[-1.109725,8.594206,-0.076812],[-0.725722,7.924485,-0.381133],[-1.485587,1.329994,-0.654405],[-4.342113,3.233735,1.752922],[-2.968049,7.955519,-2.09405],[-3.130948,0.446196,0.85287],[-4.958475,5.757329,1.447055],[-3.086547,7.615193,-1.953168],[-3.751923,5.412821,3.373373],[-4.599645,7.480953,1.677134],[1.133992,0.274871,0.032249],[-2.956512,8.126905,-1.785461],[-0.960645,4.73065,-1.191786],[-2.871064,0.875559,0.424881],[-4.932114,5.99614,1.483845],[-2.981761,8.124612,-1.387276],[0.362298,8.978545,-1.368024],[-4.408375,3.046271,0.602373],[2.865841,2.322263,-1.344625],[-4.7848,5.620895,0.594432],[-2.88322,0.338931,1.67231],[-4.688101,6.772931,1.872318],[-4.903948,6.164698,1.27135],[2.85663,1.005647,-0.906843],[2.691286,0.209811,0.050512],[-4.693636,6.477556,0.665796],[-4.472331,6.861067,0.477318],[0.883065,0.204907,3.073933],[-0.995867,8.048729,-0.653897],[-0.794663,5.670397,-0.390119],[3.313153,1.638006,-0.722289],[-4.856459,5.394758,1.032591],[-3.005448,7.783023,-0.819641],[3.11891,2.036974,-1.08689],[-2.364319,2.408419,2.63419],[-2.927132,8.75435,-3.537159],[-3.296222,7.964629,-3.134625],[-1.642041,4.13417,-1.301665],[2.030759,0.176372,-1.030923],[-4.559069,3.751053,0.548453],[3.438385,4.59454,-0.243215],[-2.561769,7.93935,0.177696],[2.990593,1.335314,-0.943177],[1.2808,0.276396,-0.49072],[-0.318889,0.290684,0.211143],[3.54614,3.342635,-0.767878],[-3.073372,7.780018,-2.357807],[-4.455388,4.387245,0.361038],[-4.659393,6.276064,2.767014],[0.636799,4.482223,-1.426284],[-2.987681,8.072969,-2.45245],[-2.610445,0.763554,1.792054],[3.358241,2.006707,-0.802973],[-0.498347,0.251594,0.962885],[3.1322,0.683312,2.038777],[-4.389801,7.493776,0.690247],[0.431467,4.22119,-1.614215],[-4.376181,3.213141,0.273255],[-4.872319,5.715645,0.829714],[-4.826893,6.195334,0.849912],[3.516562,2.23732,-0.677597],[3.131656,1.698841,-0.975761],[-4.754925,5.411666,1.989303],[-2.987299,7.320765,-0.629479],[-3.757635,3.274862,-0.744022],[3.487044,2.541999,-0.699933],[-4.53274,4.649505,0.77093],[-1.424192,0.099423,2.633327],[3.090867,2.476975,-1.146957],[-2.713256,0.815622,2.17311],[3.348121,3.254167,-0.984896],[-3.031379,0.16453,-0.309937],[-0.949757,4.518137,-1.309172],[-0.889509,0.095256,1.288803],[3.539594,1.966105,-0.553965],[-4.60612,7.127749,0.811958],[-2.332953,1.444713,1.624548],[3.136293,2.95805,-1.138272],[3.540808,3.069058,-0.735285],[3.678852,2.362375,-0.452543],[-4.648898,7.37438,0.954791],[-0.646871,0.19037,3.344746],[2.2825,0.29343,-0.826273],[-4.422291,7.183959,0.557517],[-4.694668,5.246103,2.541768],[-4.583691,4.145486,0.600207],[-2.934854,7.912513,-1.539269],[-3.067861,7.817472,-0.546501],[3.825095,3.229512,-0.237547],[2.532494,0.323059,2.387105],[-2.514583,0.692857,1.23597],[-4.736805,7.214384,1.259421],[-2.98071,8.409903,-2.468199],[2.621468,1.385844,-1.406355],[3.811447,3.560855,1.847828],[3.432925,1.497205,-0.489784],[3.746609,3.631538,-0.39067],[3.594909,2.832257,-0.576012],[-0.404192,5.300188,-0.856561],[-4.762996,6.483774,1.702648],[-4.756612,6.786223,1.43682],[-2.965309,8.437217,-2.785495],[2.863867,0.74087,-0.429684],[4.02503,2.968753,1.392419],[3.669036,1.833858,-0.304971],[-2.888864,0.720537,0.778057],[-2.36982,0.979443,1.054447],[-2.959259,8.222303,-2.659724],[-3.467825,7.545739,-2.333445],[2.153426,0.446256,-1.20523],[-3.229807,9.189699,-3.596609],[-3.72486,8.773707,-2.046671],[3.687218,3.297751,-0.523746],[1.381025,0.08815,-1.185668],[-2.796828,7.205622,-0.208783],[3.647194,4.066232,-0.291507],[-4.578376,3.885556,1.52546],[-2.840262,0.63094,1.89499],[-2.429514,0.922118,1.820781],[-4.675079,6.573925,2.423363],[2.806207,4.320188,-1.027372],[-1.289608,0.097241,1.321661],[-3.010731,8.141334,-2.866148],[3.202291,1.235617,-0.549025],[4.094792,2.477519,0.304581],[2.948403,0.966873,-0.664857],[-4.83297,5.920587,2.095461],[-2.169693,7.257277,0.946184],[-1.335807,3.057597,-1.303166],[-1.037877,0.64151,-1.685271],[2.627919,0.089814,0.439074],[3.815794,3.808102,1.730493],[-2.973455,8.433141,-3.08872],[-2.391558,7.331428,1.658264],[-4.333107,4.529978,1.850516],[-4.640293,3.767107,1.168841],[3.600716,4.46931,1.734024],[3.880803,1.730158,-0.172736],[3.814183,4.262372,1.167042],[4.37325,0.829542,1.413729],[2.490447,5.75111,0.011492],[3.460003,4.962436,1.188971],[3.918419,3.814234,1.358271],[-0.807595,8.840504,-0.953711],[3.752855,4.20577,1.57177],[-2.991085,8.816501,-3.244595],[-2.333196,7.128889,1.551985],[3.977718,3.570941,1.25937],[4.360071,0.755579,1.079916],[4.637579,1.027973,1.032567],[-2.317,7.421066,1.329589],[-1.013404,8.293662,-0.7823],[4.548023,1.020644,1.420462],[4.763258,1.266798,1.296203],[4.896,2.073084,1.255213],[4.015005,3.325226,1.093879],[4.94885,1.860936,0.894463],[-2.189645,6.954634,1.270077],[4.887442,1.720992,1.288526],[-3.184068,7.871802,0.956189],[-1.274318,0.839887,-1.224389],[-2.919521,7.84432,0.541629],[-2.994586,7.766102,1.96867],[-3.417504,9.241714,-3.093201],[-3.174563,7.466456,2.473617],[-3.263067,9.069412,-3.003459],[-2.841592,0.529833,2.693434],[-3.611069,9.158804,-2.829871],[-4.642828,5.927526,0.320549],[-3.809308,9.051035,-2.692749],[-2.837582,7.487987,-0.106206],[4.773025,2.330442,1.213899],[4.897435,2.209906,0.966657],[-3.067637,8.164062,-1.12661],[-3.122129,8.08074,-0.899194],[4.571019,2.358113,1.462054],[4.584884,2.454418,0.709466],[-3.661093,7.146581,-0.475948],[4.735131,2.415859,0.933939],[4.207556,2.540018,1.218293],[-3.607595,7.89161,-0.121172],[-1.527952,0.775564,-1.061903],[4.53874,2.503273,1.099583],[-3.938837,7.587988,0.082449],[-4.853582,6.152409,1.787943],[-4.752214,6.247234,2.296873],[4.602935,2.363955,0.488901],[-1.81638,6.365879,0.868272],[0.595467,4.744074,-1.32483],[1.87635,3.511986,-1.842924],[4.330947,2.534326,0.720503],[4.108736,2.750805,0.904552],[-1.890939,8.492628,-0.290768],[-3.504309,6.173058,-0.422804],[-1.611992,6.196732,0.648736],[-3.899149,7.826123,1.088845],[-3.078303,3.008813,-1.035784],[-2.798999,7.844899,1.340061],[-1.248839,5.959105,0.041761],[0.767779,4.337318,3.090817],[-3.831177,7.515605,2.432261],[-1.667528,6.156208,0.365267],[-1.726078,6.237384,1.100059],[-3.972037,4.520832,-0.370756],[-4.40449,7.636357,1.520425],[-1.34506,6.004054,1.293159],[-1.233556,6.049933,0.500651],[-3.696869,7.79732,0.37979],[-3.307798,8.949964,-2.698113],[-1.997295,6.615056,1.103691],[-3.219222,8.336394,-1.150614],[-3.452623,8.31866,-0.9417],[-3.94641,2.990494,2.212592],[-3.250025,8.030414,-0.596097],[-2.02375,1.571333,2.397939],[-3.190358,7.665013,2.268183],[-2.811918,7.618526,2.145587],[-1.005265,5.892303,0.072158],[-0.93721,5.974148,0.906669],[-4.646072,7.492193,1.45312],[-0.252931,1.797654,3.140638],[-1.076064,5.738433,1.695953],[-3.980534,7.744391,1.735791],[-0.721187,5.939396,0.526032],[-0.42818,5.919755,0.229001],[-1.43429,6.11622,0.93863],[-0.985638,5.939683,0.290636],[-4.433836,7.461372,1.966437],[-3.696398,7.844859,1.547325],[-3.390772,7.820186,1.812204],[-2.916787,7.864019,0.804341],[-3.715952,8.037269,-0.591341],[-4.204634,7.72919,1.119866],[-4.592233,5.592883,0.246264],[3.307299,5.061701,1.622917],[-3.515159,7.601467,2.368914],[-3.435742,8.533457,-1.37916],[-0.269421,4.545635,-1.366445],[-2.542124,3.768736,-1.258512],[-3.034003,7.873773,1.256854],[-2.801399,7.856028,1.080137],[3.29354,5.220894,1.081767],[-2.35109,1.299486,1.01206],[-3.232213,7.768136,2.047563],[3.290415,5.217525,0.68019],[-3.415109,7.731034,2.144326],[3.440357,4.962463,0.373387],[3.147346,5.352121,1.386923],[2.847252,5.469051,1.831981],[3.137682,5.410222,1.050188],[3.102694,5.310456,1.676434],[-3.044601,0.39515,1.994084],[2.903647,5.561338,1.518598],[-3.810148,8.093598,-0.889131],[4.234835,0.803054,1.593271],[3.240165,5.228747,0.325955],[3.037452,5.509825,0.817137],[2.635031,5.795187,1.439724],[3.071607,5.318303,0.080142],[2.909167,5.611751,1.155874],[3.044889,5.465928,0.486566],[2.502256,5.770673,1.740054],[-0.067497,0.086416,-1.190239],[2.33326,5.906051,0.138295],[0.65096,4.205423,3.308767],[-2.671137,7.936535,0.432731],[2.14463,5.879214,1.866047],[-4.776469,5.890689,0.561986],[2.72432,5.655145,0.211951],[2.730488,5.751455,0.695894],[2.572682,5.869295,1.152663],[1.906776,5.739123,2.196551],[2.344414,5.999961,0.772922],[-3.377905,7.448708,-1.863251],[2.285149,5.968156,1.459258],[2.385989,5.928974,0.3689],[2.192111,6.087516,0.959901],[2.36372,6.001101,1.074346],[1.972022,6.079603,1.591175],[1.87615,5.976698,1.91554],[-3.824761,9.05372,-2.928615],[2.044704,6.129704,1.263111],[-2.583046,0.849537,2.497344],[-0.078825,2.342205,3.520322],[-0.704686,0.537165,3.397194],[-0.257449,3.235334,3.647545],[-0.332064,1.448284,3.022583],[-2.200146,0.898284,-0.447212],[-2.497508,1.745446,1.829167],[0.30702,4.416315,2.978956],[-3.205197,3.479307,-1.040582],[0.110069,9.347725,-1.563686],[-0.82754,0.883886,3.065838],[-2.017103,1.244785,2.42512],[-0.421091,2.309929,3.153898],[-0.491604,3.796072,3.16245],[2.786955,3.501241,-1.340214],[-3.229055,4.380713,-0.899241],[3.730768,0.76845,1.90312],[-0.561079,2.652382,3.152463],[-3.461471,3.086496,2.662505],[-0.661405,3.446009,3.179939],[-0.915351,0.636755,3.243708],[-2.992964,8.915628,-3.729833],[-0.439627,3.502104,3.42665],[-1.154217,0.883181,2.800835],[-1.736193,1.465474,2.595489],[-0.423928,3.24435,3.548277],[-0.511153,2.871046,3.379749],[-0.675722,2.991756,3.143262],[-1.092602,0.599103,3.090639],[-0.89821,2.836952,2.840023],[-2.658412,0.781376,0.960575],[-2.271455,1.222857,1.330478],[-0.877861,1.111222,2.72263],[-0.306959,2.876987,3.556044],[-3.839274,7.84138,-0.918404],[-0.172094,4.083799,3.141708],[-1.548332,0.2529,2.864655],[-0.217353,4.873911,-1.223104],[-3.384242,3.181056,-0.95579],[-2.731704,0.382421,2.895502],[-1.285037,0.551267,2.947675],[0.077224,4.246579,3.066738],[-0.479979,1.77955,2.860011],[-0.716375,1.224694,2.666751],[-0.54622,3.138255,3.393457],[-2.33413,1.821222,2.124883],[-0.50653,2.037147,2.897465],[2.451291,1.211389,-1.466589],[-3.160047,2.894081,2.724286],[-4.137258,5.433431,3.21201],[0.462896,0.320456,-0.174837],[-0.37458,2.609447,3.379253],[-3.095244,0.256205,2.196446],[-4.197985,5.732991,3.262924],[-0.729747,0.246036,0.497036],[-2.356189,5.062,-0.965619],[-1.609036,0.25962,-1.487367],[-4.074381,6.074061,3.409459],[-3.619304,4.0022,2.65705],[-0.543393,8.742896,-1.056622],[-4.30356,6.858934,2.879642],[-0.716688,2.901831,-2.11202],[1.547362,0.083189,1.138764],[-0.250916,0.275268,1.201344],[-3.778035,3.13624,2.466177],[-4.594316,5.771342,3.01694],[-3.717706,3.442887,2.603344],[-4.311163,5.224669,3.019373],[-0.610389,2.095161,-1.923515],[-3.040086,6.196918,-0.429149],[-3.802695,3.768247,2.545523],[-0.159541,2.043362,3.328549],[-3.744329,4.31785,2.491889],[-3.047939,0.214155,1.873639],[-4.41685,6.113058,3.166774],[-1.165133,0.460692,-1.742134],[-1.371289,4.249996,-1.317935],[-3.447883,0.3521,0.466205],[-4.495555,6.465548,2.944147],[-3.455335,0.171653,0.390816],[-3.964028,4.017196,2.376009],[-1.323595,1.763126,-0.750772],[-3.971142,5.277524,-0.19496],[-3.222052,0.237723,0.872229],[-4.403784,3.89107,1.872077],[-3.333311,0.342997,0.661016],[-4.495871,4.29606,1.63608],[-3.636081,2.760711,2.361949],[-4.487235,3.559608,1.66737],[-4.719787,7.26888,1.658722],[-1.086143,9.035741,-0.707144],[-2.339693,1.600485,-0.404817],[-4.642011,7.123829,1.990987],[-1.498077,3.854035,-1.369787],[-4.188372,4.729363,2.02983],[-3.116344,5.882284,-0.468884],[-4.305236,4.246417,1.976991],[-3.022509,0.22819,1.065688],[-2.799916,0.52022,1.128319],[-4.262823,3.534409,2.020383],[-4.221533,3.947676,2.11735],[-3.744353,4.391712,-0.6193],[-1.272905,0.156694,-1.741753],[-3.62491,2.669825,-0.549664],[-4.180756,3.096179,1.987215],[-4.059276,4.305313,2.232924],[-2.812753,0.183226,1.370267],[-4.032437,3.512234,2.309985],[-0.03787,0.28188,0.530391],[-4.711562,5.468653,2.822838],[-4.500636,6.953314,2.564445],[-4.479433,7.216991,2.270682],[3.990562,0.50522,0.716309],[-2.512229,6.863447,-0.100658],[-2.968058,6.956639,-0.37061],[2.550375,3.142683,-1.54068],[-2.320059,3.521605,-1.279397],[-4.556319,6.64662,2.745363],[-4.281091,7.108116,2.667598],[-2.050095,8.411689,0.121353],[-2.44854,1.135487,0.851875],[3.121815,0.699943,-0.277167],[-4.69877,6.00376,2.843035],[-1.360599,8.824742,-0.595597],[1.128437,0.171611,0.301691],[-4.360146,6.289423,0.042233],[1.400795,4.088829,-1.620409],[-3.193462,8.460137,-3.559446],[-3.168771,8.878431,-3.635795],[-3.434275,9.304302,-3.460878],[-3.349993,8.808093,-3.38179],[-3.304823,8.323865,-3.325905],[-3.572607,9.308843,-3.207672],[-3.166393,8.201215,-3.43014],[-3.451638,9.05331,-3.351345],[-3.309591,8.549758,-3.375055],[-3.527992,8.793926,-3.100376],[-3.6287,8.981677,-3.076319],[-3.445505,8.001887,-2.8273],[-3.408011,8.221014,-3.039237],[-3.65928,8.740382,-2.808856],[-3.878019,8.797295,-2.462866],[-3.515132,8.232341,-2.747739],[-3.460331,8.51524,-3.06818],[-3.403703,7.658628,-2.648789],[-3.507113,8.00159,-2.582275],[-3.607373,8.174737,-2.401723],[-3.749043,8.378084,-2.226959],[-3.648514,8.502213,-2.6138],[-2.534199,0.904753,2.021148],[1.4083,5.744252,-0.571402],[-3.852536,8.571009,-2.352358],[2.868255,5.373126,-0.163705],[2.224363,4.669891,-1.061586],[-4.528281,4.885838,1.340274],[1.30817,4.609629,-1.28762],[-4.519698,3.422501,1.354826],[-3.549955,7.783228,-2.332859],[1.12313,6.120856,0.045115],[-3.620324,7.57716,-2.033423],[-0.798833,2.624133,-1.992682],[-3.617587,7.783148,-2.051383],[-3.669293,8.103776,-2.10227],[-3.892417,8.667436,-2.167288],[-0.537435,0.285345,-0.176267],[-0.841522,3.299866,-1.887861],[-0.761547,3.647082,-1.798953],[-3.661544,7.85708,-1.867924],[-3.886763,8.551783,-1.889171],[-0.591244,1.549749,-1.714784],[-0.775276,1.908218,-1.597609],[-0.961458,2.573273,-1.695549],[-2.215672,1.335009,2.143031],[-4.622674,4.130242,1.220683],[1.07344,0.290099,1.584734],[-0.976906,2.92171,-1.76667],[-1.13696,3.194401,-1.513455],[-3.743262,7.99949,-1.629286],[-2.876359,4.900986,-0.879556],[0.550835,3.905557,-2.031372],[0.777647,4.992314,-1.215703],[1.445881,4.266201,-1.414663],[1.274222,5.510543,-0.824495],[-0.864685,2.318581,-1.702389],[-0.627458,3.820722,-1.743153],[-3.867699,8.30866,-1.850066],[1.635287,5.45587,-0.83844],[-1.037876,2.538589,-1.513504],[-4.38993,4.73926,1.699639],[0.048709,4.765232,-1.279506],[-0.626548,1.339887,-1.595114],[-3.682827,7.643453,-1.723398],[-3.868783,8.180191,-1.511743],[-0.76988,1.508373,-1.419599],[-1.138374,2.766765,-1.448163],[1.699883,5.780752,-0.475361],[1.214305,0.308517,1.866405],[-1.713642,0.373461,-1.265204],[-1.582388,0.58294,-1.267977],[-0.879549,1.821581,-1.313787],[0.519057,5.858757,-0.381397],[-3.770989,2.449208,-0.132655],[0.087576,0.156713,-1.53616],[-0.942622,2.146534,-1.421494],[-1.026192,1.022164,-1.145423],[-0.964079,1.645473,-1.067631],[-1.109128,2.458789,-1.29106],[-1.037478,0.209489,-1.805424],[-3.724391,7.599686,-1.273458],[-3.787898,7.951792,-1.304794],[3.821677,2.165581,-0.181535],[-2.39467,0.304606,-0.570375],[-2.352928,1.0439,2.079369],[-0.288899,9.640684,-1.006079],[-3.472118,7.263001,-1.080326],[-1.240769,0.972352,-0.976446],[-1.845253,0.356801,-0.995574],[-2.32279,7.915361,-0.057477],[-1.08092,2.179315,-1.168821],[4.598833,2.156768,0.280264],[-4.725417,6.442373,2.056809],[-0.490347,9.46429,-0.981092],[-1.99652,0.09737,-0.765828],[-1.137793,1.888846,-0.894165],[-0.37247,4.29661,-1.465199],[-0.184631,5.692946,-0.421398],[-3.751694,7.742231,-1.086908],[-1.001416,1.298225,-0.904674],[-3.536884,7.190777,-0.788609],[-3.737597,7.511281,-0.940052],[-1.766651,0.669388,-0.873054],[3.112245,3.474345,-1.129672],[-0.175504,3.81298,-2.0479],[-3.766762,7.412514,-0.681569],[-0.63375,9.439424,-0.785128],[-0.518199,4.768982,-1.258625],[0.790619,4.212759,-1.610218],[-3.761951,3.742528,-0.756283],[0.897483,5.679808,-0.612423],[2.221126,4.427468,-1.252155],[-0.728577,5.846457,0.062702],[0.194451,9.503908,-1.482461],[-0.099243,9.385459,-1.39564],[0.643185,3.636855,-2.180247],[0.894522,5.900601,-0.356935],[2.595516,4.75731,-0.893245],[1.108497,3.936893,-1.905098],[1.989894,5.789726,-0.343268],[-3.802345,7.655508,-0.613817],[2.339353,4.96257,-0.90308],[0.12564,4.013324,-1.879236],[-4.078965,3.683254,-0.445439],[2.092899,5.256128,-0.831607],[0.427571,0.291769,1.272964],[2.335549,3.480056,-1.581949],[-0.15687,0.324827,-1.648922],[-0.536522,5.760786,-0.203535],[1.507082,0.078251,-0.923109],[-1.854742,0.134826,2.698774],[-3.939827,3.168498,-0.526144],[-3.98461,3.39869,-0.533212],[-3.961738,4.217132,-0.489147],[4.273789,2.181164,0.153786],[-0.470498,5.645664,-0.439079],[-0.414539,5.488017,-0.673379],[-0.097462,5.062739,-1.114863],[1.198092,5.882232,-0.391699],[2.855834,5.085022,-0.498678],[1.037998,4.129757,-1.701811],[1.728091,5.068444,-1.063761],[-3.832258,2.625141,-0.311384],[-4.078526,3.070256,-0.284362],[-4.080365,3.954243,-0.440471],[-0.152578,5.276267,-0.929815],[-1.489635,8.928082,-0.295891],[0.759294,5.15585,-1.087374],[-4.000338,2.801647,-0.235135],[-4.290801,3.823209,-0.19374],[-4.221493,4.25618,-0.189894],[-4.066195,4.71916,-0.201724],[-0.155386,4.076396,-1.662865],[3.054571,4.414305,-0.825985],[-1.652919,8.726499,-0.388504],[-3.042753,0.560068,-0.126425],[-2.434456,1.118088,-0.213563],[-2.623502,1.845062,-0.283697],[-4.233371,3.43941,-0.202918],[2.726702,3.82071,-1.280097],[0.184199,4.14639,-1.673653],[-1.289203,0.624562,-1.560929],[-3.823676,7.382458,-0.407223],[0.476667,5.064419,-1.143742],[-3.873651,4.955112,-0.269389],[1.349666,5.312227,-1.000274],[-2.043776,8.434488,-0.108891],[-2.763964,0.733395,-0.129294],[-4.380505,3.664409,-0.024546],[-0.71211,5.341811,-0.803281],[-3.960858,7.183112,-0.118407],[-3.822277,7.712853,-0.263221],[-2.346808,8.108588,0.063244],[-1.841731,8.642999,-0.142496],[-2.600055,0.985604,-0.043595],[-3.513057,2.213243,-0.044151],[-3.963492,2.603055,-0.080898],[-4.258066,3.14537,-0.027046],[-4.261572,5.00334,0.13004],[0.795464,3.99873,-1.905688],[-3.300873,0.384761,0.013271],[-2.770244,0.881942,0.077313],[-3.456227,1.993871,0.301054],[-4.441987,3.914144,0.177867],[-4.367075,6.611414,0.165312],[-3.201767,0.576292,0.105769],[-3.174354,0.645009,0.440373],[-2.996576,0.74262,0.161325],[-2.724979,1.656497,0.092983],[-3.261757,2.017742,-0.070763],[-4.280173,4.518235,-0.002999],[-4.471073,5.945358,0.05202],[-3.877137,2.40743,0.274928],[-4.371219,4.252758,0.078039],[-3.400914,0.40983,0.238599],[-4.44293,3.523242,0.146339],[-4.574528,5.279761,0.353923],[-4.226643,7.191282,0.269256],[-4.16361,2.843204,0.097727],[-4.528506,5.011661,0.536625],[0.35514,5.664802,-0.572814],[2.508711,5.580976,-0.266636],[2.556226,3.633779,-1.426362],[1.878456,4.533714,-1.223744],[2.460709,4.440241,-1.1395],[2.218589,5.514603,-0.560066],[2.263712,5.737023,-0.250694],[2.964981,3.814858,-1.139927],[0.991384,5.304131,-0.999867],[2.81187,4.547292,-0.916025],[2.918089,4.768382,-0.702808],[3.262403,4.414286,-0.657935],[0.652136,6.089113,0.069089],[3.361389,3.5052,-0.946123],[2.613042,5.037192,-0.697153],[0.094339,4.36858,-1.451238],[3.290862,4.155716,-0.732318],[2.658063,4.073614,-1.217455],[3.260349,3.753257,-0.946819],[1.124268,4.862463,-1.207855],[3.35158,4.899247,-0.027586],[3.194057,4.691257,-0.524566],[3.090119,5.116085,-0.23255],[2.418965,3.811753,-1.419399],[2.191789,3.877038,-1.47023],[4.043166,2.034188,0.015477],[-1.026966,0.86766,-1.410912],[1.937563,3.860005,-1.617465],[2.98904,4.101806,-0.998132],[-0.142611,5.865305,-0.100872],[3.972673,2.292069,0.089463],[3.23349,3.959925,-0.849829],[0.16304,5.857276,-0.216704],[4.122964,1.770061,-0.114906],[2.099057,4.978374,-0.98449],[3.502411,3.76181,-0.667502],[2.079484,5.939614,-0.036205],[-0.084568,3.525193,-2.253506],[0.423859,4.06095,-1.845327],[1.6013,6.006466,-0.153429],[0.271701,3.844964,-2.078748],[0.273577,5.218904,-0.994711],[-0.410578,3.92165,-1.773635],[1.941954,5.60041,-0.621569],[0.100825,5.462131,-0.774256],[-0.53016,3.619892,-2.027451],[-0.822371,5.517453,-0.605747],[-2.474925,7.670892,-0.020174],[4.01571,0.830194,-0.013793],[-0.400092,5.094112,-1.041992],[-2.887284,5.581246,-0.525324],[-1.559841,6.050972,0.079301],[-0.469317,3.291673,-2.235211],[0.337397,3.467926,-2.295458],[-2.632074,5.573701,-0.582717],[-0.030318,6.011395,0.276616],[-0.934373,0.388987,-1.780523],[-2.661263,5.844838,-0.425966],[0.549353,5.489646,-0.807268],[-2.194355,6.197491,-0.109322],[-2.289618,5.664813,-0.581098],[1.583583,3.796366,-1.844498],[0.855295,0.215979,-1.425557],[-2.627569,5.300236,-0.767174],[4.333347,2.384332,0.399129],[-1.880401,5.583843,-0.696561],[-2.172346,5.324859,-0.846246],[-2.27058,5.906265,-0.388373],[-1.960049,5.889346,-0.397593],[0.965756,3.67547,-2.105671],[-2.014066,6.431125,0.287254],[-1.776173,5.287097,-0.89091],[-2.025852,5.089562,-0.980218],[-1.886418,6.108358,-0.000667],[-1.600803,5.785347,-0.491069],[-1.66188,4.968053,-1.042535],[-1.600621,5.962818,-0.188044],[-1.588831,5.615418,-0.665456],[4.46901,1.880138,0.057248],[-1.978845,0.927399,-0.554856],[-1.408074,5.325266,-0.83967],[1.923123,4.843955,-1.101389],[-2.87378,0.117106,-0.412735],[-1.222193,5.62638,-0.539981],[-2.632537,0.166349,-0.489218],[-1.370865,5.838832,-0.341026],[-1.067742,5.448874,-0.692701],[-1.073798,5.220878,-0.908779],[-1.147562,4.950417,-1.079727],[-2.789115,4.531047,-1.042713],[-3.550826,4.170487,-0.806058],[-3.331694,4.798177,-0.69568],[-3.689404,4.688543,-0.534317],[-3.511509,5.106246,-0.483632],[1.796344,0.076137,0.080455],[-3.306354,5.473605,-0.478764],[-2.692503,3.346604,-1.20959],[-3.963056,5.187462,3.113156],[-3.901231,6.391477,-0.246984],[4.484234,1.518638,-0.001617],[4.308829,1.657716,-0.119275],[4.290045,1.339528,-0.110626],[-3.514938,3.524974,-0.909109],[-2.1943,2.12163,-0.71966],[4.108206,1.091087,-0.11416],[3.785312,1.392435,-0.28588],[4.092886,1.480476,-0.210655],[-2.965937,6.469006,-0.379085],[-3.708581,2.962974,-0.63979],[-3.297971,2.218917,-0.299872],[3.806949,0.804703,-0.11438],[3.747957,1.059258,-0.273069],[-3.101827,4.111444,-1.006255],[-1.536445,4.658913,-1.195049],[-3.549826,2.450555,-0.375694],[-3.676495,2.108366,0.534323],[-3.674738,5.925075,-0.400011],[-2.250115,2.848335,-1.121174],[-3.698062,5.667567,-0.381396],[3.468966,0.734643,-0.190624],[-3.97972,5.670078,-0.26874],[-3.002087,4.337837,-1.033421],[-3.356392,2.608308,-0.713323],[-1.833016,3.359983,-1.28775],[-1.989069,3.632416,-1.305607],[3.591254,0.542371,0.026146],[3.364927,1.082572,-0.342613],[-3.393759,3.866801,-0.937266],[-4.124865,5.549529,-0.161729],[-4.423423,5.687223,0.000103],[-1.496881,2.601785,-1.114328],[-2.642297,6.496932,-0.264175],[-3.684236,6.819423,-0.320233],[-2.286996,3.167067,-1.246651],[-1.624896,8.44848,-0.530014],[-3.666787,2.159266,0.268149],[-2.402625,2.011243,-0.56446],[-2.736166,2.259839,-0.6943],[-2.168611,3.89078,-1.292206],[-2.065956,3.345708,-1.281346],[-2.778147,2.675605,-0.995706],[-3.507431,4.513272,-0.71829],[-2.301184,4.293911,-1.238182],[3.205808,0.211078,0.394349],[-2.129936,4.870577,-1.080781],[-2.287977,2.496593,-0.934069],[-2.701833,2.931814,-1.114509],[3.294795,0.50631,-0.081062],[-2.552829,7.468771,-0.021541],[3.06721,0.944066,-0.43074],[-2.86086,1.973622,-0.303132],[-3.598818,5.419613,-0.401645],[-1.524381,0.080156,-1.61662],[-1.907291,2.646274,-1.039438],[2.950783,0.407562,-0.105407],[-1.663048,1.655038,-0.689787],[-1.728102,1.110064,-0.635963],[-2.085823,7.686296,-0.159745],[2.883518,3.157009,-1.30858],[-2.724116,0.417169,-0.389719],[-1.788636,7.862672,-0.346413],[-2.186418,1.249609,-0.434583],[-3.092434,2.606657,-0.860002],[-1.737314,3.874201,-1.330986],[2.564522,0.422967,-0.390903],[1.670782,3.538432,-1.924753],[-2.338131,4.02578,-1.286673],[-1.916516,4.054121,-1.301788],[2.87159,2.034949,-1.267139],[-1.931518,3.062883,-1.197227],[-0.816602,0.135682,3.104104],[0.469392,0.213916,-1.489608],[2.574055,1.950091,-1.514427],[2.733595,2.682546,-1.461213],[-1.915407,4.693647,-1.151721],[-3.412883,5.867094,-0.450528],[2.28822,0.120432,-0.04102],[2.244477,0.14424,-0.376933],[-1.676198,3.570698,-1.328031],[-1.821193,4.366982,-1.266271],[-1.552208,8.099221,-0.53262],[-1.727419,2.39097,-0.989456],[-2.468226,4.711663,-1.069766],[-2.451669,6.113319,-0.273788],[2.635447,2.295842,-1.518361],[-2.020809,8.150253,-0.246714],[2.292455,0.805596,-1.3042],[2.641556,1.65665,-1.466962],[2.409062,2.842538,-1.635025],[2.456682,1.459484,-1.57543],[-1.691047,3.173582,-1.247082],[-1.865642,1.957608,-0.768683],[-3.401579,0.20407,0.100932],[2.301981,1.7102,-1.650461],[2.342929,2.611944,-1.690713],[-1.676111,2.923894,-1.17835],[-2.992039,3.547631,-1.118945],[-3.571677,6.504634,-0.375455],[2.141764,1.460869,-1.702464],[-3.221958,5.146049,-0.615632],[2.19238,2.949367,-1.747242],[2.320791,2.232971,-1.706842],[2.088678,2.585235,-1.813159],[-2.196404,0.592218,-0.569709],[-2.120811,1.836483,-0.62338],[-1.949935,2.271249,-0.874128],[2.235901,1.110183,-1.510719],[2.020157,3.241128,-1.803917],[2.054336,1.949394,-1.792332],[-3.094117,4.996595,-0.740238],[2.038063,0.635949,-1.402041],[1.980644,1.684408,-1.76778],[1.587432,3.306542,-1.991131],[1.935322,0.976267,-1.602208],[1.922621,1.235522,-1.698813],[1.712495,1.911874,-1.903234],[1.912802,2.259273,-1.888698],[1.884367,0.355453,-1.312633],[1.676427,0.76283,-1.539455],[1.78453,2.83662,-1.943035],[1.697312,0.120281,-1.150324],[1.648318,2.484973,-1.999505],[-4.051804,5.958472,-0.231731],[-1.964823,1.464607,-0.58115],[1.55996,2.183486,-1.971378],[1.628125,1.045912,-1.707832],[1.701684,1.540428,-1.827156],[1.567475,4.869481,-1.184665],[1.432492,0.843779,-1.648083],[1.173837,2.978983,-2.156687],[1.235287,3.37975,-2.09515],[1.252589,1.525293,-1.949205],[1.159334,2.336379,-2.105361],[1.49061,2.695263,-2.083216],[-4.122486,6.782604,-0.02545],[1.173388,0.279193,-1.423418],[1.505684,0.380815,-1.414395],[1.391423,1.343031,-1.843557],[1.263449,2.73225,-2.144961],[1.295858,0.597122,-1.515628],[1.245851,3.729126,-1.993015],[-2.761439,6.23717,-0.365856],[0.978887,1.664888,-2.046633],[1.219542,0.982729,-1.785486],[1.315915,1.91748,-2.02788],[-3.052746,2.127222,-0.369082],[0.977656,1.36223,-1.944119],[0.936122,3.39447,-2.203007],[-2.740036,4.184702,-1.122849],[0.853581,2.864694,-2.260847],[0.719569,0.818762,-1.763618],[0.839115,1.159359,-1.907943],[0.932069,1.94559,-2.117962],[0.579321,3.326747,-2.299369],[0.86324,0.597822,-1.565106],[0.574567,1.158452,-1.943123],[0.525138,2.137252,-2.213867],[0.779941,2.342019,-2.206157],[0.915255,2.618102,-2.209041],[0.526426,3.02241,-2.321826],[0.495431,2.521396,-2.295905],[0.80799,3.156817,-2.286432],[0.273556,1.304936,-2.012509],[0.664326,1.530024,-2.048722],[0.219173,2.32907,-2.323212],[0.405324,0.695359,-1.704884],[0.398827,0.946649,-1.843899],[0.345109,1.608829,-2.100174],[-2.356743,0.062032,-0.4947],[-3.001084,0.27146,2.560034],[-2.064663,0.303055,-0.697324],[0.221271,3.174023,-2.374399],[0.195842,0.437865,-1.621473],[-0.385613,0.297763,1.960096],[1.999609,0.108928,-0.79125],[0.351698,9.227494,-1.57565],[0.021477,2.191913,-2.309353],[0.246381,2.836575,-2.356365],[1.543281,0.237539,1.901906],[0.031881,9.147022,-1.454203],[-0.001881,1.648503,-2.108044],[0.333423,1.907088,-2.204533],[0.044063,2.634032,-2.368412],[-0.028148,3.053684,-2.390082],[0.02413,3.34297,-2.36544],[-0.272645,9.02879,-1.238685],[-0.006348,0.832044,-1.758222],[-0.321105,1.458754,-1.886313],[-0.153948,8.618809,-1.105353],[-0.409303,1.137783,-1.720556],[-0.410054,1.742789,-1.957989],[-0.287905,2.380404,-2.294509],[-0.261375,2.646629,-2.356322],[-0.221986,3.215303,-2.345844],[-0.31608,0.687581,-1.71901],[-0.537705,0.855802,-1.648585],[-0.142834,1.193053,-1.87371],[-0.24371,2.044435,-2.176958],[-0.437999,2.959748,-2.299698],[-0.78895,0.176226,-1.729046],[-0.608509,0.546932,-1.734032],[-0.693698,4.478782,-1.369372],[-0.669153,8.469645,-0.911149],[-0.741857,1.082705,-1.458474],[-0.554059,2.440325,-2.141785],[2.09261,0.153182,2.57581],[1.792547,0.111794,2.563777],[1.855787,0.189541,2.835089],[1.492601,0.232246,2.987681],[-0.284918,0.236687,3.429738],[2.604841,0.11997,1.01506],[0.331271,0.168113,3.124031],[0.280606,0.308368,2.495937],[0.544591,0.325711,2.081274],[0.193145,0.19154,-0.977556],[3.810099,0.42324,1.032202],[3.54622,0.379245,1.392814],[0.61402,0.276328,0.849356],[-1.198628,0.144953,2.911457],[4.17199,0.68037,1.391526],[0.88279,0.321339,2.059129],[1.93035,0.109992,2.054154],[1.620331,0.121986,2.37203],[2.374812,0.10921,1.734876],[-0.031227,0.294412,2.593687],[4.075018,0.561914,1.038065],[-0.570366,0.126583,2.975558],[0.950052,0.318463,1.804012],[1.130034,0.117125,0.98385],[2.123049,0.08946,1.665911],[2.087572,0.068621,0.335013],[2.927337,0.167117,0.289611],[0.528876,0.313434,3.205969],[1.174911,0.162744,1.328262],[-4.88844,5.59535,1.661134],[-4.709607,5.165338,1.324082],[0.871199,0.277021,1.263831],[-3.910877,2.349318,1.272269],[1.56824,0.118605,2.768112],[1.179176,0.152617,-0.858003],[1.634629,0.247872,2.128625],[-4.627425,5.126935,1.617836],[3.845542,0.54907,1.45601],[2.654006,0.165508,1.637169],[-0.678324,0.26488,1.974741],[2.451139,0.100377,0.213768],[0.633199,0.286719,0.403357],[-0.533042,0.2524,1.373267],[0.99317,0.171106,0.624966],[-0.100063,0.306466,2.170225],[1.245943,0.092351,0.661031],[1.390414,0.198996,-0.0864],[-4.457265,5.030531,2.138242],[2.89776,0.146575,1.297468],[1.802703,0.088824,-0.490405],[1.055447,0.309261,2.392437],[2.300436,0.142429,2.104254],[2.33399,0.187756,2.416935],[2.325183,0.134349,0.574063],[2.410924,0.370971,2.637115],[1.132924,0.290511,3.061],[1.764028,0.070212,-0.80535],[2.156994,0.397657,2.844061],[0.920711,0.225527,-0.882456],[-4.552135,5.24096,2.85514],[0.210016,0.309396,2.064296],[0.612067,0.136815,-1.086002],[3.150236,0.426757,1.802703],[-0.24824,0.282258,1.470997],[0.974269,0.301311,-0.640898],[-4.401413,5.03966,2.535553],[0.644319,0.274006,-0.817806],[0.332922,0.309077,0.108474],[3.610001,0.317447,0.689353],[3.335681,0.358195,0.118477],[0.623544,0.318983,-0.4193],[-0.11012,0.307747,1.831331],[-0.407528,0.291044,2.282935],[0.069783,0.285095,0.950289],[0.970135,0.310392,-0.283742],[0.840564,0.306898,0.098854],[-0.541827,0.267753,1.683795],[-3.956082,4.55713,2.297164],[-4.161036,2.834481,1.64183],[-4.093952,4.977551,2.747747],[2.661819,0.261867,1.926145],[-3.749926,2.161875,0.895238],[-2.497776,1.3629,0.791855],[0.691482,0.304968,1.582939],[-4.013193,4.830963,2.4769],[-3.639585,2.091265,1.304415],[-3.9767,2.563053,1.6284],[-3.979915,2.788616,1.977977],[0.388782,0.312656,1.709168],[-3.40873,1.877324,0.851652],[-3.671637,5.136974,3.170734],[-3.12964,1.852012,0.157682],[-3.629687,4.852698,2.686837],[-3.196164,1.793459,0.452804],[-3.746338,2.31357,1.648551],[2.992192,0.125251,0.575976],[-3.254051,0.054431,0.314152],[-3.474644,1.925288,1.134116],[-3.418372,2.022882,1.578901],[-2.920955,1.705403,0.29842],[-3.57229,2.152022,1.607572],[-3.251259,0.09013,-0.106174],[-3.299952,1.877781,1.348623],[-3.666819,2.441459,2.004838],[-2.912646,1.824748,-0.045348],[-3.399511,2.479484,2.340393],[-3.009754,0.015286,0.075567],[-3.381443,2.316937,2.156923],[-3.352801,2.133341,1.857366],[-3.01788,1.687685,0.645867],[-2.931857,1.678712,1.158472],[-3.301008,0.08836,0.591001],[1.358025,0.19795,1.599144],[-2.999565,1.845016,1.618396],[-2.767957,0.028397,-0.196436],[-2.93962,2.078779,2.140593],[-3.346648,2.674056,2.518097],[3.324322,0.20822,0.628605],[3.091677,0.137202,0.9345],[-2.881807,0.009952,0.318439],[-2.764946,1.786619,1.693439],[-2.905542,1.932343,1.900002],[-3.140854,2.271384,2.274946],[-2.88995,2.487856,2.574759],[-2.367194,-0.000943,-0.15576],[-3.050738,0.068703,0.742988],[-2.759525,1.55679,0.877782],[-3.151775,2.48054,2.482749],[-2.578618,-0.002885,0.165716],[-2.651618,1.877246,1.981189],[-2.933973,0.133731,1.631023],[1.047628,0.100284,-1.085248],[-1.585123,0.062083,-1.394896],[-2.287917,-0.002671,0.214434],[-2.524899,0.007481,0.471788],[-2.815492,2.188198,2.343294],[-2.095142,-0.003149,-0.094574],[-2.172686,-0.000133,0.47963],[-2.732704,0.074306,1.742079],[-2.49653,2.145668,2.42691],[-1.343683,0.047721,-1.506391],[-2.581185,0.048703,0.975528],[-2.905101,0.083158,2.010052],[-2.601514,2.007801,2.223089],[-2.339464,0.02634,1.484304],[-2.907873,0.10367,2.378149],[-1.368796,0.062516,-1.049125],[-1.93244,0.02443,-0.427603],[-2.705081,0.060513,2.303802],[3.372155,0.206274,0.892293],[-1.761827,0.093202,-1.037404],[-1.700667,0.0397,-0.614221],[-1.872291,0.011979,-0.135753],[-1.929257,0.074005,0.728999],[-2.520128,0.049665,1.99054],[-2.699411,0.10092,2.603116],[3.211701,0.27302,1.423357],[-1.445362,0.1371,-0.626491],[2.921332,0.259112,1.645525],[-0.993242,0.058686,-1.408916],[-0.944986,0.157541,-1.097665],[-2.154301,0.032749,1.882001],[-2.108789,1.988557,2.442673],[-1.015659,0.25497,-0.416665],[-1.898411,0.015872,0.16715],[-1.585517,0.027121,0.453445],[-2.311105,0.061264,2.327061],[-2.637042,0.152224,2.832201],[-2.087515,2.292972,2.617585],[-0.750611,0.056697,-1.504516],[-0.472029,0.075654,-1.360203],[-0.710798,0.139244,-1.183863],[-0.97755,0.26052,-0.831167],[-0.655814,0.260843,-0.880068],[-0.897513,0.275537,-0.133042],[-2.049194,0.084947,2.455422],[-0.177837,0.076362,-1.449009],[-0.553393,0.279083,-0.59573],[-1.788636,0.06163,2.231198],[-0.34761,0.255578,-0.999614],[-1.398589,0.036482,0.65871],[-1.133918,0.05617,0.69473],[-1.43369,0.058226,1.977865],[-2.505459,1.492266,1.19295]];
bunny.cells=[[2,1661,3],[1676,7,6],[712,1694,9],[3,1674,1662],[11,1672,0],[1705,0,1],[5,6,1674],[4,5,1674],[7,8,712],[2,1662,10],[1,10,1705],[11,1690,1672],[1705,11,0],[5,1676,6],[7,9,6],[7,712,9],[2,3,1662],[3,4,1674],[1,2,10],[12,82,1837],[1808,12,1799],[1808,1799,1796],[12,861,82],[861,1808,13],[1808,861,12],[1799,12,1816],[1680,14,1444],[15,17,16],[14,1678,1700],[16,17,1679],[15,1660,17],[14,1084,1678],[15,1708,18],[15,18,1660],[1680,1084,14],[1680,15,1084],[15,1680,1708],[793,813,119],[1076,793,119],[1076,1836,22],[23,19,20],[21,1076,22],[21,22,23],[23,20,21],[1076,119,1836],[806,634,470],[432,1349,806],[251,42,125],[809,1171,791],[953,631,827],[634,1210,1176],[157,1832,1834],[56,219,53],[126,38,83],[37,85,43],[59,1151,1154],[83,75,41],[77,85,138],[201,948,46],[1362,36,37],[452,775,885],[1237,95,104],[966,963,1262],[85,77,43],[36,85,37],[1018,439,1019],[41,225,481],[85,83,127],[93,83,41],[935,972,962],[116,93,100],[98,82,813],[41,75,225],[298,751,54],[1021,415,1018],[77,138,128],[766,823,1347],[593,121,573],[905,885,667],[786,744,747],[100,41,107],[604,334,765],[779,450,825],[968,962,969],[225,365,481],[365,283,196],[161,160,303],[875,399,158],[328,1817,954],[62,61,1079],[358,81,72],[74,211,133],[160,161,138],[91,62,1079],[167,56,1405],[56,167,219],[913,914,48],[344,57,102],[43,77,128],[1075,97,1079],[389,882,887],[219,108,53],[1242,859,120],[604,840,618],[754,87,762],[197,36,1362],[1439,88,1200],[1652,304,89],[81,44,940],[445,463,151],[717,520,92],[129,116,100],[1666,1811,624],[1079,97,91],[62,91,71],[688,898,526],[463,74,133],[278,826,99],[961,372,42],[799,94,1007],[100,93,41],[1314,943,1301],[184,230,109],[875,1195,231],[133,176,189],[751,755,826],[101,102,57],[1198,513,117],[748,518,97],[1145,1484,1304],[358,658,81],[971,672,993],[445,151,456],[252,621,122],[36,271,126],[85,36,126],[116,83,93],[141,171,1747],[1081,883,103],[1398,1454,149],[457,121,593],[127,116,303],[697,70,891],[457,891,1652],[1058,1668,112],[518,130,97],[214,319,131],[185,1451,1449],[463,133,516],[1428,123,177],[113,862,561],[215,248,136],[186,42,251],[127,83,116],[160,85,127],[162,129,140],[154,169,1080],[169,170,1080],[210,174,166],[1529,1492,1524],[450,875,231],[399,875,450],[171,141,170],[113,1155,452],[131,319,360],[44,175,904],[452,872,113],[746,754,407],[147,149,150],[309,390,1148],[53,186,283],[757,158,797],[303,129,162],[429,303,162],[154,168,169],[673,164,193],[38,271,75],[320,288,1022],[246,476,173],[175,548,904],[182,728,456],[199,170,169],[168,199,169],[199,171,170],[184,238,230],[246,247,180],[1496,1483,1467],[147,150,148],[828,472,445],[53,108,186],[56,53,271],[186,961,42],[1342,391,57],[1664,157,1834],[1070,204,178],[178,204,179],[285,215,295],[692,55,360],[192,193,286],[359,673,209],[586,195,653],[121,89,573],[202,171,199],[238,515,311],[174,210,240],[174,105,166],[717,276,595],[1155,1149,452],[1405,56,197],[53,283,30],[75,53,30],[45,235,1651],[210,166,490],[181,193,192],[185,620,217],[26,798,759],[1070,226,204],[220,187,179],[220,168,187],[202,222,171],[359,209,181],[182,456,736],[964,167,1405],[76,250,414],[807,1280,1833],[70,883,1652],[227,179,204],[221,199,168],[221,202,199],[360,494,131],[214,241,319],[105,247,166],[205,203,260],[388,480,939],[482,855,211],[8,807,1833],[226,255,204],[228,221,168],[166,173,490],[701,369,702],[211,855,262],[631,920,630],[1448,1147,1584],[255,227,204],[237,220,179],[228,168,220],[222,256,555],[215,259,279],[126,271,38],[108,50,186],[227,236,179],[236,237,179],[220,237,228],[228,202,221],[256,222,202],[555,256,229],[259,152,279],[27,1296,31],[186,50,961],[961,234,372],[1651,235,812],[1572,1147,1448],[255,226,1778],[255,236,227],[256,257,229],[106,184,109],[241,410,188],[177,578,620],[209,673,181],[1136,1457,79],[1507,245,718],[255,273,236],[275,410,241],[206,851,250],[1459,253,1595],[1406,677,1650],[228,274,202],[202,281,256],[348,239,496],[205,172,203],[369,248,702],[261,550,218],[261,465,550],[574,243,566],[921,900,1220],[291,273,255],[348,238,265],[109,230,194],[149,380,323],[443,270,421],[272,291,255],[274,228,237],[274,292,202],[281,257,256],[276,543,341],[152,259,275],[1111,831,249],[632,556,364],[299,273,291],[299,236,273],[280,237,236],[202,292,281],[247,246,173],[282,49,66],[1620,1233,1553],[299,280,236],[280,305,237],[237,305,274],[306,292,274],[330,257,281],[246,194,264],[166,247,173],[912,894,896],[611,320,244],[1154,1020,907],[969,962,290],[272,299,291],[305,318,274],[145,212,240],[164,248,285],[259,277,275],[193,164,295],[269,240,210],[1033,288,320],[46,948,206],[336,280,299],[330,281,292],[257,307,300],[369,136,248],[145,240,269],[502,84,465],[193,295,286],[164,285,295],[282,302,49],[161,303,429],[318,306,274],[306,330,292],[315,257,330],[315,307,257],[307,352,300],[300,352,308],[275,277,403],[353,1141,333],[1420,425,47],[611,313,320],[85,126,83],[128,1180,43],[303,116,129],[280,314,305],[314,318,305],[190,181,242],[203,214,131],[820,795,815],[322,299,272],[322,336,299],[315,339,307],[172,152,617],[172,214,203],[321,1033,320],[1401,941,946],[85,160,138],[976,454,951],[747,60,786],[317,322,272],[339,352,307],[266,33,867],[163,224,218],[247,614,180],[648,639,553],[388,172,205],[611,345,313],[313,345,320],[160,127,303],[454,672,951],[317,329,322],[314,280,336],[306,338,330],[330,339,315],[1236,115,436],[342,321,320],[1046,355,328],[328,346,325],[325,346,317],[367,314,336],[314,337,318],[337,306,318],[338,343,330],[342,320,345],[355,349,328],[346,329,317],[347,336,322],[314,362,337],[330,343,339],[340,308,352],[135,906,1022],[239,156,491],[194,230,486],[40,1015,1003],[321,355,1046],[329,382,322],[382,347,322],[347,367,336],[337,371,306],[306,371,338],[1681,296,1493],[286,172,388],[230,348,486],[348,183,486],[384,332,830],[328,349,346],[367,362,314],[371,343,338],[339,351,352],[57,344,78],[342,355,321],[386,346,349],[386,350,346],[346,350,329],[347,366,367],[343,363,339],[323,380,324],[152,275,241],[345,1045,342],[350,374,329],[339,363,351],[234,340,352],[353,361,354],[40,34,1015],[373,355,342],[373,349,355],[374,382,329],[366,347,382],[371,363,343],[351,379,352],[379,372,352],[372,234,352],[156,190,491],[319,241,692],[354,361,31],[366,377,367],[363,379,351],[133,590,516],[197,56,271],[1045,370,342],[370,373,342],[374,350,386],[377,366,382],[367,395,362],[400,337,362],[400,371,337],[378,363,371],[106,109,614],[181,673,193],[953,920,631],[376,349,373],[376,386,349],[378,379,363],[224,375,218],[279,152,172],[361,619,381],[1347,823,795],[760,857,384],[392,374,386],[394,395,367],[383,371,400],[383,378,371],[218,375,261],[197,271,36],[414,454,976],[385,376,373],[1051,382,374],[387,394,367],[377,387,367],[395,400,362],[279,172,295],[30,365,225],[450,231,825],[385,373,370],[398,374,392],[1051,377,382],[396,378,383],[348,496,183],[295,172,286],[357,269,495],[1148,390,1411],[75,30,225],[206,76,54],[412,386,376],[412,392,386],[396,383,400],[651,114,878],[123,1241,506],[238,311,265],[381,653,29],[618,815,334],[427,1032,411],[298,414,976],[791,332,384],[129,100,140],[412,404,392],[392,404,398],[140,107,360],[395,394,400],[423,379,378],[385,412,376],[406,94,58],[419,415,1021],[422,423,378],[423,125,379],[258,508,238],[311,156,265],[213,287,491],[449,411,1024],[412,1068,404],[55,140,360],[76,414,54],[394,416,400],[400,416,396],[422,378,396],[1258,796,789],[427,411,449],[427,297,1032],[1385,1366,483],[417,448,284],[1507,341,245],[162,140,444],[658,44,81],[433,125,423],[438,251,125],[429,162,439],[1342,57,1348],[765,766,442],[697,891,695],[1057,396,416],[440,423,422],[440,433,423],[433,438,125],[438,196,251],[74,482,211],[1136,79,144],[29,195,424],[242,1004,492],[57,757,28],[414,298,54],[238,348,230],[224,163,124],[295,215,279],[495,269,490],[449,446,427],[446,297,427],[1020,1163,909],[128,138,419],[66,980,443],[415,439,1018],[111,396,1057],[111,422,396],[840,249,831],[593,664,596],[218,550,155],[109,194,180],[483,268,855],[161,415,419],[1737,232,428],[360,107,494],[1006,1011,410],[444,140,55],[919,843,430],[190,242,213],[275,403,410],[131,494,488],[449,663,446],[138,161,419],[128,419,34],[439,162,444],[460,440,422],[440,438,433],[472,74,445],[491,190,213],[238,508,515],[46,206,54],[972,944,962],[1241,1428,1284],[111,460,422],[470,432,806],[248,164,702],[1025,467,453],[553,1235,648],[263,114,881],[267,293,896],[469,438,440],[455,196,438],[287,242,492],[239,265,156],[213,242,287],[1684,746,63],[663,474,446],[415,161,429],[140,100,107],[1055,459,467],[469,455,438],[259,542,277],[446,474,466],[446,466,447],[439,444,1019],[614,109,180],[190,359,181],[156,497,190],[726,474,663],[1023,458,459],[461,440,460],[269,210,490],[246,180,194],[590,133,189],[163,218,155],[467,468,453],[1063,1029,111],[111,1029,460],[1029,464,460],[461,469,440],[150,149,323],[828,445,456],[375,502,261],[474,475,466],[573,426,462],[478,1023,477],[478,458,1023],[458,479,467],[459,458,467],[468,393,453],[464,461,460],[484,365,455],[1232,182,1380],[172,617,214],[547,694,277],[542,547,277],[184,258,238],[261,502,465],[467,479,468],[484,455,469],[1380,182,864],[475,476,466],[80,447,476],[466,476,447],[415,429,439],[479,487,468],[487,287,468],[492,393,468],[260,469,461],[481,365,484],[531,473,931],[692,360,319],[726,495,474],[468,287,492],[480,464,1029],[260,461,464],[494,481,484],[74,472,482],[174,240,212],[223,106,614],[486,477,485],[478,496,458],[491,487,479],[123,402,177],[488,469,260],[488,484,469],[265,239,348],[248,215,285],[474,490,475],[477,486,478],[458,496,479],[239,491,479],[1584,1147,1334],[488,494,484],[401,123,506],[495,490,474],[490,173,475],[80,476,264],[491,287,487],[480,1029,1004],[480,205,464],[173,476,475],[485,194,486],[486,183,478],[478,183,496],[496,239,479],[848,1166,60],[268,262,855],[205,260,464],[260,203,488],[203,131,488],[246,264,476],[194,485,264],[1002,310,1664],[311,515,497],[515,359,497],[565,359,515],[1250,1236,301],[736,456,151],[654,174,567],[577,534,648],[519,505,645],[725,565,508],[150,1723,148],[584,502,505],[584,526,502],[502,526,84],[607,191,682],[560,499,660],[607,517,191],[1038,711,124],[951,672,971],[716,507,356],[868,513,1198],[615,794,608],[682,191,174],[1313,928,1211],[617,241,214],[511,71,91],[408,800,792],[192,286,525],[80,485,447],[91,97,130],[1675,324,888],[207,756,532],[582,1097,1124],[311,497,156],[510,130,146],[523,511,510],[608,708,616],[546,690,650],[511,527,358],[536,146,518],[465,418,550],[418,709,735],[520,514,500],[584,505,519],[536,518,509],[146,536,510],[538,527,511],[876,263,669],[646,524,605],[510,536,523],[527,175,358],[724,876,669],[721,724,674],[524,683,834],[558,509,522],[558,536,509],[523,538,511],[611,243,574],[528,706,556],[668,541,498],[523,537,538],[527,540,175],[532,756,533],[1013,60,747],[551,698,699],[92,520,500],[535,536,558],[536,569,523],[538,540,527],[539,548,175],[567,212,145],[401,896,293],[534,675,639],[1510,595,1507],[557,545,530],[569,536,535],[537,540,538],[540,539,175],[569,537,523],[1135,718,47],[587,681,626],[580,535,558],[99,747,278],[701,565,725],[665,132,514],[665,514,575],[132,549,653],[176,651,189],[65,47,266],[597,569,535],[569,581,537],[537,581,540],[563,539,540],[539,564,548],[1509,1233,1434],[132,653,740],[550,710,155],[714,721,644],[410,1011,188],[732,534,586],[560,562,729],[555,557,222],[580,558,545],[597,535,580],[581,563,540],[5,821,1676],[576,215,136],[649,457,741],[564,539,563],[124,711,224],[550,668,710],[550,541,668],[565,701,673],[560,613,499],[233,532,625],[545,555,580],[601,581,569],[594,904,548],[1463,1425,434],[185,149,1454],[721,674,644],[185,380,149],[577,424,586],[462,586,559],[597,601,569],[594,548,564],[566,603,574],[165,543,544],[457,89,121],[586,424,195],[725,587,606],[1078,582,1124],[588,925,866],[462,559,593],[189,878,590],[555,229,580],[602,563,581],[904,594,956],[434,1425,1438],[1024,112,821],[572,587,626],[600,597,580],[599,591,656],[600,580,229],[601,622,581],[581,622,602],[602,564,563],[602,594,564],[603,611,574],[498,529,546],[697,1145,70],[592,628,626],[610,597,600],[597,610,601],[222,557,171],[604,765,799],[573,462,593],[133,200,176],[729,607,627],[1011,692,188],[518,146,130],[585,687,609],[682,627,607],[1712,599,656],[562,592,607],[643,656,654],[257,600,229],[601,633,622],[623,594,602],[174,212,567],[725,606,701],[609,701,606],[610,633,601],[633,642,622],[380,216,324],[142,143,1249],[501,732,586],[534,577,586],[648,1235,577],[610,641,633],[310,1002,1831],[618,334,604],[1710,145,269],[707,498,659],[501,586,462],[625,501,462],[726,663,691],[300,600,257],[641,610,600],[622,629,602],[602,629,623],[55,692,444],[518,748,509],[929,1515,1411],[620,578,267],[71,511,358],[707,668,498],[650,687,585],[600,300,641],[641,657,633],[1675,888,1669],[622,636,629],[505,502,375],[541,529,498],[332,420,1053],[637,551,638],[534,639,648],[69,623,873],[300,512,641],[633,657,642],[562,660,579],[687,637,638],[709,646,605],[775,738,885],[559,549,132],[646,683,524],[641,512,657],[266,897,949],[1712,643,1657],[184,727,258],[674,724,669],[699,714,647],[628,659,572],[657,662,642],[571,881,651],[517,607,504],[598,706,528],[598,694,547],[640,552,560],[655,693,698],[698,693,721],[91,510,511],[144,301,1136],[324,216,888],[870,764,1681],[575,514,520],[276,544,543],[658,175,44],[645,505,711],[659,546,572],[700,524,655],[605,700,529],[266,867,897],[1695,1526,764],[579,659,628],[654,591,682],[586,549,559],[698,721,714],[896,401,506],[640,734,599],[664,665,575],[621,629,636],[1712,656,643],[547,644,598],[710,668,707],[640,560,734],[655,698,551],[694,528,277],[512,662,657],[504,592,626],[688,584,519],[152,241,617],[587,725,681],[598,669,706],[526,670,84],[598,528,694],[710,707,499],[579,592,562],[660,659,579],[323,324,1134],[326,895,473],[195,29,653],[84,670,915],[560,660,562],[504,626,681],[711,505,224],[651,881,114],[216,620,889],[1362,678,197],[493,99,48],[1659,691,680],[529,690,546],[430,843,709],[655,524,693],[174,191,105],[674,669,598],[98,712,82],[572,546,585],[72,61,71],[912,911,894],[106,223,184],[664,132,665],[843,646,709],[635,699,136],[699,698,714],[593,132,664],[688,526,584],[185,177,620],[533,675,534],[687,638,635],[1652,89,457],[896,506,912],[132,740,514],[689,685,282],[691,449,680],[48,436,493],[136,699,647],[739,640,554],[549,586,653],[532,533,625],[1530,695,649],[653,381,619],[736,151,531],[188,692,241],[177,402,578],[33,689,867],[689,33,685],[593,559,132],[949,65,266],[711,1038,661],[939,480,1004],[609,369,701],[616,552,615],[619,361,740],[151,463,516],[513,521,117],[691,663,449],[186,251,196],[333,302,327],[613,560,552],[616,613,552],[690,551,637],[660,707,659],[704,208,1203],[418,735,550],[163,708,124],[524,834,693],[554,640,599],[245,341,165],[565,673,359],[155,710,708],[105,191,517],[1515,198,1411],[1709,554,599],[60,289,786],[838,1295,1399],[533,534,625],[710,499,708],[556,632,410],[217,620,216],[591,627,682],[504,503,223],[643,654,567],[690,637,650],[545,557,555],[174,654,682],[719,691,1659],[727,681,508],[645,711,661],[794,615,739],[565,515,508],[282,685,302],[1150,397,1149],[638,699,635],[544,685,33],[719,726,691],[1742,1126,1733],[1724,1475,148],[556,410,403],[185,217,380],[503,504,681],[277,556,403],[32,1178,158],[1712,1709,599],[605,529,541],[635,136,369],[687,635,369],[529,700,690],[700,551,690],[89,304,573],[625,534,732],[730,302,685],[503,681,727],[702,673,701],[730,327,302],[327,353,333],[596,664,575],[660,499,707],[585,546,650],[560,729,734],[700,655,551],[176,571,651],[517,504,223],[730,685,544],[1661,1682,726],[1682,495,726],[1250,301,917],[605,524,700],[609,687,369],[516,389,895],[1553,686,1027],[673,702,164],[656,591,654],[520,596,575],[402,123,401],[828,456,728],[1645,677,1653],[528,556,277],[638,551,699],[190,497,359],[276,730,544],[1117,1525,933],[1027,686,1306],[155,708,163],[709,605,541],[647,644,547],[650,637,687],[599,734,591],[578,293,267],[1682,357,495],[510,91,130],[734,729,627],[576,542,215],[709,541,735],[735,541,550],[276,500,730],[500,327,730],[653,619,740],[414,851,454],[734,627,591],[729,562,607],[615,552,640],[525,181,192],[308,512,300],[223,503,727],[266,165,33],[92,500,276],[321,1046,1033],[585,609,606],[1200,1559,86],[628,572,626],[301,436,803],[714,644,647],[708,499,613],[721,693,724],[514,353,327],[353,740,361],[344,158,78],[708,613,616],[615,640,739],[500,514,327],[514,740,353],[1449,177,185],[462,233,625],[851,405,1163],[608,616,615],[647,542,576],[625,732,501],[1097,582,1311],[1235,424,577],[579,628,592],[607,592,504],[24,432,470],[105,614,247],[104,742,471],[542,259,215],[365,196,455],[1420,47,65],[223,727,184],[547,542,647],[572,585,606],[587,572,606],[262,780,1370],[647,576,136],[644,674,598],[271,53,75],[727,508,258],[471,742,142],[505,375,224],[357,1710,269],[725,508,681],[659,498,546],[743,1178,32],[1195,634,231],[1176,24,470],[743,1110,1178],[135,809,857],[63,746,407],[634,1176,470],[159,1112,27],[1176,1685,24],[399,450,779],[1178,856,875],[751,744,54],[436,48,772],[634,1108,1210],[769,1285,1286],[751,298,755],[746,1684,754],[754,924,87],[722,1625,756],[87,839,153],[489,795,820],[758,808,1518],[839,840,153],[831,1111,959],[1111,749,959],[810,1253,1363],[1247,1394,713],[1388,1329,1201],[1242,120,761],[857,791,384],[758,1523,808],[296,764,1504],[70,1652,891],[207,233,1638],[1348,57,28],[858,420,332],[964,1379,1278],[420,1194,816],[784,1076,1186],[1076,21,1186],[1710,767,1],[849,822,778],[806,137,787],[786,790,744],[790,54,744],[771,63,407],[785,852,818],[774,1823,272],[895,151,516],[135,1022,809],[99,826,48],[48,826,755],[808,705,408],[833,441,716],[1733,743,32],[1385,836,852],[772,827,737],[1005,49,781],[793,1697,813],[1518,441,1537],[1139,1132,859],[782,801,770],[1510,1530,676],[770,814,835],[231,787,825],[207,722,756],[26,771,798],[782,863,865],[832,54,790],[865,842,507],[799,765,94],[1175,1261,1353],[800,408,805],[262,986,200],[792,800,814],[801,792,770],[704,1203,1148],[356,1514,822],[165,544,33],[561,776,113],[1043,738,775],[815,831,820],[773,792,801],[772,48,914],[772,737,803],[436,772,803],[808,817,705],[1624,822,1527],[588,1144,788],[799,762,604],[821,1520,1676],[854,803,666],[828,482,472],[445,74,463],[831,489,820],[828,836,482],[716,782,763],[334,815,766],[815,823,766],[334,766,765],[819,805,837],[1716,1521,1412],[1684,924,754],[800,805,819],[1709,829,554],[806,1349,137],[99,1013,747],[341,595,276],[817,810,818],[1176,1691,1685],[763,782,865],[830,846,1052],[865,1499,842],[982,846,1053],[847,832,790],[1178,875,158],[817,818,705],[1302,1392,45],[96,417,284],[223,614,517],[356,507,1514],[1166,848,1179],[1349,432,26],[717,92,276],[770,835,863],[522,509,1745],[847,841,832],[832,841,46],[829,739,554],[802,824,39],[397,1043,775],[1567,849,778],[1385,483,855],[1349,26,1346],[441,801,782],[402,401,293],[1043,667,738],[759,798,1007],[819,837,728],[728,837,828],[837,852,828],[1537,441,833],[148,1475,147],[805,705,837],[716,441,782],[483,1371,780],[814,819,844],[845,753,1336],[1661,719,4],[862,847,790],[737,827,666],[201,46,841],[810,785,818],[408,705,805],[1560,1536,849],[1585,853,1786],[7,1668,807],[7,807,8],[822,1514,1527],[800,819,814],[847,862,841],[991,857,760],[705,818,837],[808,408,773],[402,293,578],[791,858,332],[1480,1228,1240],[814,844,835],[785,1385,852],[1132,120,859],[1743,1726,684],[1704,783,1279],[1623,1694,1731],[959,489,831],[1518,808,773],[862,872,841],[441,773,801],[331,512,308],[380,217,216],[841,872,201],[818,852,837],[448,1480,1240],[856,1108,1195],[1527,1514,1526],[819,182,1232],[871,724,693],[852,836,828],[770,792,814],[803,737,666],[751,826,278],[1674,1727,1699],[849,356,822],[871,693,834],[507,842,1514],[1406,1097,869],[1328,1349,1346],[823,815,795],[744,751,278],[1110,856,1178],[520,717,316],[871,834,683],[884,876,724],[165,266,47],[716,763,507],[216,889,888],[853,1585,1570],[1536,716,356],[886,873,623],[782,770,863],[432,24,26],[683,882,871],[884,724,871],[114,876,884],[516,590,389],[11,1218,1628],[862,113,872],[886,623,629],[830,1052,1120],[762,153,604],[773,408,792],[763,865,507],[153,840,604],[882,884,871],[531,151,326],[886,890,873],[133,262,200],[819,1232,844],[621,636,122],[645,892,519],[1130,1076,784],[114,263,876],[1670,10,1663],[911,670,894],[452,885,872],[872,885,201],[887,882,683],[878,884,882],[590,878,882],[890,867,689],[897,629,621],[897,886,629],[819,728,182],[519,893,688],[894,670,526],[898,894,526],[1536,356,849],[810,1363,785],[878,114,884],[879,888,892],[892,889,893],[893,898,688],[895,683,843],[895,887,683],[889,620,267],[590,882,389],[418,465,84],[949,897,621],[897,890,886],[889,267,893],[898,267,896],[531,326,473],[189,651,878],[843,683,646],[897,867,890],[888,889,892],[893,267,898],[896,894,898],[473,895,843],[895,389,887],[974,706,669],[513,1115,521],[326,151,895],[809,791,857],[211,262,133],[920,923,947],[923,90,947],[90,25,947],[25,972,935],[64,431,899],[52,899,901],[903,905,59],[437,967,73],[839,1242,761],[904,975,44],[917,301,144],[915,670,911],[905,201,885],[1684,63,1685],[1033,1194,288],[950,913,755],[912,918,911],[950,914,913],[506,918,912],[922,919,915],[911,922,915],[1004,451,492],[1263,553,639],[922,911,918],[630,920,947],[916,506,926],[916,918,506],[521,1115,1098],[916,922,918],[919,418,915],[83,38,75],[24,1685,771],[110,1230,1213],[712,8,1837],[922,930,919],[919,430,418],[1395,1402,1187],[930,922,916],[594,623,69],[35,431,968],[35,968,969],[866,924,1684],[1625,1263,675],[631,630,52],[930,931,919],[430,709,418],[302,333,49],[1446,978,1138],[799,1007,798],[931,843,919],[947,25,64],[885,738,667],[1262,963,964],[899,970,901],[1401,946,938],[1117,933,1091],[1685,63,771],[905,948,201],[979,937,980],[951,953,950],[937,270,443],[1154,903,59],[1194,954,1067],[909,405,907],[850,1151,59],[1769,811,1432],[76,206,250],[938,946,966],[965,927,942],[938,966,957],[955,975,904],[927,965,934],[52,51,631],[59,905,667],[431,935,968],[786,289,561],[252,122,671],[481,494,107],[954,1817,1067],[795,25,90],[958,965,945],[795,972,25],[902,983,955],[972,489,944],[1256,29,424],[671,331,945],[946,958,963],[956,955,904],[902,955,956],[671,512,331],[945,331,961],[662,671,122],[671,662,512],[934,65,927],[630,947,52],[666,631,910],[850,59,667],[961,331,234],[1024,411,1042],[890,69,873],[252,671,945],[975,290,940],[283,186,196],[30,283,365],[950,755,298],[946,965,958],[985,290,975],[969,290,985],[405,851,206],[935,431,64],[941,1423,1420],[964,963,167],[942,252,945],[78,757,57],[49,1005,66],[937,979,270],[631,666,827],[980,937,443],[66,689,282],[421,902,956],[947,64,52],[35,979,899],[951,971,953],[762,87,153],[27,31,381],[924,839,87],[946,963,966],[331,308,340],[957,966,1262],[473,843,931],[953,971,920],[270,969,902],[935,962,968],[51,1005,781],[969,983,902],[437,73,940],[69,421,956],[761,249,840],[263,974,669],[962,944,967],[962,437,290],[985,975,955],[907,405,948],[720,957,1262],[25,935,64],[176,200,571],[108,945,50],[250,851,414],[200,986,571],[881,974,263],[827,772,953],[970,899,980],[29,159,27],[234,331,340],[948,405,206],[980,899,979],[986,984,571],[571,984,881],[990,706,974],[946,934,965],[970,980,66],[1113,1486,1554],[984,981,881],[881,987,974],[689,66,443],[1005,901,66],[983,985,955],[165,47,718],[987,990,974],[1370,986,262],[901,970,66],[51,901,1005],[981,987,881],[988,706,990],[942,945,965],[290,437,940],[64,899,52],[988,556,706],[941,934,946],[431,35,899],[996,989,984],[984,989,981],[981,989,987],[35,969,270],[1370,995,986],[986,995,984],[989,999,987],[987,992,990],[992,988,990],[962,967,437],[951,950,976],[979,35,270],[421,270,902],[998,995,1370],[987,999,992],[988,364,556],[969,985,983],[689,443,890],[995,1000,984],[219,958,108],[998,1000,995],[999,997,992],[914,953,772],[845,1336,745],[806,787,231],[1000,996,984],[989,996,999],[50,945,961],[443,421,69],[797,158,779],[1098,1463,434],[996,1009,999],[1001,988,992],[1001,364,988],[903,907,905],[26,759,973],[997,1001,992],[632,364,1001],[1346,26,973],[998,1008,1000],[1000,1009,996],[531,931,736],[252,949,621],[286,388,525],[1174,1008,998],[1009,1010,999],[999,1010,997],[1014,1001,997],[614,105,517],[958,945,108],[525,1004,242],[963,958,219],[233,426,304],[1000,1008,1009],[1010,1014,997],[1001,1006,632],[824,413,39],[642,636,622],[480,388,205],[28,757,797],[1014,1006,1001],[1006,410,632],[975,940,44],[1234,420,858],[54,832,46],[1009,1012,1010],[167,963,219],[41,481,107],[1017,1010,1012],[122,636,662],[939,525,388],[525,939,1004],[950,953,914],[829,1735,739],[1008,880,1015],[1008,1015,1009],[1263,639,675],[956,594,69],[795,90,1347],[1179,848,1013],[759,1007,973],[1009,1015,1012],[1012,1016,1017],[1017,1014,1010],[1019,1011,1006],[927,65,949],[649,316,595],[913,48,755],[976,950,298],[1003,1015,880],[1018,1006,1014],[1021,1018,1014],[444,692,1011],[451,1029,1063],[1185,851,1163],[29,27,381],[181,525,242],[1021,1014,1017],[1016,1021,1017],[1018,1019,1006],[1019,444,1011],[927,949,942],[451,393,492],[903,1154,907],[391,101,57],[94,765,58],[419,1016,1012],[949,252,942],[907,1020,909],[765,442,58],[94,406,908],[1007,94,908],[34,1012,1015],[34,419,1012],[419,1021,1016],[451,1057,393],[907,948,905],[1034,1073,1039],[1061,906,1619],[1068,960,1034],[471,1249,104],[112,1024,1042],[372,379,125],[341,543,165],[141,1094,170],[566,243,1061],[398,1034,1039],[325,317,1823],[1493,296,1724],[850,667,1043],[1054,297,1065],[1619,135,1074],[1061,243,906],[680,1024,821],[1103,96,1245],[1440,1123,1491],[1047,1025,1044],[672,454,1231],[1484,697,1530],[993,672,1231],[178,154,1088],[1044,1041,1066],[112,1062,1058],[1530,649,676],[178,1088,1040],[1046,328,954],[243,244,1022],[954,1194,1033],[1042,411,1032],[971,993,1056],[960,1093,1034],[1754,1338,232],[385,1064,412],[1057,1063,111],[748,1071,1447],[1530,697,695],[971,1056,1270],[977,1059,1211],[649,741,316],[1060,1452,1030],[353,354,1323],[695,768,649],[398,404,1034],[596,316,741],[1836,119,13],[1513,1115,1528],[883,1081,1652],[1039,1073,1048],[462,426,233],[31,1296,354],[1055,1047,1066],[1032,1054,1045],[1521,310,1224],[119,861,13],[1194,1234,288],[1109,1771,1070],[1166,1160,776],[1044,1035,1041],[1026,960,1064],[1050,1032,1045],[1049,1041,387],[115,1013,99],[1046,954,1033],[1321,920,971],[611,1058,345],[1048,1066,1049],[1023,1055,1073],[1029,451,1004],[118,1094,141],[1094,1080,170],[1042,1032,1050],[1026,1064,385],[15,16,1084],[1096,1079,61],[1075,1071,748],[325,1817,328],[909,1163,405],[1022,1234,809],[374,398,1051],[1082,72,81],[1023,1034,1093],[1817,1794,1067],[86,1445,1400],[1507,1535,1510],[1079,1096,1075],[568,1478,1104],[1070,178,1040],[1034,1023,1073],[776,1155,113],[1103,143,142],[1140,81,73],[1082,81,1140],[1060,1030,936],[1040,1086,1109],[370,1065,385],[61,72,1082],[1087,1096,1144],[1040,1088,1086],[1651,812,752],[1062,1050,1045],[187,154,178],[179,187,178],[1099,1344,1101],[1668,1058,807],[1073,1055,1048],[1099,1336,1344],[1283,943,1123],[1049,387,1051],[1024,680,449],[61,1082,1100],[967,749,1111],[1439,1037,88],[742,1505,142],[398,1039,1051],[1107,1336,1099],[1344,1542,1101],[142,1505,1103],[477,1093,447],[477,1023,1093],[471,142,1249],[1041,1035,394],[1328,568,1104],[61,1100,1096],[154,1092,1088],[112,1042,1050],[154,187,168],[435,235,45],[1075,1096,1087],[97,1075,748],[1049,1066,1041],[816,1067,1028],[846,982,1142],[1245,96,284],[1092,154,1080],[1057,451,1063],[387,377,1051],[1055,1025,1047],[1075,1087,1089],[1106,1108,856],[1068,1034,404],[1480,1545,868],[906,135,1619],[1074,991,1095],[570,566,1061],[1025,453,1044],[745,1336,1107],[1035,1057,416],[1092,1102,1129],[1074,135,991],[1105,745,1107],[447,1026,446],[394,387,1041],[73,81,940],[1118,1108,1106],[1210,1108,874],[243,1022,906],[412,1064,1068],[1280,611,603],[960,447,1093],[1051,1039,1049],[1040,1109,1070],[1471,1037,1439],[69,890,443],[1377,703,1374],[1092,1080,1102],[1096,1100,788],[1096,788,1144],[1114,967,1111],[446,1026,297],[70,1112,883],[453,393,1057],[1118,874,1108],[1054,370,1045],[1080,1094,1102],[1039,1048,1049],[428,753,845],[1047,1044,1066],[1044,453,1035],[1472,731,1512],[1126,1121,743],[743,1121,1110],[1032,297,1054],[1480,868,1216],[71,358,72],[1133,967,1114],[1105,1119,745],[1035,453,1057],[1026,447,960],[454,851,1190],[1030,1477,652],[589,816,1028],[1110,1121,1106],[1122,1118,1106],[1116,874,1118],[1048,1055,1066],[1194,1067,816],[744,278,747],[745,1120,845],[845,1052,428],[1105,1780,1119],[1065,297,385],[1098,1529,1463],[731,1060,936],[235,434,812],[1445,1525,1117],[1106,1121,1122],[1122,1127,1118],[1127,1116,1118],[1094,118,1732],[1119,1120,745],[1406,1124,1097],[435,117,235],[1462,1440,1037],[1126,1129,1121],[1088,1092,1129],[1133,73,967],[1120,1052,845],[812,434,752],[1441,1559,1200],[1131,588,413],[1054,1065,370],[235,1098,434],[1052,1142,428],[1737,428,1142],[1496,1446,1483],[1182,1083,1654],[1121,1129,1122],[1732,1116,1127],[768,457,649],[761,1114,249],[1064,960,1068],[1135,1481,1136],[1126,952,1129],[1087,588,1131],[1087,1144,588],[859,788,1139],[1140,1133,1132],[1133,1140,73],[1822,570,1061],[394,1035,416],[1055,1023,459],[80,264,485],[1119,1128,1120],[145,1658,567],[695,891,768],[1129,1102,1122],[1122,1102,1127],[1416,1077,1413],[297,1026,385],[1052,846,1142],[1445,1117,1400],[952,1086,1129],[1714,1089,1131],[1131,1089,1087],[1100,1139,788],[112,1050,1062],[1323,354,1296],[49,333,1141],[1142,982,1737],[79,1457,1091],[1088,1129,1086],[1102,1094,1127],[1127,1094,1732],[1100,1082,1139],[1082,1132,1139],[1082,1140,1132],[1150,1043,397],[60,1166,289],[1696,1146,1698],[1297,1202,1313],[409,1297,1313],[1234,1194,420],[1408,1391,1394],[424,1235,1243],[1203,309,1148],[485,477,447],[1152,1156,850],[1153,1149,1155],[1153,1157,1149],[1149,1152,1150],[1156,1154,1151],[776,1153,1155],[1157,1152,1149],[1217,1393,1208],[1156,1159,1154],[1153,1165,1157],[1165,1152,1157],[1159,1020,1154],[1161,1153,776],[1161,1165,1153],[1165,1158,1152],[1152,1158,1156],[1158,1159,1156],[1166,776,561],[1160,1161,776],[1161,1164,1165],[1161,1160,1164],[1158,1162,1159],[1159,1162,1020],[1270,1321,971],[1164,1170,1165],[1165,1162,1158],[1162,1163,1020],[588,788,925],[1166,1167,1160],[1165,1170,1162],[1160,1167,1164],[1162,1170,1163],[1179,1167,1166],[1167,1168,1164],[1164,1168,1170],[1168,1169,1170],[1234,1022,288],[802,39,866],[1179,1168,1167],[1169,1173,1170],[1170,1173,1163],[1173,1185,1163],[1360,1267,1364],[1169,1185,1173],[611,244,243],[900,1226,1376],[1260,1408,1350],[618,840,831],[1181,1183,1179],[1179,1184,1168],[1208,1274,1291],[1183,1184,1179],[1168,1184,1169],[1387,1395,1254],[1208,1204,1172],[1182,1197,1083],[1187,1083,1197],[1213,1183,1181],[1169,1207,1185],[135,857,991],[1013,1213,1181],[1189,1183,1213],[1183,1189,1184],[1169,1184,1207],[1207,1190,1185],[1180,1389,1288],[1191,1192,1640],[1640,1192,1090],[1090,1205,1654],[1654,1205,1182],[1188,1395,1187],[1126,743,1733],[788,859,925],[809,1234,1171],[1193,1197,1182],[1189,1199,1184],[1639,1191,1637],[1639,1212,1191],[1205,1193,1182],[1198,1187,1197],[1199,1207,1184],[332,1053,846],[1090,1192,1205],[117,1188,1187],[435,1188,117],[435,1206,1188],[1199,1189,1213],[420,816,1053],[1212,1215,1191],[117,1187,1198],[45,1206,435],[120,1132,1133],[874,1116,1210],[1191,1215,1192],[1193,1216,1197],[1216,1198,1197],[1199,1214,1207],[117,521,235],[1220,1311,1078],[1220,900,1311],[1653,1215,1212],[1192,1225,1205],[1205,1209,1193],[1209,1216,1193],[1389,1217,1172],[1207,1214,454],[171,557,1747],[1805,1078,1787],[1805,1219,1078],[1198,1216,868],[666,910,854],[1230,1231,1213],[1213,1231,1199],[1199,1231,1214],[1219,1220,1078],[1215,1221,1192],[1192,1221,1225],[1225,1228,1205],[1205,1228,1209],[1209,1228,1216],[1464,1325,1223],[1215,1227,1221],[1228,1480,1216],[1226,1653,1376],[1653,1249,1215],[1221,1240,1225],[1225,1240,1228],[839,761,840],[1238,1219,1805],[1238,1220,1219],[1232,1380,1375],[1226,1249,1653],[1221,1227,1240],[233,207,532],[110,1236,1230],[1248,1231,1230],[1231,454,1214],[1249,1227,1215],[1248,1056,1231],[489,959,944],[448,1240,284],[925,859,1242],[1805,1244,1238],[1252,1220,1238],[1252,921,1220],[1236,1251,1230],[1230,1251,1248],[1056,993,1231],[1031,1264,1263],[68,1186,157],[1227,1245,1240],[1103,1245,143],[1243,1235,612],[1252,95,921],[1249,1226,1237],[1390,1387,1254],[1120,384,830],[830,332,846],[1227,143,1245],[1315,1369,1358],[1356,1269,1386],[972,795,489],[1831,1224,310],[1250,1255,1251],[1251,1056,1248],[1256,1243,103],[658,358,175],[1620,1238,1244],[1620,1252,1238],[1506,95,1252],[104,1249,1237],[1249,143,1227],[1268,1419,1329],[634,806,231],[618,831,815],[924,1242,839],[1255,1270,1251],[1251,1270,1056],[866,925,1242],[103,29,1256],[424,1243,1256],[134,1651,752],[1250,917,1255],[1172,1204,1260],[1352,1036,1276],[1265,1201,1329],[804,1282,1259],[1259,1294,723],[335,1330,1305],[407,762,799],[875,856,1195],[32,158,344],[967,944,749],[372,125,42],[1175,1354,1261],[553,612,1235],[1259,1273,1294],[1294,1283,723],[757,78,158],[407,799,798],[901,51,52],[139,1386,1389],[1386,1269,1389],[1389,1269,1217],[1148,1590,1268],[1428,1449,1450],[804,1281,1282],[1273,1259,1282],[158,399,779],[771,407,798],[521,1098,235],[917,1312,1255],[1312,1270,1255],[1217,1269,1393],[1195,1108,634],[1110,1106,856],[1210,1691,1176],[27,1112,1145],[1296,27,1145],[1171,858,791],[704,1148,1290],[1430,1436,1437],[1282,1308,1273],[1300,943,1283],[1393,1355,1274],[720,1278,769],[1287,1059,1399],[1310,1388,1272],[1312,1321,1270],[851,1185,1190],[1296,1145,1304],[26,24,771],[51,910,631],[1329,1290,1268],[1290,1148,1268],[1298,1293,733],[1281,1293,1282],[1282,1293,1308],[1308,1299,1273],[1300,1283,1294],[1340,943,1300],[1340,1301,943],[407,754,762],[1287,1399,1295],[34,139,128],[1288,1172,1260],[120,1133,1114],[1306,1113,1511],[1464,1223,1292],[1299,1294,1273],[1299,1300,1294],[1286,1295,838],[1285,1247,1286],[1247,713,1286],[1201,1265,1390],[1378,1368,1357],[1482,1320,917],[917,1320,1312],[850,1156,1151],[588,39,413],[1324,1306,686],[789,1365,928],[1223,1326,1292],[1292,1326,1298],[869,1097,1311],[790,786,561],[1323,1304,932],[1323,1296,1304],[1317,1324,686],[1306,368,1113],[1325,1342,1223],[1326,1348,1298],[1293,1327,1308],[1308,1318,1299],[704,1290,1258],[1320,1321,1312],[761,120,1114],[1684,802,866],[1674,6,1727],[1316,1323,932],[1335,1337,1305],[1348,1327,1293],[1298,1348,1293],[1333,1300,1299],[1333,1343,1300],[1328,1301,1340],[1328,1314,1301],[838,1399,1319],[921,1237,900],[409,1391,1408],[1376,1653,677],[1281,804,1458],[1331,1324,1317],[1324,368,1306],[368,1338,1307],[1327,797,1308],[797,1345,1308],[1308,1345,1318],[1318,1333,1299],[1341,1147,1572],[923,1321,1320],[923,920,1321],[39,588,866],[1141,1323,1316],[1330,1335,1305],[1337,1335,1336],[1339,1332,1325],[1223,1342,1326],[1342,1348,1326],[1348,797,1327],[1345,1333,1318],[1343,1340,1300],[1419,1265,1329],[1347,1320,1584],[1535,1141,1316],[1078,1311,582],[1344,1335,1330],[753,1331,1337],[368,1324,1331],[753,368,1331],[1332,1485,1325],[1325,1485,1342],[787,1343,1333],[137,1328,1340],[973,1341,1479],[406,1147,1341],[1171,1234,858],[1141,1535,1322],[49,1141,1322],[1344,1336,1335],[973,908,1341],[766,1347,1584],[1347,923,1320],[781,49,1322],[368,232,1338],[787,1340,1343],[787,137,1340],[568,1346,973],[58,1147,406],[442,1334,1147],[58,442,1147],[442,766,1334],[90,923,1347],[428,368,753],[779,1333,1345],[825,787,1333],[137,1349,1328],[1328,1346,568],[908,406,1341],[924,866,1242],[1336,753,1337],[428,232,368],[1115,777,1098],[1348,28,797],[797,779,1345],[779,825,1333],[1007,908,973],[583,1351,880],[1365,1246,977],[1658,145,1710],[1310,796,1388],[718,245,165],[1302,1272,1254],[1174,1351,583],[1174,715,1351],[1358,1260,1204],[1374,1373,1276],[1377,1374,1276],[678,1362,1382],[1377,1276,254],[139,34,40],[1008,1174,583],[1396,1286,1319],[768,891,457],[1316,932,1535],[1289,1371,1360],[182,736,864],[1355,1364,1274],[860,1367,1354],[1362,1222,1382],[1376,869,1311],[1590,1411,198],[1232,1375,877],[1394,1295,1286],[880,1356,1386],[880,1351,1356],[1211,1059,1287],[197,678,1405],[880,1386,1003],[1368,1253,1357],[1357,1253,1036],[715,1289,1364],[1354,1367,703],[1383,877,1375],[1266,1288,1260],[1373,1374,703],[1372,1289,1174],[1303,1366,1378],[1351,715,1355],[1665,1666,624],[1309,1357,1036],[900,1237,1226],[1174,1289,715],[1337,1331,1317],[1360,1303,1359],[1267,1354,1175],[1241,1284,1414],[1377,254,929],[1385,855,836],[1396,1319,1436],[1361,1366,1303],[1381,1368,1378],[1313,1211,1391],[1368,1385,1363],[813,82,861],[1058,1280,807],[893,519,892],[1359,1303,860],[1382,1350,1247],[1371,1303,1360],[1267,1175,1271],[769,1286,1396],[712,1837,82],[1366,1385,1381],[1365,796,1310],[1003,1386,40],[780,1371,1370],[561,862,790],[1284,1380,864],[1449,1428,177],[611,1280,1058],[1284,1375,1380],[926,506,1241],[1305,1337,1317],[309,1203,208],[1388,1201,1390],[1309,1036,1352],[1377,929,1411],[1399,1059,1257],[1112,70,1145],[289,1166,561],[1288,1389,1172],[1362,37,1180],[713,1394,1286],[1355,1393,1269],[1401,1423,941],[1274,1271,1384],[860,1378,1367],[715,1364,1355],[677,1406,869],[1297,1358,1202],[1388,1258,1329],[1180,1288,1266],[1008,583,880],[1524,1425,1463],[1390,1403,1387],[1278,1379,1247],[1278,1247,1285],[964,1278,1262],[1358,1369,1202],[1715,1699,1726],[926,1241,1414],[1341,1572,1479],[926,930,916],[1397,51,781],[409,1358,1297],[1236,436,301],[1376,677,869],[1351,1355,1356],[758,1534,1523],[1378,1357,1367],[977,1211,1365],[1135,1136,854],[1394,1391,1295],[1266,1260,1222],[1365,1302,1246],[1232,877,844],[736,930,864],[1408,1358,409],[1508,817,1523],[1381,1385,1368],[718,854,910],[854,718,1135],[1382,1222,1350],[1391,1211,1287],[1391,1287,1295],[1257,1651,134],[1414,1284,864],[1291,1369,1315],[1202,928,1313],[86,1400,1413],[1413,1200,86],[1263,1625,1031],[1413,1400,1404],[1002,1664,1834],[930,926,1414],[1399,1257,134],[520,316,596],[1393,1274,1208],[1657,1655,1712],[1407,1404,1400],[1404,1410,1413],[1649,1229,1406],[1362,1266,1222],[1384,1271,1175],[900,1376,1311],[1274,1384,1291],[1291,1384,1431],[1433,1396,1436],[1267,1359,1354],[309,1353,703],[838,1319,1286],[1407,1410,1404],[441,1518,773],[1241,123,1428],[1622,1521,1224],[1217,1208,1172],[1130,793,1076],[425,1409,1481],[1481,1409,1533],[1303,1378,860],[1350,1408,1394],[1246,1651,977],[1289,1360,1364],[1727,1694,1623],[1417,1407,1533],[1417,1410,1407],[1406,1650,1649],[1319,134,1437],[1414,864,930],[1406,1229,1124],[1354,1359,860],[1433,769,1396],[1417,1533,1409],[1416,1413,1410],[1415,1416,1410],[95,1237,921],[1392,1254,1395],[1360,1359,1267],[1258,1290,1329],[1180,128,1389],[1420,1409,425],[1417,1418,1410],[1418,1415,1410],[1422,1077,1416],[1247,1350,1394],[37,43,1180],[1204,1315,1358],[1428,1383,1375],[1356,1355,1269],[1409,1418,1417],[1302,45,1246],[1421,1416,1415],[1421,1422,1416],[1422,1494,1077],[957,720,938],[1423,1409,1420],[1423,1418,1409],[752,434,1438],[1260,1358,1408],[1363,1385,785],[1423,1426,1418],[1426,1424,1418],[1229,1649,1124],[1222,1260,1350],[1508,1523,1137],[1278,1285,769],[1482,917,144],[1418,1424,1415],[1425,1422,1421],[1425,1524,1422],[1272,1388,1390],[1391,409,1313],[1378,1366,1381],[1371,483,1361],[720,1262,1278],[29,103,159],[1271,1364,1267],[1424,1427,1415],[1537,1522,1518],[134,752,1438],[1420,934,941],[1428,1375,1284],[1277,1224,1831],[1362,1180,1266],[1401,1426,1423],[1577,1369,1291],[268,483,262],[1383,1450,1456],[1384,1175,1431],[1430,1415,1427],[1430,1421,1415],[1430,1425,1421],[1379,1382,1247],[1252,1553,1429],[1206,1392,1395],[1433,1430,1427],[309,208,1353],[1272,1390,1254],[1361,483,1366],[1523,817,808],[1302,1254,1392],[1371,1361,1303],[1426,1435,1424],[1435,1433,1424],[1433,1427,1424],[720,769,1433],[796,1258,1388],[1590,1419,1268],[1289,1372,1371],[1305,1317,1509],[998,1372,1174],[40,1386,139],[1261,1354,703],[1364,1271,1274],[134,1438,1437],[1436,1319,1437],[1317,686,1509],[1484,932,1304],[1434,1432,1509],[1420,65,934],[931,930,736],[1367,1357,1309],[1372,1370,1371],[1204,1208,1315],[1426,938,1435],[1368,1363,1253],[1207,454,1190],[1302,1310,1272],[309,1377,390],[390,1377,1411],[1370,1372,998],[1411,1590,1148],[720,1433,1435],[1450,1383,1428],[1379,678,1382],[1405,678,1379],[1208,1291,1315],[1399,134,1319],[1367,1309,1373],[1373,1352,1276],[596,741,593],[553,1264,612],[1433,1436,1430],[1437,1438,1430],[964,1405,1379],[1373,1309,1352],[1265,1403,1390],[1233,1618,1434],[1365,1310,1302],[789,796,1365],[720,1435,938],[128,139,1389],[1466,933,1525],[1191,1640,1637],[1314,1442,943],[1141,353,1323],[1489,1138,1474],[1462,1477,1440],[1474,1138,1488],[1442,1314,1443],[1446,1030,1546],[1484,1145,697],[1549,1443,1445],[1470,1572,1468],[1397,1239,1507],[1649,1825,1824],[1259,1440,1477],[1451,1450,1449],[978,1446,652],[1454,1456,1451],[1451,1456,1450],[341,1507,595],[933,1547,79],[804,1452,1060],[1454,1455,1456],[1398,1460,1454],[1455,877,1456],[1277,1831,1825],[804,1060,1458],[1339,1459,1595],[1314,1104,1443],[933,1448,1547],[147,1460,1398],[1460,1461,1454],[1454,1461,1455],[1292,1125,1464],[417,1531,1480],[1459,1339,1325],[811,1756,335],[1512,936,1490],[777,1529,1098],[147,1475,1460],[1464,253,1459],[836,855,482],[1487,1486,1307],[1104,1501,1443],[1439,1200,1532],[1475,1469,1460],[1460,1469,1461],[1325,1464,1459],[1277,1825,1649],[1532,1200,1077],[844,877,1455],[1572,933,1466],[1479,568,973],[1509,335,1305],[1339,1595,1759],[1469,1476,1461],[1461,1476,1455],[1104,1470,1468],[1464,1472,253],[1117,1091,1407],[1756,1542,335],[1206,1395,1188],[335,1542,1330],[835,844,1455],[1471,1598,1462],[1491,1442,1441],[835,1455,1476],[1441,1442,1443],[1489,1474,1473],[1251,1236,1250],[1030,1452,1477],[1598,1439,1532],[978,1598,1492],[1426,1401,938],[1448,1584,1482],[1724,1497,1475],[1475,1497,1469],[1484,1535,932],[1307,1486,1113],[1487,696,1495],[1037,1491,1441],[1030,1446,936],[1453,1487,1495],[696,1467,1495],[1138,1489,1483],[1497,1143,1469],[1469,1143,1476],[652,1598,978],[850,1043,1150],[1482,1584,1320],[1731,98,1697],[1113,1554,1573],[1524,1532,1494],[1496,1467,696],[1452,1259,1477],[296,1504,1497],[1504,1143,1497],[1143,1499,1476],[718,910,1498],[868,1540,1528],[817,1253,810],[1490,696,1487],[1440,1491,1037],[1510,676,595],[1488,1492,1517],[781,1239,1397],[1467,1519,1503],[1500,1307,1759],[1149,397,452],[1504,1514,1143],[1514,842,1143],[1125,733,1458],[1503,1531,1555],[1276,1036,1137],[1440,723,1123],[1036,1508,1137],[817,1508,1253],[103,883,1112],[1458,731,1472],[1512,1490,1487],[1487,1453,1486],[1138,978,1488],[1036,1253,1508],[1398,149,147],[1474,1517,1513],[1125,1458,1472],[1486,1453,1554],[1518,1534,758],[345,1058,1062],[928,1202,1369],[1554,1541,1505],[1464,1125,1472],[1504,764,1514],[304,426,573],[1505,742,1506],[1479,1572,1478],[1519,1483,1489],[833,716,1069],[1522,1534,1518],[1115,1513,777],[811,335,1432],[1591,1533,1407],[777,1517,1529],[1513,1517,777],[1498,910,1397],[1069,1539,833],[833,1539,1537],[1522,1551,1534],[1534,1551,1523],[1538,1137,1523],[910,51,1397],[1367,1373,703],[1466,1525,1468],[157,1186,1832],[1429,1511,1506],[1573,1505,1506],[1259,1452,804],[1503,1495,1467],[262,483,780],[1572,1466,1468],[1536,1556,716],[716,1556,1069],[1544,1523,1551],[1544,1538,1523],[1511,1573,1506],[933,1572,1448],[1543,1537,1539],[1537,1543,1522],[1091,933,79],[1519,1540,1545],[1549,1445,86],[1069,1548,1539],[1548,1543,1539],[1543,1551,1522],[1500,1487,1307],[68,784,1186],[1552,1544,1551],[1550,1538,1544],[1538,1550,1137],[1519,1473,1540],[1547,1448,1482],[1560,1563,1536],[1536,1563,1556],[1556,1548,1069],[1543,1558,1551],[1137,1550,1276],[1453,1495,1555],[1561,1543,1548],[1543,1561,1558],[1558,1566,1551],[1552,1550,1544],[1569,1557,1550],[1557,1276,1550],[1276,1557,254],[1531,1503,1480],[1535,1530,1510],[1545,1503,1519],[1547,1482,79],[1566,1552,1551],[1552,1569,1550],[1503,1545,1480],[703,1377,309],[1625,675,756],[1037,1441,88],[929,254,1557],[849,1567,1560],[1556,1564,1548],[1492,1529,1517],[1252,1429,1506],[1553,1027,1429],[1453,1555,1541],[1554,1453,1541],[1233,686,1553],[1328,1104,1314],[1564,1576,1548],[1548,1576,1561],[1557,1562,929],[1520,112,1668],[1483,1446,1138],[778,1570,1567],[1563,1564,1556],[1561,1565,1558],[1565,1566,1558],[1569,1552,1566],[1562,1557,1569],[1530,1535,1484],[1387,1402,1395],[1621,1634,1387],[1567,1568,1560],[1560,1568,1563],[1571,1569,1566],[1344,1330,1542],[1577,1431,1353],[1638,233,304],[1524,1463,1529],[1353,1431,1175],[1077,1200,1413],[1478,1470,1104],[1568,1575,1563],[1563,1575,1564],[1575,1576,1564],[1561,1576,1565],[1565,1574,1566],[1562,1515,929],[1555,96,1541],[1531,417,96],[1555,1531,96],[1246,45,1651],[208,1577,1353],[1586,1568,1567],[1574,1571,1566],[1571,1583,1569],[1474,1513,1528],[1239,1322,1535],[1478,1572,1470],[1570,1586,1567],[1488,1517,1474],[8,1833,1837],[1123,1442,1491],[1589,1568,1586],[1576,1594,1565],[1565,1594,1574],[1562,198,1515],[1559,1441,1549],[1441,1443,1549],[1135,425,1481],[1239,1535,1507],[1595,1487,1500],[1570,1585,1586],[1589,1578,1568],[1568,1578,1575],[1579,1569,1583],[1177,1577,208],[115,1236,110],[1578,1593,1575],[1587,1576,1575],[1576,1581,1594],[1571,1582,1583],[1588,1579,1583],[1579,1580,1562],[1569,1579,1562],[1562,1580,198],[1027,1511,1429],[1589,1593,1578],[1587,1581,1576],[1582,1574,1594],[1574,1582,1571],[1575,1593,1587],[1583,1582,1588],[1580,1590,198],[1587,1593,1581],[1505,1541,96],[1369,1577,1177],[1573,1554,1505],[1479,1478,568],[1585,1589,1586],[1369,1177,704],[766,1584,1334],[977,1257,1059],[1091,1591,1407],[1591,1091,1457],[1585,1604,1589],[1581,1592,1594],[1602,1582,1594],[1582,1608,1588],[1608,1579,1588],[1579,1597,1580],[1419,1590,1580],[1597,1419,1580],[1431,1577,1291],[1589,1604,1593],[1601,1596,1593],[1593,1596,1581],[1306,1511,1027],[1511,1113,1573],[1786,1412,1585],[1412,1604,1585],[1581,1596,1592],[1592,1602,1594],[1608,1599,1579],[1599,1611,1579],[1579,1611,1597],[1512,1487,253],[1519,1489,1473],[1545,1540,868],[1083,1187,1402],[1117,1407,1400],[1292,733,1125],[284,1240,1245],[1604,1600,1593],[1600,1601,1593],[1582,1607,1608],[789,1369,704],[1467,1483,1519],[1601,1613,1596],[1596,1613,1592],[1602,1607,1582],[1620,1553,1252],[1601,1605,1613],[1592,1613,1602],[1602,1606,1607],[1608,1609,1599],[1599,1609,1611],[1603,1597,1611],[1265,1419,1597],[1603,1265,1597],[1392,1206,45],[928,1369,789],[1474,1528,1473],[1104,1468,1501],[1412,1521,1604],[1613,1631,1602],[1607,1610,1608],[1608,1610,1609],[1476,863,835],[1495,1503,1555],[1498,1397,718],[1520,1668,7],[1604,1615,1600],[1605,1601,1600],[1602,1631,1606],[1606,1610,1607],[1759,1595,1500],[1292,1298,733],[1615,1604,1521],[1609,1603,1611],[652,1462,1598],[1468,1525,1445],[1443,1501,1445],[1134,1723,150],[1521,1622,1615],[1615,1616,1600],[1616,1605,1600],[1605,1616,1612],[1605,1612,1613],[1612,1617,1613],[1613,1617,1631],[1606,1614,1610],[1265,1603,1403],[448,417,1480],[1595,253,1487],[1501,1468,1445],[1383,1456,877],[1490,1496,696],[1610,1627,1609],[1627,1621,1609],[1591,1481,1533],[1598,1471,1439],[1353,1261,703],[1606,1631,1614],[1609,1621,1403],[1532,1077,1494],[1528,1115,513],[1546,652,1446],[1211,928,1365],[1540,1473,1528],[1078,1502,1787],[1425,1430,1438],[1617,1630,1631],[959,749,944],[566,570,603],[1716,310,1521],[775,452,397],[1615,1636,1616],[1616,1636,1612],[1610,1632,1627],[789,704,1258],[1457,1481,1591],[1769,1756,811],[207,1629,722],[1629,1625,722],[1224,1277,1622],[1622,1636,1615],[1636,1646,1612],[1612,1630,1617],[1631,1626,1614],[1614,1632,1610],[1506,104,95],[1481,1457,1136],[1123,943,1442],[936,1446,1496],[1499,863,1476],[1629,1031,1625],[1233,1509,686],[1633,1634,1621],[1621,1387,1403],[1472,1512,253],[1177,208,704],[1277,1636,1622],[1626,1632,1614],[1627,1633,1621],[936,1496,1490],[185,1454,1451],[731,936,1512],[1638,1635,207],[553,1263,1264],[1653,1212,1639],[1633,1627,1632],[1633,1387,1634],[1458,1060,731],[368,1307,1113],[1264,1031,1629],[1152,850,1150],[1277,1644,1636],[1646,1637,1612],[1637,1630,1612],[1647,1631,1630],[1647,1626,1631],[1422,1524,1494],[1030,652,1546],[1635,1629,207],[1635,1264,1629],[1639,1646,1636],[1637,1640,1630],[1641,1632,1626],[1632,1642,1633],[1633,1643,1387],[842,1499,1143],[865,863,1499],[1516,978,1492],[67,1130,784],[1103,1505,96],[88,1441,1200],[1644,1639,1636],[1640,1647,1630],[1647,1641,1626],[1633,1648,1643],[1492,1532,1524],[1488,1516,1492],[1037,1471,1462],[612,1264,1635],[1502,1078,1124],[1641,1642,1632],[1648,1633,1642],[1528,513,868],[1492,1598,1532],[1095,991,760],[679,157,1664],[760,1128,1785],[1277,1650,1644],[320,1022,244],[1559,1549,86],[1676,1520,7],[1488,978,1516],[1095,760,1785],[1128,384,1120],[304,312,1638],[1081,1638,312],[1081,1635,1638],[103,612,1635],[652,1477,1462],[1650,1645,1644],[1645,1639,1644],[1639,1637,1646],[1640,1090,1647],[1654,1641,1647],[1654,1642,1641],[1654,1648,1642],[1643,1402,1387],[1432,335,1509],[384,1128,760],[1652,312,304],[103,1243,612],[1277,1649,1650],[1090,1654,1647],[1643,1648,1402],[1134,324,1675],[679,68,157],[1652,1081,312],[1136,301,803],[1653,1639,1645],[723,1440,1259],[803,854,1136],[104,1506,742],[1112,159,103],[1654,1083,1648],[977,1651,1257],[1397,1507,718],[1081,103,1635],[1650,677,1645],[1083,1402,1648],[1706,1655,1671],[1624,1704,1711],[767,2,1],[608,794,294],[1678,1683,1686],[767,1682,2],[1669,1692,1675],[296,1681,764],[1671,1656,1672],[17,1673,1679],[1706,1671,1673],[1662,1674,1699],[1655,1657,1656],[418,84,915],[1526,1514,764],[1658,1657,567],[870,1695,764],[813,1697,98],[1659,821,5],[60,1013,848],[1013,110,1213],[661,1038,1692],[1660,1703,17],[1693,1673,17],[1663,1715,1743],[1013,115,110],[344,1733,32],[1670,1663,1743],[1670,1743,1738],[1677,1670,1738],[1661,4,3],[1084,1683,1678],[1728,793,1130],[1683,1767,1196],[1677,1738,1196],[1279,1786,853],[294,1038,608],[1279,1689,1786],[870,18,1708],[870,1680,1695],[1705,10,1670],[1084,1767,1683],[1196,1738,1686],[1750,870,1681],[1750,18,870],[1773,1703,1660],[1135,47,425],[150,323,1134],[1707,1655,1706],[1741,344,1687],[1685,1691,1684],[1684,1691,802],[1672,1656,0],[1038,124,608],[1671,1672,1690],[1628,1218,1767],[1686,1275,1667],[1493,1750,1681],[1773,18,1750],[1773,1660,18],[1679,1671,16],[1735,1706,1673],[1667,1678,1686],[1688,1658,1],[1656,1688,0],[1293,1281,1458],[1698,1678,1667],[1696,1130,1722],[1698,1667,1696],[1715,1662,1699],[1692,1038,294],[1682,767,357],[1669,661,1692],[802,1702,824],[1028,1067,1784],[822,1624,778],[119,813,861],[1218,1670,1677],[1703,1693,17],[1658,1710,1],[750,1730,1729],[1701,750,1729],[1693,1735,1673],[1731,1694,98],[1691,1702,802],[783,1729,1719],[1680,870,1708],[1707,1709,1655],[533,756,675],[1691,1210,1702],[11,1705,1670],[1767,1218,1196],[1218,1677,1196],[1664,1716,1721],[1729,1725,1719],[1729,1072,1725],[1210,1116,1702],[1702,1720,824],[1682,1661,2],[1713,1719,1721],[1716,1786,1713],[1730,1722,1072],[294,1717,1811],[1692,294,1666],[1659,680,821],[824,1720,1714],[1726,1731,1718],[345,1062,1045],[1738,1743,1275],[1075,1089,1071],[783,1719,1689],[1275,684,1728],[1692,1666,1665],[1675,1692,1665],[294,1811,1666],[1716,1664,310],[1678,1698,1700],[6,9,1727],[676,649,595],[381,31,361],[1723,1804,1772],[1727,9,1694],[1720,1089,1714],[1786,1716,1412],[1683,1196,1686],[1718,1697,1085],[1116,1739,1702],[1739,1734,1720],[1702,1739,1720],[1089,1720,1734],[509,748,1745],[1743,1715,1726],[1717,294,794],[1116,1732,1739],[1718,1731,1697],[1696,1667,1130],[1134,1665,1723],[1694,712,98],[101,1687,102],[391,1736,101],[662,636,642],[1734,1447,1089],[1089,1447,1071],[436,99,493],[1689,1279,783],[1485,1465,1342],[1736,1687,101],[344,1741,1733],[1741,1742,1733],[1735,829,1706],[829,1707,1706],[1485,1332,1465],[952,1126,1742],[1747,1447,1734],[879,892,645],[1730,1146,1696],[829,1709,1707],[1709,1712,1655],[118,1739,1732],[1332,1744,1465],[1687,1749,1741],[1741,1758,1742],[679,1072,68],[1072,1722,68],[118,1747,1739],[1747,1734,1739],[1465,1744,1736],[1736,1740,1687],[1704,1701,783],[1665,624,1723],[1722,1130,67],[1025,1055,467],[1444,14,1701],[558,522,530],[1657,1658,1688],[1339,1746,1332],[1332,1748,1744],[1687,1740,1749],[1741,1749,1758],[1109,952,1742],[1747,118,141],[1671,1690,1628],[1671,1628,16],[1657,1688,1656],[1745,748,1447],[357,767,1710],[1746,1748,1332],[1146,1700,1698],[1759,1307,1338],[1239,781,1322],[1745,1447,1747],[522,1745,1747],[316,717,595],[148,1493,1724],[1758,1109,1742],[1725,1072,679],[726,719,1661],[1695,1680,1526],[1772,1750,1493],[148,1772,1493],[1542,1751,1101],[952,1109,1086],[1744,1752,1736],[1736,1752,1740],[1753,1755,1740],[391,1342,1736],[821,112,1520],[557,530,1747],[530,522,1747],[994,879,645],[1542,1756,1751],[1813,1693,1703],[1746,1754,1748],[1748,1764,1744],[1752,1757,1740],[1740,1757,1753],[1749,1740,1755],[1755,1763,1749],[1763,1758,1749],[1275,1743,684],[1813,1735,1693],[1107,1099,1101],[1723,624,1804],[1403,1603,1609],[1748,1754,1764],[1744,1757,1752],[1760,1109,1758],[1465,1736,1342],[436,115,99],[1686,1738,1275],[1751,1766,1101],[1759,1754,1746],[1755,1753,1763],[1570,1279,853],[1701,1146,750],[1655,1656,1671],[11,1670,1218],[1761,1751,1756],[1766,1107,1101],[1726,1623,1731],[1711,1704,1279],[67,784,68],[558,530,545],[1620,1618,1233],[1769,1761,1756],[102,1687,344],[1338,1754,1759],[1754,232,1764],[1744,1765,1757],[1757,1763,1753],[1762,1760,1758],[1760,1771,1109],[1339,1759,1746],[1675,1665,1134],[1730,1696,1722],[1774,1751,1761],[1766,1780,1107],[1780,1105,1107],[1764,1765,1744],[1763,1762,1758],[1772,1773,1750],[1811,1813,1703],[1434,1769,1432],[1780,1766,1751],[232,1781,1764],[1711,1279,1570],[1688,1,0],[1774,1780,1751],[1764,1781,1765],[1765,1768,1757],[1757,1768,1763],[1777,1782,1760],[1762,1777,1760],[1769,1774,1761],[1763,1777,1762],[1760,1782,1771],[232,1737,1781],[1768,1776,1763],[272,255,774],[1669,994,661],[1618,1769,1434],[1765,589,1768],[1770,1777,1763],[1701,1729,783],[1783,1774,1769],[1789,1780,1774],[589,1775,1768],[1776,1770,1763],[1782,1778,1771],[1771,1778,1070],[624,1703,1773],[624,1811,1703],[1620,1244,1618],[1779,1769,1618],[1779,1783,1769],[739,1735,1813],[1775,1776,1768],[1790,1777,1770],[1777,1778,1782],[1725,679,1721],[733,1293,1458],[1802,1618,1244],[1802,1779,1618],[1788,1783,1779],[1789,1774,1783],[1796,1780,1789],[1796,1119,1780],[1823,1817,325],[1699,1727,1623],[750,1146,1730],[1497,1724,296],[1128,1119,1796],[61,62,71],[1131,413,824],[1114,1111,249],[1784,1776,1775],[1123,723,1283],[1791,1788,1779],[1788,1789,1783],[1095,1797,1074],[1028,1784,1775],[1784,1770,1776],[1777,1790,1778],[1793,1797,1095],[1797,1800,1074],[1798,1790,1770],[1805,1802,1244],[1802,1791,1779],[1792,1789,1788],[1793,1785,1128],[1793,1095,1785],[1074,1800,1619],[741,457,593],[1798,1770,1784],[1798,1794,1790],[1786,1689,1713],[684,1726,1718],[1728,1085,793],[1795,1787,1502],[1806,1802,1805],[1819,1788,1791],[1067,1798,1784],[1790,1794,1778],[1795,1502,1124],[1801,1805,1787],[1807,1791,1802],[1807,1819,1791],[1819,1792,1788],[1799,1128,1796],[994,645,661],[684,1085,1728],[684,1718,1085],[1699,1623,1726],[1801,1787,1795],[1808,1789,1792],[1808,1796,1789],[1799,1793,1128],[1809,1797,1793],[1809,1803,1797],[1803,1800,1797],[1067,1794,1798],[774,255,1778],[1673,1671,1679],[879,1669,888],[19,1807,1802],[1810,1619,1800],[879,994,1669],[1794,774,1778],[1723,1772,148],[1804,1773,1772],[1814,1795,1124],[1649,1814,1124],[1814,1801,1795],[1812,1806,1805],[19,1802,1806],[19,1819,1807],[1810,1800,1803],[1804,624,1773],[1714,1131,824],[1801,1812,1805],[1812,19,1806],[1808,1792,1819],[1799,1809,1793],[1821,1810,1803],[1717,739,1813],[1061,1619,1822],[1794,1817,774],[79,1482,144],[1815,1801,1814],[23,1819,19],[589,1028,1775],[1817,1823,774],[1689,1719,1713],[1824,1814,1649],[1827,1818,1801],[1818,1812,1801],[1818,19,1812],[1818,20,19],[1816,1809,1799],[1821,1803,1809],[1822,1619,1810],[124,708,608],[1663,10,1715],[1815,1827,1801],[1820,1808,1819],[23,1820,1819],[603,1810,1821],[603,1822,1810],[1085,1697,793],[1628,1690,11],[1527,1704,1624],[1730,1072,1729],[1526,1444,1704],[1526,1680,1444],[1704,1444,1701],[1816,1821,1809],[1722,67,68],[317,272,1823],[1716,1713,1721],[16,1628,1767],[1527,1526,1704],[1824,1826,1814],[1814,1826,1815],[1818,21,20],[1835,1808,1820],[603,570,1822],[226,1070,1778],[1013,1181,1179],[1721,679,1664],[1717,1813,1811],[1828,1827,1815],[22,1820,23],[22,1835,1820],[1830,603,1821],[719,1659,5],[643,567,1657],[1717,794,739],[1825,1826,1824],[1828,1815,1826],[1829,21,1818],[1808,1835,13],[4,719,5],[10,1662,1715],[1828,1832,1827],[1832,1818,1827],[12,1833,1816],[1833,1821,1816],[1833,1830,1821],[14,1146,1701],[1186,1829,1818],[1280,603,1830],[14,1700,1146],[1667,1728,1130],[1825,1834,1826],[1834,1828,1826],[1832,1186,1818],[1836,13,1835],[1624,1711,1570],[778,1624,1570],[1719,1725,1721],[1002,1825,1831],[1002,1834,1825],[1834,1832,1828],[1186,21,1829],[1836,1835,22],[1837,1833,12],[1280,1830,1833],[1667,1275,1728],[16,1767,1084],[589,1765,1838],[1765,1781,1838],[1781,1737,1838],[1737,982,1838],[982,1053,1838],[1053,816,1838],[816,589,1838]];

var heap$1 = {exports: {}};

(function (module, exports) {
// Generated by CoffeeScript 1.8.0
(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };


  /*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };


  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function(array, cmp) {
    var i, _i, _len, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };


  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };


  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function(array, n, cmp) {
    var elem, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (_j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  (function(root, factory) {
    {
      return module.exports = factory();
    }
  })(this, function() {
    return Heap;
  });

}).call(commonjsGlobal);
}(heap$1));

var heap = heap$1.exports;

function iota$1(n) {
  var result = new Array(n);
  for(var i=0; i<n; ++i) {
    result[i] = i;
  }
  return result
}

var iota_1 = iota$1;

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
var isBuffer_1 = function (obj) {
  return obj != null && (isBuffer$1(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
};

function isBuffer$1 (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer$1(obj.slice(0, 0))
}

var iota = iota_1;
var isBuffer = isBuffer_1;

var hasTypedArrays  = ((typeof Float64Array) !== "undefined");

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride;
  var terms = new Array(stride.length);
  var i;
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i];
  }
  terms.sort(compare1st);
  var result = new Array(terms.length);
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1];
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("");
  if(dimension < 0) {
    className = "View_Nil" + dtype;
  }
  var useGetters = (dtype === "generic");

  if(dimension === -1) {
    //Special case for trivial arrays
    var code =
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}";
    var procedure = new Function(code);
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}";
    var procedure = new Function("TrivialArray", code);
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"];

  //Create constructor for view
  var indices = iota(dimension);
  var args = indices.map(function(i) { return "i"+i });
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i
      }).join("+");
  var shapeArg = indices.map(function(i) {
      return "b"+i
    }).join(",");
  var strideArg = indices.map(function(i) {
      return "c"+i
    }).join(",");
  code.push(
    "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
      "this.shape=[" + shapeArg + "]",
      "this.stride=[" + strideArg + "]",
      "this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension);

  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
"}})");

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]");
  } else {
    code.push("Object.defineProperty(proto,'order',{get:");
    if(dimension < 4) {
      code.push("function "+className+"_order(){");
      if(dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})");
      }
    } else {
      code.push("ORDER})");
    }
  }

  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){");
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}");
  } else {
    code.push("return this.data["+index_str+"]=v}");
  }

  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){");
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}");
  } else {
    code.push("return this.data["+index_str+"]}");
  }

  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}");

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this.stride["+i + "]"
    }).join(",")+",this.offset)}");

  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" });
  var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" });
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","));
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}");
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}");

  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this.shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this.stride["+i+"]"
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil");
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}");
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}");

  //view.transpose():
  var tShape = new Array(dimension);
  var tStride = new Array(dimension);
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]";
    tStride[i] = "b[i"+i+"]";
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}");

  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset");
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}");
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}");

  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}");

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(isBuffer(data)) {
    return "buffer"
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
      case "[object BigInt64Array]":
        return "bigint64"
      case "[object BigUint64Array]":
        return "biguint64"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "bigint64": [],
  "biguint64": [],
  "buffer":[],
  "generic":[]
}

;
function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0];
    return ctor([])
  } else if(typeof data === "number") {
    data = [data];
  }
  if(shape === undefined) {
    shape = [ data.length ];
  }
  var d = shape.length;
  if(stride === undefined) {
    stride = new Array(d);
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz;
      sz *= shape[i];
    }
  }
  if(offset === undefined) {
    offset = 0;
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i];
      }
    }
  }
  var dtype = arrayDType(data);
  var ctor_list = CACHED_CONSTRUCTORS[dtype];
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1));
  }
  var ctor = ctor_list[d+1];
  return ctor(data, shape, stride, offset)
}

var ndarray$5 = wrappedNDArrayCtor;

var epsilon = 0.000001;

var create_1$1 = create$2;

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create$2() {
    var out = new Float32Array(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out
}

var clone_1$1 = clone$2;

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone$2(a) {
    var out = new Float32Array(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out
}

var fromValues_1$1 = fromValues$2;

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues$2(x, y, z) {
    var out = new Float32Array(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out
}

var normalize_1$1 = normalize$2;

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize$2(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out
}

var dot_1$1 = dot$2;

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot$2(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
}

var angle_1 = angle;

var fromValues$1 = fromValues_1$1;
var normalize$1 = normalize_1$1;
var dot$1 = dot_1$1;

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
    var tempA = fromValues$1(a[0], a[1], a[2]);
    var tempB = fromValues$1(b[0], b[1], b[2]);
 
    normalize$1(tempA, tempA);
    normalize$1(tempB, tempB);
 
    var cosine = dot$1(tempA, tempB);

    if(cosine > 1.0){
        return 0
    } else {
        return Math.acos(cosine)
    }     
}

var copy_1$1 = copy$1;

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy$1(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out
}

var set_1$1 = set$1;

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set$1(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out
}

var equals_1 = equals;

var EPSILON = epsilon;

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0];
  var a1 = a[1];
  var a2 = a[2];
  var b0 = b[0];
  var b1 = b[1];
  var b2 = b[2];
  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)))
}

var exactEquals_1 = exactEquals;

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2]
}

var add_1$1 = add$1;

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add$1(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out
}

var subtract_1$1 = subtract$1;

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract$1(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out
}

var sub = subtract_1$1;

var multiply_1$1 = multiply$1;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply$1(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out
}

var mul = multiply_1$1;

var divide_1$1 = divide$1;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide$1(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out
}

var div = divide_1$1;

var min_1$1 = min$1;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min$1(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out
}

var max_1$1 = max$2;

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max$2(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out
}

var floor_1 = floor;

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out
}

var ceil_1 = ceil;

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out
}

var round_1 = round;

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out
}

var scale_1$2 = scale$2;

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale$2(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out
}

var scaleAndAdd_1$1 = scaleAndAdd$1;

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd$1(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out
}

var distance_1$1 = distance$1;

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance$1(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z)
}

var dist = distance_1$1;

var squaredDistance_1$1 = squaredDistance$1;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance$1(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z
}

var sqrDist = squaredDistance_1$1;

var length_1$1 = length$1;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length$1(a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z)
}

var len$1 = length_1$1;

var squaredLength_1$1 = squaredLength$1;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength$1(a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z
}

var sqrLen = squaredLength_1$1;

var negate_1$1 = negate$1;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate$1(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out
}

var inverse_1$1 = inverse$1;

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse$1(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out
}

var cross_1 = cross;

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out
}

var lerp_1$1 = lerp$1;

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function lerp$1(out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out
}

var random_1$1 = random$1;

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random$1(out, scale) {
    scale = scale || 1.0;

    var r = Math.random() * 2.0 * Math.PI;
    var z = (Math.random() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out
}

var transformMat4_1$1 = transformMat4$2;

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4$2(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out
}

var transformMat3_1 = transformMat3;

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out
}

var transformQuat_1$1 = transformQuat$1;

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat$1(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out
}

var rotateX_1 = rotateX;

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c){
    var by = b[1];
    var bz = b[2];

    // Translate point to the origin
    var py = a[1] - by;
    var pz = a[2] - bz;

    var sc = Math.sin(c);
    var cc = Math.cos(c);

    // perform rotation and translate to correct position
    out[0] = a[0];
    out[1] = by + py * cc - pz * sc;
    out[2] = bz + py * sc + pz * cc;

    return out
}

var rotateY_1 = rotateY;

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c){
    var bx = b[0];
    var bz = b[2];

    // translate point to the origin
    var px = a[0] - bx;
    var pz = a[2] - bz;
    
    var sc = Math.sin(c);
    var cc = Math.cos(c);
  
    // perform rotation and translate to correct position
    out[0] = bx + pz * sc + px * cc;
    out[1] = a[1];
    out[2] = bz + pz * cc - px * sc;
  
    return out
}

var rotateZ_1 = rotateZ;

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c){
    var bx = b[0];
    var by = b[1];

    //Translate point to the origin
    var px = a[0] - bx;
    var py = a[1] - by;
  
    var sc = Math.sin(c);
    var cc = Math.cos(c);

    // perform rotation and translate to correct position
    out[0] = bx + px * cc - py * sc;
    out[1] = by + px * sc + py * cc;
    out[2] = a[2];
  
    return out
}

var forEach_1 = forEach$1;

var vec = create_1$1();

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
function forEach$1(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; 
            vec[1] = a[i+1]; 
            vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; 
            a[i+1] = vec[1]; 
            a[i+2] = vec[2];
        }
        
        return a
}

var glVec3 = {
  EPSILON: epsilon
  , create: create_1$1
  , clone: clone_1$1
  , angle: angle_1
  , fromValues: fromValues_1$1
  , copy: copy_1$1
  , set: set_1$1
  , equals: equals_1
  , exactEquals: exactEquals_1
  , add: add_1$1
  , subtract: subtract_1$1
  , sub: sub
  , multiply: multiply_1$1
  , mul: mul
  , divide: divide_1$1
  , div: div
  , min: min_1$1
  , max: max_1$1
  , floor: floor_1
  , ceil: ceil_1
  , round: round_1
  , scale: scale_1$2
  , scaleAndAdd: scaleAndAdd_1$1
  , distance: distance_1$1
  , dist: dist
  , squaredDistance: squaredDistance_1$1
  , sqrDist: sqrDist
  , length: length_1$1
  , len: len$1
  , squaredLength: squaredLength_1$1
  , sqrLen: sqrLen
  , negate: negate_1$1
  , inverse: inverse_1$1
  , normalize: normalize_1$1
  , dot: dot_1$1
  , cross: cross_1
  , lerp: lerp_1$1
  , random: random_1$1
  , transformMat4: transformMat4_1$1
  , transformMat3: transformMat3_1
  , transformQuat: transformQuat_1$1
  , rotateX: rotateX_1
  , rotateY: rotateY_1
  , rotateZ: rotateZ_1
  , forEach: forEach_1
};

var create_1 = create$1;

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create$1 () {
  var out = new Float32Array(4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out
}

var clone_1 = clone$1;

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
function clone$1 (a) {
  var out = new Float32Array(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out
}

var fromValues_1 = fromValues;

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
function fromValues (x, y, z, w) {
  var out = new Float32Array(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out
}

var copy_1 = copy;

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
function copy (out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out
}

var set_1 = set;

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function set (out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out
}

var add_1 = add;

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function add (out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out
}

var subtract_1 = subtract;

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function subtract (out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out
}

var multiply_1 = multiply;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function multiply (out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out
}

var divide_1 = divide;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function divide (out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out
}

var min_1 = min;

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function min (out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out
}

var max_1 = max$1;

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function max$1 (out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out
}

var scale_1$1 = scale$1;

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
function scale$1 (out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out
}

var scaleAndAdd_1 = scaleAndAdd;

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
function scaleAndAdd (out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  return out
}

var distance_1 = distance;

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
function distance (a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1],
    z = b[2] - a[2],
    w = b[3] - a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w)
}

var squaredDistance_1 = squaredDistance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance (a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1],
    z = b[2] - a[2],
    w = b[3] - a[3];
  return x * x + y * y + z * z + w * w
}

var length_1 = length;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
function length (a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w)
}

var squaredLength_1 = squaredLength;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength (a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  return x * x + y * y + z * z + w * w
}

var negate_1 = negate;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
function negate (out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out
}

var inverse_1 = inverse;

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
function inverse (out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out
}

var normalize_1 = normalize;

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
function normalize (out, a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  var len = x * x + y * y + z * z + w * w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
  }
  return out
}

var dot_1 = dot;

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot (a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]
}

var lerp_1 = lerp;

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
function lerp (out, a, b, t) {
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out
}

var vecNormalize = normalize_1;
var vecScale = scale_1$1;

var random_1 = random;

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
function random (out, scale) {
  scale = scale || 1.0;

  // TODO: This is a pretty awful way of doing this. Find something better.
  out[0] = Math.random();
  out[1] = Math.random();
  out[2] = Math.random();
  out[3] = Math.random();
  vecNormalize(out, out);
  vecScale(out, out, scale);
  return out
}

var transformMat4_1 = transformMat4$1;

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
function transformMat4$1 (out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out
}

var transformQuat_1 = transformQuat;

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
function transformQuat (out, a, q) {
  var x = a[0], y = a[1], z = a[2],
    qx = q[0], qy = q[1], qz = q[2], qw = q[3],

    // calculate quat * vec
    ix = qw * x + qy * z - qz * y,
    iy = qw * y + qz * x - qx * z,
    iz = qw * z + qx * y - qy * x,
    iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out
}

var glVec4 = {
  create: create_1,
  clone: clone_1,
  fromValues: fromValues_1,
  copy: copy_1,
  set: set_1,
  add: add_1,
  subtract: subtract_1,
  multiply: multiply_1,
  divide: divide_1,
  min: min_1,
  max: max_1,
  scale: scale_1$1,
  scaleAndAdd: scaleAndAdd_1,
  distance: distance_1,
  squaredDistance: squaredDistance_1,
  length: length_1,
  squaredLength: squaredLength_1,
  negate: negate_1,
  inverse: inverse_1,
  normalize: normalize_1,
  dot: dot_1,
  lerp: lerp_1,
  random: random_1,
  transformMat4: transformMat4_1,
  transformQuat: transformQuat_1
};

var normals$2 = {};

var DEFAULT_NORMALS_EPSILON = 1e-6;
var DEFAULT_FACE_EPSILON = 1e-6;

//Estimate the vertex normals of a mesh
normals$2.vertexNormals = function(faces, positions, specifiedEpsilon) {

  var N         = positions.length;
  var normals   = new Array(N);
  var epsilon   = specifiedEpsilon === void(0) ? DEFAULT_NORMALS_EPSILON : specifiedEpsilon;

  //Initialize normal array
  for(var i=0; i<N; ++i) {
    normals[i] = [0.0, 0.0, 0.0];
  }

  //Walk over all the faces and add per-vertex contribution to normal weights
  for(var i=0; i<faces.length; ++i) {
    var f = faces[i];
    var p = 0;
    var c = f[f.length-1];
    var n = f[0];
    for(var j=0; j<f.length; ++j) {

      //Shift indices back
      p = c;
      c = n;
      n = f[(j+1) % f.length];

      var v0 = positions[p];
      var v1 = positions[c];
      var v2 = positions[n];

      //Compute infineteismal arcs
      var d01 = new Array(3);
      var m01 = 0.0;
      var d21 = new Array(3);
      var m21 = 0.0;
      for(var k=0; k<3; ++k) {
        d01[k] = v0[k]  - v1[k];
        m01   += d01[k] * d01[k];
        d21[k] = v2[k]  - v1[k];
        m21   += d21[k] * d21[k];
      }

      //Accumulate values in normal
      if(m01 * m21 > epsilon) {
        var norm = normals[c];
        var w = 1.0 / Math.sqrt(m01 * m21);
        for(var k=0; k<3; ++k) {
          var u = (k+1)%3;
          var v = (k+2)%3;
          norm[k] += w * (d21[u] * d01[v] - d21[v] * d01[u]);
        }
      }
    }
  }

  //Scale all normals to unit length
  for(var i=0; i<N; ++i) {
    var norm = normals[i];
    var m = 0.0;
    for(var k=0; k<3; ++k) {
      m += norm[k] * norm[k];
    }
    if(m > epsilon) {
      var w = 1.0 / Math.sqrt(m);
      for(var k=0; k<3; ++k) {
        norm[k] *= w;
      }
    } else {
      for(var k=0; k<3; ++k) {
        norm[k] = 0.0;
      }
    }
  }

  //Return the resulting set of patches
  return normals;
};

//Compute face normals of a mesh
normals$2.faceNormals = function(faces, positions, specifiedEpsilon) {

  var N         = faces.length;
  var normals   = new Array(N);
  var epsilon   = specifiedEpsilon === void(0) ? DEFAULT_FACE_EPSILON : specifiedEpsilon;

  for(var i=0; i<N; ++i) {
    var f = faces[i];
    var pos = new Array(3);
    for(var j=0; j<3; ++j) {
      pos[j] = positions[f[j]];
    }

    var d01 = new Array(3);
    var d21 = new Array(3);
    for(var j=0; j<3; ++j) {
      d01[j] = pos[1][j] - pos[0][j];
      d21[j] = pos[2][j] - pos[0][j];
    }

    var n = new Array(3);
    var l = 0.0;
    for(var j=0; j<3; ++j) {
      var u = (j+1)%3;
      var v = (j+2)%3;
      n[j] = d01[u] * d21[v] - d01[v] * d21[u];
      l += n[j] * n[j];
    }
    if(l > epsilon) {
      l = 1.0 / Math.sqrt(l);
    } else {
      l = 0.0;
    }
    for(var j=0; j<3; ++j) {
      n[j] *= l;
    }
    normals[i] = n;
  }
  return normals;
};

var ndarrayOps = {};

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0];
  for(var i=1; i<len; ++i) {
    b = a;
    a = list[i];
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++;
        continue
      }
      list[ptr++] = a;
    }
  }
  list.length = ptr;
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0];
  for(var i=1; i<len; ++i, b=a) {
    b = a;
    a = list[i];
    if(a !== b) {
      if(i === ptr) {
        ptr++;
        continue
      }
      list[ptr++] = a;
    }
  }
  list.length = ptr;
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare);
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort();
  }
  return unique_eq(list)
}

var uniq$1 = unique;

var uniq = uniq$1;

// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
function innerFill(order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , has_index = proc.indexArgs.length>0
    , code = []
    , vars = []
    , idx=0, pidx=0, i, j;
  for(i=0; i<dimension; ++i) { // Iteration variables
    vars.push(["i",i,"=0"].join(""));
  }
  //Compute scan deltas
  for(j=0; j<nargs; ++j) {
    for(i=0; i<dimension; ++i) {
      pidx = idx;
      idx = order[i];
      if(i === 0) { // The innermost/fastest dimension's delta is simply its stride
        vars.push(["d",j,"s",i,"=t",j,"p",idx].join(""));
      } else { // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
        vars.push(["d",j,"s",i,"=(t",j,"p",idx,"-s",pidx,"*t",j,"p",pidx,")"].join(""));
      }
    }
  }
  if (vars.length > 0) {
    code.push("var " + vars.join(","));
  }  
  //Scan loop
  for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards
    idx = order[i];
    code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""));
  }
  //Push body of inner loop
  code.push(body);
  //Advance scan pointers
  for(i=0; i<dimension; ++i) {
    pidx = idx;
    idx = order[i];
    for(j=0; j<nargs; ++j) {
      code.push(["p",j,"+=d",j,"s",i].join(""));
    }
    if(has_index) {
      if(i > 0) {
        code.push(["index[",pidx,"]-=s",pidx].join(""));
      }
      code.push(["++index[",idx,"]"].join(""));
    }
    code.push("}");
  }
  return code.join("\n")
}

// Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
function outerFill(matched, order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , blockSize = proc.blockSize
    , has_index = proc.indexArgs.length > 0
    , code = [];
  for(var i=0; i<nargs; ++i) {
    code.push(["var offset",i,"=p",i].join(""));
  }
  //Generate loops for unmatched dimensions
  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
  // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
  for(var i=matched; i<dimension; ++i) {
    code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join("")); // Iterate back to front
    code.push(["if(j",i,"<",blockSize,"){"].join("")); // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
    code.push(["s",order[i],"=j",i].join(""));
    code.push(["j",i,"=0"].join(""));
    code.push(["}else{s",order[i],"=",blockSize].join(""));
    code.push(["j",i,"-=",blockSize,"}"].join(""));
    if(has_index) {
      code.push(["index[",order[i],"]=j",i].join(""));
    }
  }
  for(var i=0; i<nargs; ++i) {
    var indexStr = ["offset"+i];
    for(var j=matched; j<dimension; ++j) {
      indexStr.push(["j",j,"*t",i,"p",order[j]].join(""));
    }
    code.push(["p",i,"=(",indexStr.join("+"),")"].join(""));
  }
  code.push(innerFill(order, proc, body));
  for(var i=matched; i<dimension; ++i) {
    code.push("}");
  }
  return code.join("\n")
}

//Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
function countMatches(orders) {
  var matched = 0, dimension = orders[0].length;
  while(matched < dimension) {
    for(var j=1; j<orders.length; ++j) {
      if(orders[j][matched] !== orders[0][matched]) {
        return matched
      }
    }
    ++matched;
  }
  return matched
}

//Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
function processBlock(block, proc, dtypes) {
  var code = block.body;
  var pre = [];
  var post = [];
  for(var i=0; i<block.args.length; ++i) {
    var carg = block.args[i];
    if(carg.count <= 0) {
      continue
    }
    var re = new RegExp(carg.name, "g");
    var ptrStr = "";
    var arrNum = proc.arrayArgs.indexOf(i);
    switch(proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i);
        var offArg = proc.offsetArgs[offArgIndex];
        arrNum = offArg.array;
        ptrStr = "+q" + offArgIndex; // Adds offset to the "pointer" in the array
      case "array":
        ptrStr = "p" + arrNum + ptrStr;
        var localStr = "l" + i;
        var arrStr = "a" + arrNum;
        if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array
          if(carg.count === 1) { // Argument/array used only once(?)
            if(dtypes[arrNum] === "generic") {
              if(carg.lvalue) {
                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")); // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                code = code.replace(re, localStr);
                post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""));
              } else {
                code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""));
              }
            } else {
              code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
            }
          } else if(dtypes[arrNum] === "generic") {
            pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")); // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr);
            if(carg.lvalue) {
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""));
            }
          } else {
            pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")); // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr);
            if(carg.lvalue) {
              post.push([arrStr, "[", ptrStr, "]=", localStr].join(""));
            }
          }
        } else { // Argument to body is a "block"
          var reStrArr = [carg.name], ptrStrArr = [ptrStr];
          for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
            reStrArr.push("\\s*\\[([^\\]]+)\\]");
            ptrStrArr.push("$" + (j+1) + "*t" + arrNum + "b" + j); // Matched index times stride
          }
          re = new RegExp(reStrArr.join(""), "g");
          ptrStr = ptrStrArr.join("+");
          if(dtypes[arrNum] === "generic") {
            /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/
            throw new Error("cwise: Generic arrays not supported in combination with blocks!")
          } else {
            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
          }
        }
      break
      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i));
      break
      case "index":
        code = code.replace(re, "index");
      break
      case "shape":
        code = code.replace(re, "shape");
      break
    }
  }
  return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length);
  var allEqual = true;
  for(var i=0; i<dtypes.length; ++i) {
    var t = dtypes[i];
    var digits = t.match(/\d+/);
    if(!digits) {
      digits = "";
    } else {
      digits = digits[0];
    }
    if(t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits;
    } else {
      summary[i] = t.charAt(0) + digits;
    }
    if(i > 0) {
      allEqual = allEqual && summary[i] === summary[i-1];
    }
  }
  if(allEqual) {
    return summary[0]
  }
  return summary.join("")
}

//Generates a cwise operator
function generateCWiseOp(proc, typesig) {

  //Compute dimension
  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
  var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0;
  var orders = new Array(proc.arrayArgs.length);
  var dtypes = new Array(proc.arrayArgs.length);
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    dtypes[i] = typesig[2*i];
    orders[i] = typesig[2*i+1];
  }
  
  //Determine where block and loop indices start and end
  var blockBegin = [], blockEnd = []; // These indices are exposed as blocks
  var loopBegin = [], loopEnd = []; // These indices are iterated over
  var loopOrders = []; // orders restricted to the loop indices
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    if (proc.arrayBlockIndices[i]<0) {
      loopBegin.push(0);
      loopEnd.push(dimension);
      blockBegin.push(dimension);
      blockEnd.push(dimension+proc.arrayBlockIndices[i]);
    } else {
      loopBegin.push(proc.arrayBlockIndices[i]); // Non-negative
      loopEnd.push(proc.arrayBlockIndices[i]+dimension);
      blockBegin.push(0);
      blockEnd.push(proc.arrayBlockIndices[i]);
    }
    var newOrder = [];
    for(var j=0; j<orders[i].length; j++) {
      if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {
        newOrder.push(orders[i][j]-loopBegin[i]); // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
      }
    }
    loopOrders.push(newOrder);
  }

  //First create arguments for procedure
  var arglist = ["SS"]; // SS is the overall shape over which we iterate
  var code = ["'use strict'"];
  var vars = [];
  
  for(var j=0; j<dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join("")); // The limits for each dimension.
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    arglist.push("a"+i); // Actual data array
    arglist.push("t"+i); // Strides
    arglist.push("p"+i); // Offset in the array at which the data starts (also used for iterating over the data)
    
    for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping
      vars.push(["t",i,"p",j,"=t",i,"[",loopBegin[i]+j,"]"].join(""));
    }
    
    for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration
      vars.push(["t",i,"b",j,"=t",i,"[",blockBegin[i]+j,"]"].join(""));
    }
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i);
  }
  if(proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)"); // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
  }
  if(proc.indexArgs.length > 0) {
    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
    var zeros = new Array(dimension);
    for(var i=0; i<dimension; ++i) {
      zeros[i] = "0";
    }
    vars.push(["index=[", zeros.join(","), "]"].join(""));
  }
  for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations
    var off_arg = proc.offsetArgs[i];
    var init_string = [];
    for(var j=0; j<off_arg.offset.length; ++j) {
      if(off_arg.offset[j] === 0) {
        continue
      } else if(off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "p", j].join(""));      
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""));
      }
    }
    if(init_string.length === 0) {
      vars.push("q" + i + "=0");
    } else {
      vars.push(["q", i, "=", init_string.join("+")].join(""));
    }
  }

  //Prepare this variables
  var thisVars = uniq([].concat(proc.pre.thisVars)
                      .concat(proc.body.thisVars)
                      .concat(proc.post.thisVars));
  vars = vars.concat(thisVars);
  if (vars.length > 0) {
    code.push("var " + vars.join(","));
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    code.push("p"+i+"|=0");
  }
  
  //Inline prelude
  if(proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes));
  }

  //Process body
  var body = processBlock(proc.body, proc, dtypes);
  var matched = countMatches(loopOrders);
  if(matched < dimension) {
    code.push(outerFill(matched, loopOrders[0], proc, body)); // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
  } else {
    code.push(innerFill(loopOrders[0], proc, body));
  }

  //Inline epilog
  if(proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes));
  }
  
  if(proc.debug) {
    console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------");
  }
  
  var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("");
  var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""));
  return f()
}
var compile$2 = generateCWiseOp;

// The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }

var compile$1 = compile$2;

function createThunk$1(proc) {
  var code = ["'use strict'", "var CACHED={}"];
  var vars = [];
  var thunkName = proc.funcName + "_cwise_thunk";
  
  //Build thunk
  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""));
  var typesig = [];
  var string_typesig = [];
  var proc_args = [["array",proc.arrayArgs[0],".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(","+proc.arrayBlockIndices[0]+")"):")"].join("")];
  var shapeLengthConditions = [], shapeConditions = [];
  // Process array arguments
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    var j = proc.arrayArgs[i];
    vars.push(["t", j, "=array", j, ".dtype,",
               "r", j, "=array", j, ".order"].join(""));
    typesig.push("t" + j);
    typesig.push("r" + j);
    string_typesig.push("t"+j);
    string_typesig.push("r"+j+".join()");
    proc_args.push("array" + j + ".data");
    proc_args.push("array" + j + ".stride");
    proc_args.push("array" + j + ".offset|0");
    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)
      shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])));
      shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[i]) + "]");
    }
  }
  // Check for shape equality
  if (proc.arrayArgs.length > 1) {
    code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')");
    code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {");
    code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')");
    code.push("}");
  }
  // Process scalar arguments
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    proc_args.push("scalar" + proc.scalarArgs[i]);
  }
  // Check for cached function (and if not present, generate it)
  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""));
  vars.push("proc=CACHED[type]");
  code.push("var " + vars.join(","));
  
  code.push(["if(!proc){",
             "CACHED[type]=proc=compile([", typesig.join(","), "])}",
             "return proc(", proc_args.join(","), ")}"].join(""));

  if(proc.debug) {
    console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------");
  }
  
  //Compile thunk
  var thunk = new Function("compile", code.join("\n"));
  return thunk(compile$1.bind(undefined, proc))
}

var thunk = createThunk$1;

var createThunk = thunk;

function Procedure() {
  this.argTypes = [];
  this.shimArgs = [];
  this.arrayArgs = [];
  this.arrayBlockIndices = [];
  this.scalarArgs = [];
  this.offsetArgs = [];
  this.offsetArgIndex = [];
  this.indexArgs = [];
  this.shapeArgs = [];
  this.funcName = "";
  this.pre = null;
  this.body = null;
  this.post = null;
  this.debug = false;
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure();
  
  //Parse blocks
  proc.pre    = user_args.pre;
  proc.body   = user_args.body;
  proc.post   = user_args.post;

  //Parse arguments
  var proc_args = user_args.args.slice(0);
  proc.argTypes = proc_args;
  for(var i=0; i<proc_args.length; ++i) {
    var arg_type = proc_args[i];
    if(arg_type === "array" || (typeof arg_type === "object" && arg_type.blockIndices)) {
      proc.argTypes[i] = "array";
      proc.arrayArgs.push(i);
      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);
      proc.shimArgs.push("array" + i);
      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
        throw new Error("cwise: pre() block may not reference array args")
      }
      if(i < proc.post.args.length && proc.post.args[i].count>0) {
        throw new Error("cwise: post() block may not reference array args")
      }
    } else if(arg_type === "scalar") {
      proc.scalarArgs.push(i);
      proc.shimArgs.push("scalar" + i);
    } else if(arg_type === "index") {
      proc.indexArgs.push(i);
      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index")
      }
      if(i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index")
      }
    } else if(arg_type === "shape") {
      proc.shapeArgs.push(i);
      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape")
      }
      if(i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape")
      }
    } else if(typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset";
      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset });
      proc.offsetArgIndex.push(i);
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i])
    }
  }
  
  //Make sure at least one array argument was specified
  if(proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified")
  }
  
  //Make sure arguments are correct
  if(proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block")
  }
  if(proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block")
  }
  if(proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block")
  }

  //Check debug flag
  proc.debug = !!user_args.printCode || !!user_args.debug;
  
  //Retrieve name
  proc.funcName = user_args.funcName || "cwise";
  
  //Read in block size
  proc.blockSize = user_args.blockSize || 64;

  return createThunk(proc)
}

var compiler = compileCwise;

(function (exports) {

var compile = compiler;

var EmptyProc = {
  body: "",
  args: [],
  thisVars: [],
  localVars: []
};

function fixup(x) {
  if(!x) {
    return EmptyProc
  }
  for(var i=0; i<x.args.length; ++i) {
    var a = x.args[i];
    if(i === 0) {
      x.args[i] = {name: a, lvalue:true, rvalue: !!x.rvalue, count:x.count||1 };
    } else {
      x.args[i] = {name: a, lvalue:false, rvalue:true, count: 1};
    }
  }
  if(!x.thisVars) {
    x.thisVars = [];
  }
  if(!x.localVars) {
    x.localVars = [];
  }
  return x
}

function pcompile(user_args) {
  return compile({
    args:     user_args.args,
    pre:      fixup(user_args.pre),
    body:     fixup(user_args.body),
    post:     fixup(user_args.proc),
    funcName: user_args.funcName
  })
}

function makeOp(user_args) {
  var args = [];
  for(var i=0; i<user_args.args.length; ++i) {
    args.push("a"+i);
  }
  var wrapper = new Function("P", [
    "return function ", user_args.funcName, "_ndarrayops(", args.join(","), ") {P(", args.join(","), ");return a0}"
  ].join(""));
  return wrapper(pcompile(user_args))
}

var assign_ops = {
  add:  "+",
  sub:  "-",
  mul:  "*",
  div:  "/",
  mod:  "%",
  band: "&",
  bor:  "|",
  bxor: "^",
  lshift: "<<",
  rshift: ">>",
  rrshift: ">>>"
}
;(function(){
  for(var id in assign_ops) {
    var op = assign_ops[id];
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a","b","c"],
             body: "a=b"+op+"c"},
      funcName: id
    });
    exports[id+"eq"] = makeOp({
      args: ["array","array"],
      body: {args:["a","b"],
             body:"a"+op+"=b"},
      rvalue: true,
      funcName: id+"eq"
    });
    exports[id+"s"] = makeOp({
      args: ["array", "array", "scalar"],
      body: {args:["a","b","s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    });
    exports[id+"seq"] = makeOp({
      args: ["array","scalar"],
      body: {args:["a","s"],
             body:"a"+op+"=s"},
      rvalue: true,
      funcName: id+"seq"
    });
  }
})();

var unary_ops = {
  not: "!",
  bnot: "~",
  neg: "-",
  recip: "1.0/"
}
;(function(){
  for(var id in unary_ops) {
    var op = unary_ops[id];
    exports[id] = makeOp({
      args: ["array", "array"],
      body: {args:["a","b"],
             body:"a="+op+"b"},
      funcName: id
    });
    exports[id+"eq"] = makeOp({
      args: ["array"],
      body: {args:["a"],
             body:"a="+op+"a"},
      rvalue: true,
      count: 2,
      funcName: id+"eq"
    });
  }
})();

var binary_ops = {
  and: "&&",
  or: "||",
  eq: "===",
  neq: "!==",
  lt: "<",
  gt: ">",
  leq: "<=",
  geq: ">="
}
;(function() {
  for(var id in binary_ops) {
    var op = binary_ops[id];
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a", "b", "c"],
             body:"a=b"+op+"c"},
      funcName: id
    });
    exports[id+"s"] = makeOp({
      args: ["array","array","scalar"],
      body: {args:["a", "b", "s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    });
    exports[id+"eq"] = makeOp({
      args: ["array", "array"],
      body: {args:["a", "b"],
             body:"a=a"+op+"b"},
      rvalue:true,
      count:2,
      funcName: id+"eq"
    });
    exports[id+"seq"] = makeOp({
      args: ["array", "scalar"],
      body: {args:["a","s"],
             body:"a=a"+op+"s"},
      rvalue:true,
      count:2,
      funcName: id+"seq"
    });
  }
})();

var math_unary = [
  "abs",
  "acos",
  "asin",
  "atan",
  "ceil",
  "cos",
  "exp",
  "floor",
  "log",
  "round",
  "sin",
  "sqrt",
  "tan"
]
;(function() {
  for(var i=0; i<math_unary.length; ++i) {
    var f = math_unary[i];
    exports[f] = makeOp({
                    args: ["array", "array"],
                    pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                    body: {args:["a","b"], body:"a=this_f(b)", thisVars:["this_f"]},
                    funcName: f
                  });
    exports[f+"eq"] = makeOp({
                      args: ["array"],
                      pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                      body: {args: ["a"], body:"a=this_f(a)", thisVars:["this_f"]},
                      rvalue: true,
                      count: 2,
                      funcName: f+"eq"
                    });
  }
})();

var math_comm = [
  "max",
  "min",
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_comm.length; ++i) {
    var f= math_comm[i];
    exports[f] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f
                });
    exports[f+"s"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f+"s"
                  });
    exports[f+"eq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"eq"
                  });
    exports[f+"seq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"seq"
                  });
  }
})();

var math_noncomm = [
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_noncomm.length; ++i) {
    var f= math_noncomm[i];
    exports[f+"op"] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"op"
                });
    exports[f+"ops"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"ops"
                  });
    exports[f+"opeq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"opeq"
                  });
    exports[f+"opseq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"opseq"
                  });
  }
})();

exports.any = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "if(a){return true}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return false"},
  funcName: "any"
});

exports.all = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1}], body: "if(!x){return false}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "all"
});

exports.sum = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s+=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "sum"
});

exports.prod = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=1"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s*=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "prod"
});

exports.norm2squared = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm2squared"
});
  
exports.norm2 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return Math.sqrt(this_s)"},
  funcName: "norm2"
});
  

exports.norminf = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:4}], body:"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norminf"
});

exports.norm1 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:3}], body: "this_s+=a<0?-a:a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm1"
});

exports.sup = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=-Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 });

exports.inf = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 });

exports.argmin = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
});

exports.argmax = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
});  

exports.random = makeOp({
  args: ["array"],
  pre: {args:[], body:"this_f=Math.random", thisVars:["this_f"]},
  body: {args: ["a"], body:"a=this_f()", thisVars:["this_f"]},
  funcName: "random"
});

exports.assign = makeOp({
  args:["array", "array"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assign" });

exports.assigns = makeOp({
  args:["array", "scalar"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assigns" });


exports.equals = compile({
  args:["array", "array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1},
               {name:"y", lvalue:false, rvalue:true, count:1}], 
        body: "if(x!==y){return false}", 
        localVars: [], 
        thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "equals"
});
}(ndarrayOps));

var scratch$1 = {};

var pool$9 = {};

var twiddle = {};

/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

//Number of bits in an integer
var INT_BITS = 32;

//Constants
twiddle.INT_BITS  = INT_BITS;
twiddle.INT_MAX   =  0x7fffffff;
twiddle.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
twiddle.sign = function(v) {
  return (v > 0) - (v < 0);
};

//Computes absolute value of integer
twiddle.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
};

//Computes minimum of integers x and y
twiddle.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
};

//Computes maximum of integers x and y
twiddle.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
};

//Checks if a number is a power of two
twiddle.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
};

//Computes log base 2 of v
twiddle.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
};

//Computes log base 10 of v
twiddle.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
};

//Counts number of bits
twiddle.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
};

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
twiddle.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
twiddle.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
};

//Rounds down to previous power of 2
twiddle.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
};

//Computes parity of word
twiddle.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
};

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
twiddle.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
};

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
twiddle.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
};

//Extracts the nth interleaved component
twiddle.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
};


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
twiddle.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
};

//Extracts nth interleaved component of a 3-tuple
twiddle.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
};

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
twiddle.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
};

function dupe_array(count, value, i) {
  var c = count[i]|0;
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j;
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value;
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1);
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i;
  result = new Array(count);
  for(i=0; i<count; ++i) {
    result[i] = value;
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0;
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

var dup$1 = dupe;

var buffer = {};

var base64Js = {};

base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens (b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4);

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen;

  var i;
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = (tmp >> 16) & 0xFF;
    arr[curByte++] = (tmp >> 8) & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4);
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2);
    arr[curByte++] = (tmp >> 8) & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    );
  }

  return parts.join('')
}

var ieee754 = {};

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = (nBytes * 8) - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
};

ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = (nBytes * 8) - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

(function (exports) {

var base64 = base64Js;
var ieee754$1 = ieee754;
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null;

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  );
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    var proto = { foo: function () { return 42 } };
    Object.setPrototypeOf(proto, Uint8Array.prototype);
    Object.setPrototypeOf(arr, proto);
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
});

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
});

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192; // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf();
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value);
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
};

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
};

function allocUnsafe (size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
};

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);

  var actual = buf.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    var copy = new Uint8Array(arrayView);
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf;
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype);

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len);
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
};

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
};

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        Buffer.from(buf).copy(buffer, pos);
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        );
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos);
    }
    pos += buf.length;
  }
  return buffer
};

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length;
  var mustMatch = (arguments.length > 2 && arguments[2] === true);
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString (encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;

function swap (b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this
};

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this
};

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this
};

Buffer.prototype.toString = function toString () {
  var length = this.length;
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
};

Buffer.prototype.toLocaleString = Buffer.prototype.toString;

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
};

Buffer.prototype.inspect = function inspect () {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  if (this.length > max) str += ' ... ';
  return '<Buffer ' + str + '>'
};
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength);
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1);
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
};

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
};

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
};

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  var strLen = string.length;

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed;
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;
    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
};

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]];
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (var i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf = this.subarray(start, end);
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype);

  return newBuf
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val
};

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val
};

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset]
};

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8)
};

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1]
};

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
};

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
};

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
};

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
};

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
};

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754$1.read(this, offset, true, 23, 4)
};

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754$1.read(this, offset, false, 23, 4)
};

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754$1.read(this, offset, true, 52, 8)
};

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754$1.read(this, offset, false, 52, 8)
};

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = (value & 0xff);
  this[offset + 1] = (value >>> 8);
  return offset + 2
};

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = (value >>> 8);
  this[offset + 1] = (value & 0xff);
  return offset + 2
};

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = (value >>> 24);
  this[offset + 2] = (value >>> 16);
  this[offset + 1] = (value >>> 8);
  this[offset] = (value & 0xff);
  return offset + 4
};

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = (value >>> 24);
  this[offset + 1] = (value >>> 16);
  this[offset + 2] = (value >>> 8);
  this[offset + 3] = (value & 0xff);
  return offset + 4
};

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = (value & 0xff);
  this[offset + 1] = (value >>> 8);
  return offset + 2
};

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = (value >>> 8);
  this[offset + 1] = (value & 0xff);
  return offset + 2
};

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = (value & 0xff);
  this[offset + 1] = (value >>> 8);
  this[offset + 2] = (value >>> 16);
  this[offset + 3] = (value >>> 24);
  return offset + 4
};

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = (value >>> 24);
  this[offset + 1] = (value >>> 16);
  this[offset + 2] = (value >>> 8);
  this[offset + 3] = (value & 0xff);
  return offset + 4
};

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
};

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
};

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    );
  }

  return len
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } else if (typeof val === 'boolean') {
    val = Number(val);
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding);
    var len = bytes.length;
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0];
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }

        // valid lead
        leadSurrogate = codePoint;

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef';
  var table = new Array(256);
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16;
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j];
    }
  }
  return table
})();
}(buffer));

var bits = twiddle;
var dup = dup$1;
var Buffer = buffer.Buffer;

//Legacy pool support
if(!commonjsGlobal.__TYPEDARRAY_POOL) {
  commonjsGlobal.__TYPEDARRAY_POOL = {
      UINT8     : dup([32, 0])
    , UINT16    : dup([32, 0])
    , UINT32    : dup([32, 0])
    , BIGUINT64 : dup([32, 0])
    , INT8      : dup([32, 0])
    , INT16     : dup([32, 0])
    , INT32     : dup([32, 0])
    , BIGINT64  : dup([32, 0])
    , FLOAT     : dup([32, 0])
    , DOUBLE    : dup([32, 0])
    , DATA      : dup([32, 0])
    , UINT8C    : dup([32, 0])
    , BUFFER    : dup([32, 0])
  };
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined';
var hasBigUint64 = (typeof BigUint64Array) !== 'undefined';
var hasBigInt64 = (typeof BigInt64Array) !== 'undefined';
var POOL = commonjsGlobal.__TYPEDARRAY_POOL;

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0]);
}
if(!POOL.BIGUINT64) {
  POOL.BIGUINT64 = dup([32, 0]);
}
if(!POOL.BIGINT64) {
  POOL.BIGINT64 = dup([32, 0]);
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0]);
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER;

pool$9.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array);
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer;
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength;
    var log_n = bits.log2(n)|0;
    DATA[log_n].push(array);
  }
};

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength;
  var log_n = bits.log2(n);
  DATA[log_n].push(buffer);
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer);
}

pool$9.freeUint8 =
pool$9.freeUint16 =
pool$9.freeUint32 =
pool$9.freeBigUint64 =
pool$9.freeInt8 =
pool$9.freeInt16 =
pool$9.freeInt32 =
pool$9.freeBigInt64 =
pool$9.freeFloat32 = 
pool$9.freeFloat =
pool$9.freeFloat64 = 
pool$9.freeDouble = 
pool$9.freeUint8Clamped = 
pool$9.freeDataView = freeTypedArray;

pool$9.freeArrayBuffer = freeArrayBuffer;

pool$9.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array);
};

pool$9.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'bigint64':
        return mallocBigInt64(n)
      case 'biguint64':
        return mallocBigUint64(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
};

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n);
  var log_n = bits.log2(n);
  var d = DATA[log_n];
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
pool$9.mallocArrayBuffer = mallocArrayBuffer;

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
pool$9.mallocUint8 = mallocUint8;

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
pool$9.mallocUint16 = mallocUint16;

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
pool$9.mallocUint32 = mallocUint32;

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
pool$9.mallocInt8 = mallocInt8;

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
pool$9.mallocInt16 = mallocInt16;

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
pool$9.mallocInt32 = mallocInt32;

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
pool$9.mallocFloat32 = pool$9.mallocFloat = mallocFloat;

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
pool$9.mallocFloat64 = pool$9.mallocDouble = mallocDouble;

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
pool$9.mallocUint8Clamped = mallocUint8Clamped;

function mallocBigUint64(n) {
  if(hasBigUint64) {
    return new BigUint64Array(mallocArrayBuffer(8*n), 0, n)
  } else {
    return null;
  }
}
pool$9.mallocBigUint64 = mallocBigUint64;

function mallocBigInt64(n) {
  if (hasBigInt64) {
    return new BigInt64Array(mallocArrayBuffer(8*n), 0, n)
  } else {
    return null;
  }
}
pool$9.mallocBigInt64 = mallocBigInt64;

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
pool$9.mallocDataView = mallocDataView;

function mallocBuffer(n) {
  n = bits.nextPow2(n);
  var log_n = bits.log2(n);
  var cache = BUFFER[log_n];
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
pool$9.mallocBuffer = mallocBuffer;

pool$9.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0;
    POOL.UINT16[i].length = 0;
    POOL.UINT32[i].length = 0;
    POOL.INT8[i].length = 0;
    POOL.INT16[i].length = 0;
    POOL.INT32[i].length = 0;
    POOL.FLOAT[i].length = 0;
    POOL.DOUBLE[i].length = 0;
    POOL.BIGUINT64[i].length = 0;
    POOL.BIGINT64[i].length = 0;
    POOL.UINT8C[i].length = 0;
    DATA[i].length = 0;
    BUFFER[i].length = 0;
  }
};

var ndarray$4 = ndarray$5;
var ops$1 = ndarrayOps;
var pool$8 = pool$9;

function clone(array) {
  var dtype = array.dtype;
  if(dtype === "generic" || dtype === "array") {
    dtype = "double";
  }
  var data = pool$8.malloc(array.size, dtype);
  var result = ndarray$4(data, array.shape);
  ops$1.assign(result, array);
  return result
}
scratch$1.clone = clone;

function malloc(shape, dtype) {
  if(!dtype) {
    dtype = "double";
  }
  var sz = 1;
  var stride = new Array(shape.length);
  for(var i=shape.length-1; i>=0; --i) {
    stride[i] = sz;
    sz *= shape[i];
  }
  return ndarray$4(pool$8.malloc(sz, dtype), shape, stride, 0)
}
scratch$1.malloc = malloc;

function free(array) {
  if(array.dtype === "generic" || array.dtype === "array") {
    return
  }
  pool$8.free(array.data);
}
scratch$1.free = free;

function zeros(shape, dtype) {
  if(!dtype) {
    dtype = "double";
  }

  var sz = 1;
  var stride = new Array(shape.length);
  for(var i=shape.length-1; i>=0; --i) {
    stride[i] = sz;
    sz *= shape[i];
  }
  var buf = pool$8.malloc(sz, dtype);
  for(var i=0; i<sz; ++i) {
    buf[i] = 0;
  }
  return ndarray$4(buf, shape, stride, 0)
}
scratch$1.zeros = zeros;

function ones(shape, dtype) {
  if(!dtype) {
    dtype = "double";
  }

  var sz = 1;
  var stride = new Array(shape.length);
  for(var i=shape.length-1; i>=0; --i) {
    stride[i] = sz;
    sz *= shape[i];
  }
  var buf = pool$8.malloc(sz, dtype);
  for(var i=0; i<sz; ++i) {
    buf[i] = 1;
  }
  return ndarray$4(buf, shape, stride, 0)
}
scratch$1.ones = ones;

function eye(shape, dtype) {
  var i, offset;
  if(!dtype) {
    dtype = "double";
  }

  var sz = 1;
  var stride = new Array(shape.length);
  for(i=shape.length-1; i>=0; --i) {
    stride[i] = sz;
    sz *= shape[i];
  }
  var buf = pool$8.malloc(sz, dtype);
  for(i=0; i<sz; ++i) {
    buf[i] = 0;
  }
  var mindim = Infinity;
  var offsum = 0;
  for( i=shape.length-1; i>=0; i--) {
    offsum += stride[i];
    mindim = Math.min(mindim,shape[i]);
  }
  for(i=0,offset=0; i<mindim; i++,offset+=offsum) {
    buf[offset] = 1;
  }
  return ndarray$4(buf, shape, stride, 0)
}
scratch$1.eye = eye;

var ndscratch = scratch$1;

var ndarrayLuSolve = function (L, U, B, X, Y) {
    var m = L.shape[0], n = L.shape[1], freeY = false;
    if (U.dimension === 1) {
        Y = X;
        X = B;
        B = U;
        U = L;
    }
    if (!X) X = ndscratch.malloc([m]);
    if (!Y) {
        Y = ndscratch.malloc([m]);
        freeY = true;
    }
    
    // LY = B, solve for Y
    for (var y = 0; y < n; y++) {
        var c = 0;
        for (var x = 0; x < y; x++) {
            c += L.get(x, y) * Y.get(x);
        }
        Y.set(y, (B.get(y) - c) / L.get(y, y));
    }
    
    //UX = Y, solve for X
    for (var y = n - 1; y >= 0; y--) {
        var c = 0;
        for (var x = n - 1; x > y; x--) {
            c += U.get(x, y) * X.get(x);
        }
        X.set(y, Y.get(y) - c);
    }
    
    if (freeY) ndscratch.free(Y);
    
    return X;
};

var ndarrayCroutDecomposition = function (A, L, U) {
    var m = A.shape[0];
    var n = A.shape[1];
    if (m !== n) return false; // non-square
    if (L && !U) U = L;
    
    // diagonalize U
    for (var i = 0; i < n; i++) {
        U.set(i, i, 1);
    }
    
    for (var j = 0; j < n; j++) {
        for (var i = j; i < n; i++) {
            var sum = 0;
            for (var k = 0; k < j; k++) {
                sum += L.get(k,i) * U.get(j,k);  
            }
            L.set(j, i, A.get(j,i) - sum);
        }

        var denom = L.get(j,j);
        if (denom === 0) return false;

        for (var i = j+1; i < n; i++){
            var sum = 0;
            for (var k = 0; k < j; k++){
                sum += L.get(k,j) * U.get(i, k);
            }
            U.set(i, j, (A.get(i,j) - sum) / denom);
        }
    }
    return true;
};

var solve$1 = ndarrayLuSolve;
var crout = ndarrayCroutDecomposition;
var scratch = scratch$1;

var ndarrayLinearSolve = function (X, A, B) {
    //Validate inputs
    if (A.dimension !== 2) throw new Error('not a 2-dimensional matrix');
    var m = A.shape[0], n = A.shape[1];
    if (m !== n) throw new Error('not a square matrix: ' + m + 'x' + n);
    if (B.dimension !== 1) throw new Error('B is not a vector');
    if (B.shape[0] !== m) throw new Error('B has an invalid length');
    if (X.dimension !== 1) throw new Error('X is not a vector');
    if (X.shape[0] !== m) throw new Error('X has an invalid length');
    
    //TODO: Implement other solvers based on the format of M
    //
    //  Would be nice to have:
    //
    //      * QR factorization for rectangular matrices
    //      * Cholesky/LDL solver for positive semidefinite matrices
    //      * Sparse solvers
    //      

    return denseGeneralSolve(m, X, A, B)
};

//TODO: Switch this to LUP eventually for better numerical stability and to support large matrices
function denseGeneralSolve(m, X, A, B) {
    var L = scratch.malloc([ m, m ]);
    var ok = crout(A, L, L);
    if (!ok) {
        scratch.free(L);
        return false;
    }
    var Y = scratch.malloc([ m ]);
    var res = solve$1(L, L, B, X, Y);
    scratch.free(Y);
    scratch.free(L);
    return !!res;
}

function removeOrphanVertices(cells, positions) {
  var newPositions = [];
  var indexLookup = {};

  var newCells = cells.map(function(cell) {
    return cell.map(function(index) {
      if(indexLookup[index] === undefined) {
        indexLookup[index] = newPositions.length;
        newPositions.push(positions[index]);
      }
      return indexLookup[index];
    });
  });

  return {
    cells: newCells,
    positions: newPositions
  };
}

var removeOrphanVertices_1 = removeOrphanVertices;

function arrayEqual(a, b) {
  if(a.length !== b.length) {
    return false;
  }

  for(var i=0; i<a.length; i++) {
    if(a[i] !== b[i]) {
      return false;
    }
  }

  return true;
}

function integerEqual(a, b) {
  return a === b;
}

function removeDegenerateCells(cells, positions) {
  var equal = integerEqual;
  if(positions) {
    equal = arrayEqual;
  }

  return cells.filter(function(cell) {
    if(positions) {
      cell = cell.map(function(index) {
        return positions[index];
      });
    }

    for(var i=0; i<cell.length; i++) {
      for(var j=0; j<cell.length; j++) {
        if(i != j && equal(cell[i], cell[j])) {
          return false;
        }
      }
    }
    return true;
  });
}

var removeDegenerateCells_1 = removeDegenerateCells;

var Heap = heap;
var ndarray$3 = ndarray$5;
var vec3 = glVec3;
var vec4 = glVec4;
var normals$1 = normals$2.faceNormals;
var ops = ndarrayOps;
var solve = ndarrayLinearSolve;
var removeOrphans = removeOrphanVertices_1;
var removeDegenerates = removeDegenerateCells_1;

function vertexError(vertex, quadratic) {
  var xformed = new Array(4);
  vec4.transformMat4(xformed, vertex, quadratic);
  return vec4.dot(vertex, xformed);
}
function optimalPosition(v1, v2) {
  var q1 = v1.error;
  var q2 = v2.error;
  var costMatrix = ndarray$3(new Float32Array(4 * 4), [4, 4]);
  ops.add(costMatrix, q1, q2);
  var mat4Cost = Array.from(costMatrix.data);
  var optimal = ndarray$3(new Float32Array(4));
  var toInvert = costMatrix;
  toInvert.set(0, 3, 0);
  toInvert.set(1, 3, 0);
  toInvert.set(2, 3, 0);
  toInvert.set(3, 3, 1);
  var solved = solve(optimal, toInvert, ndarray$3([0, 0, 0, 1]));

  if (!solved) {
    var v1Homogenous = Array.from(v1.position);
    v1Homogenous.push(1);
    var v2Homogenous = Array.from(v2.position);
    v2Homogenous.push(1);
    var midpoint = vec3.add(new Array(3), v1.position, v2.position);
    vec3.scale(midpoint, midpoint, 0.5);
    midpoint.push(1);
    var v1Error = vertexError(v1Homogenous, mat4Cost);
    var v2Error = vertexError(v2Homogenous, mat4Cost);
    var midpointError = vertexError(midpoint, mat4Cost);
    var minimum = Math.min([v1Error, v2Error, midpointError]);
    if (v1Error == minimum) {
      optimal = v1Homogenous;
    } else if (v2Error == minimum) {
      optimal = v2Homogenous;
    } else {
      optimal = midpoint;
    }
  } else {
    optimal = optimal.data;
  }

  var error = vertexError(optimal, mat4Cost);
  return {vertex: optimal.slice(0, 3), error: error};
}
var meshSimplify = function(cells, positions, faceNormals, threshold = 0) {
  cells = removeDegenerates(cells);

  if (!faceNormals) {
    faceNormals = normals$1(cells, positions);
  }

  var n = positions.length;
  var vertices = positions.map(function(p, i) {
    return {
      position: p,
      index: i,
      pairs: [],
      error: ndarray$3(new Float32Array(4 * 4).fill(0), [4, 4])
    }
  });

  cells.map(function(cell) {
    for (var i = 0; i < 2; i++) {
      var j = (i + 1) % 3;
      var v1 = cell[i];
      var v2 = cell[j];
      // consistent ordering to prevent double entries
      if (v1 < v2) {
        vertices[v1].pairs.push(v2);
      } else {
        vertices[v2].pairs.push(v1);
      }
    }
  });

  if (threshold > 0) {
    for (var i = 0; i < n; i++) {
      for (var j = i - 1; j >= 0; j--) {
        if (vec3.distance(cells[i], cells[j]) < threshold) {
          if (i < j) {
            vertices[i].pairs.push(vertices[j]);
          } else {
            vertices[j].pairs.push(vertices[i]);
          }
        }
      }
    }
  }

  cells.map(function(cell, cellId) {
    var normal = faceNormals[cellId];
    // [a, b, c, d] where plane is defined by a*x+by+cz+d=0
    // choose the first vertex WLOG
    var pointOnTri = positions[cell[0]];
    var plane = [normal[0], normal[1], normal[2], -vec3.dot(normal, pointOnTri)];

    cell.map(function(vertexId) {
      var errorQuadric = ndarray$3(new Float32Array(4 * 4), [4, 4]);
      for (var i = 0; i < 4; i++) {
        for (var j = i; j >= 0; j--) {
          var value = plane[i] * plane[j];
          errorQuadric.set(i, j, value);
          if (i != j) {
            errorQuadric.set(j, i, value);
          }
        }
      }

      var existingQuadric = vertices[vertexId].error;
      ops.add(existingQuadric, existingQuadric, errorQuadric);
    });
  });

  var costs = new Heap(function(a, b) {
    return a.cost - b.cost;
  });

  var edges = [];
  vertices.map(function(v1) {
    v1.pairs.map(function(v2Index) {
      var v2 = vertices[v2Index];
      var optimal = optimalPosition(v1, v2);

      var edge = {
        pair: [v1.index, v2Index],
        cost: optimal.error,
        optimalPosition: optimal.vertex
      };

      costs.push(edge);
      // to update costs
      edges.push(edge);
    });
  });

  var n = positions.length;
  return function(targetCount) {
    // deep-copy trick: https://stackoverflow.com/questions/597588/how-do-you-clone-an-array-of-objects-in-javascript
    var newCells = JSON.parse(JSON.stringify(cells));
    var deletedCount = 0;

    while (n - deletedCount > targetCount) {
      var leastCost = costs.pop();
      var i1 = leastCost.pair[0];
      var i2 = leastCost.pair[1];
      if (i1 == i2) {
        // edge has already been collapsed
        continue;
      }
      vertices[i1].position = leastCost.optimalPosition;

      for (var i = newCells.length - 1; i >= 0; i--) {
        var cell = newCells[i];
        var cellIndex2 = cell.indexOf(i2);
        if (cellIndex2 != -1) {
          if (cell.indexOf(i1) != -1) {
            // Delete cells with zero area, as v1 == v2 now
            newCells.splice(i, 1);
          }

          cell[cellIndex2] = i1;
        }
      }

      var v1 = vertices[i1];
      edges.map(function(edge, i) {
        var edgeIndex1 = edge.pair.indexOf(i1);
        var edgeIndex2 = edge.pair.indexOf(i2);

        if (edgeIndex1 != -1 && edgeIndex2 != -1) {
          edge.pair[edgeIndex2] = i1;
          return;
        }

        if (edge.pair.indexOf(i1) != -1) {
          var optimal = optimalPosition(v1, vertices[edge.pair[(edgeIndex1 + 1) % 2]]);
          edge.optimalPosition = optimal.vertex;
          edge.cost = optimal.error;
        }

        if (edge.pair.indexOf(i2) != -1) {
          // use v1 as that is the new position of v2
          var optimal = optimalPosition(v1, vertices[edge.pair[(edgeIndex2 + 1) % 2]]);
          edge.pair[edgeIndex2] = i1;
          edge.optimalPosition = optimal.vertex;
          edge.cost = optimal.error;
        }
      });

      costs.heapify();
      deletedCount++;
    }

    return removeOrphans(newCells, vertices.map(function(p) {
      return p.position
    }));
  };
};

var refine = {exports: {}};

var np2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1
};

var pool$7      = pool$9;
var nextPow2$1  = np2;

var mesh = createMesh$1;

function Mesh(numCells, cells, numVerts, verts, normals) {
  this.numCells = numCells;
  this.cells    = cells;
  this.numVerts = numVerts;
  this.verts    = verts;
  this.normals  = normals;
}

var proto = Mesh.prototype;

function unpackTriples(count, data) {
  var unpacked = new Array(count);
  for(var i=0; i<count; ++i) {
    unpacked[i] = [
      data[3*i],
      data[3*i+1],
      data[3*i+2]
    ];
  }
  return unpacked
}

proto.unpack = function() {
  return {
    cells:     unpackTriples(this.numCells, this.cells),
    positions: unpackTriples(this.numVerts, this.verts),
    normals:   unpackTriples(this.numVerts, this.normals)
  }
};

proto.dispose = function() {
  pool$7.free(this.cells);
  pool$7.free(this.verts);
  pool$7.free(this.normals);
};

function packCells(cells) {
  var n = cells.length;
  var result = pool$7.mallocInt32(nextPow2$1(3 * n));
  var ptr = 0;
  for(var i=0; i<n; ++i) {
    var c = cells[i];
    for(var j=0; j<3; ++j) {
      result[ptr++] = c[j];
    }
  }
  return result
}

function packVerts(positions) {
  var n = positions.length;
  var result = pool$7.mallocFloat32(nextPow2$1(3 * n));
  var ptr = 0;
  for(var i=0; i<n; ++i) {
    var p = positions[i];
    for(var j=0; j<3; ++j) {
      result[ptr++] = p[j];
    }
  }
  return result
}


function createMesh$1(cells, positions, normals) {
  return new Mesh(
    cells.length,     packCells(cells),
    positions.length, packVerts(positions), packVerts(normals))
}

var pool$6 = pool$9;

var INSERTION_SORT_THRESHOLD = 32;

function getMallocFree(dtype) {
  switch(dtype) {
    case "uint8":
      return [pool$6.mallocUint8, pool$6.freeUint8]
    case "uint16":
      return [pool$6.mallocUint16, pool$6.freeUint16]
    case "uint32":
      return [pool$6.mallocUint32, pool$6.freeUint32]
    case "int8":
      return [pool$6.mallocInt8, pool$6.freeInt8]
    case "int16":
      return [pool$6.mallocInt16, pool$6.freeInt16]
    case "int32":
      return [pool$6.mallocInt32, pool$6.freeInt32]
    case "float32":
      return [pool$6.mallocFloat, pool$6.freeFloat]
    case "float64":
      return [pool$6.mallocDouble, pool$6.freeDouble]
    default:
      return null
  }
}

function shapeArgs(dimension) {
  var args = [];
  for(var i=0; i<dimension; ++i) {
    args.push("s"+i);
  }
  for(var i=0; i<dimension; ++i) {
    args.push("n"+i);
  }
  for(var i=1; i<dimension; ++i) {
    args.push("d"+i);
  }
  for(var i=1; i<dimension; ++i) {
    args.push("e"+i);
  }
  for(var i=1; i<dimension; ++i) {
    args.push("f"+i);
  }
  return args
}

function createInsertionSort(order, dtype) {

  var code = ["'use strict'"];
  var funcName = ["ndarrayInsertionSort", order.join("d"), dtype].join("");
  var funcArgs = ["left", "right", "data", "offset" ].concat(shapeArgs(order.length));
  var allocator = getMallocFree(dtype);
  
  var vars = [ "i,j,cptr,ptr=left*s0+offset" ];
  
  if(order.length > 1) {
    var scratch_shape = [];
    for(var i=1; i<order.length; ++i) {
      vars.push("i"+i);
      scratch_shape.push("n"+i);
    }
    if(allocator) {
      vars.push("scratch=malloc(" + scratch_shape.join("*") + ")");
    } else {
      vars.push("scratch=new Array("+scratch_shape.join("*") + ")");
    }
    vars.push("dptr","sptr","a","b");
  } else {
    vars.push("scratch");
  }
  
  function dataRead(ptr) {
    if(dtype === "generic") {
      return ["data.get(", ptr, ")"].join("")
    }
    return ["data[",ptr,"]"].join("")
  }
  
  function dataWrite(ptr, v) {
    if(dtype === "generic") {
      return ["data.set(", ptr, ",", v, ")"].join("")
    }
    return ["data[",ptr,"]=",v].join("")
  }
  
  //Create function header
  code.push(
    ["function ", funcName, "(", funcArgs.join(","), "){var ", vars.join(",")].join(""),
      "for(i=left+1;i<=right;++i){",
        "j=i;ptr+=s0",
        "cptr=ptr");
  
  
  if(order.length > 1) {
  
    //Copy data into scratch
    code.push("dptr=0;sptr=ptr");
    for(var i=order.length-1; i>=0; --i) {
      var j = order[i];
      if(j === 0) {
        continue
      }
      code.push(["for(i",j,"=0;i",j,"<n",j,";++i",j,"){"].join(""));
    }
    code.push("scratch[dptr++]=",dataRead("sptr"));
    for(var i=0; i<order.length; ++i) {
      var j = order[i];
      if(j === 0) {
        continue
      }
      code.push("sptr+=d"+j,"}");
    }

    
    //Compare items in outer loop
    code.push("__g:while(j-->left){",
              "dptr=0",
              "sptr=cptr-s0");
    for(var i=1; i<order.length; ++i) {
      if(i === 1) {
        code.push("__l:");
      }
      code.push(["for(i",i,"=0;i",i,"<n",i,";++i",i,"){"].join(""));
    }
    code.push(["a=", dataRead("sptr"),"\nb=scratch[dptr]\nif(a<b){break __g}\nif(a>b){break __l}"].join(""));
    for(var i=order.length-1; i>=1; --i) {
      code.push(
        "sptr+=e"+i,
        "dptr+=f"+i,
        "}");
    }
    
    //Copy data back
    code.push("dptr=cptr;sptr=cptr-s0");
    for(var i=order.length-1; i>=0; --i) {
      var j = order[i];
      if(j === 0) {
        continue
      }
      code.push(["for(i",j,"=0;i",j,"<n",j,";++i",j,"){"].join(""));
    }
    code.push(dataWrite("dptr", dataRead("sptr")));
    for(var i=0; i<order.length; ++i) {
      var j = order[i];
      if(j === 0) {
        continue
      }
      code.push(["dptr+=d",j,";sptr+=d",j].join(""),"}");
    }
    
    //Close while loop
    code.push("cptr-=s0\n}");

    //Copy scratch into cptr
    code.push("dptr=cptr;sptr=0");
    for(var i=order.length-1; i>=0; --i) {
      var j = order[i];
      if(j === 0) {
        continue
      }
      code.push(["for(i",j,"=0;i",j,"<n",j,";++i",j,"){"].join(""));
    }
    code.push(dataWrite("dptr", "scratch[sptr++]"));
    for(var i=0; i<order.length; ++i) {
      var j = order[i];
      if(j === 0) {
        continue
      }
      code.push("dptr+=d"+j,"}");
    }
  } else {
    code.push("scratch=" + dataRead("ptr"),
              "while((j-->left)&&("+dataRead("cptr-s0")+">scratch)){",
                dataWrite("cptr", dataRead("cptr-s0")),
                "cptr-=s0",
              "}",
              dataWrite("cptr", "scratch"));
  }
  
  //Close outer loop body
  code.push("}");
  if(order.length > 1 && allocator) {
    code.push("free(scratch)");
  }
  code.push("} return " + funcName);
  
  //Compile and link function
  if(allocator) {
    var result = new Function("malloc", "free", code.join("\n"));
    return result(allocator[0], allocator[1])
  } else {
    var result = new Function(code.join("\n"));
    return result()
  }
}

function createQuickSort(order, dtype, insertionSort) {
  var code = [ "'use strict'" ];
  var funcName = ["ndarrayQuickSort", order.join("d"), dtype].join("");
  var funcArgs = ["left", "right", "data", "offset" ].concat(shapeArgs(order.length));
  var allocator = getMallocFree(dtype);
  var labelCounter=0;
  
  code.push(["function ", funcName, "(", funcArgs.join(","), "){"].join(""));
  
  var vars = [
    "sixth=((right-left+1)/6)|0",
    "index1=left+sixth",
    "index5=right-sixth",
    "index3=(left+right)>>1",
    "index2=index3-sixth",
    "index4=index3+sixth",
    "el1=index1",
    "el2=index2",
    "el3=index3",
    "el4=index4",
    "el5=index5",
    "less=left+1",
    "great=right-1",
    "pivots_are_equal=true",
    "tmp",
    "tmp0",
    "x",
    "y",
    "z",
    "k",
    "ptr0",
    "ptr1",
    "ptr2",
    "comp_pivot1=0",
    "comp_pivot2=0",
    "comp=0"
  ];
  
  if(order.length > 1) {
    var ele_size = [];
    for(var i=1; i<order.length; ++i) {
      ele_size.push("n"+i);
      vars.push("i"+i);
    }
    for(var i=0; i<8; ++i) {
      vars.push("b_ptr"+i);
    }
    vars.push(
      "ptr3",
      "ptr4",
      "ptr5",
      "ptr6",
      "ptr7",
      "pivot_ptr",
      "ptr_shift",
      "elementSize="+ele_size.join("*"));
    if(allocator) {
      vars.push("pivot1=malloc(elementSize)",
                "pivot2=malloc(elementSize)");
    } else {
      vars.push("pivot1=new Array(elementSize),pivot2=new Array(elementSize)");
    }
  } else {
    vars.push("pivot1", "pivot2");
  }
  
  //Initialize local variables
  code.push("var " + vars.join(","));
  
  function toPointer(v) {
    return ["(offset+",v,"*s0)"].join("")
  }
  
  function dataRead(ptr) {
    if(dtype === "generic") {
      return ["data.get(", ptr, ")"].join("")
    }
    return ["data[",ptr,"]"].join("")
  }
  
  function dataWrite(ptr, v) {
    if(dtype === "generic") {
      return ["data.set(", ptr, ",", v, ")"].join("")
    }
    return ["data[",ptr,"]=",v].join("")
  }
  
  function cacheLoop(ptrs, usePivot, body) {
    if(ptrs.length === 1) {
      code.push("ptr0="+toPointer(ptrs[0]));
    } else {
      for(var i=0; i<ptrs.length; ++i) {
        code.push(["b_ptr",i,"=s0*",ptrs[i]].join(""));
      }
    }
    if(usePivot) {
      code.push("pivot_ptr=0");
    }
    code.push("ptr_shift=offset");
    for(var i=order.length-1; i>=0; --i) {
      var j = order[i];
      if(j === 0) {
        continue
      }
      code.push(["for(i",j,"=0;i",j,"<n",j,";++i",j,"){"].join(""));
    }
    if(ptrs.length > 1) {
      for(var i=0; i<ptrs.length; ++i) {
        code.push(["ptr",i,"=b_ptr",i,"+ptr_shift"].join(""));
      }
    }
    code.push(body);
    if(usePivot) {
      code.push("++pivot_ptr");
    }
    for(var i=0; i<order.length; ++i) {
      var j = order[i];
      if(j === 0) {
        continue
      }
      if(ptrs.length>1) {
        code.push("ptr_shift+=d"+j);
      } else {
        code.push("ptr0+=d"+j);
      }
      code.push("}");
    }
  }
  
  function lexicoLoop(label, ptrs, usePivot, body) {
    if(ptrs.length === 1) {
      code.push("ptr0="+toPointer(ptrs[0]));
    } else {
      for(var i=0; i<ptrs.length; ++i) {
        code.push(["b_ptr",i,"=s0*",ptrs[i]].join(""));
      }
      code.push("ptr_shift=offset");
    }
    if(usePivot) {
      code.push("pivot_ptr=0");
    }
    if(label) {
      code.push(label+":");
    }
    for(var i=1; i<order.length; ++i) {
      code.push(["for(i",i,"=0;i",i,"<n",i,";++i",i,"){"].join(""));
    }
    if(ptrs.length > 1) {
      for(var i=0; i<ptrs.length; ++i) {
        code.push(["ptr",i,"=b_ptr",i,"+ptr_shift"].join(""));
      }
    }
    code.push(body);
    for(var i=order.length-1; i>=1; --i) {
      if(usePivot) {
        code.push("pivot_ptr+=f"+i);
      }
      if(ptrs.length > 1) {
        code.push("ptr_shift+=e"+i);
      } else {
        code.push("ptr0+=e"+i);
      }
      code.push("}");
    }
  }
  
  function cleanUp() {
    if(order.length > 1 && allocator) {
      code.push("free(pivot1)", "free(pivot2)");
    }
  }
  
  function compareSwap(a_id, b_id) {
    var a = "el"+a_id;
    var b = "el"+b_id;
    if(order.length > 1) {
      var lbl = "__l" + (++labelCounter);
      lexicoLoop(lbl, [a, b], false, [
        "comp=",dataRead("ptr0"),"-",dataRead("ptr1"),"\n",
        "if(comp>0){tmp0=", a, ";",a,"=",b,";", b,"=tmp0;break ", lbl,"}\n",
        "if(comp<0){break ", lbl, "}"
      ].join(""));
    } else {
      code.push(["if(", dataRead(toPointer(a)), ">", dataRead(toPointer(b)), "){tmp0=", a, ";",a,"=",b,";", b,"=tmp0}"].join(""));
    }
  }
  
  compareSwap(1, 2);
  compareSwap(4, 5);
  compareSwap(1, 3);
  compareSwap(2, 3);
  compareSwap(1, 4);
  compareSwap(3, 4);
  compareSwap(2, 5);
  compareSwap(2, 3);
  compareSwap(4, 5);
  
  if(order.length > 1) {
    cacheLoop(["el1", "el2", "el3", "el4", "el5", "index1", "index3", "index5"], true, [
      "pivot1[pivot_ptr]=",dataRead("ptr1"),"\n",
      "pivot2[pivot_ptr]=",dataRead("ptr3"),"\n",
      "pivots_are_equal=pivots_are_equal&&(pivot1[pivot_ptr]===pivot2[pivot_ptr])\n",
      "x=",dataRead("ptr0"),"\n",
      "y=",dataRead("ptr2"),"\n",
      "z=",dataRead("ptr4"),"\n",
      dataWrite("ptr5", "x"),"\n",
      dataWrite("ptr6", "y"),"\n",
      dataWrite("ptr7", "z")
    ].join(""));
  } else {
    code.push([
      "pivot1=", dataRead(toPointer("el2")), "\n",
      "pivot2=", dataRead(toPointer("el4")), "\n",
      "pivots_are_equal=pivot1===pivot2\n",
      "x=", dataRead(toPointer("el1")), "\n",
      "y=", dataRead(toPointer("el3")), "\n",
      "z=", dataRead(toPointer("el5")), "\n",
      dataWrite(toPointer("index1"), "x"), "\n",
      dataWrite(toPointer("index3"), "y"), "\n",
      dataWrite(toPointer("index5"), "z")
    ].join(""));
  }
  

  function moveElement(dst, src) {
    if(order.length > 1) {
      cacheLoop([dst, src], false,
        dataWrite("ptr0", dataRead("ptr1"))
      );
    } else {
      code.push(dataWrite(toPointer(dst), dataRead(toPointer(src))));
    }
  }
  
  moveElement("index2", "left");
  moveElement("index4", "right");
  
  function comparePivot(result, ptr, n) {
    if(order.length > 1) {
      var lbl = "__l" + (++labelCounter);
      lexicoLoop(lbl, [ptr], true, [
        result,"=",dataRead("ptr0"),"-pivot",n,"[pivot_ptr]\n",
        "if(",result,"!==0){break ", lbl, "}"
      ].join(""));
    } else {
      code.push([result,"=", dataRead(toPointer(ptr)), "-pivot", n].join(""));
    }
  }
  
  function swapElements(a, b) {
    if(order.length > 1) {
      cacheLoop([a,b],false,[
        "tmp=",dataRead("ptr0"),"\n",
        dataWrite("ptr0", dataRead("ptr1")),"\n",
        dataWrite("ptr1", "tmp")
      ].join(""));
    } else {
      code.push([
        "ptr0=",toPointer(a),"\n",
        "ptr1=",toPointer(b),"\n",
        "tmp=",dataRead("ptr0"),"\n",
        dataWrite("ptr0", dataRead("ptr1")),"\n",
        dataWrite("ptr1", "tmp")
      ].join(""));
    }
  }
  
  function tripleSwap(k, less, great) {
    if(order.length > 1) {
      cacheLoop([k,less,great], false, [
        "tmp=",dataRead("ptr0"),"\n",
        dataWrite("ptr0", dataRead("ptr1")),"\n",
        dataWrite("ptr1", dataRead("ptr2")),"\n",
        dataWrite("ptr2", "tmp")
      ].join(""));
      code.push("++"+less, "--"+great);
    } else {
      code.push([
        "ptr0=",toPointer(k),"\n",
        "ptr1=",toPointer(less),"\n",
        "ptr2=",toPointer(great),"\n",
        "++",less,"\n",
        "--",great,"\n",
        "tmp=", dataRead("ptr0"), "\n",
        dataWrite("ptr0", dataRead("ptr1")), "\n",
        dataWrite("ptr1", dataRead("ptr2")), "\n",
        dataWrite("ptr2", "tmp")
      ].join(""));
    }
  }
  
  function swapAndDecrement(k, great) {
    swapElements(k, great);
    code.push("--"+great);
  }
    
  code.push("if(pivots_are_equal){");
    //Pivots are equal case
    code.push("for(k=less;k<=great;++k){");
      comparePivot("comp", "k", 1);
      code.push("if(comp===0){continue}");
      code.push("if(comp<0){");
        code.push("if(k!==less){");
          swapElements("k", "less");
        code.push("}");
        code.push("++less");
      code.push("}else{");
        code.push("while(true){");
          comparePivot("comp", "great", 1);
          code.push("if(comp>0){");
            code.push("great--");
          code.push("}else if(comp<0){");
            tripleSwap("k", "less", "great");
            code.push("break");
          code.push("}else{");
            swapAndDecrement("k", "great");
            code.push("break");
          code.push("}");
        code.push("}");
      code.push("}");
    code.push("}");
  code.push("}else{");
    //Pivots not equal case
    code.push("for(k=less;k<=great;++k){");
      comparePivot("comp_pivot1", "k", 1);
      code.push("if(comp_pivot1<0){");
        code.push("if(k!==less){");
          swapElements("k", "less");
        code.push("}");
        code.push("++less");
      code.push("}else{");
        comparePivot("comp_pivot2", "k", 2);
        code.push("if(comp_pivot2>0){");
          code.push("while(true){");
            comparePivot("comp", "great", 2);
            code.push("if(comp>0){");
              code.push("if(--great<k){break}");
              code.push("continue");
            code.push("}else{");
              comparePivot("comp", "great", 1);
              code.push("if(comp<0){");
                tripleSwap("k", "less", "great");
              code.push("}else{");
                swapAndDecrement("k", "great");
              code.push("}");
              code.push("break");
            code.push("}");
          code.push("}");
        code.push("}");
      code.push("}");
    code.push("}");
  code.push("}");
  
  //Move pivots to correct place
  function storePivot(mem_dest, pivot_dest, pivot) {
    if(order.length>1) {
      cacheLoop([mem_dest, pivot_dest], true, [
        dataWrite("ptr0", dataRead("ptr1")), "\n",
        dataWrite("ptr1", ["pivot",pivot,"[pivot_ptr]"].join(""))
      ].join(""));
    } else {
      code.push(
          dataWrite(toPointer(mem_dest), dataRead(toPointer(pivot_dest))),
          dataWrite(toPointer(pivot_dest), "pivot"+pivot));
    }
  }
  
  storePivot("left", "(less-1)", 1);
  storePivot("right", "(great+1)", 2);

  //Recursive sort call
  function doSort(left, right) {
    code.push([
      "if((",right,"-",left,")<=",INSERTION_SORT_THRESHOLD,"){\n",
        "insertionSort(", left, ",", right, ",data,offset,", shapeArgs(order.length).join(","), ")\n",
      "}else{\n",
        funcName, "(", left, ",", right, ",data,offset,", shapeArgs(order.length).join(","), ")\n",
      "}"
    ].join(""));
  }
  doSort("left", "(less-2)");
  doSort("(great+2)", "right");
  
  //If pivots are equal, then early out
  code.push("if(pivots_are_equal){");
    cleanUp();
    code.push("return");
  code.push("}");
  
  function walkPointer(ptr, pivot, body) {
    if(order.length > 1) {
      code.push(["__l",++labelCounter,":while(true){"].join(""));
      cacheLoop([ptr], true, [
        "if(", dataRead("ptr0"), "!==pivot", pivot, "[pivot_ptr]){break __l", labelCounter, "}"
      ].join(""));
      code.push(body, "}");
    } else {
      code.push(["while(", dataRead(toPointer(ptr)), "===pivot", pivot, "){", body, "}"].join(""));
    }
  }
  
  //Check bounds
  code.push("if(less<index1&&great>index5){");
  
    walkPointer("less", 1, "++less");
    walkPointer("great", 2, "--great");
  
    code.push("for(k=less;k<=great;++k){");
      comparePivot("comp_pivot1", "k", 1);
      code.push("if(comp_pivot1===0){");
        code.push("if(k!==less){");
          swapElements("k", "less");
        code.push("}");
        code.push("++less");
      code.push("}else{");
        comparePivot("comp_pivot2", "k", 2);
        code.push("if(comp_pivot2===0){");
          code.push("while(true){");
            comparePivot("comp", "great", 2);
            code.push("if(comp===0){");
              code.push("if(--great<k){break}");
              code.push("continue");
            code.push("}else{");
              comparePivot("comp", "great", 1);
              code.push("if(comp<0){");
                tripleSwap("k", "less", "great");
              code.push("}else{");
                swapAndDecrement("k", "great");
              code.push("}");
              code.push("break");
            code.push("}");
          code.push("}");
        code.push("}");
      code.push("}");
    code.push("}");
  code.push("}");
  
  //Clean up and do a final sorting pass
  cleanUp();
  doSort("less", "great");
 
  //Close off main loop
  code.push("}return " + funcName);
  
  //Compile and link
  if(order.length > 1 && allocator) {
    var compiled = new Function("insertionSort", "malloc", "free", code.join("\n"));
    return compiled(insertionSort, allocator[0], allocator[1])
  }
  var compiled = new Function("insertionSort", code.join("\n"));
  return compiled(insertionSort)
}

function compileSort(order, dtype) {
  var code = ["'use strict'"];
  var funcName = ["ndarraySortWrapper", order.join("d"), dtype].join("");
  var funcArgs = [ "array" ];
  
  code.push(["function ", funcName, "(", funcArgs.join(","), "){"].join(""));
  
  //Unpack local variables from array
  var vars = ["data=array.data,offset=array.offset|0,shape=array.shape,stride=array.stride"];
  for(var i=0; i<order.length; ++i) {
    vars.push(["s",i,"=stride[",i,"]|0,n",i,"=shape[",i,"]|0"].join(""));
  }
  
  var scratch_stride = new Array(order.length);
  var nprod = [];
  for(var i=0; i<order.length; ++i) {
    var k = order[i];
    if(k === 0) {
      continue
    }
    if(nprod.length === 0) {
      scratch_stride[k] = "1";
    } else {
      scratch_stride[k] = nprod.join("*");
    }
    nprod.push("n"+k);
  }
  
  var p = -1, q = -1;
  for(var i=0; i<order.length; ++i) {
    var j = order[i];
    if(j !== 0) {
      if(p > 0) {
        vars.push(["d",j,"=s",j,"-d",p,"*n",p].join(""));
      } else {
        vars.push(["d",j,"=s",j].join(""));
      }
      p = j;
    }
    var k = order.length-1-i;
    if(k !== 0) {
      if(q > 0) {
        vars.push(["e",k,"=s",k,"-e",q,"*n",q,
                  ",f",k,"=",scratch_stride[k],"-f",q,"*n",q].join(""));
      } else {
        vars.push(["e",k,"=s",k,",f",k,"=",scratch_stride[k]].join(""));
      }
      q = k;
    }
  }
  
  //Declare local variables
  code.push("var " + vars.join(","));
  
  //Create arguments for subroutine
  var sortArgs = ["0", "n0-1", "data", "offset"].concat(shapeArgs(order.length));
  
  //Call main sorting routine
  code.push([
    "if(n0<=",INSERTION_SORT_THRESHOLD,"){",
      "insertionSort(", sortArgs.join(","), ")}else{",
      "quickSort(", sortArgs.join(","),
    ")}"
  ].join(""));
  
  //Return
  code.push("}return " + funcName);
  
  //Link everything together
  var result = new Function("insertionSort", "quickSort", code.join("\n"));
  var insertionSort = createInsertionSort(order, dtype);
  var quickSort = createQuickSort(order, dtype, insertionSort);
  return result(insertionSort, quickSort)
}

var compile_sort = compileSort;

var compile = compile_sort;
var CACHE = {};

function sort(array) {
  var order = array.order;
  var dtype = array.dtype;
  var typeSig = [order, dtype ];
  var typeName = typeSig.join(":");
  var compiled = CACHE[typeName];
  if(!compiled) {
    CACHE[typeName] = compiled = compile(order, dtype);
  }
  compiled(array);
  return array
}

var sort_1 = sort;

var averageEdgeLength_1 = averageEdgeLength;

var pool$5    = pool$9;
var ndarray$2 = ndarray$5;
var ndsort$2  = sort_1;

function dist2$2(ax, ay, az, bx, by, bz) {
  return Math.pow(ax-bx, 2) + Math.pow(ay-by,2) + Math.pow(az-bz,2)
}

function averageEdgeLength(mesh) {
  var numCells  = mesh.numCells;
  var cells     = mesh.cells;
  var verts     = mesh.verts;

  var edgeLengths = pool$5.mallocFloat32(3 * numCells);
  for(var i=0; i<numCells; ++i) {
    var a = cells[3*i];
    var b = cells[3*i+1];
    var c = cells[3*i+2];

    var ax = verts[3*a];
    var ay = verts[3*a+1];
    var az = verts[3*a+2];

    var bx = verts[3*b];
    var by = verts[3*b+1];
    var bz = verts[3*b+2];

    var cx = verts[3*c];
    var cy = verts[3*c+1];
    var cz = verts[3*c+2];

    edgeLengths[3*i]   = dist2$2(ax, ay, az, bx, by, bz);
    edgeLengths[3*i+1] = dist2$2(bx, by, bz, cx, cy, cz);
    edgeLengths[3*i+2] = dist2$2(cx, cy, cz, ax, ay, az);
  }

  ndsort$2(ndarray$2(edgeLengths));
  var midLength = edgeLengths[edgeLengths.length>>1];

  pool$5.free(edgeLengths);

  return Math.sqrt(midLength)
}

var splitEdges_1 = splitEdges$1;

var pool$4     = pool$9;
var ndarray$1  = ndarray$5;
var ndsort$1   = sort_1;
var nextPow2 = np2;

var EDGE_SIZE = 3;

function dist2$1(ax, ay, az, bx, by, bz) {
  return Math.pow(ax-bx, 2) + Math.pow(ay-by,2) + Math.pow(az-bz,2)
}

function reserve(array, capacity, used) {
  if(array.length >= capacity) {
    return array
  }
  capacity = nextPow2(capacity);
  var next = pool$4.mallocFloat32(capacity);
  for(var i=0; i<used; ++i) {
    next[i] = array[i];
  }
  pool$4.free(array);
  return next
}

function edgeIndex(cells, x, a, b) {
  for(var i=0; i<3; ++i) {
    var c = cells[3*x + i];
    if(c !== a && c !== b) {
      return i
    }
  }
  return -1
}

var SPLIT_ARRAY = [-1, -1, -1, -1, -1];

function splitEdges$1(mesh, splitBound, maxIters, minSplit) {
  for(var iter=0; iter<maxIters; ++iter) {
    var numCells = mesh.numCells;
    var cells    = mesh.cells;
    var numVerts = mesh.numVerts;
    var verts    = mesh.verts;
    var normals  = mesh.normals;

    var maxEdges = 3 * numCells;
    var ePtr = 0;
    var edges = pool$4.mallocInt32(maxEdges * EDGE_SIZE);

    //Generate a list of all edges which must be split
    for(var i=0; i<numCells; ++i) {
      var a = cells[3*i];
      var b = cells[3*i+1];
      var c = cells[3*i+2];

      var ax = verts[3*a];
      var ay = verts[3*a+1];
      var az = verts[3*a+2];

      var bx = verts[3*b];
      var by = verts[3*b+1];
      var bz = verts[3*b+2];

      var cx = verts[3*c];
      var cy = verts[3*c+1];
      var cz = verts[3*c+2];

      if(dist2$1(ax, ay, az, bx, by, bz) > splitBound) {
        edges[ePtr++] = Math.min(a, b);
        edges[ePtr++] = Math.max(a, b);
        edges[ePtr++] = i;
      }

      if(dist2$1(bx, by, bz, cx, cy, cz) > splitBound) {
        edges[ePtr++] = Math.min(b, c);
        edges[ePtr++] = Math.max(b, c);
        edges[ePtr++] = i;
      }

      if(dist2$1(cx, cy, cz, ax, ay, az) > splitBound) {
        edges[ePtr++] = Math.min(c, a);
        edges[ePtr++] = Math.max(c, a);
        edges[ePtr++] = i;
      }
    }

    if(ePtr < 3*minSplit) {
      pool$4.free(edges);
      return iter > 0
    }

    //sort edges by their vertices
    var numSplits = (ePtr / EDGE_SIZE)|0;
    ndsort$1(ndarray$1(edges, [numSplits, EDGE_SIZE], [EDGE_SIZE, 1], 0));

    //again, this upper bound is crude
    verts   = reserve(verts,   3 * (numSplits + numVerts), 3 * numVerts);
    normals = reserve(normals, 3 * (numSplits + numVerts), 3 * numVerts);

    //Pass 3: (edges) split edges, log splits into vertex stream
    var splitPtr = 0;

    var pa = -1;
    var pb = -1;
    var pf = -1;
    for(var i=0; i<ePtr; i+=EDGE_SIZE) {
      var a = edges[i];
      var b = edges[i+1];
      var f = edges[i+2];

      if(a === pa && b === pb) {
        var vptr = numVerts++;
        verts[3*vptr]   = 0.5 * (verts[3*a]   + verts[3*b]);
        verts[3*vptr+1] = 0.5 * (verts[3*a+1] + verts[3*b+1]);
        verts[3*vptr+2] = 0.5 * (verts[3*a+2] + verts[3*b+2]);

        var nax = normals[3*a];
        var nay = normals[3*a+1];
        var naz = normals[3*a+2];
        var nx = 0.5 * (nax + normals[3*b]);
        var ny = 0.5 * (nay + normals[3*b+1]);
        var nz = 0.5 * (naz + normals[3*b+2]);
        var nl = Math.pow(nx,2) + Math.pow(ny,2) + Math.pow(nz,2);

        if(nl > 1e-6) {
          nl = 1/Math.sqrt(nl);
          normals[3*vptr]   = nx * nl;
          normals[3*vptr+1] = ny * nl;
          normals[3*vptr+2] = nz * nl;
        } else {
          normals[3*vptr]   = nax;
          normals[3*vptr+1] = nay;
          normals[3*vptr+2] = naz;
        }

        edges[splitPtr++] = 4*f  + edgeIndex(cells, f, a, b);
        edges[splitPtr++] = vptr;

        edges[splitPtr++] = 4*pf + edgeIndex(cells, pf, a, b);
        edges[splitPtr++] = vptr;
      }

      pa = a;
      pb = b;
      pf = f;
    }

    var splitCount = (splitPtr/2)|0;

    if(splitCount < minSplit) {
      pool$4.free(edges);
      return iter > 0
    }

    //sort edges by cell id
    ndsort$1(ndarray$1(edges, [splitCount, 2], [2, 1], 0));

    //Apply splits to cells
    var cPtr = 0;
    var outCells = pool$4.mallocInt32(nextPow2(3 * (numCells + splitCount)));
    var sPtr = 0;
    for(var i=0; i<numCells; ++i) {

      if(sPtr >= numSplits || (edges[2*sPtr]>>2) !== i) {
        outCells[cPtr++] = cells[3*i];
        outCells[cPtr++] = cells[3*i+1];
        outCells[cPtr++] = cells[3*i+2];
        continue
      }

      //Sort of messy, need to handle case of multiple splits per cell

      SPLIT_ARRAY[0] = cells[3*i+1];
      SPLIT_ARRAY[1] = -1;
      SPLIT_ARRAY[2] = cells[3*i+2];
      SPLIT_ARRAY[3] = -1;
      SPLIT_ARRAY[4] = cells[3*i];
      SPLIT_ARRAY[5] = -1;

      var idx = 0;
      while(sPtr < splitCount) {
        var head = edges[2*sPtr];
        if((head>>2) !== i) {
          break
        }
        idx = 1 + 2*(head&3);
        SPLIT_ARRAY[idx] = edges[2*sPtr+1];
        sPtr += 1;
      }

      //Triangulate SPLIT_ARRAY starting from base cell IDX
      var lastIdx  = -1;
      var startIdx = SPLIT_ARRAY[idx];
      for(var j=1; j<6; ++j) {
        var oppIdx = SPLIT_ARRAY[(j + idx) % 6];
        if(oppIdx < 0) {
          continue
        }
        if(lastIdx >= 0) {
          outCells[cPtr++] = startIdx;
          outCells[cPtr++] = lastIdx;
          outCells[cPtr++] = oppIdx;
        }
        lastIdx = oppIdx;
      }
    }

    mesh.numVerts = numVerts;
    mesh.verts    = verts;
    mesh.numCells = (cPtr/3)|0;
    mesh.cells    = outCells;
    mesh.normals  = normals;

    pool$4.free(cells);
    pool$4.free(edges);
  }

  return iter > 0
}

var _1Ring = compute1Ring;

function compute1Ring(numCells, cells, numVerts, counts, pointers, rings) {
  for(var i=0; i<numVerts; ++i) {
    counts[i] = 0;
  }

  for(var j=0; j<3*numCells; ++j) {
    counts[cells[j]] += 2;
  }

  var totalCount = 0;
  for(var i=0; i<numVerts; ++i) {
    pointers[i] = totalCount;
    totalCount += counts[i];
  }

  for(var i=0; i<numCells; ++i) {
    var a = cells[3*i];
    var b = cells[3*i+1];
    var c = cells[3*i+2];

    var pa = pointers[a];
    pointers[a] = pa + 2;

    var pb = pointers[b];
    pointers[b] = pb + 2;

    var pc = pointers[c];
    pointers[c] = pc + 2;

    rings[pa]   = b;
    rings[pa+1] = c;

    rings[pb]   = a;
    rings[pb+1] = c;

    rings[pc]   = a;
    rings[pc+1] = b;
  }

  //Compact and sort vertex rings
  var ptr  = 0;
  var optr = 0;
  for(var i=0; i<numVerts; ++i) {
    var end     = pointers[i];
    var start   = ptr;
    ptr         = end;
    pointers[i] = optr;

    //Insertion sort on i's ring
    for(var j=start; j<end; ++j) {
      var x = rings[j];
      for(var k=j; k>start; --k) {
        var y = rings[k-1];
        if(y <= x) {
          break
        }
        rings[k] = y;
      }
      rings[k] = x;
    }

    //Remove duplicates from i's ring and compact stream
    var last = -1;
    var pptr = optr;
    for(var j=start; j<end; ++j) {
      var x = rings[j];
      if(x !== last) {
        rings[optr++] = last = x;
      }
    }

    counts[i] = optr - pptr;
  }
}

var collapseEdges_1 = collapseEdges$1;

var pool$3 = pool$9;
var computeRings = _1Ring;

function dist2(ax, ay, az, bx, by, bz) {
  return Math.pow(ax-bx, 2) + Math.pow(ay-by,2) + Math.pow(az-bz,2)
}

function badEdge(limit, ax, ay, az, ptr, len, verts, rings, labels) {
  for(var i=0; i<len; ++i) {
    var v = rings[ptr + i];
    if(labels[v] >= 0 ||
        dist2(ax, ay, az,
          verts[3*v],
          verts[3*v+1],
          verts[3*v+2]) >= limit) {
      return true
    }
  }
  return false
}

function collapse(
  verts, normals,
  labels,
  ringPointers, ringCounts, rings,
  collapseBound, splitBound,
  a, b,
  ax,  ay,  az,
  bx,  by,  bz,
  nax, nay, naz,
  nbx, nby, nbz) {

  if(dist2(ax, ay, az, bx, by, bz) > collapseBound) {
    return false
  }

  var aptr = ringPointers[a];
  var alen = ringCounts[a];
  var bptr = ringPointers[b];
  var blen = ringCounts[b];

  var mx = 0.5 * (ax + bx);
  var my = 0.5 * (ay + by);
  var mz = 0.5 * (az + bz);

  //Check for non-manifold edge
  var ii = 0;
  var jj = 0;
  var intersect = 0;
  while(ii < alen && jj < blen) {
    var an = rings[ii+aptr];
    var bn = rings[jj+bptr];
    if(an === bn) {
      if(++intersect > 2) {
        //If more than 2 verts intersect, don't collapse to avoid making non-manifold flap
        return false
      }
      ii += 1;
      jj += 1;
    } else if(an < bn) {
      ii += 1;
    } else {
      jj += 1;
    }
  }

  if(badEdge(splitBound, mx, my, mz, aptr, alen, verts, rings, labels) ||
     badEdge(splitBound, mx, my, mz, bptr, blen, verts, rings, labels)) {
    return false
  }

  //Check vertex normals
  var nx = 0.5 * (nax + nbx);
  var ny = 0.5 * (nay + nby);
  var nz = 0.5 * (naz + nbz);
  var nl = Math.pow(nx,2) + Math.pow(ny,2) + Math.pow(nz,2);

  //If normals are too far apart, don't collapse
  if(nl < 0.1) {
    return false
  }

  var x = Math.min(a,b)|0;

  labels[a] = labels[b] = x;

  verts[3*x]   = mx;
  verts[3*x+1] = my;
  verts[3*x+2] = mz;

  nl = 1/Math.sqrt(nl);
  normals[3*x]   = nx * nl;
  normals[3*x+1] = ny * nl;
  normals[3*x+2] = nz * nl;

  return true
}


function collapseEdges$1(mesh, collapseBound, splitBound, maxIters, minCollapse) {
  var numCells  = mesh.numCells|0;
  var cells     = mesh.cells;
  var numVerts  = mesh.numVerts|0;
  var verts     = mesh.verts;
  var normals   = mesh.normals;

  var ringPointers = pool$3.mallocInt32(numVerts);
  var ringCounts   = pool$3.mallocInt32(numVerts);
  var rings        = pool$3.mallocInt32(6 * numCells);


  for(var iter=0; iter<maxIters; ++iter) {
    computeRings(numCells, cells, numVerts, ringCounts, ringPointers, rings);

    var labels = pool$3.mallocInt32(numVerts);
    for(var i=0; i<numVerts; ++i) {
      labels[i] = -1;
    }

    //Find short edges
    var collapseCount = 0;

    for(var i=0; i<numCells; ++i) {
      var a  = cells[3*i];
      var b  = cells[3*i+1];
      var c  = cells[3*i+2];

      var la = labels[a];
      var lb = labels[b];
      var lc = labels[c];

      if(la >= 0 || lb >= 0 || lc >= 0) {
        continue
      }

      var ax = verts[3*a];
      var ay = verts[3*a+1];
      var az = verts[3*a+2];

      var bx = verts[3*b];
      var by = verts[3*b+1];
      var bz = verts[3*b+2];

      var cx = verts[3*c];
      var cy = verts[3*c+1];
      var cz = verts[3*c+2];

      var nax = normals[3*a];
      var nay = normals[3*a+1];
      var naz = normals[3*a+2];

      var nbx = normals[3*b];
      var nby = normals[3*b+1];
      var nbz = normals[3*b+2];

      var ncx = normals[3*c];
      var ncy = normals[3*c+1];
      var ncz = normals[3*c+2];

      if(collapse(
          verts, normals,
          labels,
          ringPointers, ringCounts, rings,
          collapseBound, splitBound,
          a, b,
          ax, ay, az,
          bx, by, bz,
          nax, nay, naz,
          nbx, nby, nbz) ||
        collapse(
          verts, normals,
          labels,
          ringPointers, ringCounts, rings,
          collapseBound, splitBound,
          b, c,
          bx, by, bz,
          cx, cy, cz,
          nbx, nby, nbz,
          ncx, ncy, ncz) ||
        collapse(
          verts, normals,
          labels,
          ringPointers, ringCounts, rings,
          collapseBound, splitBound,
          c, a,
          cx, cy, cz,
          ax, ay, az,
          ncx, ncy, ncz,
          nax, nay, naz)) {
        collapseCount += 1;
      }
    }

    if(collapseCount < minCollapse) {
      break
    }

    //Compact vertices
    var vptr = 0;
    for(var i=0; i<numVerts; ++i) {
      var l = labels[i];
      if(l < 0 || l === i) {
        if(ringCounts[i] > 0) {
          labels[i] = vptr;

          verts[3*vptr]     = verts[3*i];
          verts[3*vptr+1]   = verts[3*i+1];
          verts[3*vptr+2]   = verts[3*i+2];

          normals[3*vptr]   = normals[3*i];
          normals[3*vptr+1] = normals[3*i+1];
          normals[3*vptr+2] = normals[3*i+2];

          vptr += 1;
        }
      } else {
        labels[i] = labels[l];
      }
    }

    //Collapse degenerate cells and compact
    var cptr = 0;
    for(var i=0; i<numCells; ++i) {
      var a = labels[cells[3*i]];
      var b = labels[cells[3*i+1]];
      var c = labels[cells[3*i+2]];

      if(a !== b && b !== c && c !== a) {
        cells[3*cptr]   = a;
        cells[3*cptr+1] = b;
        cells[3*cptr+2] = c;
        cptr += 1;
      }
    }

    mesh.numVerts = numVerts = vptr;
    mesh.numCells = numCells = cptr;
  }

  pool$3.free(labels);
  pool$3.free(ringCounts);
  pool$3.free(ringPointers);
  pool$3.free(rings);

  return iter > 0
}

var topology = computeTopology;

var pool$2    = pool$9;
var ndarray = ndarray$5;
var ndsort  = sort_1;

function computeTopology(numCells, cells, corners, numVerts, valence) {

  //Clear valence array
  for(var i=0; i<numVerts; ++i) {
    valence[i] = 0;
  }

  //Clear corner array
  for(var i=0; i<3*numCells; ++i) {
    corners[i] = -1;
  }

  var maxEdges = 3 * numCells;
  var edges = pool$2.mallocInt32(3 * maxEdges);
  var eptr = 0;
  for(var i=0; i<numCells; ++i) {
    var a = cells[3*i];
    var b = cells[3*i+1];
    var c = cells[3*i+2];

    edges[eptr++] = Math.min(a,b)|0;
    edges[eptr++] = Math.max(a,b)|0;
    edges[eptr++] = 4*i+2;

    edges[eptr++] = Math.min(b,c)|0;
    edges[eptr++] = Math.max(b,c)|0;
    edges[eptr++] = 4*i;

    edges[eptr++] = Math.min(c,a)|0;
    edges[eptr++] = Math.max(c,a)|0;
    edges[eptr++] = 4*i+1;
  }

  var numEdges = (eptr/3)|0;
  ndsort(ndarray(edges, [numEdges, 3], [3, 1], 0));

  var pa = -1;
  var pb = -1;
  var pf = -1;
  for(var i=0; i<numEdges; ++i) {
    var a = edges[3*i];
    var b = edges[3*i+1];
    var f = edges[3*i+2];

    if(a === pa && b === pb) {
      var x0 = f>>2;
      var x1 = f&3;
      var y0 = pf>>2;
      var y1 = pf&3;
      corners[3*x0 + x1] = pf;
      corners[3*y0 + y1] = f;
    } else if(pa >= 0) {
      valence[pa] += 1;
      valence[pb] += 1;
    }

    pa = a;
    pb = b;
    pf = f;
  }

  if(pa >= 0) {
    valence[pa] += 1;
    valence[pb] += 1;
  }

  pool$2.free(edges);
}

var flipEdges_1 = flipEdges$1;

var pool$1 = pool$9;
var topoIndex = topology;

function flipEdges$1(mesh, maxIters, minFlip) {
  var numCells = mesh.numCells;
  var cells    = mesh.cells;
  var numVerts = mesh.numVerts;

  //Build topological index
  var corners = pool$1.mallocInt32(6 * numCells);
  var valence = pool$1.mallocInt32(2 * numVerts);
  topoIndex(numCells, cells, corners, numVerts, valence);

  for(var iter=0; iter<maxIters; ++iter) {
    var flipCount = 0;

    for(var i=0; i<numCells; ++i) {
      var a = cells[3*i];
      var b = cells[3*i+1];
      var c = cells[3*i+2];

      var oa = corners[3*i];
      var ob = corners[3*i+1];
      var oc = corners[3*i+2];

      var va = valence[a];
      var vb = valence[b];
      var vc = valence[c];

      var ta = 6;
      var tb = 6;
      var tc = 6;

      if(oa < 0) {
        tb = tc = 4;
      }
      if(ob < 0) {
        tc = ta = 4;
      }
      if(oc < 0) {
        tb = ta = 4;
      }

      var da0 = Math.abs(va - ta + 1)|0;
      var da1 = Math.abs(va - ta)|0;
      var da2 = Math.abs(va - ta - 1)|0;

      var db0 = Math.abs(vb - tb + 1)|0;
      var db1 = Math.abs(vb - tb)|0;
      var db2 = Math.abs(vb - tb - 1)|0;

      var dc0 = Math.abs(vc - tc + 1)|0;
      var dc1 = Math.abs(vc - tc)|0;
      var dc2 = Math.abs(vc - tc - 1)|0;

      if(oa >= 0) {
        var j  = oa >> 2;
        var jx = oa & 3;
        var d  = cells[3*j + jx];
        var vd = valence[d];

        var yi = 3*j + ((jx+1)%3);
        cells[yi];
        var oy = corners[yi];
        var oz = corners[3*j+((jx+2)%3)];

        if(cells[yi] === b) {
          var tmp = oy;
          oy = oz;
          oz = tmp;
        }

        var td = 6;
        if(oz < 0 || oy < 0) {
          td = 4;
        }

        var dd0 = Math.abs(vd - td + 1)|0;
        var dd1 = Math.abs(vd - td)|0;

        if(da0 + db2 + dc2 + dd0 <
           da1 + db1 + dc1 + dd1) {

          cells[3*i]   = a;
          cells[3*i+1] = b;
          cells[3*i+2] = d;

          corners[3*i]   = oy;
          corners[3*i+1] = 4*j+2;
          corners[3*i+2] = oc;

          if(oy >= 0) {
            corners[3*(oy>>2)+(oy&3)] = 4*i;
          }
          if(oc >= 0) {
            corners[3*(oc>>2)+(oc&3)] = 4*i+2;
          }

          cells[3*j]   = a;
          cells[3*j+1] = d;
          cells[3*j+2] = c;

          corners[3*j]   = oz;
          corners[3*j+1] = ob;
          corners[3*j+2] = 4*i+1;

          if(oz >= 0) {
            corners[3*(oz>>2)+(oz&3)] = 4*j;
          }
          if(ob >= 0) {
            corners[3*(ob>>2)+(ob&3)] = 4*j+1;
          }

          valence[a] += 1;
          valence[b] -= 1;
          valence[c] -= 1;
          valence[d] += 1;

          flipCount += 1;

          continue
        }
      }

      if(ob >= 0) {
        var j  = ob >> 2;
        var jx = ob & 3;
        var d  = cells[3*j + jx];
        var vd = valence[d];

        var yi = 3*j + ((jx+1)%3);
        cells[yi];
        var oy = corners[yi];
        var oz = corners[3*j+((jx+2)%3)];

        if(cells[yi] === c) {
          var tmp = oy;
          oy = oz;
          oz = tmp;
        }

        var td = 6;
        if(oy < 0 || oz < 0) {
          td = 4;
        }

        var dd0 = Math.abs(vd - td + 1)|0;
        var dd1 = Math.abs(vd - td)|0;

        if(da2 + db0 + dc2 + dd0 <
           da1 + db1 + dc1 + dd1) {

          cells[3*i]   = b;
          cells[3*i+1] = c;
          cells[3*i+2] = d;

          corners[3*i]   = oy;
          corners[3*i+1] = 4*j+2;
          corners[3*i+2] = oa;

          if(oy >= 0) {
            corners[3*(oy>>2)+(oy&3)] = 4*i;
          }
          if(oa >= 0) {
            corners[3*(oa>>2)+(oa&3)] = 4*i+2;
          }

          cells[3*j]   = b;
          cells[3*j+1] = d;
          cells[3*j+2] = a;

          corners[3*j]   = oz;
          corners[3*j+1] = oc;
          corners[3*j+2] = 4*i+1;

          if(oz >= 0) {
            corners[3*(oz>>2)+(oz&3)] = 4*j;
          }
          if(oc >= 0) {
            corners[3*(oc>>2)+(oc&3)] = 4*j+1;
          }

          valence[a] -= 1;
          valence[b] += 1;
          valence[c] -= 1;
          valence[d] += 1;

          flipCount += 1;

          continue
        }
      }

      if(oc >= 0) {
        var j  = oc >> 2;
        var jx = oc & 3;
        var d  = cells[3*j + jx];
        var vd = valence[d];

        var yi = 3*j + ((jx+1)%3);
        cells[yi];
        var oy = corners[yi];
        var oz = corners[3*j+((jx+2)%3)];

        if(cells[yi] === a) {
          var tmp = oy;
          oy = oz;
          oz = tmp;
        }

        var td = 6;
        if(oy < 0 || oz < 0) {
          td = 4;
        }

        var dd0 = Math.abs(vd - td + 1)|0;
        var dd1 = Math.abs(vd - td)|0;

        if(da2 + db2 + dc0 + dd0 <
           da1 + db1 + dc1 + dd1) {

          cells[3*i]   = c;
          cells[3*i+1] = a;
          cells[3*i+2] = d;

          corners[3*i]   = oy;
          corners[3*i+1] = 4*j+2;
          corners[3*i+2] = ob;

          if(oy >= 0) {
            corners[3*(oy>>2)+(oy&3)] = 4*i;
          }
          if(ob >= 0) {
            corners[3*(ob>>2)+(ob&3)] = 4*i+2;
          }

          cells[3*j]   = c;
          cells[3*j+1] = d;
          cells[3*j+2] = b;

          corners[3*j]   = oz;
          corners[3*j+1] = oa;
          corners[3*j+2] = 4*i+1;

          if(oz >= 0) {
            corners[3*(oz>>2)+(oz&3)] = 4*j;
          }
          if(oa >= 0) {
            corners[3*(oa>>2)+(oa&3)] = 4*j+1;
          }

          valence[a] -= 1;
          valence[b] -= 1;
          valence[c] += 1;
          valence[d] += 1;

          flipCount += 1;

          continue
        }
      }
    }

    if(flipCount < minFlip) {
      break
    }
  }

  pool$1.free(valence);
  pool$1.free(corners);

  return iter > 0
}

var smoothVerts_1 = smoothVerts$1;

var pool = pool$9;

function smoothVerts$1(mesh, smoothRate, maxIters, smoothThreshold) {
  var numCells = mesh.numCells;
  var cells    = mesh.cells;
  var numVerts = mesh.numVerts;
  var verts    = mesh.verts;
  var normals  = mesh.normals;

  var targets = pool.mallocFloat32(4 * numVerts);

  for(var iter=0; iter<maxIters; ++iter) {
    for(var i=0; i<4*numVerts; ++i) {
      targets[i] = 0;
    }

    for(var i=0; i<numCells; ++i) {
      var a = cells[3*i];
      var b = cells[3*i+1];
      var c = cells[3*i+2];

      var ax = verts[3*a];
      var ay = verts[3*a+1];
      var az = verts[3*a+2];

      var bx = verts[3*b];
      var by = verts[3*b+1];
      var bz = verts[3*b+2];

      var cx = verts[3*c];
      var cy = verts[3*c+1];
      var cz = verts[3*c+2];

      var px = ax + bx + cx;
      var py = ay + by + cy;
      var pz = az + bz + cz;

      targets[4*a]   += px;
      targets[4*a+1] += py;
      targets[4*a+2] += pz;
      targets[4*a+3] += 1;

      targets[4*b]   += px;
      targets[4*b+1] += py;
      targets[4*b+2] += pz;
      targets[4*b+3] += 1;

      targets[4*c]   += px;
      targets[4*c+1] += py;
      targets[4*c+2] += pz;
      targets[4*c+3] += 1;
    }

    var maxDist = 0.0;
    for(var i=0; i<numVerts; ++i) {
      var px = verts[3*i];
      var py = verts[3*i+1];
      var pz = verts[3*i+2];

      var qx = targets[4*i];
      var qy = targets[4*i+1];
      var qz = targets[4*i+2];
      var qw = targets[4*i+3];

      qw = 1/(3.0 * qw);
      qx *= qw;
      qy *= qw;
      qz *= qw;

      var nx = normals[3*i];
      var ny = normals[3*i+1];
      var nz = normals[3*i+2];

      var dx = qx - px;
      var dy = qy - py;
      var dz = qz - pz;

      var l = nx * dx + ny * dy + nz * dz;

      var rx = verts[3*i]   = px + smoothRate * (dx - l * nx);
      var ry = verts[3*i+1] = py + smoothRate * (dy - l * ny);
      var rz = verts[3*i+2] = pz + smoothRate * (dz - l * nz);

      maxDist = Math.max(maxDist,
        Math.pow(rx-px,2) + Math.pow(ry-py,2) + Math.pow(rz-pz,2));
    }

    if(maxDist < smoothThreshold) {
      break
    }
  }

  pool.free(targets);

  return iter > 0
}

refine.exports = refineMesh;
refine.exports.packed = refinePackedMesh;

var createMesh    = mesh;
var avgEdgeLength = averageEdgeLength_1;
var splitEdges    = splitEdges_1;
var collapseEdges = collapseEdges_1;
var flipEdges     = flipEdges_1;
var smoothVerts   = smoothVerts_1;

function refinePackedMesh(mesh, options) {
  options = options || {};

  var edgeLength    = options.edgeLength    || avgEdgeLength(mesh);
  var smoothRate    = options.smoothRate    || 0.95;
  smoothRate = Math.max(Math.min(smoothRate, 1.0), 0.001);

  var splitBound    = Math.pow(1.25 * edgeLength, 2);
  var collapseBound = Math.pow(0.75 * edgeLength, 2);

  var maxIters      = options.maxIters      || 5;
  var splitIters    = options.splitIters    || 10;
  var collapseIters = options.collapseIters || 10;
  var flipIters     = options.flipIters     || 10;
  var smoothIters   = options.smoothIters   || 20;

  var minSplit    = Math.max(options.minSplit || 0, 0)|0;
  var minCollapse = Math.max(options.minCollapse || 0, 0)|0;
  var minFlip     = Math.max(options.minFlip || 0, 0)|0;
  var minSmooth   = Math.pow(Math.max(options.minSmooth ||
                        (0.05 * edgeLength / smoothRate), 0), 2);

  var changed = true;
  for(var i=0; changed && i<maxIters; ++i) {
    changed = false;
    changed = splitEdges(
                  mesh,
                  splitBound,
                  splitIters,
                  minSplit) || changed;
    changed = collapseEdges(
                  mesh,
                  collapseBound,
                  splitBound,
                  collapseIters,
                  minCollapse) || changed;
    changed = flipEdges(
                  mesh,
                  flipIters,
                  minFlip) || changed;
    changed = smoothVerts(
                  mesh,
                  smoothRate,
                  smoothIters,
                  minSmooth) || changed;
  }
}

function refineMesh(cells, positions, normals, options) {
  var mesh = createMesh(cells, positions, normals);

  refinePackedMesh(mesh, options);

  var result = mesh.unpack();
  mesh.dispose();
  return result
}

const prepareMesh = ({ cells, positions }) =>
  cells.map((cell) => cell.map((i) => [0, ...positions[i]]));

const simpleBunny = moize((num) =>
  meshSimplify(bunny.cells, bunny.positions)(num)
);
simpleBunny(400);

var identity_1 = identity$1;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity$1(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

var invert_1 = invert;

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
}

var translate_1 = translate;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
}

var scale_1 = scale;

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}

var identity = identity_1;

var lookAt_1 = lookAt$1;

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt$1(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < 0.000001 &&
        Math.abs(eyey - centery) < 0.000001 &&
        Math.abs(eyez - centerz) < 0.000001) {
        return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
}

var perspective_1 = perspective$1;

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective$1(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
}

var transformMat4 = transformMat4_1$1;
var vec3RotateY = rotateY_1;
var vec3RotateX = rotateX_1;
var vec3Equals = equals_1;
var vec3Add = add_1$1;
var vec3ScaleAndAdd = scaleAndAdd_1$1;
var vec3Copy = copy_1$1;
var vec3Normalize = normalize_1$1;
var mat4Identity = identity_1;
var mat4Invert = invert_1;
var mat4Translate = translate_1;
var mat4Scale = scale_1;
var lookAt = lookAt_1;
var perspective = perspective_1;

// This is a quick and dirty way of avoiding the poles.
var MAX_PHI = Math.PI * 0.5 - 1e-4;
var MIN_PHI = -Math.PI * 0.5 + 1e-4;

var inertialTurntableCamera = function createCamera (opts) {
  opts = opts || {};

  // A proxy flag with which we track the dirty params so that it doesn't need
  // an extra method to tell the camera that the scene *has been* rendered.
  var willBeDirty = true;

  var params = {
    aspectRatio: opts.aspectRatio ? opts.aspectRatio : 1,

    // Zoom about the cursor as opposed to the center of the scene
    zoomAboutCursor: opts.zoomAboutCursor === undefined ? true : opts.zoomAboutCursor,

    // Spherical coords!
    distance: opts.distance === undefined ? 10 : opts.distance,
    phi: opts.phi === undefined ? 0 : opts.phi,
    theta: opts.theta === undefined ? 0 : opts.theta,

    // Camera parameters
    fovY: opts.fovY === undefined ? Math.PI / 4 : opts.fovY,
    near: opts.near === undefined ? 0.1 : opts.near,
    far: opts.far === undefined ? 100 : opts.far,

    // Decay of inertia, in ms
    panDecayTime: opts.panDecayTime || 100,
    zoomDecayTime: opts.zoomDecayTime || 100,
    rotationDecayTime: opts.rotationDecayTime || 100,

    dirty: true,

    up: opts.up || new Float32Array([0, 1, 0]),
    center: opts.center || new Float32Array(3),
    rotationCenter: opts.rotationCenter || opts.center && opts.center.slice() || new Float32Array(3),

    // Current interactions, which can be set directly. If setting directly, changes
    // will be additive to changes resulting from interactions.
    zoom: 0,
    panX: 0,
    panY: 0,
    panZ: 0,
    pitch: 0,
    yaw: 0,
    dTheta: 0,
    dPhi: 0,

    // Mouse coordinates of the interaction. Note that we fudge things ever so slightly
    // here and only store one mouse position per frame, so that we might actually
    // apply multiple accumulated events per frame about the *slightly* incorrect point.
    // In reality, I think this fudgeable.
    mouseX: 0,
    mouseY: 0,
  };

  var t0 = null;
  var camera = {
    tick: function (mergeState) {
      // If we've accumulated interactions, then set them in the params directly.
      // Alternatively, we could recompute the full params on every single interaction
      // event, but that would result in maybe twice as many full matrix/view updates
      // as could ever be rendered in browsers like Safari that dispatch multiple
      // events per requestAnimationFrame.
      if (accumulator.zoom) params.zoom = accumulator.zoom;
      if (accumulator.dTheta) params.dTheta = accumulator.dTheta;
      if (accumulator.dPhi) params.dPhi = accumulator.dPhi;
      if (accumulator.panX) params.panX = accumulator.panX;
      if (accumulator.panY) params.panY = accumulator.panY;
      if (accumulator.panZ) params.panZ = accumulator.panZ;
      if (accumulator.yaw) params.yaw = accumulator.yaw;
      if (accumulator.pitch) params.pitch = accumulator.pitch;
      zeroChanges(accumulator);

      if (mergeState) {
        // Okay, so if we just merge changes, that totally breaks mouse interaction
        // because provided dPhi will zero out dPhi resulting from mouse interaction.
        // It would be better to accumulate mouse pixel changes separately and then
        // add this in afterwards, but since we've accumulated dPhi etc right in the
        // params, we need to cache this, then merge changes, then add these back in
        // if necessary. Consider this a low-priority cleanup item.
        var cachedDPhi = params.dPhi;
        var cachedDTheta = params.dTheta;
        var cachedZoom = params.zoom;
        var cachedPanX = params.panX;
        var cachedPanY = params.panY;
        var cachedPanZ = params.panZ;
        var cachedPitch = params.pitch;
        var cachedYaw = params.yaw;

        // This merges anything and everything in the params vector.
        Object.assign(params, mergeState);

        // Yup, so add them back in.
        if (mergeState.dPhi !== undefined) params.dPhi += cachedDPhi;
        if (mergeState.dTheta !== undefined) params.dTheta += cachedDTheta;
        if (mergeState.zoom !== undefined) params.zoom += cachedZoom;
        if (mergeState.panX !== undefined) params.panX += cachedPanX;
        if (mergeState.panY !== undefined) params.panY += cachedPanY;
        if (mergeState.panZ !== undefined) params.panZ += cachedPanZ;
        if (mergeState.pitch !== undefined) params.pitch += cachedPitch;
        if (mergeState.yaw !== undefined) params.yaw += cachedYaw;
      }

      // Check for and apply passive changes to the params vector. That is, if you
      // set camera.params.distance, this will automatically factor in those changes.
      if (paramsVectorHasChanged()) {
        applyStateChanges();
      }

      // Check if the view is changing above some threshold tolerance.
      if (viewIsChanging()) {
        // If so, update the view.
        applyViewChanges(params);
      } else {
        // If not, fully zero it out.
        zeroChanges(params);
      }

      // Not the highest resolution timer, but we only use it for inertia decay.
      var t = Date.now();
      if (t0 !== null) decay(t - t0);
      t0 = t;

      // Transfer this flag in a subtle way so that camera.params.dirty is writable.
      camera.state.dirty = willBeDirty;
      willBeDirty = false;

      storeCurrentState();
    },
    taint: taint,
    resize: resize,
    params: params,
    rotate: rotate,
    pivot: pivot,
    pan: pan,
    zoom: zoom,
  };

  camera.state = {
  };

  camera.state.projection = new Float32Array(16);
  camera.state.viewInv = new Float32Array(16);
  camera.state.view = new Float32Array(16);
  camera.state.width = null;
  camera.state.height = null;
  camera.state.eye = new Float32Array(3);

  // Vectors used but not exposed. Not they couldn't be, but you can get these
  // from the view matrix just fine.
  var tmp = new Float32Array(3);
  var viewUp = new Float32Array(3);
  var viewRight = new Float32Array(3);
  var viewForward = new Float32Array(3);
  var origin = new Float32Array(3);
  var dView = new Float32Array(16);

  // Track the previous params so that we can detect changes in these parameters
  var previousState = {
    up: new Float32Array(3),
    center: new Float32Array(3)
  };
  storeCurrentState();

  function storeCurrentState () {
    vec3Copy(previousState.up, params.up);
    vec3Copy(previousState.center, params.center);
    previousState.near = params.near;
    previousState.far = params.far;
    previousState.distance = params.distance;
    previousState.phi = params.phi;
    previousState.theta = params.theta;
    previousState.fovY = params.fovY;
  }

  function paramsVectorHasChanged () {
    if (!vec3Equals(params.up, previousState.up)) return true;
    if (!vec3Equals(params.center, previousState.center)) return true;
    if (params.near !== previousState.near) return true;
    if (params.far !== previousState.far) return true;
    if (params.phi !== previousState.phi) return true;
    if (params.theta !== previousState.theta) return true;
    if (params.distance !== previousState.distance) return true;
    if (params.fovY !== previousState.fovY) return true;
    return false;
  }

  var paramsChanges = {};
  function applyStateChanges () {
    paramsChanges.dPhi = params.phi - previousState.phi;
    paramsChanges.dTheta = params.theta - previousState.theta;
    paramsChanges.zoom = params.distance / previousState.distance - 1;
    params.theta = previousState.theta;
    params.distance = previousState.distance;
    params.phi = previousState.phi;
    paramsChanges.yaw = 0;
    paramsChanges.pitch = 0;
    paramsChanges.panX = 0;
    paramsChanges.panY = 0;
    paramsChanges.panZ = 0;
    paramsChanges.mouseX = 0;
    paramsChanges.mouseY = 0;

    applyViewChanges(paramsChanges);
  }

  // The meat of it. Note that this function is intentionally very simple! There must
  // not be any logic or complexity to this function. The complexity is in moving this
  // view, not constructing it.
  function computeMatrices () {
    // Spherical coords
    camera.state.eye[0] = 0;
    camera.state.eye[1] = 0;
    camera.state.eye[2] = params.distance;
    vec3RotateX(camera.state.eye, camera.state.eye, origin, -params.phi);
    vec3RotateY(camera.state.eye, camera.state.eye, origin, params.theta);
    vec3Add(camera.state.eye, camera.state.eye, params.center);

    // View + projection
    lookAt(camera.state.view, camera.state.eye, params.center, params.up);
    perspective(camera.state.projection, params.fovY, camera.params.aspectRatio, params.near, params.far);

    // For convenience, but also because we already use this, so let's just expose it
    mat4Invert(camera.state.viewInv, camera.state.view);
  }

  // Track this not on the params itself so that you can write camera.params.dirty
  function taint () {
    willBeDirty = true;
  }

  function resize (aspectRatio) {
    camera.params.aspectRatio = aspectRatio;
    computeMatrices();
    taint();
  }

  // All of these are mosty unitless, proportional, or at least relative to a window
  // size that doesn't change much so that fixed tolerances seem fine.
  function viewIsChanging () {
    if (Math.abs(params.zoom) > 1e-4) return true;
    if (Math.abs(params.panX) > 1e-4) return true;
    if (Math.abs(params.panY) > 1e-4) return true;
    if (Math.abs(params.panZ) > 1e-4) return true;
    if (Math.abs(params.dTheta) > 1e-4) return true;
    if (Math.abs(params.dPhi) > 1e-4) return true;
    if (Math.abs(params.yaw) > 1e-4) return true;
    if (Math.abs(params.pitch) > 1e-4) return true;
  }

  function zeroChanges (obj) {
    obj.zoom = 0;
    obj.dTheta = 0;
    obj.dPhi = 0;
    obj.panX = 0;
    obj.panY = 0;
    obj.panZ = 0;
    obj.yaw = 0;
    obj.pitch = 0;
  }

  // Exponential decay. Basically time-correct proportional decay.
  function decay (dt) {
    var panDecay = params.panDecayTime ? Math.exp(-dt / params.panDecayTime / Math.LN2) : 0;
    var zoomDecay = params.zoomDecayTime ? Math.exp(-dt / params.zoomDecayTime / Math.LN2) : 0;
    var rotateDecay = params.rotationDecayTime ? Math.exp(-dt / params.rotationDecayTime / Math.LN2) : 0;
    params.zoom *= zoomDecay;
    params.panX *= panDecay;
    params.panY *= panDecay;
    params.panZ *= panDecay;
    params.dTheta *= rotateDecay;
    params.dPhi *= rotateDecay;
    params.yaw *= rotateDecay;
    params.pitch *= rotateDecay;
  }

  // Accumulate changes per-frame since it turns out that Safari dispatches mouse events
  // more than once per RAF while chrome sticks to strictly once per RAF. How surprising!
  var accumulator = {};
  zeroChanges(accumulator);

  function pan (panX, panY) {
    var scaleFactor = camera.params.distance * Math.tan(camera.params.fovY * 0.5) * 2.0;
    accumulator.panX += panX * params.aspectRatio * scaleFactor;
    accumulator.panY += panY * scaleFactor;
    return camera;
  }

  function zoom (mouseX, mouseY, zoom) {
    accumulator.zoom += zoom;
    params.mouseX = mouseX;
    params.mouseY = mouseY;
    return camera;
  }

  function pivot (yaw, pitch) {
    var scaleFactor = camera.params.fovY;
    accumulator.yaw += yaw * scaleFactor * params.aspectRatio;
    accumulator.pitch += pitch * scaleFactor;
  }

  function rotate (dTheta, dPhi) {
    accumulator.dTheta += dTheta;
    accumulator.dPhi += dPhi;
  }

  function applyViewChanges (changes) {
    var zoomScaleFactor;

    // Initialize a veiw-space transformation for panning and zooming
    mat4Identity(dView);

    // Zoom about the mouse location in view-space
    if (params.zoomAboutCursor) {
      zoomScaleFactor = params.distance * Math.tan(params.fovY * 0.5);
      tmp[0] = changes.mouseX * params.aspectRatio * zoomScaleFactor;
      tmp[1] = changes.mouseY * zoomScaleFactor;
      tmp[2] = 0;
      mat4Translate(dView, dView, tmp);
    }

    tmp[0] = 1 + changes.zoom;
    tmp[1] = 1 + changes.zoom;
    tmp[2] = 1;
    mat4Scale(dView, dView, tmp);

    if (params.zoomAboutCursor) {
      zoomScaleFactor = params.distance * Math.tan(params.fovY * 0.5);
      tmp[0] = -changes.mouseX * params.aspectRatio * zoomScaleFactor;
      tmp[1] = -changes.mouseY * zoomScaleFactor;
      tmp[2] = 0;
      mat4Translate(dView, dView, tmp);
    }

    // Pan the view matrix
    dView[12] -= changes.panX * 0.5;
    dView[13] -= changes.panY * 0.5;

    // transform into view space, then transfor, then invert again
    transformMat4(params.center, params.center, camera.state.view);
    transformMat4(params.center, params.center, dView);
    transformMat4(params.center, params.center, camera.state.viewInv);

    // If rotating about the center of the screen, then copy center -> rotationCenter
    if (params.rotateAboutCenter) {
      vec3Copy(params.rotationCenter, params.center);
    }

    params.distance *= 1 + changes.zoom;

    var prevPhi = params.phi;
    params.phi += changes.dPhi;
    params.phi = Math.min(MAX_PHI, Math.max(MIN_PHI, params.phi));
    var dPhi = params.phi - prevPhi;

    var prevTheta = params.theta;
    params.theta += changes.dTheta;
    var dTheta = params.theta - prevTheta;

    vec3RotateY(params.center, params.center, params.rotationCenter, dTheta - params.theta);
    vec3RotateX(params.center, params.center, params.rotationCenter, -dPhi);
    vec3RotateY(params.center, params.center, params.rotationCenter, params.theta);

    if (changes.yaw !== 0 || changes.pitch !== 0) {
      viewRight[0] = camera.state.view[0];
      viewRight[1] = camera.state.view[4];
      viewRight[2] = camera.state.view[8];
      vec3Normalize(viewRight, viewRight);

      viewUp[0] = camera.state.view[1];
      viewUp[1] = camera.state.view[5];
      viewUp[2] = camera.state.view[9];
      vec3Normalize(viewUp, viewUp);

      viewForward[0] = camera.state.view[2];
      viewForward[1] = camera.state.view[6];
      viewForward[2] = camera.state.view[10];
      vec3Normalize(viewForward, viewForward);

      var clippedPhi = Math.min(MAX_PHI, Math.max(MIN_PHI, params.phi + changes.pitch * 0.5));
      var clippedPitch = clippedPhi - params.phi;

      vec3ScaleAndAdd(params.center, params.center, viewRight, -Math.sin(changes.yaw * 0.5) * params.distance);
      vec3ScaleAndAdd(params.center, params.center, viewUp, -Math.sin(clippedPitch) * params.distance);
      vec3ScaleAndAdd(params.center, params.center, viewForward, (2 - Math.cos(changes.yaw * 0.5) - Math.cos(clippedPitch)) * params.distance);
      params.phi = clippedPhi;
      params.theta += changes.yaw * 0.5;
    }

    computeMatrices();
    taint();
  }

  resize(camera.params.aspectRatio);

  return camera;
};

var mouse$1 = {};

function mouseButtons(ev) {
  if(typeof ev === 'object') {
    if('buttons' in ev) {
      return ev.buttons
    } else if('which' in ev) {
      var b = ev.which;
      if(b === 2) {
        return 4
      } else if(b === 3) {
        return 2
      } else if(b > 0) {
        return 1<<(b-1)
      }
    } else if('button' in ev) {
      var b = ev.button;
      if(b === 1) {
        return 4
      } else if(b === 2) {
        return 2
      } else if(b >= 0) {
        return 1<<b
      }
    }
  }
  return 0
}
mouse$1.buttons = mouseButtons;

function mouseElement(ev) {
  return ev.target || ev.srcElement || window
}
mouse$1.element = mouseElement;

function mouseRelativeX(ev) {
  if(typeof ev === 'object') {
    if('offsetX' in ev) {
      return ev.offsetX
    }
    var target = mouseElement(ev);
    var bounds = target.getBoundingClientRect();
    return ev.clientX - bounds.left
  }
  return 0
}
mouse$1.x = mouseRelativeX;

function mouseRelativeY(ev) {
  if(typeof ev === 'object') {
    if('offsetY' in ev) {
      return ev.offsetY
    }
    var target = mouseElement(ev);
    var bounds = target.getBoundingClientRect();
    return ev.clientY - bounds.top
  }
  return 0
}
mouse$1.y = mouseRelativeY;

var mouseListen_1 = mouseListen;

var mouse = mouse$1;

function mouseListen (element, callback) {
  if (!callback) {
    callback = element;
    element = window;
  }

  var buttonState = 0;
  var x = 0;
  var y = 0;
  var mods = {
    shift: false,
    alt: false,
    control: false,
    meta: false
  };
  var attached = false;

  function updateMods (ev) {
    var changed = false;
    if ('altKey' in ev) {
      changed = changed || ev.altKey !== mods.alt;
      mods.alt = !!ev.altKey;
    }
    if ('shiftKey' in ev) {
      changed = changed || ev.shiftKey !== mods.shift;
      mods.shift = !!ev.shiftKey;
    }
    if ('ctrlKey' in ev) {
      changed = changed || ev.ctrlKey !== mods.control;
      mods.control = !!ev.ctrlKey;
    }
    if ('metaKey' in ev) {
      changed = changed || ev.metaKey !== mods.meta;
      mods.meta = !!ev.metaKey;
    }
    return changed
  }

  function handleEvent (nextButtons, ev) {
    var nextX = mouse.x(ev);
    var nextY = mouse.y(ev);
    if ('buttons' in ev) {
      nextButtons = ev.buttons | 0;
    }
    if (nextButtons !== buttonState ||
      nextX !== x ||
      nextY !== y ||
      updateMods(ev)) {
      buttonState = nextButtons | 0;
      x = nextX || 0;
      y = nextY || 0;
      callback && callback(buttonState, x, y, mods);
    }
  }

  function clearState (ev) {
    handleEvent(0, ev);
  }

  function handleBlur () {
    if (buttonState ||
      x ||
      y ||
      mods.shift ||
      mods.alt ||
      mods.meta ||
      mods.control) {
      x = y = 0;
      buttonState = 0;
      mods.shift = mods.alt = mods.control = mods.meta = false;
      callback && callback(0, 0, 0, mods);
    }
  }

  function handleMods (ev) {
    if (updateMods(ev)) {
      callback && callback(buttonState, x, y, mods);
    }
  }

  function handleMouseMove (ev) {
    if (mouse.buttons(ev) === 0) {
      handleEvent(0, ev);
    } else {
      handleEvent(buttonState, ev);
    }
  }

  function handleMouseDown (ev) {
    handleEvent(buttonState | mouse.buttons(ev), ev);
  }

  function handleMouseUp (ev) {
    handleEvent(buttonState & ~mouse.buttons(ev), ev);
  }

  function attachListeners () {
    if (attached) {
      return
    }
    attached = true;

    element.addEventListener('mousemove', handleMouseMove);

    element.addEventListener('mousedown', handleMouseDown);

    element.addEventListener('mouseup', handleMouseUp);

    element.addEventListener('mouseleave', clearState);
    element.addEventListener('mouseenter', clearState);
    element.addEventListener('mouseout', clearState);
    element.addEventListener('mouseover', clearState);

    element.addEventListener('blur', handleBlur);

    element.addEventListener('keyup', handleMods);
    element.addEventListener('keydown', handleMods);
    element.addEventListener('keypress', handleMods);

    if (element !== window) {
      window.addEventListener('blur', handleBlur);

      window.addEventListener('keyup', handleMods);
      window.addEventListener('keydown', handleMods);
      window.addEventListener('keypress', handleMods);
    }
  }

  function detachListeners () {
    if (!attached) {
      return
    }
    attached = false;

    element.removeEventListener('mousemove', handleMouseMove);

    element.removeEventListener('mousedown', handleMouseDown);

    element.removeEventListener('mouseup', handleMouseUp);

    element.removeEventListener('mouseleave', clearState);
    element.removeEventListener('mouseenter', clearState);
    element.removeEventListener('mouseout', clearState);
    element.removeEventListener('mouseover', clearState);

    element.removeEventListener('blur', handleBlur);

    element.removeEventListener('keyup', handleMods);
    element.removeEventListener('keydown', handleMods);
    element.removeEventListener('keypress', handleMods);

    if (element !== window) {
      window.removeEventListener('blur', handleBlur);

      window.removeEventListener('keyup', handleMods);
      window.removeEventListener('keydown', handleMods);
      window.removeEventListener('keypress', handleMods);
    }
  }

  // Attach listeners
  attachListeners();

  var result = {
    element: element
  };

  Object.defineProperties(result, {
    enabled: {
      get: function () { return attached },
      set: function (f) {
        if (f) {
          attachListeners();
        } else {
          detachListeners();
        }
      },
      enumerable: true
    },
    buttons: {
      get: function () { return buttonState },
      enumerable: true
    },
    x: {
      get: function () { return x },
      enumerable: true
    },
    y: {
      get: function () { return y },
      enumerable: true
    },
    mods: {
      get: function () { return mods },
      enumerable: true
    }
  });

  return result
}

var rootPosition = { left: 0, top: 0 };

var mouseEventOffset_1 = mouseEventOffset;
function mouseEventOffset (ev, target, out) {
  target = target || ev.currentTarget || ev.srcElement;
  if (!Array.isArray(out)) {
    out = [ 0, 0 ];
  }
  var cx = ev.clientX || 0;
  var cy = ev.clientY || 0;
  var rect = getBoundingClientOffset(target);
  out[0] = cx - rect.left;
  out[1] = cy - rect.top;
  return out
}

function getBoundingClientOffset (element) {
  if (element === window ||
      element === document ||
      element === document.body) {
    return rootPosition
  } else {
    return element.getBoundingClientRect()
  }
}

var eventEmitter$1 = {exports: {}};

var d$1 = {exports: {}};

// ES3 safe
var _undefined$1 = void 0;

var is$4 = function (value) { return value !== _undefined$1 && value !== null; };

var isValue$5 = is$4;

// prettier-ignore
var possibleTypes = { "object": true, "function": true, "undefined": true /* document.all */ };

var is$3 = function (value) {
	if (!isValue$5(value)) return false;
	return hasOwnProperty.call(possibleTypes, typeof value);
};

var isObject = is$3;

var is$2 = function (value) {
	if (!isObject(value)) return false;
	try {
		if (!value.constructor) return false;
		return value.constructor.prototype === value;
	} catch (error) {
		return false;
	}
};

var isPrototype = is$2;

var is$1 = function (value) {
	if (typeof value !== "function") return false;

	if (!hasOwnProperty.call(value, "length")) return false;

	try {
		if (typeof value.length !== "number") return false;
		if (typeof value.call !== "function") return false;
		if (typeof value.apply !== "function") return false;
	} catch (error) {
		return false;
	}

	return !isPrototype(value);
};

var isFunction = is$1;

var classRe = /^\s*class[\s{/}]/, functionToString = Function.prototype.toString;

var is = function (value) {
	if (!isFunction(value)) return false;
	if (classRe.test(functionToString.call(value))) return false;
	return true;
};

var isImplemented$2 = function () {
	var assign = Object.assign, obj;
	if (typeof assign !== "function") return false;
	obj = { foo: "raz" };
	assign(obj, { bar: "dwa" }, { trzy: "trzy" });
	return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
};

var isImplemented$1 = function () {
	try {
		Object.keys("primitive");
		return true;
	} catch (e) {
		return false;
	}
};

// eslint-disable-next-line no-empty-function
var noop = function () {};

var _undefined = noop(); // Support ES3 engines

var isValue$4 = function (val) { return val !== _undefined && val !== null; };

var isValue$3 = isValue$4;

var keys$2 = Object.keys;

var shim$2 = function (object) { return keys$2(isValue$3(object) ? Object(object) : object); };

var keys$1 = isImplemented$1() ? Object.keys : shim$2;

var isValue$2 = isValue$4;

var validValue = function (value) {
	if (!isValue$2(value)) throw new TypeError("Cannot use null or undefined");
	return value;
};

var keys  = keys$1
  , value = validValue
  , max   = Math.max;

var shim$1 = function (dest, src/*, srcn*/) {
	var error, i, length = max(arguments.length, 2), assign;
	dest = Object(value(dest));
	assign = function (key) {
		try {
			dest[key] = src[key];
		} catch (e) {
			if (!error) error = e;
		}
	};
	for (i = 1; i < length; ++i) {
		src = arguments[i];
		keys(src).forEach(assign);
	}
	if (error !== undefined) throw error;
	return dest;
};

var assign$1 = isImplemented$2() ? Object.assign : shim$1;

var isValue$1 = isValue$4;

var forEach = Array.prototype.forEach, create = Object.create;

var process = function (src, obj) {
	var key;
	for (key in src) obj[key] = src[key];
};

// eslint-disable-next-line no-unused-vars
var normalizeOptions = function (opts1/*, options*/) {
	var result = create(null);
	forEach.call(arguments, function (options) {
		if (!isValue$1(options)) return;
		process(Object(options), result);
	});
	return result;
};

var str = "razdwatrzy";

var isImplemented = function () {
	if (typeof str.contains !== "function") return false;
	return str.contains("dwa") === true && str.contains("foo") === false;
};

var indexOf = String.prototype.indexOf;

var shim = function (searchString/*, position*/) {
	return indexOf.call(this, searchString, arguments[1]) > -1;
};

var contains$1 = isImplemented() ? String.prototype.contains : shim;

var isValue         = is$4
  , isPlainFunction = is
  , assign          = assign$1
  , normalizeOpts   = normalizeOptions
  , contains        = contains$1;

var d = (d$1.exports = function (dscr, value/*, options*/) {
	var c, e, w, options, desc;
	if (arguments.length < 2 || typeof dscr !== "string") {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (isValue(dscr)) {
		c = contains.call(dscr, "c");
		e = contains.call(dscr, "e");
		w = contains.call(dscr, "w");
	} else {
		c = w = true;
		e = false;
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOpts(options), desc);
});

d.gs = function (dscr, get, set/*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== "string") {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (!isValue(get)) {
		get = undefined;
	} else if (!isPlainFunction(get)) {
		options = get;
		get = set = undefined;
	} else if (!isValue(set)) {
		set = undefined;
	} else if (!isPlainFunction(set)) {
		options = set;
		set = undefined;
	}
	if (isValue(dscr)) {
		c = contains.call(dscr, "c");
		e = contains.call(dscr, "e");
	} else {
		c = true;
		e = false;
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

var validCallable = function (fn) {
	if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
	return fn;
};

(function (module, exports) {

var d        = d$1.exports
  , callable = validCallable

  , apply = Function.prototype.apply, call = Function.prototype.call
  , create = Object.create, defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , descriptor = { configurable: true, enumerable: false, writable: true }

  , on, once, off, emit, methods, descriptors, base;

on = function (type, listener) {
	var data;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) {
		data = descriptor.value = create(null);
		defineProperty(this, '__ee__', descriptor);
		descriptor.value = null;
	} else {
		data = this.__ee__;
	}
	if (!data[type]) data[type] = listener;
	else if (typeof data[type] === 'object') data[type].push(listener);
	else data[type] = [data[type], listener];

	return this;
};

once = function (type, listener) {
	var once, self;

	callable(listener);
	self = this;
	on.call(this, type, once = function () {
		off.call(self, type, once);
		apply.call(listener, this, arguments);
	});

	once.__eeOnceListener__ = listener;
	return this;
};

off = function (type, listener) {
	var data, listeners, candidate, i;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) return this;
	data = this.__ee__;
	if (!data[type]) return this;
	listeners = data[type];

	if (typeof listeners === 'object') {
		for (i = 0; (candidate = listeners[i]); ++i) {
			if ((candidate === listener) ||
					(candidate.__eeOnceListener__ === listener)) {
				if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
				else listeners.splice(i, 1);
			}
		}
	} else {
		if ((listeners === listener) ||
				(listeners.__eeOnceListener__ === listener)) {
			delete data[type];
		}
	}

	return this;
};

emit = function (type) {
	var i, l, listener, listeners, args;

	if (!hasOwnProperty.call(this, '__ee__')) return;
	listeners = this.__ee__[type];
	if (!listeners) return;

	if (typeof listeners === 'object') {
		l = arguments.length;
		args = new Array(l - 1);
		for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

		listeners = listeners.slice();
		for (i = 0; (listener = listeners[i]); ++i) {
			apply.call(listener, this, args);
		}
	} else {
		switch (arguments.length) {
		case 1:
			call.call(listeners, this);
			break;
		case 2:
			call.call(listeners, this, arguments[1]);
			break;
		case 3:
			call.call(listeners, this, arguments[1], arguments[2]);
			break;
		default:
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) {
				args[i - 1] = arguments[i];
			}
			apply.call(listeners, this, args);
		}
	}
};

methods = {
	on: on,
	once: once,
	off: off,
	emit: emit
};

descriptors = {
	on: d(on),
	once: d(once),
	off: d(off),
	emit: d(emit)
};

base = defineProperties({}, descriptors);

module.exports = exports = function (o) {
	return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
};
exports.methods = methods;
}(eventEmitter$1, eventEmitter$1.exports));

var normalizedInteractionEvents_1 = normalizedInteractionEvents;

var mouseChange = mouseListen_1;
var eventOffset = mouseEventOffset_1;
var eventEmitter = eventEmitter$1.exports;

function normalizedInteractionEvents (element) {
  element = element || window;

  var emitter = eventEmitter();
  var previousPosition = [null, null];
  var previousFingerPosition = [null, null];
  var currentPosition = [null, null];
  var fingers = [null, null];
  var activeTouchCount = 0;
  var ev = {};


  var width, height;

  var getSize = element === window ? function () {
    width = window.innerWidth;
    height = window.innerHeight;
  } : function () {
    width = element.clientWidth;
    height = element.clientHeight;
  };

  var buttons = 0;
  var mouseX;
  var mouseY;
  var mods = {};
  var changeListener = mouseChange(element, function(pbuttons, px, py, pmods) {
    mouseX = px;
    mouseY = py;
    buttons = pbuttons;
    mods = pmods;
  });

  function onWheel (event) {
    eventOffset(event, element, currentPosition);
    getSize();

    ev.buttons = buttons;
    ev.mods = mods;
    ev.x0 = ev.x = ev.x1 = 2 * currentPosition[0] / width - 1;
    ev.y0 = ev.y = ev.y1 = 1 - 2 * currentPosition[1] / height;
    ev.x2 = null;
    ev.y2 = null;
    ev.dx = 2 * event.deltaX / width;
    ev.dy = -2 * event.deltaY / height;
    ev.dz = 2 * event.deltaZ / width;
    ev.active = 1;
    ev.zoomx = 1;
    ev.zoomy = 1;
    ev.theta = 0;
    ev.dtheta = 0;
    ev.originalEvent = event;

    emitter.emit('wheel', ev);

    previousPosition[0] = currentPosition[0];
    previousPosition[1] = currentPosition[1];
  }

  var x0 = null;
  var y0 = null;
  var active = 0;

  function onMouseUp (event) {
    eventOffset(event, element, currentPosition);
    active = 0;
    getSize();

    ev.buttons = buttons;
    ev.mods = mods;
    ev.x = ev.x1 = 2 * currentPosition[0] / width - 1;
    ev.y = ev.y1 = 1 - 2 * currentPosition[1] / height;
    ev.x2 = null;
    ev.y2 = null;
    ev.active = active;
    ev.x0 = 2 * x0 / width - 1;
    ev.y0 = 1 - 2 * y0 / height;
    ev.dx = 0;
    ev.dy = 0;
    ev.dz = 0;
    ev.zoomx = 1;
    ev.zoomy = 1;
    ev.theta = 0;
    ev.dtheta = 0;
    ev.originalEvent = event;

    emitter.emit('mouseup', ev);

    x0 = y0 = null;

    previousPosition[0] = currentPosition[0];
    previousPosition[1] = currentPosition[1];
  }

  function onMouseDown (event) {
    eventOffset(event, element, currentPosition);
    active = 1;
    getSize();

    x0 = mouseX;
    y0 = mouseY;

    ev.buttons = buttons;
    ev.mods = mods;
    ev.x = ev.x0 = ev.x1 = 2 * currentPosition[0] / width - 1;
    ev.y = ev.y0 = ev.y1 = 1 - 2 * currentPosition[1] / height;
    ev.x2 = null;
    ev.y2 = null;
    ev.active = active;
    ev.dx = 0;
    ev.dy = 0;
    ev.dz = 0;
    ev.zoomx = 1;
    ev.zoomy = 1;
    ev.theta = 0;
    ev.dtheta = 0;
    ev.originalEvent = event;

    emitter.emit('mousedown', ev);

    previousPosition[0] = currentPosition[0];
    previousPosition[1] = currentPosition[1];
  }

  function onMouseMove (event) {
    eventOffset(event, element, currentPosition);
    getSize();

    ev.buttons = buttons;
    ev.mods = mods;
    ev.x0 = 2 * x0 / width - 1;
    ev.y0 = 1 - 2 * y0 / height;
    ev.x = ev.x1 = 2 * currentPosition[0] / width - 1;
    ev.y = ev.y1 = 1 - 2 * currentPosition[1] / height;
    ev.x2 = null;
    ev.y2 = null;
    ev.dx = 2 * (currentPosition[0] - previousPosition[0]) / width;
    ev.dy = -2 * (currentPosition[1] - previousPosition[1]) / height;
    ev.active = active;
    ev.dz = 0;
    ev.zoomx = 1;
    ev.zoomy = 1;
    ev.theta = 0;
    ev.dtheta = 0;
    ev.originalEvent = event;

    emitter.emit('mousemove', ev);

    previousPosition[0] = currentPosition[0];
    previousPosition[1] = currentPosition[1];
  }

  function indexOfTouch (touch) {
    var id = touch.identifier;
    for (var i = 0; i < fingers.length; i++) {
      if (fingers[i] &&
        fingers[i].touch &&
        fingers[i].touch.identifier === id) {
        return i
      }
    }
    return -1
  }

  function onTouchStart (event) {
    previousFingerPosition[0] = null;
    previousFingerPosition[1] = null;

    for (var i = 0; i < event.changedTouches.length; i++) {
      var newTouch = event.changedTouches[i];
      var id = newTouch.identifier;
      var idx = indexOfTouch(id);

      if (idx === -1 && activeTouchCount < 2) {

        // newest and previous finger (previous may be undefined)
        var newIndex = fingers[0] ? 1 : 0;
        var oldIndex = fingers[0] ? 0 : 1;
        var newFinger = {
          position: [0, 0],
          touch: null
        };

        // add to stack
        fingers[newIndex] = newFinger;
        activeTouchCount++;

        // update touch event & position
        newFinger.touch = newTouch;
        eventOffset(newTouch, element, newFinger.position);

        fingers[oldIndex] ? fingers[oldIndex].touch : undefined;
      }
    }

    var xavg = 0;
    var yavg = 0;
    var fingerCount = 0;
    for (var i = 0; i < fingers.length; i++) {
      if (!fingers[i]) continue;
      xavg += fingers[i].position[0];
      yavg += fingers[i].position[1];
      fingerCount++;
    }
    xavg /= fingerCount;
    yavg /= fingerCount;


    if (activeTouchCount > 0) {
      ev.theta = 0;

      if (fingerCount > 1) {
        var dx = fingers[1].position[0] - fingers[0].position[0];
        var dy = (fingers[0].position[1] - fingers[1].position[1]) * width / height;
        ev.theta = Math.atan2(dy, dx);
      }

      getSize();
      ev.buttons = 0;
      ev.mods = {};
      ev.active = activeTouchCount;
      x0 = xavg;
      y0 = yavg;
      ev.x0 = 2 * x0 / width - 1;
      ev.y0 = 1 - 2 * y0 / height;
      ev.x = 2 * xavg / width - 1;
      ev.y = 1 - 2 * yavg / height;
      ev.x1 = 2 * fingers[0].position[0] / width - 1;
      ev.y1 = 1 - 2 * fingers[0].position[1] / height;
      if (activeTouchCount > 1) {
        ev.x2 = 2 * fingers[1].position[0] / width - 1;
        ev.y2 = 1 - 2 * fingers[1].position[1] / height;
      }
      ev.active = activeTouchCount;
      ev.dx = 0;
      ev.dy = 0;
      ev.dz = 0;
      ev.zoomx = 1;
      ev.zoomy = 1;
      ev.dtheta = 0;
      ev.originalEvent = event;
      emitter.emit(activeTouchCount === 1 ? 'touchstart' : 'pinchstart', ev);
    }
  }

  function onTouchMove (event) {
    var idx;
    var changed = false;
    for (var i = 0; i < event.changedTouches.length; i++) {
      var movedTouch = event.changedTouches[i];
      idx = indexOfTouch(movedTouch);

      if (idx !== -1) {
        changed = true;
        fingers[idx].touch = movedTouch; // avoid caching touches
        eventOffset(movedTouch, element, fingers[idx].position);
      }
    }

    if (changed) {
      if (activeTouchCount === 1) {
        for (idx = 0; idx < fingers.length; idx++) {
          if (fingers[idx]) break;
        }

        if (fingers[idx] && previousFingerPosition[idx]) {
          var x = fingers[idx].position[0];
          var y = fingers[idx].position[1];

          var dx = x - previousFingerPosition[idx][0];
          var dy = y - previousFingerPosition[idx][1];

          ev.buttons = 0;
          ev.mods = {};
          ev.active = activeTouchCount;
          ev.x = ev.x1 = 2 * x / width - 1;
          ev.y = ev.y1 = 1 - 2 * y / height;
          ev.x2 = null;
          ev.y2 = null;
          ev.x0 = 2 * x0 / width - 1;
          ev.y0 = 1 - 2 * y0 / height;
          ev.dx = 2 * dx / width;
          ev.dy = -2 * dy / height;
          ev.dz = 0;
          ev.zoomx = 1;
          ev.zoomy = 1;
          ev.theta = 0;
          ev.dtheta = 0;
          ev.originalEvent = event;

          emitter.emit('touchmove', ev);
        }
      } else if (activeTouchCount === 2) {
        if (previousFingerPosition[0] && previousFingerPosition[1]) {
          // Previous two-finger vector:
          var pos0A = previousFingerPosition[0];
          var pos0B = previousFingerPosition[1];
          var dx0 = pos0B[0] - pos0A[0];
          var dy0 = (pos0B[1] - pos0A[1]) * width / height;

          // Current two-finger vector:
          var pos1A = fingers[0].position;
          var pos1B = fingers[1].position;
          var dx1 = pos1B[0] - pos1A[0];
          var dy1 = (pos1A[1] - pos1B[1]) * width / height;

          // r, theta for the previous two-finger touch:
          var r0 = Math.sqrt(dx0 * dx0 + dy0 * dy0) * 0.5;
          var theta0 = Math.atan2(dy0, dx0);

          // r, theta for the current two-finger touch:
          var r1 = Math.sqrt(dx1 * dx1 + dy1 * dy1) * 0.5;
          var theta1 = Math.atan2(dy1, dx1);

          var xavg = (pos0B[0] + pos0A[0]) * 0.5;
          var yavg = (pos0B[1] + pos0A[1]) * 0.5;
          var dx = 0.5 * (pos1B[0] + pos1A[0] - pos0A[0] - pos0B[0]);
          var dy = 0.5 * (pos1B[1] + pos1A[1] - pos0A[1] - pos0B[1]);

          var dr = r1 / r0;
          var dtheta = theta1 - theta0;

          ev.buttons = 0;
          ev.mods = mods;
          ev.active = activeTouchCount;
          ev.x = 2 * xavg / width - 1;
          ev.y = 1 - 2 * yavg / height;
          ev.x0 = 2 * x0 / width - 1;
          ev.y0 = 1 - 2 * y0 / height;
          ev.x1 = 2 * pos1A[0] / width - 1;
          ev.y1 = 1 - 2 * pos1A[1] / height;
          ev.x2 = 2 * pos1B[0] / width - 1;
          ev.y2 = 1 - 2 * pos1B[1] / height;
          ev.dx = 2 * dx / width;
          ev.dy = -2 * dy / height;
          ev.dz = 0;
          ev.zoomx = dr;
          ev.zoomy = dr;
          ev.theta = theta1;
          ev.dtheta = dtheta;
          ev.originalEvent = event;

          emitter.emit('pinchmove', ev);
        }
      }
    }

    if (fingers[0]) {
      previousFingerPosition[0] = fingers[0].position.slice();
    }

    if (fingers[1]) {
      previousFingerPosition[1] = fingers[1].position.slice();
    }
  }

  function onTouchRemoved (event) {
    var lastFinger;
    for (var i = 0; i < event.changedTouches.length; i++) {
      var removed = event.changedTouches[i];
      var idx = indexOfTouch(removed);

      if (idx !== -1) {
        lastFinger = fingers[idx];
        fingers[idx] = null;
        activeTouchCount--;
        var otherIdx = idx === 0 ? 1 : 0;
        fingers[otherIdx] ? fingers[otherIdx].touch : undefined;
      }
    }

    var xavg = 0;
    var yavg = 0;
    if (activeTouchCount === 0) {
      if (lastFinger) {
        xavg = lastFinger.position[0];
        yavg = lastFinger.position[1];
      }
    } else {
      var fingerCount = 0;
      for (var i = 0; i < fingers.length; i++) {
        if (!fingers[i]) continue;
        xavg += fingers[i].position[0];
        yavg += fingers[i].position[1];
        fingerCount++;
      }
      xavg /= fingerCount;
      yavg /= fingerCount;
    }

    if (activeTouchCount < 2) {
      ev.buttons = 0;
      ev.mods = mods;
      ev.active = activeTouchCount;
      ev.x = 2 * xavg / width - 1;
      ev.y = 1 - 2 * yavg / height;
      ev.x0 = 2 * x0 / width - 1;
      ev.y0 = 1 - 2 * y0 / height;
      ev.dx = 0;
      ev.dy = 0;
      ev.dz = 0;
      ev.zoomx = 1;
      ev.zoomy = 1;
      ev.theta = 0;
      ev.dtheta = 0;
      ev.originalEvent = event;
      emitter.emit(activeTouchCount === 0 ? 'touchend' : 'pinchend', ev);
    }
    if (activeTouchCount === 0) {
      x0 = y0 = null;
    }
  }


  var enabled = false;
  function enable () {
    if (enabled) return;
    enabled = true;
    changeListener.enabled = true;
    element.addEventListener('wheel', onWheel, false);
    element.addEventListener('mousedown', onMouseDown, false);
    window.addEventListener('mousemove', onMouseMove, false);
    window.addEventListener('mouseup', onMouseUp, false);

    element.addEventListener('touchstart', onTouchStart, false);
    window.addEventListener('touchmove', onTouchMove, false);
    window.addEventListener('touchend', onTouchRemoved, false);
    window.addEventListener('touchcancel', onTouchRemoved, false);
  }

  function disable () {
    if (!enabled) return;
    enabled = false;
    changeListener.enabled = false;
    element.removeEventListener('wheel', onWheel, false);
    element.removeEventListener('mousedown', onMouseDown, false);
    window.removeEventListener('mousemove', onMouseMove, false);
    window.removeEventListener('mouseup', onMouseUp, false);

    element.removeEventListener('touchstart', onTouchStart, false);
    window.removeEventListener('touchmove', onTouchMove, false);
    window.removeEventListener('touchend', onTouchRemoved, false);
    window.removeEventListener('touchcancel', onTouchRemoved, false);
  }

  enable();

  emitter.enable = enable;
  emitter.disable = disable;

  return emitter;
}

const decayTime = 100;
const makeCamera = () => inertialTurntableCamera({
  aspectRatio: window.innerWidth / window.innerHeight,
  distance: 100,
  center: [0, 0, 0],
  rotationDecayTime: decayTime,
  panDecayTime: decayTime,
  zoomDecayTime: decayTime,
  // fovY: Math.PI*5/7,
  far: 100000000000000000,
  near: 0.01
});

const radiansPerHalfScreenWidth = Math.PI * 1;

const setupCamera = (canvas, camera) => {
  normalizedInteractionEvents_1(canvas)
    .on("wheel", function (ev) {
      camera.zoom(ev.x, ev.y, Math.exp(-ev.dy) - 1.0);
      ev.originalEvent.preventDefault();
    })
    .on("mousemove", function (ev) {
      if (!ev.active || ev.buttons !== 1) return;

      if (ev.mods.shift) {
        camera.pan(ev.dx, ev.dy);
      } else if (ev.mods.meta) {
        camera.pivot(ev.dx, ev.dy);
      } else {
        camera.rotate(
          -ev.dx * radiansPerHalfScreenWidth,
          -ev.dy * radiansPerHalfScreenWidth
        );
      }
      ev.originalEvent.preventDefault();
    })
    .on("touchmove", function (ev) {
      if (!ev.active) return;
      camera.rotate(
        -ev.dx * radiansPerHalfScreenWidth,
        -ev.dy * radiansPerHalfScreenWidth
      );
      ev.originalEvent.preventDefault();
    })
    .on("pinchmove", function (ev) {
      if (!ev.active) return;
      camera.zoom(ev.x, ev.y, 1 - ev.zoomx);
      camera.pan(ev.dx, ev.dy);
    })
    .on("touchstart", (ev) => ev.originalEvent.preventDefault())
    .on("pinchstart", (ev) => ev.originalEvent.preventDefault());

  window.addEventListener(
    "resize",
    function () {
      width = window.innerWidth;
      height = window.innerHeight;
      camera.resize(width / height);
    },
    false
  );
};

function requestAnimationFrame$1(callback) {
  return typeof window !== 'undefined' && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1000 / 60);
}

const membersCGA3 = [
  `scalar`,
  `e1`,
  `e2`,
  `e3`,
  `e4`,
  `e5`,
  `e12`,
  `e13`,
  `e14`,
  `e15`,
  `e23`,
  `e24`,
  `e25`,
  `e34`,
  `e35`,
  `e45`,
  `e123`,
  `e124`,
  `e125`,
  `e134`,
  `e135`,
  `e145`,
  `e234`,
  `e235`,
  `e245`,
  `e345`,
  `e1234`,
  `e1235`,
  `e1245`,
  `e1345`,
  `e2345`,
  `e12345`
];
const arrayToCga3StructProps = (array) => fromPairs(zip$2(membersCGA3, array));

moize((shape, resolution = 8) => {
  let points;
  if (Array.isArray(resolution)) {
    resolution = resolution;
    points = (shape === QUAD ? quadPatch(...resolution) : triPatch(...resolution)).points;
  } else {
    points = shape === QUAD ? uvGrid(resolution) : triPatch(resolution, resolution, resolution).points;
  }
  return Delaunator.from(points);
});
moize((grid) => {
  let mesh = {};
  mesh.cells = chunk(grid.triangles, 3);
  mesh.positions = chunk(grid.coords, 2).map(([u, v]) => [
    u,
    v,
    0
  ]);
  mesh.normals = normals(mesh.cells, mesh.positions);
  return mesh;
}, { maxSize: 40 });
const QUAD = "quad";

const canvas = document.createElement("canvas");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
document.body.appendChild(canvas);
const app = PicoGL.createApp(canvas)
  .clearColor(0.0, 0.0, 0.0, 1.0)
  // .enable(PicoGL.BLEND)
  .blendFunc(PicoGL.ONE, PicoGL.ONE_MINUS_SRC_ALPHA);
app.clear();

// Create a Clifford Algebra with 4,1 metric for 3D CGA.
Algebra(4, 1, () => {
  const Element = globalThis;
  // We start by defining a null basis, and upcasting for points
  var ni = 1e4 + 1e5,
    no = 0.5e5 - 0.5e4;
  var up = (x) => no + x + 0.5 * x * x * ni;

  // Next we'll define 4 points
  var p1 = up(0.5e1),
    p2 = up(0 + 1e2),
    p3 = up(0 - 1e2),
    p4 = up(0 + 1e1 + 1e2);

  // The outer product can be used to construct the sphere through
  // any four points.
  var s = () => p1 ^ p2 ^ p3 ^ p4;

  // The outer product between any three points and infinity is a plane.
  var p = () => p1 ^ p2 ^ p3 ^ ni;

  // Graph the items.
  const graph = Element.graph(
    [
      0x00ff0000,
      p1,
      "p1",
      p2,
      "p2",
      p3,
      "p3",
      p4,
      "p4", // points
      0xe0008800,
      p,
      "p", // plane
      0xe00000ff,
      s,
      "s", // sphere
    ],
    { conformal: true, gl: true, grid: true, alpha: true }
  );
  graph.setAttribute("id", "graph");
  window.graph = graph;
  document.body.appendChild(graph);
  return globalThis;
});
const cubeMeshPolys = moize((divs = null) => {
  const mesh = primitiveCube(
    1,
    1,
    1,
    divs || Number(document.querySelector("#cube-divs").value)
  );
  const meshPolys = prepareMesh(mesh);
  return meshPolys;
});

document.addEventListener("DOMContentLoaded", async function () {
  const camera = makeCamera();
  window.cam = camera;
  setupCamera(canvas, camera);
  const { swooshImage, seafoamImage, matcapImages } = await __vitePreload(() => import(
    './load-textures.061de84c.js'
  ),true?[]:void 0);
  const matcap = app.createTexture2D(matcapImages[4]);
  matcapImages.map((data) => app.createTexture2D(data));
  const texture = app.createTexture2D(seafoamImage);

  const buffersAndDrawer = moize.infinite((cubeDivs, lod, cornerColors) => {
    console.log("computing buffers and drawcall");
    const transformer = cellsTransformer(app, cubeMeshPolys(cubeDivs));

    const { transformedPointsBuffer, transformedWeightsBuffer } = transformer;

    const { patchDraw, tessellation } = patchDrawCall(
      app,
      lod,
      transformedPointsBuffer,
      transformedWeightsBuffer,
      cornerColors
    );

    return {
      patchDraw: patchDraw
        .texture("colorTexture", texture)
        .texture("matcapTexture", matcap),
      tessellation,
      ...transformer,
    };
  });

  const raf = () => {
    const enableCornerColors = document.querySelector('#corner-colors').checked;
    const {
      patchDraw,
      drawer: transformer,
      // getTransformedWeights,
      // getTransformedPoints,
      getLODs,
      numCells,
      tessellation,
      // transformedPointsBuffer,
      // transformedWeightsBuffer,
    } = buffersAndDrawer(
      Number(document.querySelector("#cube-divs").value),
      Number(document.querySelector("#lod").value),
      enableCornerColors
    );

    document.querySelector("#tris").textContent = `tris: ${humanFormat(
      numCells * tessellation.cells.length
    )}`;

    const sph = arrayToCga3StructProps(graph.value[13]());
    // console.log(JSON.stringify(sph));

    // camera.tick();
    app.enable(PicoGL.RASTERIZER_DISCARD);
    app.disable(PicoGL.DEPTH_TEST);

    setStructUniforms(transformer, "transformation", sph)
      .uniform(
        "x",
        new Float32Array(
          [...document.querySelectorAll(".x")].map((x) => Number(x.value))
        )
      )
      .uniform(
        "y",
        new Float32Array(
          [...document.querySelectorAll(".y")].map((x) => Number(x.value))
        )
      )
      .draw();

    app.disable(PicoGL.RASTERIZER_DISCARD);
    app.enable(PicoGL.DEPTH_TEST);
    app.clear();

    patchDraw
      // .drawRanges(...(new Array(50)).fill([0,90*4,1]))
      .uniform("projection", new Float32Array(graph.options.proj))
      .uniform("eye", camera.state.eye)
      .uniform("view", new Float32Array(graph.options.mv))
      .draw();

    requestAnimationFrame$1(raf);
  };

  requestAnimationFrame$1(raf);
  document
    .querySelector("#toggle-graph")
    .addEventListener("click", () => graph.classList.toggle("hidden"));
});

var index_html_htmlProxy_index_1 = '';

export { __vitePreload as _ };
