// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"idWrV":[function(require,module,exports) {
// @ts-ignore
var _worker = require("threads/worker");
var _tessellation = require("./tessellation");
// create a worker and register public functions
_worker.expose({
    tessellationMesh: _tessellation.tessellationMesh
});

},{"threads/worker":"1X3yE","./tessellation":"0FAPM"}],"1X3yE":[function(require,module,exports) {
module.exports = require("./dist/worker/index");

},{"./dist/worker/index":"eOhss"}],"eOhss":[function(require,module,exports) {
"use strict";
var process = require("process");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.expose = exports.isWorkerRuntime = exports.Transfer = exports.registerSerializer = void 0;
const is_observable_1 = __importDefault(require("is-observable"));
const common_1 = require("../common");
const transferable_1 = require("../transferable");
const messages_1 = require("../types/messages");
const implementation_1 = __importDefault(require("./implementation"));
var common_2 = require("../common");
Object.defineProperty(exports, "registerSerializer", {
    enumerable: true,
    get: function() {
        return common_2.registerSerializer;
    }
});
var transferable_2 = require("../transferable");
Object.defineProperty(exports, "Transfer", {
    enumerable: true,
    get: function() {
        return transferable_2.Transfer;
    }
});
/** Returns `true` if this code is currently running in a worker. */ exports.isWorkerRuntime = implementation_1.default.isWorkerRuntime;
let exposeCalled = false;
const activeSubscriptions = new Map();
const isMasterJobCancelMessage = (thing)=>thing && thing.type === messages_1.MasterMessageType.cancel
;
const isMasterJobRunMessage = (thing)=>thing && thing.type === messages_1.MasterMessageType.run
;
/**
 * There are issues with `is-observable` not recognizing zen-observable's instances.
 * We are using `observable-fns`, but it's based on zen-observable, too.
 */ const isObservable = (thing)=>is_observable_1.default(thing) || isZenObservable(thing)
;
function isZenObservable(thing) {
    return thing && typeof thing === "object" && typeof thing.subscribe === "function";
}
function deconstructTransfer(thing) {
    return transferable_1.isTransferDescriptor(thing) ? {
        payload: thing.send,
        transferables: thing.transferables
    } : {
        payload: thing,
        transferables: undefined
    };
}
function postFunctionInitMessage() {
    const initMessage = {
        type: messages_1.WorkerMessageType.init,
        exposed: {
            type: "function"
        }
    };
    implementation_1.default.postMessageToMaster(initMessage);
}
function postModuleInitMessage(methodNames) {
    const initMessage = {
        type: messages_1.WorkerMessageType.init,
        exposed: {
            type: "module",
            methods: methodNames
        }
    };
    implementation_1.default.postMessageToMaster(initMessage);
}
function postJobErrorMessage(uid, rawError) {
    const { payload: error , transferables  } = deconstructTransfer(rawError);
    const errorMessage = {
        type: messages_1.WorkerMessageType.error,
        uid,
        error: common_1.serialize(error)
    };
    implementation_1.default.postMessageToMaster(errorMessage, transferables);
}
function postJobResultMessage(uid, completed, resultValue) {
    const { payload , transferables  } = deconstructTransfer(resultValue);
    const resultMessage = {
        type: messages_1.WorkerMessageType.result,
        uid,
        complete: completed ? true : undefined,
        payload
    };
    implementation_1.default.postMessageToMaster(resultMessage, transferables);
}
function postJobStartMessage(uid, resultType) {
    const startMessage = {
        type: messages_1.WorkerMessageType.running,
        uid,
        resultType
    };
    implementation_1.default.postMessageToMaster(startMessage);
}
function postUncaughtErrorMessage(error) {
    try {
        const errorMessage = {
            type: messages_1.WorkerMessageType.uncaughtError,
            error: common_1.serialize(error)
        };
        implementation_1.default.postMessageToMaster(errorMessage);
    } catch (subError) {
        // tslint:disable-next-line no-console
        console.error("Not reporting uncaught error back to master thread as it occured while reporting an uncaught error already.\nLatest error:", subError, "\nOriginal error:", error);
    }
}
function runFunction(jobUID, fn, args) {
    return __awaiter(this, void 0, void 0, function*() {
        let syncResult;
        try {
            syncResult = fn(...args);
        } catch (error1) {
            return postJobErrorMessage(jobUID, error1);
        }
        const resultType = isObservable(syncResult) ? "observable" : "promise";
        postJobStartMessage(jobUID, resultType);
        if (isObservable(syncResult)) {
            const subscription = syncResult.subscribe((value)=>postJobResultMessage(jobUID, false, common_1.serialize(value))
            , (error)=>{
                postJobErrorMessage(jobUID, common_1.serialize(error));
                activeSubscriptions.delete(jobUID);
            }, ()=>{
                postJobResultMessage(jobUID, true);
                activeSubscriptions.delete(jobUID);
            });
            activeSubscriptions.set(jobUID, subscription);
        } else try {
            const result = yield syncResult;
            postJobResultMessage(jobUID, true, common_1.serialize(result));
        } catch (error) {
            postJobErrorMessage(jobUID, common_1.serialize(error));
        }
    });
}
/**
 * Expose a function or a module (an object whose values are functions)
 * to the main thread. Must be called exactly once in every worker thread
 * to signal its API to the main thread.
 *
 * @param exposed Function or object whose values are functions
 */ function expose(exposed) {
    if (!implementation_1.default.isWorkerRuntime()) throw Error("expose() called in the master thread.");
    if (exposeCalled) throw Error("expose() called more than once. This is not possible. Pass an object to expose() if you want to expose multiple functions.");
    exposeCalled = true;
    if (typeof exposed === "function") {
        implementation_1.default.subscribeToMasterMessages((messageData)=>{
            if (isMasterJobRunMessage(messageData) && !messageData.method) runFunction(messageData.uid, exposed, messageData.args.map(common_1.deserialize));
        });
        postFunctionInitMessage();
    } else if (typeof exposed === "object" && exposed) {
        implementation_1.default.subscribeToMasterMessages((messageData)=>{
            if (isMasterJobRunMessage(messageData) && messageData.method) runFunction(messageData.uid, exposed[messageData.method], messageData.args.map(common_1.deserialize));
        });
        const methodNames = Object.keys(exposed).filter((key)=>typeof exposed[key] === "function"
        );
        postModuleInitMessage(methodNames);
    } else throw Error(`Invalid argument passed to expose(). Expected a function or an object, got: ${exposed}`);
    implementation_1.default.subscribeToMasterMessages((messageData)=>{
        if (isMasterJobCancelMessage(messageData)) {
            const jobUID = messageData.uid;
            const subscription = activeSubscriptions.get(jobUID);
            if (subscription) {
                subscription.unsubscribe();
                activeSubscriptions.delete(jobUID);
            }
        }
    });
}
exports.expose = expose;
if (typeof self !== "undefined" && typeof self.addEventListener === "function" && implementation_1.default.isWorkerRuntime()) {
    self.addEventListener("error", (event)=>{
        // Post with some delay, so the master had some time to subscribe to messages
        setTimeout(()=>postUncaughtErrorMessage(event.error || event)
        , 250);
    });
    self.addEventListener("unhandledrejection", (event)=>{
        const error = event.reason;
        if (error && typeof error.message === "string") // Post with some delay, so the master had some time to subscribe to messages
        setTimeout(()=>postUncaughtErrorMessage(error)
        , 250);
    });
}
if (typeof process !== "undefined" && typeof process.on === "function" && implementation_1.default.isWorkerRuntime()) {
    process.on("uncaughtException", (error)=>{
        // Post with some delay, so the master had some time to subscribe to messages
        setTimeout(()=>postUncaughtErrorMessage(error)
        , 250);
    });
    process.on("unhandledRejection", (error)=>{
        if (error && typeof error.message === "string") // Post with some delay, so the master had some time to subscribe to messages
        setTimeout(()=>postUncaughtErrorMessage(error)
        , 250);
    });
}

},{"process":"jhUEF","is-observable":"2UHUF","../common":"l8QHj","../transferable":"8esid","../types/messages":"i6dgh","./implementation":"4pSnX"}],"jhUEF":[function(require,module,exports) {
"use strict";

},{}],"2UHUF":[function(require,module,exports) {
'use strict';
module.exports = (value)=>{
    if (!value) return false;
    // eslint-disable-next-line no-use-extend-native/no-use-extend-native
    if (typeof Symbol.observable === 'symbol' && typeof value[Symbol.observable] === 'function') // eslint-disable-next-line no-use-extend-native/no-use-extend-native
    return value === value[Symbol.observable]();
    if (typeof value['@@observable'] === 'function') return value === value['@@observable']();
    return false;
};

},{}],"l8QHj":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.serialize = exports.deserialize = exports.registerSerializer = void 0;
const serializers_1 = require("./serializers");
let registeredSerializer = serializers_1.DefaultSerializer;
function registerSerializer(serializer) {
    registeredSerializer = serializers_1.extendSerializer(registeredSerializer, serializer);
}
exports.registerSerializer = registerSerializer;
function deserialize(message) {
    return registeredSerializer.deserialize(message);
}
exports.deserialize = deserialize;
function serialize(input) {
    return registeredSerializer.serialize(input);
}
exports.serialize = serialize;

},{"./serializers":"7HwjH"}],"7HwjH":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DefaultSerializer = exports.extendSerializer = void 0;
function extendSerializer(extend, implementation) {
    const fallbackDeserializer = extend.deserialize.bind(extend);
    const fallbackSerializer = extend.serialize.bind(extend);
    return {
        deserialize (message) {
            return implementation.deserialize(message, fallbackDeserializer);
        },
        serialize (input) {
            return implementation.serialize(input, fallbackSerializer);
        }
    };
}
exports.extendSerializer = extendSerializer;
const DefaultErrorSerializer = {
    deserialize (message) {
        return Object.assign(Error(message.message), {
            name: message.name,
            stack: message.stack
        });
    },
    serialize (error) {
        return {
            __error_marker: "$$error",
            message: error.message,
            name: error.name,
            stack: error.stack
        };
    }
};
const isSerializedError = (thing)=>thing && typeof thing === "object" && "__error_marker" in thing && thing.__error_marker === "$$error"
;
exports.DefaultSerializer = {
    deserialize (message) {
        if (isSerializedError(message)) return DefaultErrorSerializer.deserialize(message);
        else return message;
    },
    serialize (input) {
        if (input instanceof Error) return DefaultErrorSerializer.serialize(input);
        else return input;
    }
};

},{}],"8esid":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Transfer = exports.isTransferDescriptor = void 0;
const symbols_1 = require("./symbols");
function isTransferable(thing) {
    if (!thing || typeof thing !== "object") return false;
    // Don't check too thoroughly, since the list of transferable things in JS might grow over time
    return true;
}
function isTransferDescriptor(thing) {
    return thing && typeof thing === "object" && thing[symbols_1.$transferable];
}
exports.isTransferDescriptor = isTransferDescriptor;
function Transfer(payload, transferables) {
    if (!transferables) {
        if (!isTransferable(payload)) throw Error();
        transferables = [
            payload
        ];
    }
    return {
        [symbols_1.$transferable]: true,
        send: payload,
        transferables
    };
}
exports.Transfer = Transfer;

},{"./symbols":"kIGFG"}],"kIGFG":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.$worker = exports.$transferable = exports.$terminate = exports.$events = exports.$errors = void 0;
exports.$errors = Symbol("thread.errors");
exports.$events = Symbol("thread.events");
exports.$terminate = Symbol("thread.terminate");
exports.$transferable = Symbol("thread.transferable");
exports.$worker = Symbol("thread.worker");

},{}],"i6dgh":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WorkerMessageType = exports.MasterMessageType = void 0;
/////////////////////////////
// Messages sent by master:
var MasterMessageType;
(function(MasterMessageType1) {
    MasterMessageType1["cancel"] = "cancel";
    MasterMessageType1["run"] = "run";
})(MasterMessageType = exports.MasterMessageType || (exports.MasterMessageType = {
}));
////////////////////////////
// Messages sent by worker:
var WorkerMessageType;
(function(WorkerMessageType1) {
    WorkerMessageType1["error"] = "error";
    WorkerMessageType1["init"] = "init";
    WorkerMessageType1["result"] = "result";
    WorkerMessageType1["running"] = "running";
    WorkerMessageType1["uncaughtError"] = "uncaughtError";
})(WorkerMessageType = exports.WorkerMessageType || (exports.WorkerMessageType = {
}));

},{}],"4pSnX":[function(require,module,exports) {
"use strict";
/// <reference lib="dom" />
// tslint:disable no-shadowed-variable
Object.defineProperty(exports, "__esModule", {
    value: true
});
const isWorkerRuntime = function isWorkerRuntime() {
    const isWindowContext = typeof self !== "undefined" && typeof Window !== "undefined" && self instanceof Window;
    return typeof self !== "undefined" && self.postMessage && !isWindowContext ? true : false;
};
const postMessageToMaster = function postMessageToMaster(data, transferList) {
    self.postMessage(data, transferList);
};
const subscribeToMasterMessages = function subscribeToMasterMessages(onMessage) {
    const messageHandler = (messageEvent)=>{
        onMessage(messageEvent.data);
    };
    const unsubscribe = ()=>{
        self.removeEventListener("message", messageHandler);
    };
    self.addEventListener("message", messageHandler);
    return unsubscribe;
};
exports.default = {
    isWorkerRuntime,
    postMessageToMaster,
    subscribeToMasterMessages
};

},{}],"0FAPM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uvGrid", ()=>uvGrid
);
parcelHelpers.export(exports, "quadEdgeWeightInterpolator", ()=>quadEdgeWeightInterpolator
);
parcelHelpers.export(exports, "triEdgeWeightInterpolator", ()=>triEdgeWeightInterpolator
);
parcelHelpers.export(exports, "quadPatch", ()=>quadPatch
);
parcelHelpers.export(exports, "triPatch", ()=>triPatch
);
parcelHelpers.export(exports, "tessellation", ()=>tessellation
);
parcelHelpers.export(exports, "prepareMesh", ()=>prepareMesh
);
parcelHelpers.export(exports, "tessellationMesh", ()=>tessellationMesh
);
var _geomAccel = require("@thi.ng/geom-accel");
var _poisson = require("@thi.ng/poisson");
var _vectors = require("@thi.ng/vectors");
// @ts-ignore
var _barycentric = require("barycentric");
var _barycentricDefault = parcelHelpers.interopDefault(_barycentric);
var _delaunator = require("delaunator");
var _delaunatorDefault = parcelHelpers.interopDefault(_delaunator);
var _lodashEs = require("lodash-es");
// @ts-ignore
var _angleNormals = require("angle-normals");
var _angleNormalsDefault = parcelHelpers.interopDefault(_angleNormals);
// @ts-ignore
var _mda = require("mda");
var _mdaDefault = parcelHelpers.interopDefault(_mda);
/* Generate a function that interpolates between edge weights of a UV square.

  v
  ^
  | ┌──────D──────┐
  | │             │
  | A             C
  | │             │
  | └──────B──────┘
 -|------------------> u

 * @param {number} A - edge A weight.
 * @param {number} B - edge B weight.
 * @param {number} C - edge C weight.
 * @param {number} D - edge D weight.
 * @return {function: } an interpolation function.
 */ const product = (...a1)=>a1.reduce((a, b)=>a.flatMap((d)=>b.map((e)=>[
                    d,
                    e
                ].flat()
            )
        )
    )
;
const uvGrid = (uResolution, vResolution = null)=>product([
        ..._lodashEs.range(0, 1, 1 / uResolution),
        1
    ], [
        ..._lodashEs.range(0, 1, 1 / (vResolution || uResolution)),
        1
    ])
;
const quadEdgeWeightInterpolator = (A, B, C, D, n = 1)=>([x, y])=>{
        const z = 1 - x;
        const w = 1 - y;
        const e0 = y * z * w;
        const e1 = x * z * w;
        const e2 = x * y * w;
        const e3 = x * y * z;
        const sum = e0 + e1 + e2 + e3;
        const c0 = A;
        const c1 = B;
        const c2 = C;
        const c3 = D;
        return ((e0 * c0) ** n + (e1 * c1) ** n + (e2 * c2) ** n + e3 * c3) / sum ** n;
    }
;
const triEdgeWeightInterpolator = (A, B, C, n = 1)=>([x, y, z])=>{
        const e0 = y * z;
        const e1 = x * z;
        const e2 = x * y;
        const sum = e0 + e1 + e2;
        const c0 = A;
        const c1 = B;
        const c2 = C;
        return ((e0 * c0) ** n + (e1 * c1) ** n + (e2 * c2) ** n) / sum ** n;
    }
;
const cartesian = (bary, corners)=>[
        bary[0] * corners[0][0] + bary[1] * corners[1][0] + bary[2] * corners[2][0],
        bary[0] * corners[0][1] + bary[1] * corners[1][1] + bary[2] * corners[2][1], 
    ]
;
const sampleTriangle = (corners)=>()=>{
        const u = [
            Math.random(),
            Math.random()
        ];
        const su0 = Math.sqrt(u[0]);
        const b0 = 1 - su0;
        const b1 = u[1] * su0;
        const pt = cartesian([
            b0,
            b1,
            1 - b0 - b1
        ], corners);
        return pt;
    }
;
const getRadiusTri = (triangle, weights)=>(pt)=>{
        let bary = _barycentricDefault.default(triangle, pt);
        const D = _vectors.dist([
            0,
            0
        ], [
            0.5,
            0.5
        ]);
        bary = [
            _vectors.divN2(null, bary[0], 1),
            _vectors.divN2(null, bary[1], D),
            _vectors.divN2(null, bary[2], D), 
        ];
        const x = triEdgeWeightInterpolator(weights[0], weights[1], weights[2])(bary);
        // console.log(x, bary, pt, triangle, weights)
        return 1 / x;
    }
;
const defaultOptions = {
    iter: 1,
    jitter: 0.00001,
    max: 3000000,
    quality: 150
};
const quadPatch = (resA, resB, resC, resD, opts = null)=>{
    opts = {
        ...defaultOptions,
        ...opts || {
        }
    };
    const index = new _geomAccel.KdTreeSet(2);
    const addPoint = (radius)=>(x1)=>index.add(x1.map((x)=>x * 1000
            ), radius)
    ;
    // add stitching points
    for(let a = 0; a <= 1; a += 1 / resA)index.add([
        0,
        a
    ]);
    for(let b = 0; b <= 1; b += 1 / resB)index.add([
        b,
        0
    ]);
    for(let c = 0; c <= 1; c += 1 / resC)index.add([
        1,
        c
    ]);
    for(let d = 0; d <= 1; d += 1 / resD)index.add([
        d,
        1
    ]);
    const interpolation = (x)=>1 / quadEdgeWeightInterpolator(resA, resB, resC, resD)(x)
    ;
    const sample = ()=>{
        const points = ()=>[
                Math.random(),
                Math.random()
            ]
        ;
        const density = interpolation;
        return _poisson.samplePoisson({
            index,
            points,
            density,
            max: 0,
            ...opts
        });
    };
    const boundaryPoints = index.keys();
    const points1 = [
        ...boundaryPoints,
        ...sample(), 
    ];
    return {
        points: points1,
        index
    };
};
const triPatch = (resA, resB, resC, opts = null)=>{
    opts = {
        ...defaultOptions,
        ...opts || {
        }
    };
    const corners1 = [
        [
            0,
            1
        ],
        [
            1,
            0
        ],
        [
            0,
            0
        ], 
    ];
    const index = new _geomAccel.KdTreeSet(2);
    const addPoint = (radius)=>(x2)=>index.add(x2.map((x)=>x * 1000
            ), radius)
    ;
    // add stitching points
    for(let a = 0; a <= 1; a += 1 / resA)index.add([
        a,
        0
    ]);
    for(let b = 0; b <= 1; b += 1 / resB)index.add([
        0,
        b
    ]);
    for(let c = 0; c <= 1; c += 1 / resC)index.add([
        1 - c,
        c
    ]);
    const interpolation = getRadiusTri(corners1, [
        resA,
        resB,
        resC
    ]);
    const sampleTri = (corners, weights)=>{
        const points = sampleTriangle(corners);
        const density = interpolation;
        return _poisson.samplePoisson({
            index,
            points,
            density,
            max: 0,
            ...opts
        });
    };
    const boundaryPoints = index.keys();
    const points2 = [
        ...boundaryPoints,
        ...sampleTri(corners1, [
            resA,
            resB,
            resC
        ]), 
    ];
    return {
        points: points2,
        index
    };
};
const tessellation = (sideLODs = 8)=>{
    let points;
    if (Array.isArray(sideLODs)) points = (sideLODs.length === 4 ? quadPatch(...sideLODs) : triPatch(...sideLODs)).points; // uvGrid(resolution)
    else points = triPatch(sideLODs, sideLODs, sideLODs).points;
    return _delaunatorDefault.default.from(points);
};
const prepareMesh = (grid, includeMda = true)=>{
    let mesh = {
    };
    const cells = _lodashEs.chunk(grid.triangles, 3);
    const positions = _lodashEs.chunk(grid.coords, 2).map(([u, v])=>[
            u,
            v,
            0, 
        ]
    );
    // mesh = mergeVertices(mesh.cells, mesh.positions)
    // top.normalize(mesh.cells)
    // mesh.incidence = top.incidence(mesh.cells, mesh.cells)
    const M = new _mdaDefault.default.Mesh();
    M.setPositions(positions);
    M.setCells(cells);
    M.process();
    mesh.cells = M.getCells();
    mesh.positions = M.getPositions();
    mesh.normals = _angleNormalsDefault.default(mesh.cells, mesh.positions);
    mesh.cellPositions = mesh.cells.map((indices)=>indices.map((i)=>mesh.positions[i]
        )
    );
    mesh.cellNormals = mesh.cells.map((indices)=>indices.map((i)=>mesh.normals[i]
        )
    );
    if (includeMda) mesh.mda = M;
    // console.log('mesh', mesh)
    return mesh;
};
function tessellationMesh(sideLODs) {
    const mesh = prepareMesh(tessellation(sideLODs), false);
    return mesh;
}

},{"@thi.ng/geom-accel":"eyFxq","@thi.ng/poisson":"hTYUR","@thi.ng/vectors":"gLU21","barycentric":"cdKXu","delaunator":"1U5NA","lodash-es":"bXNwz","angle-normals":"3WkEt","mda":"9J7Dv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eyFxq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _kdTreeMapJs = require("./kd-tree-map.js");
parcelHelpers.exportAll(_kdTreeMapJs, exports);
var _kdTreeSetJs = require("./kd-tree-set.js");
parcelHelpers.exportAll(_kdTreeSetJs, exports);
var _ndQuadtreeMapJs = require("./nd-quadtree-map.js");
parcelHelpers.exportAll(_ndQuadtreeMapJs, exports);
var _ndQuadtreeSetJs = require("./nd-quadtree-set.js");
parcelHelpers.exportAll(_ndQuadtreeSetJs, exports);
var _spatialGrid2Js = require("./spatial-grid2.js");
parcelHelpers.exportAll(_spatialGrid2Js, exports);
var _spatialGrid3Js = require("./spatial-grid3.js");
parcelHelpers.exportAll(_spatialGrid3Js, exports);

},{"./kd-tree-map.js":"7aH1S","./kd-tree-set.js":"5eyOc","./nd-quadtree-map.js":"5mrju","./nd-quadtree-set.js":"6tjbR","./spatial-grid2.js":"b6jlb","./spatial-grid3.js":"epsDv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7aH1S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KdNode", ()=>KdNode
);
/**
 * {@link https://en.wikipedia.org/wiki/K-d_tree}
 *
 * Partially based on:
 * {@link https://github.com/ubilabs/kd-tree-javascript}
 *
 */ parcelHelpers.export(exports, "KdTreeMap", ()=>KdTreeMap
);
var _ensureArray = require("@thi.ng/arrays/ensure-array");
var _heap = require("@thi.ng/heaps/heap");
var _api = require("@thi.ng/math/api");
var _map = require("@thi.ng/transducers/map");
var _distsq = require("@thi.ng/vectors/distsq");
var _utilsJs = require("./utils.js");
class KdNode {
    constructor(parent, dim, key, val){
        this.parent = parent;
        this.d = dim;
        this.k = key;
        this.v = val;
    }
    get height() {
        return 1 + Math.max(this.l ? this.l.height : 0, this.r ? this.r.height : 0);
    }
}
class KdTreeMap {
    constructor(dim, pairs){
        this.dim = dim;
        this._size = 0;
        this.root = pairs ? this.buildTree(_ensureArray.ensureArray(pairs), 0) : undefined;
    }
    *[Symbol.iterator]() {
        let queue = this.root ? [
            this.root
        ] : [];
        while(queue.length){
            const n = queue.pop();
            if (n) {
                yield [
                    n.k,
                    n.v
                ];
                queue.push(n.r, n.l);
            }
        }
    }
    *keys() {
        let queue = this.root ? [
            this.root
        ] : [];
        while(queue.length){
            const n = queue.pop();
            if (n) {
                yield n.k;
                queue.push(n.r, n.l);
            }
        }
    }
    values() {
        return _map.map((p)=>p[1]
        , this);
    }
    get size() {
        return this._size;
    }
    get height() {
        return this.root ? this.root.height : 0;
    }
    get ratio() {
        return this._size ? this.height / Math.log2(this._size) : 0;
    }
    copy() {
        return new KdTreeMap(this.dim, this);
    }
    clear() {
        delete this.root;
        this._size = 0;
    }
    empty() {
        return new KdTreeMap(this.dim);
    }
    set(key, val, eps = _api.EPS) {
        eps = Math.max(0, eps);
        eps *= eps;
        const search = (node, parent)=>node ? search(key[node.d] < node.k[node.d] ? node.l : node.r, node) : parent
        ;
        let parent1;
        if (this.root) {
            parent1 = nearest1(key, [
                eps,
                undefined
            ], this.dim, this.root)[1];
            if (parent1) {
                parent1.v = val;
                return false;
            }
            parent1 = search(this.root, undefined);
            const dim = parent1.d;
            parent1[key[dim] < parent1.k[dim] ? "l" : "r"] = new KdNode(parent1, (dim + 1) % this.dim, key, val);
        } else this.root = new KdNode(undefined, 0, key, val);
        this._size++;
        return true;
    }
    into(pairs, eps = _api.EPS) {
        return _utilsJs.into(this, pairs, eps);
    }
    remove(key) {
        const node = find(key, this.root, 0);
        if (node) {
            remove(node) && (this.root = undefined);
            this._size--;
            return true;
        }
        return false;
    }
    has(key, eps = _api.EPS) {
        return !!this.root && !!nearest1(key, [
            eps * eps,
            undefined
        ], this.dim, this.root)[1];
    }
    get(key, eps = _api.EPS) {
        if (this.root) {
            const node = nearest1(key, [
                eps * eps,
                undefined
            ], this.dim, this.root)[1];
            return node ? node.v : undefined;
        }
    }
    query(q, maxDist, limit, acc) {
        return this.doSelect(q, (x)=>[
                x.k,
                x.v
            ]
        , maxDist, limit, acc);
    }
    queryKeys(q, maxDist, limit, acc) {
        return this.doSelect(q, (x)=>x.k
        , maxDist, limit, acc);
    }
    queryValues(q, maxDist, limit, acc) {
        return this.doSelect(q, (x)=>x.v
        , maxDist, limit, acc);
    }
    doSelect(q, f, maxDist, maxNum = 1, acc = []) {
        if (!this.root) return [];
        maxDist *= maxDist;
        if (maxNum === 1) {
            const sel = nearest1(q, [
                maxDist,
                undefined
            ], this.dim, this.root)[1];
            sel && acc.push(f(sel));
        } else {
            const nodes = new _heap.Heap([
                [
                    maxDist,
                    undefined
                ]
            ], {
                compare: _utilsJs.CMP
            });
            nearest(q, nodes, this.dim, maxNum, this.root);
            return _utilsJs.addResults(f, nodes.values, acc);
        }
        return acc;
    }
    buildTree(points, depth, parent) {
        const n = points.length;
        if (n === 0) return;
        this._size++;
        let dim = depth % this.dim;
        if (n === 1) return new KdNode(parent, dim, ...points[0]);
        points.sort((a, b)=>a[0][dim] - b[0][dim]
        );
        const med = n >>> 1;
        const node = new KdNode(parent, dim, ...points[med]);
        node.l = this.buildTree(points.slice(0, med), depth + 1, node);
        node.r = this.buildTree(points.slice(med + 1), depth + 1, node);
        return node;
    }
}
/**
 * Returns node for point or `undefined` if none found.
 *
 * @param p - point
 * @param node - tree node
 * @param epsSq - squared epsilon / tolerance
 */ const find = (p, node, epsSq)=>{
    if (!node) return;
    return _distsq.distSq(p, node.k) <= epsSq ? node : find(p, p[node.d] < node.k[node.d] ? node.l : node.r, epsSq);
};
const findMin = (node, dim)=>{
    if (!node) return;
    if (node.d === dim) return node.l ? findMin(node.l, dim) : node;
    const q = node.k[dim];
    const l = findMin(node.l, dim);
    const r = findMin(node.r, dim);
    let min = node;
    if (l && l.k[dim] < q) min = l;
    if (r && r.k[dim] < min.k[dim]) min = r;
    return min;
};
/**
 * Returns true if root is to be deleted.
 *
 * @param node - tree node
 */ const remove = (node)=>{
    if (!node.l && !node.r) {
        if (!node.parent) return true;
        const parent = node.parent;
        const pdim = parent.d;
        parent[node.k[pdim] < parent.k[pdim] ? "l" : "r"] = undefined;
        return;
    }
    let next;
    let nextP;
    if (node.r) {
        next = findMin(node.r, node.d);
        nextP = next.k;
        remove(next);
        node.k = nextP;
    } else {
        next = findMin(node.l, node.d);
        nextP = next.k;
        remove(next);
        node.r = node.l;
        node.l = undefined;
        node.k = nextP;
    }
};
const nearest = (q, acc, dims, maxNum, node)=>{
    const p = node.k;
    const ndist = _distsq.distSq(p, q);
    if (!node.l && !node.r) {
        collect(acc, maxNum, node, ndist);
        return;
    }
    const tdist = nodeDist(node, dims, q, p);
    let best = bestChild(node, q);
    nearest(q, acc, dims, maxNum, best);
    collect(acc, maxNum, node, ndist);
    if (tdist < acc.values[0][0]) {
        best = best === node.l ? node.r : node.l;
        best && nearest(q, acc, dims, maxNum, best);
    }
};
/**
 * Optimized version of {@link nearest} for single closest point search.
 *
 * @param q - search point
 * @param acc - accumulator
 * @param dims - dimensions
 * @param node - tree node
 */ const nearest1 = (q, acc, dims, node)=>{
    const p = node.k;
    const ndist = _distsq.distSq(p, q);
    if (!node.l && !node.r) {
        collect1(acc, node, ndist);
        return acc;
    }
    const tdist = nodeDist(node, dims, q, p);
    let best = bestChild(node, q);
    nearest1(q, acc, dims, best);
    collect1(acc, node, ndist);
    if (tdist < acc[0]) {
        best = best === node.l ? node.r : node.l;
        best && nearest1(q, acc, dims, best);
    }
    return acc;
};
const bestChild = (node, q)=>{
    const d = node.d;
    return !node.r ? node.l : !node.l ? node.r : q[d] < node.k[d] ? node.l : node.r;
};
const collect = (acc, maxNum, node, ndist)=>(!acc.length || ndist < acc.peek()[0]) && (acc.length >= maxNum ? acc.pushPop([
        ndist,
        node
    ]) : acc.push([
        ndist,
        node
    ]))
;
const collect1 = (acc, node, ndist)=>ndist < acc[0] && (acc[0] = ndist, acc[1] = node)
;
const TMP = [];
const nodeDist = (node, dims, q, p)=>{
    for(let i = dims, d = node.d; i-- > 0;)TMP[i] = i === d ? q[i] : p[i];
    return _distsq.distSq(TMP, p);
};

},{"@thi.ng/arrays/ensure-array":"6Tcdc","@thi.ng/heaps/heap":"18spH","@thi.ng/math/api":"4a98p","@thi.ng/transducers/map":"fW6Xn","@thi.ng/vectors/distsq":"8XCdB","./utils.js":"9RX5K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Tcdc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ensureArray", ()=>ensureArray
);
parcelHelpers.export(exports, "ensureArrayLike", ()=>ensureArrayLike
);
var _isArray = require("@thi.ng/checks/is-array");
var _isArraylike = require("@thi.ng/checks/is-arraylike");
var _ensureIterableJs = require("./ensure-iterable.js");
const ensureArray = (x)=>_isArray.isArray(x) ? x : [
        ..._ensureIterableJs.ensureIterable(x)
    ]
;
const ensureArrayLike = (x)=>_isArraylike.isArrayLike(x) ? x : [
        ..._ensureIterableJs.ensureIterable(x)
    ]
;

},{"@thi.ng/checks/is-array":"cOR5q","@thi.ng/checks/is-arraylike":"8nYo2","./ensure-iterable.js":"cXcgx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cOR5q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isArray", ()=>isArray
);
const isArray = Array.isArray;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"8nYo2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isArrayLike", ()=>isArrayLike
);
const isArrayLike = (x)=>x != null && typeof x !== "function" && x.length !== undefined
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cXcgx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ensureIterable", ()=>ensureIterable
);
var _illegalArguments = require("@thi.ng/errors/illegal-arguments");
const ensureIterable = (x)=>{
    (x == null || !x[Symbol.iterator]) && _illegalArguments.illegalArgs(`value is not iterable: ${x}`);
    return x;
};

},{"@thi.ng/errors/illegal-arguments":"co01S","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"co01S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IllegalArgumentError", ()=>IllegalArgumentError
);
parcelHelpers.export(exports, "illegalArgs", ()=>illegalArgs
);
var _deferrorJs = require("./deferror.js");
const IllegalArgumentError = _deferrorJs.defError(()=>"illegal argument(s)"
);
const illegalArgs = (msg)=>{
    throw new IllegalArgumentError(msg);
};

},{"./deferror.js":"l9nQt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l9nQt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defError", ()=>defError
);
const defError = (prefix, suffix = (msg)=>msg !== undefined ? ": " + msg : ""
)=>class extends Error {
        constructor(msg){
            super(prefix(msg) + suffix(msg));
        }
    }
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"18spH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defHeap", ()=>defHeap
);
/**
 * Generic binary heap / priority queue with customizable ordering via
 * user-supplied comparator. By default, implements min-heap ordering
 * and uses @thi.ng/compare.
 *
 * @example
 * ```ts
 * h = new Heap([20, 5, 10]);
 * h.push(15);
 *
 * h.pop(); // 5
 * h.pop(); // 10
 * h.pop(); // 15
 * h.pop(); // 20
 * h.pop(); // undefined
 * ```
 */ parcelHelpers.export(exports, "Heap", ()=>Heap
);
var _compare = require("@thi.ng/compare/compare");
var _equiv = require("@thi.ng/equiv");
const defHeap = (values, opts)=>new Heap(values, opts)
;
class Heap {
    constructor(values, opts){
        opts = {
            compare: _compare.compare,
            equiv: _equiv.equiv,
            ...opts
        };
        this.compare = opts.compare;
        this.equiv = opts.equiv;
        this.values = [];
        if (values) this.into(values);
    }
    static parentIndex(idx) {
        return idx > 0 ? idx - 1 >> 1 : -1;
    }
    static childIndex(idx) {
        return idx >= 0 ? (idx << 1) + 1 : -1;
    }
    *[Symbol.iterator]() {
        yield* this.min();
    }
    get length() {
        return this.values.length;
    }
    copy() {
        const h = this.empty();
        h.values = this.values.slice();
        return h;
    }
    clear() {
        this.values.length = 0;
    }
    empty() {
        return new Heap(null, {
            compare: this.compare
        });
    }
    peek() {
        return this.values[0];
    }
    push(val) {
        this.values.push(val);
        this.percolateUp(this.values.length - 1);
        return this;
    }
    pop() {
        const vals = this.values;
        const tail = vals.pop();
        let res;
        if (vals.length > 0) {
            res = vals[0];
            vals[0] = tail;
            this.percolateDown(0);
        } else res = tail;
        return res;
    }
    pushPop(val, vals = this.values) {
        const head = vals[0];
        if (vals.length > 0 && this.compare(head, val) <= 0) {
            vals[0] = val;
            val = head;
            this.percolateDown(0, vals);
        }
        return val;
    }
    into(vals) {
        for (let v of vals)this.push(v);
        return this;
    }
    /**
     * Calls {@link Heap.pushPop} for each given value in `vals` and
     * returns last result (i.e. the smallest value in heap after
     * processing all `vals`).
     *
     * @param vals - values to insert
     */ pushPopAll(vals) {
        let res;
        for (let v of vals)res = this.pushPop(v);
        return res;
    }
    replaceHead(val) {
        const res = this.values[0];
        this.values[0] = val;
        this.percolateDown(0);
        return res;
    }
    remove(val) {
        const { values , equiv  } = this;
        for(let i = values.length; i-- > 0;)if (equiv(values[i], val)) {
            this.values.splice(i, 1);
            this.heapify();
            return true;
        }
        return false;
    }
    find(val) {
        const { values , equiv  } = this;
        for(let i = values.length; i-- > 0;){
            if (equiv(values[i], val)) return values[i];
        }
    }
    findWith(pred) {
        const values = this.values;
        for(let i = values.length; i-- > 0;){
            if (pred(values[i])) return values[i];
        }
    }
    has(val) {
        return this.find(val) !== undefined;
    }
    heapify(vals = this.values) {
        for(let i = vals.length - 1 >> 1; i >= 0; i--)this.percolateDown(i, vals);
    }
    /**
     * Returns the largest `n` values (or less) in heap, based on
     * comparator ordering.
     *
     * @param n - number of values
     */ max(n = this.values.length) {
        const { compare , values  } = this;
        const res = values.slice(0, n);
        if (!n) return res;
        this.heapify(res);
        for(let m = values.length; n < m; n++)this.pushPop(values[n], res);
        return res.sort((a, b)=>compare(b, a)
        );
    }
    /**
     * Returns the smallest `n` values (or less) in heap, based on
     * comparator ordering.
     *
     * @param n - number of values
     */ min(n = this.values.length) {
        const { compare , values  } = this;
        const res = values.slice(0, n).sort(compare);
        if (!n) return res;
        let x = res[n - 1], y;
        for(let i = n, m = values.length; i < m; i++){
            y = values[i];
            if (compare(y, x) < 0) {
                res.splice(binarySearch(y, res, 0, n, compare), 0, y);
                res.pop();
                x = res[n - 1];
            }
        }
        return res;
    }
    parent(n) {
        n = Heap.parentIndex(n);
        return n >= 0 ? this.values[n] : undefined;
    }
    children(n) {
        n = Heap.childIndex(n);
        const vals = this.values;
        const m = vals.length;
        if (n >= m) return;
        if (n === m - 1) return [
            vals[n]
        ];
        return [
            vals[n],
            vals[n + 1]
        ];
    }
    leaves() {
        const vals = this.values;
        if (!vals.length) return [];
        return vals.slice(Heap.parentIndex(vals.length - 1) + 1);
    }
    percolateUp(i, vals = this.values) {
        const node = vals[i];
        const cmp = this.compare;
        while(i > 0){
            const pi = i - 1 >> 1;
            const parent = vals[pi];
            if (cmp(node, parent) >= 0) break;
            vals[pi] = node;
            vals[i] = parent;
            i = pi;
        }
    }
    percolateDown(i, vals = this.values) {
        const n = vals.length;
        const node = vals[i];
        const cmp = this.compare;
        let child = (i << 1) + 1;
        while(child < n){
            const next = child + 1;
            if (next < n && cmp(vals[child], vals[next]) >= 0) child = next;
            if (cmp(vals[child], node) < 0) vals[i] = vals[child];
            else break;
            i = child;
            child = (i << 1) + 1;
        }
        vals[i] = node;
    }
}
const binarySearch = (x, vals, lo, hi, cmp)=>{
    let m;
    while(lo < hi){
        m = lo + hi >>> 1;
        if (cmp(x, vals[m]) < 0) hi = m;
        else lo = m + 1;
    }
    return lo;
};

},{"@thi.ng/compare/compare":"5WIs8","@thi.ng/equiv":"e2rLA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5WIs8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compare", ()=>compare
);
const compare = (a, b)=>{
    if (a === b) return 0;
    if (a == null) return b == null ? 0 : -1;
    if (b == null) return a == null ? 0 : 1;
    if (typeof a.compare === "function") return a.compare(b);
    if (typeof b.compare === "function") return -b.compare(a);
    return a < b ? -1 : a > b ? 1 : 0;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e2rLA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "equiv", ()=>equiv
);
parcelHelpers.export(exports, "equivArrayLike", ()=>equivArrayLike
);
parcelHelpers.export(exports, "equivSet", ()=>equivSet
);
parcelHelpers.export(exports, "equivMap", ()=>equivMap
);
parcelHelpers.export(exports, "equivObject", ()=>equivObject
);
const OBJP = Object.getPrototypeOf({
});
const FN = "function";
const STR = "string";
const equiv = (a, b)=>{
    let proto;
    if (a === b) return true;
    if (a != null) {
        if (typeof a.equiv === FN) return a.equiv(b);
    } else return a == b;
    if (b != null) {
        if (typeof b.equiv === FN) return b.equiv(a);
    } else return a == b;
    if (typeof a === STR || typeof b === STR) return false;
    if ((proto = Object.getPrototypeOf(a), proto == null || proto === OBJP) && (proto = Object.getPrototypeOf(b), proto == null || proto === OBJP)) return equivObject(a, b);
    if (typeof a !== FN && a.length !== undefined && typeof b !== FN && b.length !== undefined) return equivArrayLike(a, b);
    if (a instanceof Set && b instanceof Set) return equivSet(a, b);
    if (a instanceof Map && b instanceof Map) return equivMap(a, b);
    if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();
    if (a instanceof RegExp && b instanceof RegExp) return a.toString() === b.toString();
    // NaN
    return a !== a && b !== b;
};
const equivArrayLike = (a, b, _equiv = equiv)=>{
    let l = a.length;
    if (l === b.length) {
        while(l-- > 0 && _equiv(a[l], b[l]));
    }
    return l < 0;
};
const equivSet = (a, b, _equiv = equiv)=>a.size === b.size && _equiv([
        ...a.keys()
    ].sort(), [
        ...b.keys()
    ].sort())
;
const equivMap = (a, b, _equiv = equiv)=>a.size === b.size && _equiv([
        ...a
    ].sort(), [
        ...b
    ].sort())
;
const equivObject = (a, b, _equiv = equiv)=>{
    if (Object.keys(a).length !== Object.keys(b).length) return false;
    for(let k in a){
        if (!b.hasOwnProperty(k) || !_equiv(a[k], b[k])) return false;
    }
    return true;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4a98p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PI", ()=>PI
);
parcelHelpers.export(exports, "TAU", ()=>TAU
);
parcelHelpers.export(exports, "HALF_PI", ()=>HALF_PI
);
parcelHelpers.export(exports, "THIRD_PI", ()=>THIRD_PI
);
parcelHelpers.export(exports, "QUARTER_PI", ()=>QUARTER_PI
);
parcelHelpers.export(exports, "SIXTH_PI", ()=>SIXTH_PI
);
parcelHelpers.export(exports, "INV_PI", ()=>INV_PI
);
parcelHelpers.export(exports, "INV_TAU", ()=>INV_TAU
);
parcelHelpers.export(exports, "INV_HALF_PI", ()=>INV_HALF_PI
);
parcelHelpers.export(exports, "DEG2RAD", ()=>DEG2RAD
);
parcelHelpers.export(exports, "RAD2DEG", ()=>RAD2DEG
);
parcelHelpers.export(exports, "PHI", ()=>PHI
);
parcelHelpers.export(exports, "SQRT2", ()=>SQRT2
);
parcelHelpers.export(exports, "SQRT3", ()=>SQRT3
);
parcelHelpers.export(exports, "SQRT2_2", ()=>SQRT2_2
);
parcelHelpers.export(exports, "SQRT3_2", ()=>SQRT3_2
);
parcelHelpers.export(exports, "THIRD", ()=>THIRD
);
parcelHelpers.export(exports, "TWO_THIRD", ()=>TWO_THIRD
);
parcelHelpers.export(exports, "SIXTH", ()=>SIXTH
);
parcelHelpers.export(exports, "EPS", ()=>EPS
);
const PI = Math.PI;
const TAU = PI * 2;
const HALF_PI = PI / 2;
const THIRD_PI = PI / 3;
const QUARTER_PI = PI / 4;
const SIXTH_PI = PI / 6;
const INV_PI = 1 / PI;
const INV_TAU = 1 / TAU;
const INV_HALF_PI = 1 / HALF_PI;
const DEG2RAD = PI / 180;
const RAD2DEG = 180 / PI;
const PHI = (1 + Math.sqrt(5)) / 2;
const SQRT2 = Math.SQRT2;
const SQRT3 = Math.sqrt(3);
const SQRT2_2 = SQRT2 / 2;
const SQRT3_2 = SQRT3 / 2;
const THIRD = 1 / 3;
const TWO_THIRD = 2 / 3;
const SIXTH = 1 / 6;
let EPS = 0.000001;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fW6Xn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "map", ()=>map
);
parcelHelpers.export(exports, "mapA", ()=>mapA
);
var _isIterable = require("@thi.ng/checks/is-iterable");
var _comprJs = require("./compr.js");
var _iteratorJs = require("./iterator.js");
function map(fn, src) {
    return _isIterable.isIterable(src) ? _iteratorJs.iterator1(map(fn), src) : (rfn)=>{
        const r = rfn[2];
        return _comprJs.compR(rfn, (acc, x)=>r(acc, fn(x))
        );
    };
}
const mapA = (fn, src)=>[
        ...map(fn, src), 
    ]
;

},{"@thi.ng/checks/is-iterable":"bDbbO","./compr.js":"ePFjm","./iterator.js":"8km8L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bDbbO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isIterable", ()=>isIterable
);
const isIterable = (x)=>x != null && typeof x[Symbol.iterator] === "function"
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ePFjm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compR", ()=>compR
);
const compR = (rfn, fn)=>[
        rfn[0],
        rfn[1],
        fn
    ]
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8km8L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Takes a transducer and input iterable. Returns iterator of
 * transformed results.
 *
 * @param xform -
 * @param xs -
 */ parcelHelpers.export(exports, "iterator", ()=>iterator
);
/**
 * Optimized version of {@link iterator} for transducers which are
 * guaranteed to:
 *
 * 1) Only produce none or a single result per input
 * 2) Do not require a `completion` reduction step
 *
 * @param xform -
 * @param xs -
 */ parcelHelpers.export(exports, "iterator1", ()=>iterator1
);
parcelHelpers.export(exports, "__iter", ()=>__iter
);
var _api = require("@thi.ng/api/api");
var _isIterable = require("@thi.ng/checks/is-iterable");
var _ensureJs = require("./ensure.js");
var _pushJs = require("./push.js");
var _reducedJs = require("./reduced.js");
function* iterator(xform, xs) {
    const rfn = _ensureJs.ensureTransducer(xform)(_pushJs.push());
    const complete = rfn[1];
    const reduce = rfn[2];
    for (let x of xs){
        const y = reduce([], x);
        if (_reducedJs.isReduced(y)) {
            yield* _reducedJs.unreduced(complete(y.deref()));
            return;
        }
        if (y.length) yield* y;
    }
    yield* _reducedJs.unreduced(complete([]));
}
function* iterator1(xform, xs) {
    const reduce = _ensureJs.ensureTransducer(xform)([
        _api.NO_OP,
        _api.NO_OP,
        (_, x)=>x
    ])[2];
    for (let x1 of xs){
        let y = reduce(_api.SEMAPHORE, x1);
        if (_reducedJs.isReduced(y)) {
            y = _reducedJs.unreduced(y.deref());
            if (y !== _api.SEMAPHORE) yield y;
            return;
        }
        if (y !== _api.SEMAPHORE) yield y;
    }
}
const __iter = (xform, args, impl = iterator1)=>{
    const n = args.length - 1;
    return _isIterable.isIterable(args[n]) ? args.length > 1 ? impl(xform.apply(null, args.slice(0, n)), args[n]) : impl(xform(), args[0]) : undefined;
};

},{"@thi.ng/api/api":"efej5","@thi.ng/checks/is-iterable":"bDbbO","./ensure.js":"lSMoA","./push.js":"8Qmga","./reduced.js":"cAjrZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"efej5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_EPS", ()=>DEFAULT_EPS
);
parcelHelpers.export(exports, "SEMAPHORE", ()=>SEMAPHORE
);
parcelHelpers.export(exports, "NO_OP", ()=>NO_OP
);
parcelHelpers.export(exports, "EVENT_ALL", ()=>EVENT_ALL
);
parcelHelpers.export(exports, "EVENT_ENABLE", ()=>EVENT_ENABLE
);
parcelHelpers.export(exports, "EVENT_DISABLE", ()=>EVENT_DISABLE
);
const DEFAULT_EPS = 0.000001;
const SEMAPHORE = Symbol();
const NO_OP = ()=>{
};
const EVENT_ALL = "*";
const EVENT_ENABLE = "enable";
const EVENT_DISABLE = "disable";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lSMoA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ensureTransducer", ()=>ensureTransducer
);
var _implementsFunction = require("@thi.ng/checks/implements-function");
const ensureTransducer = (x)=>_implementsFunction.implementsFunction(x, "xform") ? x.xform() : x
;

},{"@thi.ng/checks/implements-function":"cjrzK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cjrzK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "implementsFunction", ()=>implementsFunction
);
const implementsFunction = (x, fn)=>x != null && typeof x[fn] === "function"
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Qmga":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "push", ()=>push
);
var _reduceJs = require("./reduce.js");
function push(xs) {
    return xs ? [
        ...xs
    ] : _reduceJs.reducer(()=>[]
    , (acc, x)=>(acc.push(x), acc)
    );
}

},{"./reduce.js":"hP05c","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hP05c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "reduce", ()=>reduce
);
parcelHelpers.export(exports, "reduceRight", ()=>reduceRight
);
parcelHelpers.export(exports, "reducer", ()=>reducer
);
parcelHelpers.export(exports, "$$reduce", ()=>$$reduce
);
var _implementsFunction = require("@thi.ng/checks/implements-function");
var _isArraylike = require("@thi.ng/checks/is-arraylike");
var _isIterable = require("@thi.ng/checks/is-iterable");
var _illegalArity = require("@thi.ng/errors/illegal-arity");
var _reducedJs = require("./reduced.js");
const parseArgs = (args)=>args.length === 2 ? [
        undefined,
        args[1]
    ] : args.length === 3 ? [
        args[1],
        args[2]
    ] : _illegalArity.illegalArity(args.length)
;
function reduce(...args) {
    const rfn = args[0];
    const init = rfn[0];
    const complete = rfn[1];
    const reduce1 = rfn[2];
    args = parseArgs(args);
    const acc = args[0] == null ? init() : args[0];
    const xs = args[1];
    return _reducedJs.unreduced(complete(_implementsFunction.implementsFunction(xs, "$reduce") ? xs.$reduce(reduce1, acc) : _isArraylike.isArrayLike(xs) ? reduceArray(reduce1, acc, xs) : reduceIterable(reduce1, acc, xs)));
}
function reduceRight(...args) {
    const rfn = args[0];
    const init = rfn[0];
    const complete = rfn[1];
    const reduce2 = rfn[2];
    args = parseArgs(args);
    let acc = args[0] == null ? init() : args[0];
    const xs = args[1];
    for(let i = xs.length; i-- > 0;){
        acc = reduce2(acc, xs[i]);
        if (_reducedJs.isReduced(acc)) {
            acc = acc.deref();
            break;
        }
    }
    return _reducedJs.unreduced(complete(acc));
}
const reduceArray = (rfn, acc, xs)=>{
    for(let i = 0, n = xs.length; i < n; i++){
        acc = rfn(acc, xs[i]);
        if (_reducedJs.isReduced(acc)) {
            acc = acc.deref();
            break;
        }
    }
    return acc;
};
const reduceIterable = (rfn, acc, xs)=>{
    for (let x of xs){
        acc = rfn(acc, x);
        if (_reducedJs.isReduced(acc)) {
            acc = acc.deref();
            break;
        }
    }
    return acc;
};
const reducer = (init, rfn)=>[
        init,
        (acc)=>acc
        ,
        rfn
    ]
;
const $$reduce = (rfn, args)=>{
    const n = args.length - 1;
    return _isIterable.isIterable(args[n]) ? args.length > 1 ? reduce(rfn.apply(null, args.slice(0, n)), args[n]) : reduce(rfn(), args[0]) : undefined;
};

},{"@thi.ng/checks/implements-function":"cjrzK","@thi.ng/checks/is-arraylike":"8nYo2","@thi.ng/checks/is-iterable":"bDbbO","@thi.ng/errors/illegal-arity":"fOKRC","./reduced.js":"cAjrZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fOKRC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IllegalArityError", ()=>IllegalArityError
);
parcelHelpers.export(exports, "illegalArity", ()=>illegalArity
);
var _deferrorJs = require("./deferror.js");
const IllegalArityError = _deferrorJs.defError(()=>"illegal arity"
);
const illegalArity = (n)=>{
    throw new IllegalArityError(n);
};

},{"./deferror.js":"l9nQt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cAjrZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Reduced", ()=>Reduced
);
parcelHelpers.export(exports, "reduced", ()=>reduced
);
parcelHelpers.export(exports, "isReduced", ()=>isReduced
);
parcelHelpers.export(exports, "ensureReduced", ()=>ensureReduced
);
parcelHelpers.export(exports, "unreduced", ()=>unreduced
);
class Reduced {
    constructor(val){
        this.value = val;
    }
    deref() {
        return this.value;
    }
}
const reduced = (x)=>new Reduced(x)
;
const isReduced = (x)=>x instanceof Reduced
;
const ensureReduced = (x)=>x instanceof Reduced ? x : new Reduced(x)
;
const unreduced = (x)=>x instanceof Reduced ? x.deref() : x
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8XCdB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distSq", ()=>distSq
);
parcelHelpers.export(exports, "distSq2", ()=>distSq2
);
parcelHelpers.export(exports, "distSq3", ()=>distSq3
);
parcelHelpers.export(exports, "distSq4", ()=>distSq4
);
var _emitJs = require("./compile/emit.js");
var _vopJs = require("./vop.js");
const tpl = ([a, b])=>`t=${a}-${b};s+=t*t;`
;
const pre = "let t,s=0;";
const $ = (dim)=>distSq.add(dim, _emitJs.compile(dim, tpl, "a,b", undefined, "s", "", pre))
;
const distSq = _vopJs.vop();
distSq.default(_emitJs.compileG(tpl, "a,b", undefined, "s", pre));
const distSq2 = $(2);
const distSq3 = $(3);
const distSq4 = $(4);

},{"./compile/emit.js":"hpIek","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hpIek":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultOut", ()=>defaultOut
);
parcelHelpers.export(exports, "compile", ()=>compile
);
parcelHelpers.export(exports, "compileHOF", ()=>compileHOF
);
parcelHelpers.export(exports, "compileG", ()=>compileG
);
parcelHelpers.export(exports, "compileS", ()=>compileS
);
parcelHelpers.export(exports, "compileGHOF", ()=>compileGHOF
);
parcelHelpers.export(exports, "defOp", ()=>defOp
);
parcelHelpers.export(exports, "defFnOp", ()=>defFnOp
);
parcelHelpers.export(exports, "defHofOp", ()=>defHofOp
);
parcelHelpers.export(exports, "defOpS", ()=>defOpS
);
parcelHelpers.export(exports, "defHofOpS", ()=>defHofOpS
);
parcelHelpers.export(exports, "defMathOp", ()=>defMathOp
);
parcelHelpers.export(exports, "defMathOpN", ()=>defMathOpN
);
parcelHelpers.export(exports, "defBitOp", ()=>defBitOp
);
parcelHelpers.export(exports, "defBitOpN", ()=>defBitOpN
);
var _comp = require("@thi.ng/transducers/comp");
var _map = require("@thi.ng/transducers/map");
var _mapIndexed = require("@thi.ng/transducers/map-indexed");
var _range = require("@thi.ng/transducers/range");
var _str = require("@thi.ng/transducers/str");
var _take = require("@thi.ng/transducers/take");
var _transduce = require("@thi.ng/transducers/transduce");
var _zip = require("@thi.ng/transducers/zip");
var _vopJs = require("../vop.js");
var _templatesJs = require("./templates.js");
/**
 * HOF array index lookup gen to provide optimized versions of:
 *
 * @example
 * ```ts
 * lookup("a")(0) // a[ia]
 * lookup("a")(1) // a[ia * sa]
 * lookup("a")(2) // a[ia + 2 * sa]
 * ```
 *
 * @param sym -
 */ const lookup = (sym)=>(i)=>i > 1 ? `${sym}[i${sym}+${i}*s${sym}]` : i == 1 ? `${sym}[i${sym}+s${sym}]` : `${sym}[i${sym}]`
;
/**
 * Infinite iterator of strided index lookups for `sym`.
 *
 * @param sym -
 */ const indicesStrided = (sym)=>_map.map(lookup(sym), _range.range())
;
/**
 * Infinite iterator of simple (non-strided) index lookups for `sym`.
 *
 * @param sym -
 */ const indices = (sym)=>_map.map((i)=>`${sym}[${i}]`
    , _range.range())
;
/**
 * Code generator for loop-unrolled vector operations. Takes a vector
 * size `dim`, a code template function `tpl` and an array of symbol
 * names participating in the template. For each symbol, creates
 * iterator of index lookups (e.g. `a[0]` or `a[ia+k*sa]`), forms them
 * into tuples and passes them to template to generate code and joins
 * generated result with `opJoin` separator (default:
 * `""`).
 *
 * If the optional `ret` arg is not `null` (default `"a"`), appends a
 * `return` statement to the result array, using `ret` as return value.
 * Returns array of source code lines.
 *
 * The optional `pre` and `post` strings can be used to wrap the
 * generated code. `post` will be injected **before** the generated
 * return statement (if not suppressed).
 *
 * @param dim -
 * @param tpl -
 * @param syms -
 * @param ret -
 * @param opJoin -
 * @param pre -
 * @param post -
 * @param strided -
 */ const assemble = (dim, tpl, syms, ret = "a", opJoin = "", pre = "", post = "", strided = false)=>[
        pre,
        _transduce.transduce(_comp.comp(_take.take(dim), _mapIndexed.mapIndexed((i, x)=>tpl(x, i)
        )), _str.str(opJoin), _zip.zip.apply(null, syms.split(",").map(strided ? indicesStrided : indices))),
        post,
        ret !== "" ? `return ${ret};` : "", 
    ]
;
const assembleG = (tpl, syms, ret = "a", pre, post, strided = false)=>[
        pre,
        "for(let i=a.length;--i>=0;) {",
        tpl(syms.split(",").map(strided ? (x)=>`${x}[i${x}+i*s${x}]`
         : (x)=>`${x}[i]`
        )),
        "}",
        post,
        ret !== null ? `return ${ret};` : "", 
    ]
;
const assembleS = (tpl, syms = _templatesJs.ARGS_VV, ret = "o", pre = _templatesJs.DEFAULT_OUT, post)=>[
        pre,
        "while(k-->0) {",
        tpl(syms.split(",").map((x)=>`${x}[i${x}+k*s${x}]`
        )),
        "}",
        post,
        ret !== null ? `return ${ret};` : "", 
    ]
;
const defaultOut = (o, args)=>`!${o} && (${o}=${args.split(",")[1]});`
;
const compile = (dim, tpl, args, syms = args, ret = "a", opJoin, pre, post, strided = false)=>new Function(args, assemble(dim, tpl, syms, ret, opJoin, pre, post, strided).join(""))
;
const compileHOF = (dim, fns, tpl, hofArgs, args, syms = args, ret = "a", opJoin = "", pre, post, strided = false)=>{
    return new Function(hofArgs, `return (${args})=>{${assemble(dim, tpl, syms, ret, opJoin, pre, post, strided).join("")}}`)(...fns);
};
const compileG = (tpl, args, syms = args, ret = "a", pre, post, strided = false)=>new Function(args, assembleG(tpl, syms, ret, pre, post, strided).join(""))
;
const compileS = (tpl, args, syms = args, ret, pre, post)=>new Function(args, assembleS(tpl, syms, ret, pre, post).join(""))
;
const compileGHOF = (fns, tpl, hofArgs, args, syms = args, ret = "a", pre, post, strided = false)=>new Function(hofArgs, `return (${args})=>{${assembleG(tpl, syms, ret, pre, post, strided).join("")}}`)(...fns)
;
const defOp = (tpl, args = _templatesJs.ARGS_VV, syms, ret = "o", dispatch = 1, pre)=>{
    syms = syms || args;
    pre = pre != null ? pre : defaultOut(ret, args);
    const fn = _vopJs.vop(dispatch);
    const $ = (dim)=>fn.add(dim, compile(dim, tpl, args, syms, ret, "", pre))
    ;
    fn.default(compileG(tpl, args, syms, ret, pre));
    return [
        fn,
        $(2),
        $(3),
        $(4)
    ];
};
const defFnOp = (op)=>defOp(_templatesJs.FN(op), _templatesJs.ARGS_V)
;
const defHofOp = (op, tpl, args = _templatesJs.ARGS_V, syms, ret = "o", dispatch = 1, pre)=>{
    const _tpl = tpl || _templatesJs.FN("op");
    syms = syms || args;
    pre = pre != null ? pre : defaultOut(ret, args);
    const fn = _vopJs.vop(dispatch);
    const $ = (dim)=>fn.add(dim, compileHOF(dim, [
            op
        ], _tpl, "op", args, syms, ret, "", pre))
    ;
    fn.default(compileGHOF([
        op
    ], _tpl, "op", args, syms, ret, pre));
    return [
        fn,
        $(2),
        $(3),
        $(4)
    ];
};
const defOpS = (tpl, args = _templatesJs.ARGS_VV, idxArgs = _templatesJs.SARGS_VV, syms = _templatesJs.ARGS_VV, ret = "o", pre, sizes = [
    2,
    3,
    4
])=>[
        compileS(tpl, `${args},k,${idxArgs}`, syms, ret, pre),
        ...sizes.map((dim)=>compile(dim, tpl, `${args},${idxArgs}`, syms, ret, "", pre != null ? pre : defaultOut(ret, args), "", true)
        ), 
    ]
;
const defHofOpS = (op, tpl, args = _templatesJs.ARGS_VV, idxArgs = _templatesJs.SARGS_VV, syms = _templatesJs.ARGS_VV, ret = "o", pre, sizes = [
    2,
    3,
    4
])=>[
        new Function("op", `return (${args},k,${idxArgs})=>{${assembleS(tpl, syms, ret, pre).join("")}}`)(op),
        ...sizes.map((dim)=>compileHOF(dim, [
                op
            ], tpl, "op", `${args},${idxArgs}`, syms, ret, "", pre != null ? pre : defaultOut(ret, args), "", true)
        ), 
    ]
;
const defMathOp = (op)=>defOp(_templatesJs.MATH(op))
;
const defMathOpN = (op)=>defOp(_templatesJs.MATH_N(op), _templatesJs.ARGS_VN)
;
const defBitOp = (op, signed = false)=>defOp((signed ? _templatesJs.SIGNED : _templatesJs.UNSIGNED)(op))
;
const defBitOpN = (op, signed = false)=>defOp((signed ? _templatesJs.SIGNED_N : _templatesJs.UNSIGNED_N)(op), _templatesJs.ARGS_VN)
;

},{"@thi.ng/transducers/comp":"7g4yM","@thi.ng/transducers/map":"fW6Xn","@thi.ng/transducers/map-indexed":"feveV","@thi.ng/transducers/range":"lUHc9","@thi.ng/transducers/str":"9x5I6","@thi.ng/transducers/take":"cr3ZD","@thi.ng/transducers/transduce":"1Ttho","@thi.ng/transducers/zip":"ithYS","../vop.js":"4v2k5","./templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7g4yM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "comp", ()=>comp
);
var _comp = require("@thi.ng/compose/comp");
var _ensureJs = require("./ensure.js");
function comp(...fns) {
    fns = fns.map(_ensureJs.ensureTransducer);
    return _comp.comp.apply(null, fns);
}

},{"@thi.ng/compose/comp":"87ham","./ensure.js":"lSMoA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"87ham":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "comp", ()=>comp
);
parcelHelpers.export(exports, "compL", ()=>compL
);
parcelHelpers.export(exports, "compI", ()=>compI
);
var _illegalArity = require("@thi.ng/errors/illegal-arity");
function comp(...fns) {
    let [a, b, c, d, e, f, g, h, i, j] = fns;
    switch(fns.length){
        case 0:
            _illegalArity.illegalArity(0);
        case 1:
            return a;
        case 2:
            return (...xs)=>a(b(...xs))
            ;
        case 3:
            return (...xs)=>a(b(c(...xs)))
            ;
        case 4:
            return (...xs)=>a(b(c(d(...xs))))
            ;
        case 5:
            return (...xs)=>a(b(c(d(e(...xs)))))
            ;
        case 6:
            return (...xs)=>a(b(c(d(e(f(...xs))))))
            ;
        case 7:
            return (...xs)=>a(b(c(d(e(f(g(...xs)))))))
            ;
        case 8:
            return (...xs)=>a(b(c(d(e(f(g(h(...xs))))))))
            ;
        case 9:
            return (...xs)=>a(b(c(d(e(f(g(h(i(...xs)))))))))
            ;
        case 10:
        default:
            const fn = (...xs)=>a(b(c(d(e(f(g(h(i(j(...xs))))))))))
            ;
            return fns.length === 10 ? fn : comp(fn, ...fns.slice(10));
    }
}
function compL(...fns) {
    return comp.apply(null, fns.reverse());
}
const compI = compL;

},{"@thi.ng/errors/illegal-arity":"fOKRC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"feveV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapIndexed", ()=>mapIndexed
);
var _comprJs = require("./compr.js");
var _iteratorJs = require("./iterator.js");
function mapIndexed(...args) {
    return _iteratorJs.__iter(mapIndexed, args) || ((rfn)=>{
        const r = rfn[2];
        const fn = args[0];
        let i = args[1] || 0;
        return _comprJs.compR(rfn, (acc, x)=>r(acc, fn(i++, x))
        );
    });
}

},{"./compr.js":"ePFjm","./iterator.js":"8km8L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lUHc9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "range", ()=>range
);
/**
 * Simple class wrapper around given range interval and implementing
 * `Iterable` and {@link IReducible} interfaces, the latter is used to
 * accelerate use with {@link (reduce:1)}.
 */ parcelHelpers.export(exports, "Range", ()=>Range
);
var _reducedJs = require("./reduced.js");
function range(from, to, step) {
    return new Range(from, to, step);
}
class Range {
    constructor(from, to, step){
        if (from === undefined) {
            from = 0;
            to = Infinity;
        } else if (to === undefined) {
            to = from;
            from = 0;
        }
        step = step === undefined ? from < to ? 1 : -1 : step;
        this.from = from;
        this.to = to;
        this.step = step;
    }
    *[Symbol.iterator]() {
        let { from , to , step  } = this;
        if (step > 0) while(from < to){
            yield from;
            from += step;
        }
        else if (step < 0) while(from > to){
            yield from;
            from += step;
        }
    }
    $reduce(rfn, acc) {
        const step = this.step;
        if (step > 0) for(let i = this.from, n = this.to; i < n && !_reducedJs.isReduced(acc); i += step)acc = rfn(acc, i);
        else for(let i1 = this.from, n1 = this.to; i1 > n1 && !_reducedJs.isReduced(acc); i1 += step)acc = rfn(acc, i1);
        return acc;
    }
}

},{"./reduced.js":"cAjrZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9x5I6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "str", ()=>str
);
var _reduceJs = require("./reduce.js");
function str(sep, xs) {
    sep = sep || "";
    let first = true;
    return xs ? [
        ...xs
    ].join(sep) : _reduceJs.reducer(()=>""
    , (acc, x)=>(acc = first ? acc + x : acc + sep + x, first = false, acc)
    );
}

},{"./reduce.js":"hP05c","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cr3ZD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "take", ()=>take
);
var _isIterable = require("@thi.ng/checks/is-iterable");
var _comprJs = require("./compr.js");
var _iteratorJs = require("./iterator.js");
var _reducedJs = require("./reduced.js");
function take(n, src) {
    return _isIterable.isIterable(src) ? _iteratorJs.iterator(take(n), src) : (rfn)=>{
        const r = rfn[2];
        let m = n;
        return _comprJs.compR(rfn, (acc, x)=>--m > 0 ? r(acc, x) : m === 0 ? _reducedJs.ensureReduced(r(acc, x)) : _reducedJs.reduced(acc)
        );
    };
}

},{"@thi.ng/checks/is-iterable":"bDbbO","./compr.js":"ePFjm","./iterator.js":"8km8L","./reduced.js":"cAjrZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Ttho":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transduce", ()=>transduce
);
parcelHelpers.export(exports, "transduceRight", ()=>transduceRight
);
var _illegalArity = require("@thi.ng/errors/illegal-arity");
var _ensureJs = require("./ensure.js");
var _mapJs = require("./map.js");
var _reduceJs = require("./reduce.js");
function transduce(...args) {
    return $transduce(transduce, _reduceJs.reduce, args);
}
function transduceRight(...args) {
    return $transduce(transduceRight, _reduceJs.reduceRight, args);
}
const $transduce = (tfn, rfn, args)=>{
    let acc, xs;
    switch(args.length){
        case 4:
            xs = args[3];
            acc = args[2];
            break;
        case 3:
            xs = args[2];
            break;
        case 2:
            return _mapJs.map((x)=>tfn(args[0], args[1], x)
            );
        default:
            _illegalArity.illegalArity(args.length);
    }
    return rfn(_ensureJs.ensureTransducer(args[0])(args[1]), acc, xs);
};

},{"@thi.ng/errors/illegal-arity":"fOKRC","./ensure.js":"lSMoA","./map.js":"fW6Xn","./reduce.js":"hP05c","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ithYS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "zip", ()=>zip
);
function* zip(...src) {
    const iters = src.map((s)=>s[Symbol.iterator]()
    );
    while(true){
        const tuple = [];
        for (let i of iters){
            let v = i.next();
            if (v.done) return;
            tuple.push(v.value);
        }
        yield tuple;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4v2k5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "vop", ()=>vop
);
var _unsupported = require("@thi.ng/errors/unsupported");
const vop = (dispatch = 0)=>{
    const impls = new Array(5);
    let fallback;
    const fn1 = (...args)=>{
        const g = impls[args[dispatch].length] || fallback;
        return g ? g(...args) : _unsupported.unsupported(`no impl for vec size ${args[dispatch].length}`);
    };
    fn1.add = (dim, fn)=>impls[dim] = fn
    ;
    fn1.default = (fn)=>fallback = fn
    ;
    fn1.impl = (dim)=>impls[dim] || fallback
    ;
    // fn.impls = impls;
    return fn1;
};

},{"@thi.ng/errors/unsupported":"dDHMM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dDHMM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnsupportedOperationError", ()=>UnsupportedOperationError
);
parcelHelpers.export(exports, "unsupported", ()=>unsupported
);
var _deferrorJs = require("./deferror.js");
const UnsupportedOperationError = _deferrorJs.defError(()=>"unsupported operation"
);
const unsupported = (msg)=>{
    throw new UnsupportedOperationError(msg);
};

},{"./deferror.js":"l9nQt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1B2Pe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ARGS_V", ()=>ARGS_V
);
parcelHelpers.export(exports, "ARGS_VV", ()=>ARGS_VV
);
parcelHelpers.export(exports, "ARGS_VVV", ()=>ARGS_VVV
);
parcelHelpers.export(exports, "ARGS_VN", ()=>ARGS_VN
);
parcelHelpers.export(exports, "ARGS_VNV", ()=>ARGS_VNV
);
parcelHelpers.export(exports, "ARGS_VVN", ()=>ARGS_VVN
);
parcelHelpers.export(exports, "SARGS_V", ()=>SARGS_V
);
parcelHelpers.export(exports, "SARGS_VV", ()=>SARGS_VV
);
parcelHelpers.export(exports, "SARGS_VVV", ()=>SARGS_VVV
);
parcelHelpers.export(exports, "DEFAULT_OUT", ()=>DEFAULT_OUT
);
parcelHelpers.export(exports, "NEW_OUT", ()=>NEW_OUT
);
parcelHelpers.export(exports, "NEW_OUT_A", ()=>NEW_OUT_A
);
parcelHelpers.export(exports, "MATH", ()=>MATH
);
parcelHelpers.export(exports, "MATH_N", ()=>MATH_N
);
parcelHelpers.export(exports, "MATH2", ()=>MATH2
);
parcelHelpers.export(exports, "MATH2_N", ()=>MATH2_N
);
parcelHelpers.export(exports, "MATH2A_N", ()=>MATH2A_N
);
parcelHelpers.export(exports, "SIGNED", ()=>SIGNED
);
parcelHelpers.export(exports, "UNSIGNED", ()=>UNSIGNED
);
parcelHelpers.export(exports, "SIGNED_N", ()=>SIGNED_N
);
parcelHelpers.export(exports, "UNSIGNED_N", ()=>UNSIGNED_N
);
parcelHelpers.export(exports, "FN", ()=>FN
);
parcelHelpers.export(exports, "FN2", ()=>FN2
);
parcelHelpers.export(exports, "FN3", ()=>FN3
);
parcelHelpers.export(exports, "FN5", ()=>FN5
);
parcelHelpers.export(exports, "FN_N", ()=>FN_N
);
parcelHelpers.export(exports, "DOT", ()=>DOT
);
parcelHelpers.export(exports, "DOT_G", ()=>DOT_G
);
parcelHelpers.export(exports, "SET", ()=>SET
);
parcelHelpers.export(exports, "SET_N", ()=>SET_N
);
parcelHelpers.export(exports, "MIX", ()=>MIX
);
parcelHelpers.export(exports, "MIX_N", ()=>MIX_N
);
const ARGS_V = "o,a";
const ARGS_VV = "o,a,b";
const ARGS_VVV = "o,a,b,c";
const ARGS_VN = "o,a,n";
const ARGS_VNV = "o,a,n,b";
const ARGS_VVN = "o,a,b,n";
const SARGS_V = "io=0,ia=0,so=1,sa=1";
const SARGS_VV = "io=0,ia=0,ib=0,so=1,sa=1,sb=1";
const SARGS_VVV = "io=0,ia=0,ib=0,ic=0,so=1,sa=1,sb=1,sc=1";
const DEFAULT_OUT = "!o&&(o=a);";
const NEW_OUT = "!o&&(o=[]);";
const NEW_OUT_A = "!a&&(a=[]);";
const MATH = (op)=>([o, a, b])=>`${o}=${a}${op}${b};`
;
const MATH_N = (op)=>([o, a])=>`${o}=${a}${op}n;`
;
const MATH2 = (op1, op2)=>([o, a, b, c])=>`${o}=(${a}${op1}${b})${op2}${c};`
;
const MATH2_N = (op1, op2)=>([o, a, b])=>`${o}=(${a}${op1}${b})${op2}n;`
;
const MATH2A_N = (op1, op2)=>([o, a, b])=>`${o}=(${a}${op1}n)${op2}${b};`
;
const SIGNED = (op)=>([o, a, b])=>`${o}=(${a}${op}${b})|0;`
;
const UNSIGNED = (op)=>([o, a, b])=>`${o}=(${a}${op}${b})>>>0;`
;
const SIGNED_N = (op)=>([o, a])=>`${o}=(${a}${op}n)|0;`
;
const UNSIGNED_N = (op)=>([o, a])=>`${o}=(${a}${op}n)>>>0;`
;
const FN = (op = "op")=>([o, a])=>`${o}=${op}(${a});`
;
const FN2 = (op = "op")=>([o, a, b])=>`${o}=${op}(${a},${b});`
;
const FN3 = (op = "op")=>([o, a, b, c])=>`${o}=${op}(${a},${b},${c});`
;
const FN5 = (op = "op")=>([o, a, b, c, d, e])=>`${o}=${op}(${a},${b},${c},${d},${e});`
;
const FN_N = (op = "op")=>([o, a])=>`${o}=${op}(${a},n);`
;
const DOT = ([a, b])=>`${a}*${b}`
;
const DOT_G = ([a, b])=>`s+=${a}*${b};`
;
const SET = ([o, a])=>`${o}=${a};`
;
const SET_N = ([a])=>`${a}=n;`
;
const MIX = ([o, a, b, c])=>`${o}=${a}+(${b}-${a})*${c};`
;
const MIX_N = ([o, a, b])=>`${o}=${a}+(${b}-${a})*n;`
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9RX5K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CMP", ()=>CMP
);
parcelHelpers.export(exports, "addResults", ()=>addResults
);
parcelHelpers.export(exports, "into", ()=>into
);
const CMP = (a, b)=>b[0] - a[0]
;
const addResults = (fn, sel, acc)=>{
    for(let n = sel.sort(CMP).length; n-- > 0;){
        const s = sel[n][1];
        s && acc.push(fn(s));
    }
    return acc;
};
const into = (map, pairs, eps)=>{
    let ok = true;
    for (let p of pairs)ok = map.set(p[0], p[1], eps) && ok;
    return ok;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5eyOc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KdTreeSet", ()=>KdTreeSet
);
var _kdTreeMapJs = require("./kd-tree-map.js");
class KdTreeSet {
    constructor(dim, keys){
        this.tree = new _kdTreeMapJs.KdTreeMap(dim);
        keys && this.into(keys);
    }
    [Symbol.iterator]() {
        return this.tree.keys();
    }
    keys() {
        return this.tree.keys();
    }
    values() {
        return this.tree.keys();
    }
    get size() {
        return this.tree.size;
    }
    get height() {
        return this.tree.height;
    }
    get ratio() {
        return this.tree.ratio;
    }
    copy() {
        return new KdTreeSet(this.tree.dim, this);
    }
    clear() {
        this.tree.clear();
    }
    empty() {
        return new KdTreeSet(this.tree.dim);
    }
    add(key, eps) {
        return this.tree.set(key, key, eps);
    }
    into(ks, eps) {
        let ok = true;
        for (let k of ks)ok = this.tree.set(k, k, eps) && ok;
        return ok;
    }
    remove(key) {
        return this.tree.remove(key);
    }
    has(key, eps) {
        return this.tree.has(key, eps);
    }
    get(key, eps) {
        return this.tree.get(key, eps);
    }
    query(q, maxDist, limit, acc) {
        return this.tree.query(q, maxDist, limit, acc);
    }
    queryKeys(q, maxDist, limit, acc) {
        return this.tree.queryKeys(q, maxDist, limit, acc);
    }
    queryValues(q, maxDist, limit, acc) {
        return this.tree.queryKeys(q, maxDist, limit, acc);
    }
}

},{"./kd-tree-map.js":"7aH1S","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5mrju":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NdQtNode", ()=>NdQtNode
);
/**
 * Point-based quadtree for nD keys and optional value association.
 * Supports radial range queries and key removal with tree pruning. See
 * {@link ndQuadtreeFromMinMax}.
 *
 * @remarks
 * Partially ported from Clojure version of {@link http://thi.ng/geom}.
 */ parcelHelpers.export(exports, "NdQuadtreeMap", ()=>NdQuadtreeMap
);
var _equiv = require("@thi.ng/equiv");
var _assert = require("@thi.ng/errors/assert");
var _point = require("@thi.ng/geom-isec/point");
var _rectCircle = require("@thi.ng/geom-isec/rect-circle");
var _heap = require("@thi.ng/heaps/heap");
var _api = require("@thi.ng/math/api");
var _iterate = require("@thi.ng/transducers/iterate");
var _map = require("@thi.ng/transducers/map");
var _permutations = require("@thi.ng/transducers/permutations");
var _repeat = require("@thi.ng/transducers/repeat");
var _take = require("@thi.ng/transducers/take");
var _addmn = require("@thi.ng/vectors/addmn");
var _distsq = require("@thi.ng/vectors/distsq");
var _madd = require("@thi.ng/vectors/madd");
var _muln = require("@thi.ng/vectors/muln");
var _submn = require("@thi.ng/vectors/submn");
var _vop = require("@thi.ng/vectors/vop");
var _utilsJs = require("./utils.js");
class NdQtNode {
    constructor(parent, pos, ext){
        this.parent = parent;
        this.pos = pos;
        this.ext = ext;
        this.numC = 0;
    }
    clear() {
        delete this.children;
        delete this.k;
        delete this.v;
        this.numC = 0;
    }
    set(p, val, eps) {
        return (eps <= 0 || !this.queryKeys(p, eps, 1, []).length) && this.containsPoint(p) && this.setUnsafe(p, val);
    }
    setUnsafe(p, val) {
        if (this.k) {
            if (_equiv.equivArrayLike(this.k, p)) {
                this.v = val;
                return false;
            }
            this.ensureChild(childID(this.k, this.pos)).setUnsafe(this.k, this.v);
            delete this.k;
            delete this.v;
        }
        if (this.children) return this.ensureChild(childID(p, this.pos)).setUnsafe(p, val);
        else {
            this.k = p;
            this.v = val;
        }
        return true;
    }
    query(fn, p, r, max, acc) {
        return _utilsJs.addResults(fn, this.doQuery(p, r, max, new _heap.Heap([
            [
                r * r
            ]
        ], {
            compare: _utilsJs.CMP
        })).values, acc);
    }
    queryKeys(p, r, max, acc) {
        return this.query((n)=>n.k
        , p, r, max, acc);
    }
    queryValues(p, r, max, acc) {
        return this.query((n)=>n.v
        , p, r, max, acc);
    }
    containsPoint(p) {
        return _point.pointInCenteredBox(p, this.pos, this.ext);
    }
    nodeForPoint(p) {
        if (this.k && _equiv.equivArrayLike(this.k, p)) return this;
        if (this.children) {
            const child = this.children[childID(p, this.pos)];
            return child ? child.nodeForPoint(p) : undefined;
        }
    }
    doQuery(p, r, max, acc) {
        if (_rectCircle.testCenteredBoxSphere(this.pos, this.ext, p, r)) {
            if (this.k) {
                const d = _distsq.distSq(this.k, p);
                if (d <= acc.values[0][0]) acc.length >= max ? acc.pushPop([
                    d,
                    this
                ]) : acc.push([
                    d,
                    this
                ]);
            } else if (this.children) {
                for(let i = MAX_CHILDREN[this.pos.length], j = this.numC; i-- > 0 && j > 0;)if (this.children[i]) {
                    this.children[i].doQuery(p, r, max, acc);
                    j--;
                }
            }
        }
        return acc;
    }
    ensureChild(id) {
        !this.children && (this.children = []);
        let c = this.children[id];
        if (!c) {
            const csize = _muln.mulN([], this.ext, 0.5);
            this.children[id] = c = new NdQtNode(this, _madd.madd([], csize, CHILD_OFFSETS[csize.length][id], this.pos), csize);
            this.numC++;
        }
        return c;
    }
}
class NdQuadtreeMap {
    constructor(pos, ext, pairs){
        const dim = pos.length;
        _assert.assert(dim > 0 && dim <= NdQuadtreeMap.MAX_DIM, `illegal dimension: ${dim}`);
        _assert.assert(ext.length === dim, `pos/ext dimensions must be equal`);
        initChildOffsets(dim);
        this.root = new NdQtNode(undefined, pos, ext);
        this._size = 0;
        pairs && this.into(pairs, -1);
    }
    /**
     * Returns a new point-based `NdQuadtreeMap` for nD keys in given
     * region defined by `min` / `max` coordinates. The dimensionality
     * of the tree is implicitly defined by the provided coordinates.
     * Only points within that region can be indexed.
     *
     * @remarks
     * Due to exponentially growing lookup tables, currently only
     * supports up to 16 dimensions.
     */ static fromMinMax(min, max) {
        return new NdQuadtreeMap(_addmn.addmN([], min, max, 0.5), _submn.submN([], max, min, 0.5));
    }
    get size() {
        return this._size;
    }
    [Symbol.iterator]() {
        return _map.map((n)=>[
                n.k,
                n.v
            ]
        , this.nodes());
    }
    keys() {
        return _map.map((n)=>n.k
        , this.nodes());
    }
    values() {
        return _map.map((n)=>n.v
        , this.nodes());
    }
    *nodes(all = false) {
        let queue = [
            this.root
        ];
        while(queue.length){
            const n = queue.pop();
            if (n) {
                if (all || n.k) yield n;
                if (n.children) queue = queue.concat(n.children);
            }
        }
    }
    copy() {
        const tree = new NdQuadtreeMap(this.root.pos, this.root.ext, this);
        return tree;
    }
    clear() {
        this.root.clear();
        this._size = 0;
    }
    empty() {
        return new NdQuadtreeMap(this.root.pos, this.root.ext);
    }
    set(key, val, eps = _api.EPS) {
        if (this.root.set(key, val, eps)) {
            this._size++;
            return true;
        }
        return false;
    }
    into(pairs, eps = _api.EPS) {
        return _utilsJs.into(this, pairs, eps);
    }
    remove(p) {
        let node = this.root.nodeForPoint(p);
        if (!node) return false;
        this._size--;
        delete node.k;
        delete node.v;
        let doPrune = true;
        while(node.parent){
            node = node.parent;
            delete node.children[childID(p, node.pos)];
            doPrune = --node.numC === 0;
            if (doPrune) delete node.children;
            else break;
        }
        return true;
    }
    has(p, eps = _api.EPS) {
        return !!(eps <= 0 ? this.root.nodeForPoint(p) : this.root.queryKeys(p, eps, 1, []).length);
    }
    get(p, eps = _api.EPS) {
        if (eps <= 0) {
            const node = this.root.nodeForPoint(p);
            return node ? node.v : undefined;
        }
        return this.root.queryValues(p, eps, 1, [])[0];
    }
    query(p, r, max = 1, acc = []) {
        return this.root.query((n)=>[
                n.k,
                n.v
            ]
        , p, r, max, acc);
    }
    queryKeys(p, r, max = 1, acc = []) {
        return this.root.queryKeys(p, r, max, acc);
    }
    queryValues(p, r, max = 1, acc = []) {
        return this.root.queryValues(p, r, max, acc);
    }
    containsPoint(p) {
        return this.root.containsPoint(p);
    }
    nodeForPoint(p) {
        return this.root.nodeForPoint(p);
    }
}
NdQuadtreeMap.MAX_DIM = 16;
const MAX_CHILDREN = [
    ..._take.take(NdQuadtreeMap.MAX_DIM + 1, _iterate.iterate((x)=>x * 2
    , 1)), 
];
const CHILD_OFFSETS = [];
const initChildOffsets = (dim)=>CHILD_OFFSETS[dim] || (CHILD_OFFSETS[dim] = [
        ..._permutations.permutations(..._repeat.repeat([
            -1,
            1
        ], dim))
    ])
;
const childID = _vop.vop(0);
childID.add(1, (p, q)=>p[0] >= q[0] ? 1 : 0
);
childID.add(2, (p, q)=>(p[0] >= q[0] ? 2 : 0) | (p[1] >= q[1] ? 1 : 0)
);
childID.add(3, (p, q)=>(p[0] >= q[0] ? 4 : 0) | (p[1] >= q[1] ? 2 : 0) | (p[2] >= q[2] ? 1 : 0)
);
childID.add(4, (p, q)=>(p[0] >= q[0] ? 8 : 0) | (p[1] >= q[1] ? 4 : 0) | (p[2] >= q[2] ? 2 : 0) | (p[3] >= q[3] ? 1 : 0)
);
childID.default((p, q)=>{
    let id = 0;
    for(let i = 0, n = p.length - 1, bit = 1 << n; i <= n; i++, bit >>>= 1)p[i] >= q[i] && (id += bit);
    return id;
});

},{"@thi.ng/equiv":"e2rLA","@thi.ng/errors/assert":"zM8kA","@thi.ng/geom-isec/point":"f9zjT","@thi.ng/geom-isec/rect-circle":"318Sg","@thi.ng/heaps/heap":"18spH","@thi.ng/math/api":"4a98p","@thi.ng/transducers/iterate":"l9qxc","@thi.ng/transducers/map":"fW6Xn","@thi.ng/transducers/permutations":"jj5MK","@thi.ng/transducers/repeat":"afG7n","@thi.ng/transducers/take":"cr3ZD","@thi.ng/vectors/addmn":"9C52h","@thi.ng/vectors/distsq":"8XCdB","@thi.ng/vectors/madd":"8NYtQ","@thi.ng/vectors/muln":"1TKlE","@thi.ng/vectors/submn":"aIPIo","@thi.ng/vectors/vop":"4v2k5","./utils.js":"9RX5K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"zM8kA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AssertionError", ()=>AssertionError
);
parcelHelpers.export(exports, "assert", ()=>assert
);
var _deferrorJs = require("./deferror.js");
var process = require("process");
const AssertionError = _deferrorJs.defError(()=>"Assertion failed"
);
const assert = (()=>typeof process !== "undefined" && typeof process.env !== "undefined" ? true : typeof __SNOWPACK_ENV__ !== "undefined" ? __SNOWPACK_ENV__.MODE !== "production" || !!__SNOWPACK_ENV__.UMBRELLA_ASSERTS || !!__SNOWPACK_ENV__.SNOWPACK_PUBLIC_UMBRELLA_ASSERTS : true
)() ? (test, msg)=>{
    if (typeof test === "function" && !test() || !test) throw new AssertionError(typeof msg === "function" ? msg() : msg);
} : ()=>{
};

},{"./deferror.js":"l9nQt","process":"jhUEF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f9zjT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pointInSegment", ()=>pointInSegment
);
parcelHelpers.export(exports, "pointInCircle", ()=>pointInCircle
);
parcelHelpers.export(exports, "pointInSphere", ()=>pointInSphere
);
parcelHelpers.export(exports, "classifyPointInCircle", ()=>classifyPointInCircle
);
parcelHelpers.export(exports, "pointIn3Circle", ()=>pointIn3Circle
);
parcelHelpers.export(exports, "pointIn4Sphere", ()=>pointIn4Sphere
);
parcelHelpers.export(exports, "pointInCircumCircle", ()=>pointInCircumCircle
);
parcelHelpers.export(exports, "pointInTriangle2", ()=>pointInTriangle2
);
parcelHelpers.export(exports, "classifyPointInTriangle2", ()=>classifyPointInTriangle2
);
parcelHelpers.export(exports, "pointInPolygon2", ()=>pointInPolygon2
);
parcelHelpers.export(exports, "classifyPointPolyPair", ()=>classifyPointPolyPair
);
parcelHelpers.export(exports, "pointInBox", ()=>pointInBox
);
parcelHelpers.export(exports, "pointInRect", ()=>pointInRect
);
parcelHelpers.export(exports, "pointInAABB", ()=>pointInAABB
);
parcelHelpers.export(exports, "pointInCenteredBox", ()=>pointInCenteredBox
);
parcelHelpers.export(exports, "pointInCenteredRect", ()=>pointInCenteredRect
);
parcelHelpers.export(exports, "pointInCenteredAABB", ()=>pointInCenteredAABB
);
var _line = require("@thi.ng/geom-closest-point/line");
var _abs = require("@thi.ng/math/abs");
var _api = require("@thi.ng/math/api");
var _interval = require("@thi.ng/math/interval");
var _clockwise = require("@thi.ng/vectors/clockwise");
var _distsq = require("@thi.ng/vectors/distsq");
var _magsq = require("@thi.ng/vectors/magsq");
var _mixn = require("@thi.ng/vectors/mixn");
var _signedArea = require("@thi.ng/vectors/signed-area");
var _vop = require("@thi.ng/vectors/vop");
const pointInSegment = (p, a, b, eps = _api.EPS)=>{
    const t = _line.closestT(p, a, b);
    return t !== undefined ? _distsq.distSq(p, _mixn.mixN([], a, b, _interval.clamp01(t))) < eps * eps : false;
};
const pointInCircle = (p, pos, r)=>_distsq.distSq(pos, p) <= r * r
;
const pointInSphere = pointInCircle;
const classifyPointInCircle = (p, pos, r, eps = _api.EPS)=>_abs.sign(r * r - _distsq.distSq(pos, p), eps)
;
const pointIn3Circle = ([px, py], a, b, c)=>{
    const apx = a[0] - px;
    const apy = a[1] - py;
    const bpx = b[0] - px;
    const bpy = b[1] - py;
    const cpx = c[0] - px;
    const cpy = c[1] - py;
    const abdet = apx * bpy - bpx * apy;
    const bcdet = bpx * cpy - cpx * bpy;
    const cadet = cpx * apy - apx * cpy;
    const alift = apx * apx + apy * apy;
    const blift = bpx * bpx + bpy * bpy;
    const clift = cpx * cpx + cpy * cpy;
    return alift * bcdet + blift * cadet + clift * abdet;
};
const pointIn4Sphere = ([px, py, pz], a, b, c, d)=>{
    const apx = a[0] - px;
    const bpx = b[0] - px;
    const cpx = c[0] - px;
    const dpx = d[0] - px;
    const apy = a[1] - py;
    const bpy = b[1] - py;
    const cpy = c[1] - py;
    const dpy = d[1] - py;
    const apz = a[2] - pz;
    const bpz = b[2] - pz;
    const cpz = c[2] - pz;
    const dpz = d[2] - pz;
    const ab = apx * bpy - bpx * apy;
    const bc = bpx * cpy - cpx * bpy;
    const cd = cpx * dpy - dpx * cpy;
    const da = dpx * apy - apx * dpy;
    const ac = apx * cpy - cpx * apy;
    const bd = bpx * dpy - dpx * bpy;
    const abc = apz * bc - bpz * ac + cpz * ab;
    const bcd = bpz * cd - cpz * bd + dpz * bc;
    const cda = cpz * da + dpz * ac + apz * cd;
    const dab = dpz * ab + apz * bd + bpz * da;
    const alift = apx * apx + apy * apy + apz * apz;
    const blift = bpx * bpx + bpy * bpy + bpz * bpz;
    const clift = cpx * cpx + cpy * cpy + cpz * cpz;
    const dlift = dpx * dpx + dpy * dpy + dpz * dpz;
    return dlift * abc - clift * dab + (blift * cda - alift * bcd);
};
const pointInCircumCircle = (a, b, c, d)=>_magsq.magSq(a) * _signedArea.signedArea2(b, c, d) - _magsq.magSq(b) * _signedArea.signedArea2(a, c, d) + _magsq.magSq(c) * _signedArea.signedArea2(a, b, d) - _magsq.magSq(d) * _signedArea.signedArea2(a, b, c) > 0
;
const pointInTriangle2 = (p, a, b, c)=>{
    const s = _clockwise.clockwise2(a, b, c) ? 1 : -1;
    return s * _signedArea.signedArea2(a, c, p) >= 0 && s * _signedArea.signedArea2(b, a, p) >= 0 && s * _signedArea.signedArea2(c, b, p) >= 0;
};
const classifyPointInTriangle2 = (p, a, b, c, eps = _api.EPS)=>{
    const s = _clockwise.clockwise2(a, b, c) ? 1 : -1;
    return _abs.sign(Math.min(s * _signedArea.signedArea2(a, c, p), s * _signedArea.signedArea2(b, a, p), s * _signedArea.signedArea2(c, b, p)), eps);
};
const pointInPolygon2 = (p, pts)=>{
    const n = pts.length - 1;
    const px = p[0];
    const py = p[1];
    let a = pts[n];
    let b = pts[0];
    let inside = 0;
    for(let i = 0; i <= n; a = b, b = pts[++i])inside = classifyPointPolyPair(px, py, a[0], a[1], b[0], b[1], inside);
    return inside;
};
const classifyPointPolyPair = (px, py, ax, ay, bx, by, inside)=>(ay < py && by >= py || by < py && ay >= py) && (ax <= px || bx <= px) ? inside ^ ~~(ax + (py - ay) / (by - ay) * (bx - ax) < px) : inside
;
const pointInBox = _vop.vop(0);
const pointInRect = pointInBox.add(2, ([x, y], pos, size)=>x >= pos[0] && x <= pos[0] + size[0] && y >= pos[1] && y <= pos[1] + size[1]
);
const pointInAABB = pointInBox.add(3, ([x, y, z], pos, size)=>x >= pos[0] && x <= pos[0] + size[0] && y >= pos[1] && y <= pos[1] + size[1] && z >= pos[2] && z <= pos[2] + size[2]
);
pointInBox.default((p, boxMin, boxSize)=>{
    for(let i = p.length; i-- > 0;){
        const x = p[i];
        const y = boxMin[i];
        if (x < y || x > y + boxSize[i]) return false;
    }
    return true;
});
const pointInCenteredBox = _vop.vop(0);
const pointInCenteredRect = pointInCenteredBox.add(2, ([x, y], pos, size)=>x >= pos[0] - size[0] && x <= pos[0] + size[0] && y >= pos[1] - size[1] && y <= pos[1] + size[1]
);
const pointInCenteredAABB = pointInCenteredBox.add(3, ([x, y, z], pos, size)=>x >= pos[0] - size[0] && x <= pos[0] + size[0] && y >= pos[1] - size[1] && y <= pos[1] + size[1] && z >= pos[2] - size[2] && z <= pos[2] + size[2]
);
pointInCenteredBox.default((p, boxCenter, boxExtent)=>{
    for(let i = p.length; i-- > 0;){
        const x = p[i];
        const y = boxCenter[i];
        const z = boxExtent[i];
        if (x < y - z || x > y + z) return false;
    }
    return true;
});

},{"@thi.ng/geom-closest-point/line":"71qLb","@thi.ng/math/abs":"he08U","@thi.ng/math/api":"4a98p","@thi.ng/math/interval":"1TDWA","@thi.ng/vectors/clockwise":"hd0jc","@thi.ng/vectors/distsq":"8XCdB","@thi.ng/vectors/magsq":"bsMC4","@thi.ng/vectors/mixn":"jolPM","@thi.ng/vectors/signed-area":"2iZFe","@thi.ng/vectors/vop":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"71qLb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "closestT", ()=>closestT
);
parcelHelpers.export(exports, "closestPointLine", ()=>closestPointLine
);
parcelHelpers.export(exports, "distToLine", ()=>distToLine
);
parcelHelpers.export(exports, "closestPointSegment", ()=>closestPointSegment
);
parcelHelpers.export(exports, "distToSegment", ()=>distToSegment
);
parcelHelpers.export(exports, "closestPointPolyline", ()=>closestPointPolyline
);
parcelHelpers.export(exports, "farthestPointSegment", ()=>farthestPointSegment
);
var _dist = require("@thi.ng/vectors/dist");
var _distsq = require("@thi.ng/vectors/distsq");
var _dot = require("@thi.ng/vectors/dot");
var _empty = require("@thi.ng/vectors/empty");
var _magsq = require("@thi.ng/vectors/magsq");
var _mixn = require("@thi.ng/vectors/mixn");
var _set = require("@thi.ng/vectors/set");
var _sub = require("@thi.ng/vectors/sub");
const closestT = (p, a, b)=>{
    const d = _sub.sub([], b, a);
    const l = _magsq.magSq(d);
    return l > 0.000001 ? _dot.dot(_sub.sub([], p, a), d) / l : undefined;
};
const closestPointLine = (p, a, b)=>_mixn.mixN([], a, b, closestT(p, a, b) || 0)
;
const distToLine = (p, a, b)=>_dist.dist(p, closestPointLine(p, a, b) || a)
;
const closestPointSegment = (p, a, b, out, insideOnly = false, eps = 0)=>{
    const t = closestT(p, a, b);
    if (t !== undefined && (!insideOnly || t >= eps && t <= 1 - eps)) {
        out = out || _empty.empty(p);
        return t <= 0 ? _set.set(out, a) : t >= 1 ? _set.set(out, b) : _mixn.mixN(out, a, b, t);
    }
};
const distToSegment = (p, a, b)=>_dist.dist(p, closestPointSegment(p, a, b) || a)
;
const closestPointPolyline = (p, pts, closed = false, out = [])=>{
    if (!pts.length) return;
    const tmp = [];
    const n = pts.length - 1;
    let minD = Infinity, i, j;
    if (closed) {
        i = n;
        j = 0;
    } else {
        i = 0;
        j = 1;
    }
    for(; j <= n; i = j, j++)if (closestPointSegment(p, pts[i], pts[j], tmp)) {
        const d = _distsq.distSq(p, tmp);
        if (d < minD) {
            minD = d;
            _set.set(out, tmp);
        }
    }
    return minD < Infinity ? out : undefined;
};
const farthestPointSegment = (a, b, points, from = 0, to = points.length)=>{
    let maxD = -1;
    let maxIdx = -1;
    const tmp = _empty.empty(a);
    for(let i = from; i < to; i++){
        const p = points[i];
        const d = _distsq.distSq(p, closestPointSegment(p, a, b, tmp) || a);
        if (d > maxD) {
            maxD = d;
            maxIdx = i;
        }
    }
    return [
        maxIdx,
        Math.sqrt(maxD)
    ];
};

},{"@thi.ng/vectors/dist":"kIwBu","@thi.ng/vectors/distsq":"8XCdB","@thi.ng/vectors/dot":"9vV5N","@thi.ng/vectors/empty":"5JVqG","@thi.ng/vectors/magsq":"bsMC4","@thi.ng/vectors/mixn":"jolPM","@thi.ng/vectors/set":"bSUB8","@thi.ng/vectors/sub":"fzaw7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kIwBu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dist", ()=>dist
);
parcelHelpers.export(exports, "dist2", ()=>dist2
);
parcelHelpers.export(exports, "dist3", ()=>dist3
);
parcelHelpers.export(exports, "dist4", ()=>dist4
);
var _distsqJs = require("./distsq.js");
const dist = (a, b)=>Math.sqrt(_distsqJs.distSq(a, b))
;
const dist2 = (a, b)=>Math.sqrt(_distsqJs.distSq2(a, b))
;
const dist3 = (a, b)=>Math.sqrt(_distsqJs.distSq3(a, b))
;
const dist4 = (a, b)=>Math.sqrt(_distsqJs.distSq4(a, b))
;

},{"./distsq.js":"8XCdB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9vV5N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dot", ()=>dot
);
parcelHelpers.export(exports, "dot2", ()=>dot2
);
parcelHelpers.export(exports, "dot3", ()=>dot3
);
parcelHelpers.export(exports, "dot4", ()=>dot4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
var _vopJs = require("./vop.js");
const $ = (dim)=>dot.add(dim, _emitJs.compile(dim, _templatesJs.DOT, "a,b", undefined, "", "+", "return ", ";"))
;
const dot = _vopJs.vop();
dot.default(_emitJs.compileG(_templatesJs.DOT_G, "a,b", undefined, "s", "let s=0;"));
const dot2 = $(2);
const dot3 = $(3);
const dot4 = $(4);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5JVqG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "empty", ()=>empty
);
var _implementsFunction = require("@thi.ng/checks/implements-function");
var _setnJs = require("./setn.js");
const empty = (v)=>_implementsFunction.implementsFunction(v, "empty") ? v.empty() : _setnJs.zeroes(v.length)
;

},{"@thi.ng/checks/implements-function":"cjrzK","./setn.js":"2M6y1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2M6y1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setN", ()=>setN
);
parcelHelpers.export(exports, "setN2", ()=>setN2
);
parcelHelpers.export(exports, "setN3", ()=>setN3
);
parcelHelpers.export(exports, "setN4", ()=>setN4
);
parcelHelpers.export(exports, "zero", ()=>zero
);
parcelHelpers.export(exports, "one", ()=>one
);
parcelHelpers.export(exports, "zeroes", ()=>zeroes
);
parcelHelpers.export(exports, "ones", ()=>ones
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [setN, setN2, setN3, setN4] = _emitJs.defOp(_templatesJs.SET_N, "a,n", "a", "a", 0, "");
const zero = (a)=>setN(a, 0)
;
const one = (a)=>setN(a, 1)
;
const zeroes = (n)=>new Array(n).fill(0)
;
const ones = (n)=>new Array(n).fill(1)
;

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bsMC4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "magSq", ()=>magSq
);
parcelHelpers.export(exports, "magSq2", ()=>magSq2
);
parcelHelpers.export(exports, "magSq3", ()=>magSq3
);
parcelHelpers.export(exports, "magSq4", ()=>magSq4
);
var _emitJs = require("./compile/emit.js");
var _vopJs = require("./vop.js");
const $ = (dim)=>magSq.add(dim, _emitJs.compile(dim, ([a])=>`${a}*${a}`
    , "a", "a", "", "+", "return ", ";"))
;
const magSq = _vopJs.vop();
magSq.default(_emitJs.compileG(([a])=>`sum+=${a}*${a};`
, "a", undefined, "sum", "let sum=0;"));
const magSq2 = $(2);
const magSq3 = $(3);
const magSq4 = $(4);

},{"./compile/emit.js":"hpIek","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jolPM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mixN", ()=>mixN
);
parcelHelpers.export(exports, "mixN2", ()=>mixN2
);
parcelHelpers.export(exports, "mixN3", ()=>mixN3
);
parcelHelpers.export(exports, "mixN4", ()=>mixN4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [mixN, mixN2, mixN3, mixN4] = _emitJs.defOp(_templatesJs.MIX_N, _templatesJs.ARGS_VVN);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bSUB8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "set", ()=>set
);
parcelHelpers.export(exports, "set2", ()=>set2
);
parcelHelpers.export(exports, "set3", ()=>set3
);
parcelHelpers.export(exports, "set4", ()=>set4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [set, set2, set3, set4] = _emitJs.defOp(_templatesJs.SET, "o,a", undefined, "o", 1, _templatesJs.NEW_OUT);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fzaw7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sub", ()=>sub
);
parcelHelpers.export(exports, "sub2", ()=>sub2
);
parcelHelpers.export(exports, "sub3", ()=>sub3
);
parcelHelpers.export(exports, "sub4", ()=>sub4
);
var _emitJs = require("./compile/emit.js");
const [sub, sub2, sub3, sub4] = _emitJs.defMathOp("-");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"he08U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "absDiff", ()=>absDiff
);
parcelHelpers.export(exports, "sign", ()=>sign
);
var _apiJs = require("./api.js");
const absDiff = (x, y)=>Math.abs(x - y)
;
const sign = (x, eps = _apiJs.EPS)=>x > eps ? 1 : x < -eps ? -1 : 0
;

},{"./api.js":"4a98p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1TDWA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "clamp", ()=>clamp
);
parcelHelpers.export(exports, "clamp0", ()=>clamp0
);
parcelHelpers.export(exports, "clamp01", ()=>clamp01
);
parcelHelpers.export(exports, "clamp11", ()=>clamp11
);
parcelHelpers.export(exports, "clamp05", ()=>clamp05
);
parcelHelpers.export(exports, "wrap", ()=>wrap
);
parcelHelpers.export(exports, "wrapOnce", ()=>wrapOnce
);
parcelHelpers.export(exports, "wrap01", ()=>wrap01
);
parcelHelpers.export(exports, "wrap11", ()=>wrap11
);
parcelHelpers.export(exports, "min2id", ()=>min2id
);
parcelHelpers.export(exports, "min3id", ()=>min3id
);
parcelHelpers.export(exports, "min4id", ()=>min4id
);
parcelHelpers.export(exports, "max2id", ()=>max2id
);
parcelHelpers.export(exports, "max3id", ()=>max3id
);
parcelHelpers.export(exports, "max4id", ()=>max4id
);
parcelHelpers.export(exports, "minNonZero2", ()=>minNonZero2
);
parcelHelpers.export(exports, "minNonZero3", ()=>minNonZero3
);
parcelHelpers.export(exports, "smin", ()=>smin
);
parcelHelpers.export(exports, "smax", ()=>smax
);
parcelHelpers.export(exports, "sclamp", ()=>sclamp
);
parcelHelpers.export(exports, "absMin", ()=>absMin
);
parcelHelpers.export(exports, "absMax", ()=>absMax
);
parcelHelpers.export(exports, "foldback", ()=>foldback
);
parcelHelpers.export(exports, "inRange", ()=>inRange
);
parcelHelpers.export(exports, "inOpenRange", ()=>inOpenRange
);
const clamp = (x, min, max)=>x < min ? min : x > max ? max : x
;
const clamp0 = (x)=>x > 0 ? x : 0
;
const clamp01 = (x)=>x < 0 ? 0 : x > 1 ? 1 : x
;
const clamp11 = (x)=>x < -1 ? -1 : x > 1 ? 1 : x
;
const clamp05 = (x)=>x < 0 ? 0 : x > 0.5 ? 0.5 : x
;
const wrap = (x, min, max)=>{
    if (min === max) return min;
    if (x > max) {
        const d = max - min;
        x -= d;
        if (x > max) x -= d * ((x - min) / d | 0);
    } else if (x < min) {
        const d = max - min;
        x += d;
        if (x < min) x += d * ((min - x) / d + 1 | 0);
    }
    return x;
};
const wrapOnce = (x, min, max)=>x < min ? x - min + max : x > max ? x - max + min : x
;
const wrap01 = (x)=>x < 0 ? x + 1 : x > 1 ? x - 1 : x
;
const wrap11 = (x)=>x < -1 ? x + 2 : x > 1 ? x - 2 : x
;
const min2id = (a, b)=>a <= b ? 0 : 1
;
const min3id = (a, b, c)=>a <= b ? a <= c ? 0 : 2 : b <= c ? 1 : 2
;
const min4id = (a, b, c, d)=>a <= b ? a <= c ? a <= d ? 0 : 3 : c <= d ? 2 : 3 : b <= c ? b <= d ? 1 : 3 : c <= d ? 2 : 3
;
const max2id = (a, b)=>a >= b ? 0 : 1
;
const max3id = (a, b, c)=>a >= b ? a >= c ? 0 : 2 : b >= c ? 1 : 2
;
const max4id = (a, b, c, d)=>a >= b ? a >= c ? a >= d ? 0 : 3 : c >= d ? 2 : 3 : b >= c ? b >= d ? 1 : 3 : c >= d ? 2 : 3
;
const minNonZero2 = (a, b)=>a !== 0 ? b !== 0 ? Math.min(a, b) : a : b
;
const minNonZero3 = (a, b, c)=>minNonZero2(minNonZero2(a, b), c)
;
const smin = (a, b, k)=>smax(a, b, -k)
;
const smax = (a, b, k)=>{
    const ea = Math.exp(a * k);
    const eb = Math.exp(b * k);
    return (a * ea + b * eb) / (ea + eb);
};
const sclamp = (x, min, max, k)=>smin(smax(x, min, k), max, k)
;
const absMin = (a, b)=>Math.abs(a) < Math.abs(b) ? a : b
;
const absMax = (a, b)=>Math.abs(a) > Math.abs(b) ? a : b
;
const foldback = (e, x)=>x < -e || x > e ? Math.abs(Math.abs((x - e) % (4 * e)) - 2 * e) - e : x
;
const inRange = (x, min, max)=>x >= min && x <= max
;
const inOpenRange = (x, min, max)=>x > min && x < max
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hd0jc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "corner2", ()=>corner2
);
parcelHelpers.export(exports, "clockwise2", ()=>clockwise2
);
var _abs = require("@thi.ng/math/abs");
var _api = require("@thi.ng/math/api");
var _signedAreaJs = require("./signed-area.js");
const corner2 = (a, b, c, eps = _api.EPS)=>_abs.sign(_signedAreaJs.signedArea2(a, b, c), eps)
;
const clockwise2 = (a, b, c, eps = _api.EPS)=>corner2(a, b, c, eps) < 0
;

},{"@thi.ng/math/abs":"he08U","@thi.ng/math/api":"4a98p","./signed-area.js":"2iZFe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2iZFe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "signedArea2", ()=>signedArea2
);
parcelHelpers.export(exports, "signedAreaC2", ()=>signedAreaC2
);
const signedArea2 = (a, b, c)=>{
    const ax = a[0];
    const ay = a[1];
    return (b[0] - ax) * (c[1] - ay) - (c[0] - ax) * (b[1] - ay);
};
const signedAreaC2 = (ax, ay, bx, by, cx, cy)=>(bx - ax) * (cy - ay) - (cx - ax) * (by - ay)
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"318Sg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "testBoxSphere", ()=>testBoxSphere
);
parcelHelpers.export(exports, "testRectCircle", ()=>testRectCircle
);
parcelHelpers.export(exports, "testAABBSphere", ()=>testAABBSphere
);
parcelHelpers.export(exports, "testCenteredBoxSphere", ()=>testCenteredBoxSphere
);
parcelHelpers.export(exports, "testCenteredRectCircle", ()=>testCenteredRectCircle
);
parcelHelpers.export(exports, "testCenteredAABBSphere", ()=>testCenteredAABBSphere
);
var _vop = require("@thi.ng/vectors/vop");
const testBoxSphere = _vop.vop(0);
const testRectCircle = testBoxSphere.add(2, (boxMinPos, boxSize, circlePos, r)=>axis(circlePos[0], boxMinPos[0], boxSize[0]) + axis(circlePos[1], boxMinPos[1], boxSize[1]) <= r * r
);
const testAABBSphere = testBoxSphere.add(3, (boxMinPos, boxSize, spherePos, r)=>axis(spherePos[0], boxMinPos[0], boxSize[0]) + axis(spherePos[1], boxMinPos[1], boxSize[1]) + axis(spherePos[2], boxMinPos[2], boxSize[2]) <= r * r
);
testBoxSphere.default((boxPos, boxSize, spherePos, r)=>{
    let sum = 0;
    for(let i = boxPos.length; i-- > 0;)sum += axis(spherePos[i], boxPos[i], boxSize[i]);
    return sum <= r * r;
});
const testCenteredBoxSphere = _vop.vop(0);
const testCenteredRectCircle = testCenteredBoxSphere.add(2, (boxPos, { 0: w , 1: h  }, circlePos, r)=>axis(circlePos[0], boxPos[0] - w, w * 2) + axis(circlePos[1], boxPos[1] - h, h * 2) <= r * r
);
const testCenteredAABBSphere = testCenteredBoxSphere.add(3, (boxPos, { 0: w , 1: h , 2: d  }, spherePos, r)=>axis(spherePos[0], boxPos[0] - w, w * 2) + axis(spherePos[1], boxPos[1] - h, h * 2) + axis(spherePos[2], boxPos[2] - d, d * 2) <= r * r
);
testCenteredBoxSphere.default((boxPos, boxExtent, spherePos, r)=>{
    let sum = 0;
    for(let i = boxPos.length; i-- > 0;)sum += axis(spherePos[i], boxPos[i] - boxExtent[i], boxExtent[i] * 2);
    return sum <= r * r;
});
const axis = (a, b, c)=>(a < b ? a - b : a > b + c ? a - b - c : 0) ** 2
;

},{"@thi.ng/vectors/vop":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l9qxc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Yields an infinite iterator of the inductive sequence:
 *
 * `f(x+1) = f(f(x))`
 *
 * @remarks
 * The first value emitted always is `seed` itself, then f(seed),
 * f(f(seed, i)) etc. The given function is called with the current
 * iteration counter as 2nd arg (starting w/ i=1).
 *
 * @example
 * ```ts
 * [...iterate((x) => x * 2, 1, 5)]
 * // [ 1, 2, 4, 8, 16 ]
 *
 * [...iterate((x, i) => x * 10 + i, 0, 8)]
 * // [ 0, 1, 12, 123, 1234, 12345, 123456, 1234567 ]
 * ```
 *
 * @param fn -
 * @param seed -
 * @param num -
 */ parcelHelpers.export(exports, "iterate", ()=>iterate
);
function* iterate(fn, seed, num = Infinity) {
    for(let i = 1; i <= num; i++){
        yield seed;
        seed = fn(seed, i);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jj5MK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "permutations", ()=>permutations
);
parcelHelpers.export(exports, "permutationsN", ()=>permutationsN
);
var _ensureArray = require("@thi.ng/arrays/ensure-array");
var _illegalArguments = require("@thi.ng/errors/illegal-arguments");
var _rangeJs = require("./range.js");
function* permutations(...src) {
    const n = src.length - 1;
    if (n < 0) return;
    const step = new Array(n + 1).fill(0);
    const realized = src.map(_ensureArray.ensureArrayLike);
    const total = realized.reduce((acc, x)=>acc * x.length
    , 1);
    for(let i = 0; i < total; i++){
        const tuple = [];
        for(let j = n; j >= 0; j--){
            const r = realized[j];
            let s = step[j];
            if (s === r.length) {
                step[j] = s = 0;
                j > 0 && step[j - 1]++;
            }
            tuple[j] = r[s];
        }
        step[n]++;
        yield tuple;
    }
}
const permutationsN = (n, m = n, offsets)=>{
    if (offsets && offsets.length < n) _illegalArguments.illegalArgs(`insufficient offsets, got ${offsets.length}, needed ${n}`);
    const seqs = [];
    while(n-- > 0){
        const o = offsets ? offsets[n] : 0;
        seqs[n] = _rangeJs.range(o, o + m);
    }
    return permutations.apply(null, seqs);
};

},{"@thi.ng/arrays/ensure-array":"6Tcdc","@thi.ng/errors/illegal-arguments":"co01S","./range.js":"lUHc9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"afG7n":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Iterator yielding an infinite (by default) repetition of given value
 * `x`. If `n` is given, only produces that many values.
 *
 * See also: {@link repeatedly}
 *
 * @example
 * ```ts
 * [...repeat(42, 5)]
 * // [42, 42, 42, 42, 42]
 * ```
 *
 * @param x - value to repeat
 * @param n - num values (default: ∞)
 */ parcelHelpers.export(exports, "repeat", ()=>repeat
);
function* repeat(x, n = Infinity) {
    while(n-- > 0)yield x;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9C52h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addmN", ()=>addmN
);
parcelHelpers.export(exports, "addmN2", ()=>addmN2
);
parcelHelpers.export(exports, "addmN3", ()=>addmN3
);
parcelHelpers.export(exports, "addmN4", ()=>addmN4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [addmN, addmN2, addmN3, addmN4] = _emitJs.defOp(_templatesJs.MATH2_N("+", "*"), _templatesJs.ARGS_VVN);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8NYtQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "madd", ()=>madd
);
parcelHelpers.export(exports, "madd2", ()=>madd2
);
parcelHelpers.export(exports, "madd3", ()=>madd3
);
parcelHelpers.export(exports, "madd4", ()=>madd4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [madd, madd2, madd3, madd4] = _emitJs.defOp(_templatesJs.MATH2("*", "+"), _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1TKlE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mulN", ()=>mulN
);
parcelHelpers.export(exports, "mulN2", ()=>mulN2
);
parcelHelpers.export(exports, "mulN3", ()=>mulN3
);
parcelHelpers.export(exports, "mulN4", ()=>mulN4
);
var _emitJs = require("./compile/emit.js");
const [mulN, mulN2, mulN3, mulN4] = _emitJs.defMathOpN("*");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aIPIo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "submN", ()=>submN
);
parcelHelpers.export(exports, "submN2", ()=>submN2
);
parcelHelpers.export(exports, "submN3", ()=>submN3
);
parcelHelpers.export(exports, "submN4", ()=>submN4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [submN, submN2, submN3, submN4] = _emitJs.defOp(_templatesJs.MATH2_N("-", "*"), _templatesJs.ARGS_VVN);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6tjbR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NdQuadtreeSet", ()=>NdQuadtreeSet
);
var _api = require("@thi.ng/math/api");
var _addmn = require("@thi.ng/vectors/addmn");
var _submn = require("@thi.ng/vectors/submn");
var _ndQuadtreeMapJs = require("./nd-quadtree-map.js");
class NdQuadtreeSet {
    constructor(pos, ext, keys){
        this.tree = new _ndQuadtreeMapJs.NdQuadtreeMap(pos, ext);
        this._size = 0;
        keys && this.into(keys);
    }
    /**
     * Returns a new point-based `NdQuadtreeSet` for nD keys in given
     * region defined by `min` / `max` coordinates. The dimensionality
     * of the tree is implicitly defined by the provided coordinates.
     * Only points within that region can be indexed.
     *
     * @remarks
     * Due to exponentially growing lookup tables, currently only
     * supports up to 16 dimensions.
     */ static fromMinMax(min, max) {
        return new NdQuadtreeSet(_addmn.addmN([], min, max, 0.5), _submn.submN([], max, min, 0.5));
    }
    [Symbol.iterator]() {
        return this.tree.keys();
    }
    keys() {
        return this.tree.keys();
    }
    values() {
        return this.tree.values();
    }
    get size() {
        return this._size;
    }
    copy() {
        return new NdQuadtreeSet(this.tree.root.pos, this.tree.root.ext, this);
    }
    clear() {
        this.tree.clear();
    }
    empty() {
        return new NdQuadtreeSet(this.tree.root.pos, this.tree.root.ext);
    }
    add(key, eps = _api.EPS) {
        return this.tree.set(key, key, eps);
    }
    into(keys, eps = _api.EPS) {
        let ok = true;
        const tree = this.tree;
        for (let k of keys)ok = tree.set(k, k, eps) && ok;
        return ok;
    }
    remove(key) {
        return this.tree.remove(key);
    }
    has(key, eps = _api.EPS) {
        return this.tree.has(key, eps);
    }
    get(key, eps) {
        return this.tree.get(key, eps);
    }
    query(q, maxDist, limit, acc) {
        return this.tree.query(q, maxDist, limit, acc);
    }
    queryKeys(q, maxDist, limit, acc) {
        return this.tree.queryKeys(q, maxDist, limit, acc);
    }
    queryValues(q, maxDist, limit, acc) {
        return this.tree.queryKeys(q, maxDist, limit, acc);
    }
}

},{"@thi.ng/math/api":"4a98p","@thi.ng/vectors/addmn":"9C52h","@thi.ng/vectors/submn":"aIPIo","./nd-quadtree-map.js":"5mrju","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b6jlb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SpatialGrid2", ()=>SpatialGrid2
);
var _isNumber = require("@thi.ng/checks/is-number");
var _heap = require("@thi.ng/heaps/heap");
var _interval = require("@thi.ng/math/interval");
var _addn = require("@thi.ng/vectors/addn");
var _distsq = require("@thi.ng/vectors/distsq");
var _subn = require("@thi.ng/vectors/subn");
var _aspatialGridJs = require("./aspatial-grid.js");
var _utilsJs = require("./utils.js");
const TMP = [];
class SpatialGrid2 extends _aspatialGridJs.ASpatialGrid {
    constructor(min, size, res){
        super(min, size, _isNumber.isNumber(res) ? [
            res,
            res
        ] : res);
        this._cells = new Array(this._res[0] * this._res[1]);
    }
    copy() {
        return super.copy();
    }
    empty() {
        return new SpatialGrid2(this._min, this._size, this._res);
    }
    doQuery(fn, k, r, limit = Infinity, acc = []) {
        const id1 = this.findIndex(_subn.subN2(TMP, k, r));
        const id2 = this.findIndex(_addn.addN2(TMP, k, r));
        const stride = this._res[0];
        const x1 = id1 % stride;
        const x2 = id2 % stride;
        const y1 = (id1 / stride | 0) * stride;
        const y2 = (id2 / stride | 0) * stride;
        const cells = this._cells;
        let c;
        let x, y;
        r *= r;
        const heap = new _heap.Heap([
            [
                r
            ]
        ], {
            compare: _utilsJs.CMP
        });
        const sel = heap.values;
        for(y = y1; y <= y2; y += stride)for(x = x1; x <= x2; x++){
            c = cells[y + x];
            c && c.length && this.queryCell(_distsq.distSq2, heap, c, k, limit);
        }
        return _utilsJs.addResults(fn, sel, acc);
    }
    findIndex(k) {
        const { _min: min , _res1: res1 , _invSize: invSize  } = this;
        const kx = _interval.clamp((k[0] - min[0]) * invSize[0], 0, res1[0]);
        const ky = _interval.clamp((k[1] - min[1]) * invSize[1], 0, res1[1]);
        return (kx | 0) + (ky | 0) * this._res[0];
    }
}

},{"@thi.ng/checks/is-number":"hNf8P","@thi.ng/heaps/heap":"18spH","@thi.ng/math/interval":"1TDWA","@thi.ng/vectors/addn":"cecib","@thi.ng/vectors/distsq":"8XCdB","@thi.ng/vectors/subn":"i3npD","./aspatial-grid.js":"hVTuS","./utils.js":"9RX5K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hNf8P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isNumber", ()=>isNumber
);
const isNumber = (x)=>typeof x === "number"
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cecib":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addN", ()=>addN
);
parcelHelpers.export(exports, "addN2", ()=>addN2
);
parcelHelpers.export(exports, "addN3", ()=>addN3
);
parcelHelpers.export(exports, "addN4", ()=>addN4
);
var _emitJs = require("./compile/emit.js");
const [addN, addN2, addN3, addN4] = _emitJs.defMathOpN("+");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i3npD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subN", ()=>subN
);
parcelHelpers.export(exports, "subN2", ()=>subN2
);
parcelHelpers.export(exports, "subN3", ()=>subN3
);
parcelHelpers.export(exports, "subN4", ()=>subN4
);
var _emitJs = require("./compile/emit.js");
const [subN, subN2, subN3, subN4] = _emitJs.defMathOpN("-");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hVTuS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Common base class for {@link SpatialGrid2} and {@link SpatialGrid3}.
 *
 * @internal
 */ parcelHelpers.export(exports, "ASpatialGrid", ()=>ASpatialGrid
);
var _api = require("@thi.ng/math/api");
var _map = require("@thi.ng/transducers/map");
var _div = require("@thi.ng/vectors/div");
var _equals = require("@thi.ng/vectors/equals");
var _floor = require("@thi.ng/vectors/floor");
var _subn = require("@thi.ng/vectors/subn");
var _utilsJs = require("./utils.js");
class ASpatialGrid {
    constructor(_min, _size, _res){
        this._min = _min;
        this._size = _size;
        this._res = _res;
        _floor.floor(null, this._res);
        this._res1 = _subn.subN([], this._res, 1);
        this._invSize = _div.div([], this._res, _size);
        this._num = 0;
    }
    get size() {
        return this._num;
    }
    *[Symbol.iterator]() {
        const cells = this._cells;
        for(let i = cells.length; i-- > 0;)if (cells[i]) yield* cells[i];
    }
    keys() {
        return _map.map((p)=>p[0]
        , this);
    }
    values() {
        return _map.map((p)=>p[1]
        , this);
    }
    copy() {
        const copy = this.empty();
        copy._num = this._num;
        const src = this._cells;
        const dest = copy._cells;
        for(let i = src.length; i-- > 0;)dest[i] = src[i] ? src[i].slice() : null;
        return copy;
    }
    clear() {
        this._cells.fill(null);
        this._num = 0;
    }
    has(k, eps = _api.EPS) {
        return !!this.find(k, eps);
    }
    get(k, eps = _api.EPS) {
        const pair = this.find(k, eps);
        return pair ? pair[1] : undefined;
    }
    set(k, v, eps = _api.EPS) {
        if (eps >= 0 && this.query(k, eps, 1).length) return false;
        const id = this.findIndex(k);
        const cell = this._cells[id];
        if (!cell) this._cells[id] = [
            [
                k,
                v
            ]
        ];
        else cell.push([
            k,
            v
        ]);
        this._num++;
        return true;
    }
    into(pairs, eps = _api.EPS) {
        return _utilsJs.into(this, pairs, eps);
    }
    remove(k) {
        const id = this.findIndex(k);
        const cell = this._cells[id];
        if (!cell) return false;
        for(let i = cell.length; i-- > 0;)if (_equals.equals(cell[i][0], k)) {
            cell.splice(i, 1);
            this._num--;
            return true;
        }
        return false;
    }
    query(q, radius, limit, acc) {
        return this.doQuery((p)=>p
        , q, radius, limit, acc);
    }
    queryKeys(q, radius, limit, acc) {
        return this.doQuery((p)=>p[0]
        , q, radius, limit, acc);
    }
    queryValues(q, radius, limit, acc) {
        return this.doQuery((p)=>p[1]
        , q, radius, limit, acc);
    }
    queryCell(dist, heap, c, k, limit) {
        for(let i = c.length; i-- > 0;){
            const d = dist(c[i][0], k);
            if (d <= heap.values[0][0]) heap.length >= limit ? heap.pushPop([
                d,
                c[i]
            ]) : heap.push([
                d,
                c[i]
            ]);
        }
    }
    find(k, eps) {
        if (eps > 0) {
            const res = this.query(k, _api.EPS, 1);
            return res.length ? res[0] : undefined;
        }
        const cell = this._cells[this.findIndex(k)];
        if (cell) for(let i = cell.length; i-- > 0;){
            if (_equals.equals(cell[i][0], k)) return cell[i];
        }
    }
}

},{"@thi.ng/math/api":"4a98p","@thi.ng/transducers/map":"fW6Xn","@thi.ng/vectors/div":"5inb4","@thi.ng/vectors/equals":"kCRCM","@thi.ng/vectors/floor":"8Bam4","@thi.ng/vectors/subn":"i3npD","./utils.js":"9RX5K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5inb4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "div", ()=>div
);
parcelHelpers.export(exports, "div2", ()=>div2
);
parcelHelpers.export(exports, "div3", ()=>div3
);
parcelHelpers.export(exports, "div4", ()=>div4
);
var _emitJs = require("./compile/emit.js");
const [div, div2, div3, div4] = _emitJs.defMathOp("/");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kCRCM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "equals2", ()=>equals2
);
parcelHelpers.export(exports, "equals3", ()=>equals3
);
parcelHelpers.export(exports, "equals4", ()=>equals4
);
var _equiv = require("@thi.ng/equiv");
var _vopJs = require("./vop.js");
const equals = _vopJs.vop(0);
const equals2 = equals.add(2, (a, b)=>a[0] === b[0] && a[1] === b[1]
);
const equals3 = equals.add(3, (a, b)=>a[0] === b[0] && a[1] === b[1] && a[2] === b[2]
);
const equals4 = equals.add(4, (a, b)=>a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3]
);
equals.default(_equiv.equivArrayLike);

},{"@thi.ng/equiv":"e2rLA","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Bam4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "floor", ()=>floor
);
parcelHelpers.export(exports, "floor2", ()=>floor2
);
parcelHelpers.export(exports, "floor3", ()=>floor3
);
parcelHelpers.export(exports, "floor4", ()=>floor4
);
var _emitJs = require("./compile/emit.js");
const [floor, floor2, floor3, floor4] = _emitJs.defFnOp("Math.floor");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"epsDv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SpatialGrid3", ()=>SpatialGrid3
);
var _isNumber = require("@thi.ng/checks/is-number");
var _heap = require("@thi.ng/heaps/heap");
var _interval = require("@thi.ng/math/interval");
var _addn = require("@thi.ng/vectors/addn");
var _distsq = require("@thi.ng/vectors/distsq");
var _subn = require("@thi.ng/vectors/subn");
var _aspatialGridJs = require("./aspatial-grid.js");
var _utilsJs = require("./utils.js");
const TMP = [];
class SpatialGrid3 extends _aspatialGridJs.ASpatialGrid {
    constructor(min, size, res){
        super(min, size, _isNumber.isNumber(res) ? [
            res,
            res,
            res
        ] : res);
        this._cells = new Array(this._res[0] * this._res[1] * this._res[2]);
        this._stride = [
            this._res[0],
            this._res[0] * this._res[1]
        ];
    }
    copy() {
        return super.copy();
    }
    empty() {
        return new SpatialGrid3(this._min, this._size, this._res);
    }
    doQuery(fn, k, r, limit = Infinity, acc = []) {
        const id1 = this.findIndex(_subn.subN3(TMP, k, r));
        const id2 = this.findIndex(_addn.addN3(TMP, k, r));
        const [width, slice] = this._stride;
        const x1 = id1 % width;
        const x2 = id2 % width;
        const y1 = (id1 / width | 0) * width;
        const y2 = (id2 / width | 0) * width;
        const z1 = (id1 / slice | 0) * slice;
        const z2 = (id2 / slice | 0) * slice;
        const cells = this._cells;
        let c;
        let x, y, z;
        r *= r;
        const heap = new _heap.Heap([
            [
                r
            ]
        ], {
            compare: _utilsJs.CMP
        });
        const sel = heap.values;
        for(z = z1; z <= z2; z += slice){
            for(y = y1; y <= y2; y += width)for(x = x1; x <= x2; x++){
                c = cells[z + y + x];
                c && c.length && this.queryCell(_distsq.distSq3, heap, c, k, limit);
            }
        }
        return _utilsJs.addResults(fn, sel, acc);
    }
    findIndex(k) {
        const { _min: min , _res1: res1 , _invSize: invSize  } = this;
        const kx = _interval.clamp((k[0] - min[0]) * invSize[0], 0, res1[0]);
        const ky = _interval.clamp((k[1] - min[1]) * invSize[1], 0, res1[1]);
        const kz = _interval.clamp((k[2] - min[2]) * invSize[2], 0, res1[2]);
        return (kx | 0) + (ky | 0) * this._stride[0] + (kz | 0) * this._stride[1];
    }
}

},{"@thi.ng/checks/is-number":"hNf8P","@thi.ng/heaps/heap":"18spH","@thi.ng/math/interval":"1TDWA","@thi.ng/vectors/addn":"cecib","@thi.ng/vectors/distsq":"8XCdB","@thi.ng/vectors/subn":"i3npD","./aspatial-grid.js":"hVTuS","./utils.js":"9RX5K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hTYUR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _apiJs = require("./api.js");
parcelHelpers.exportAll(_apiJs, exports);
var _poissonJs = require("./poisson.js");
parcelHelpers.exportAll(_poissonJs, exports);
var _stratifiedJs = require("./stratified.js");
parcelHelpers.exportAll(_stratifiedJs, exports);

},{"./api.js":"5xKqf","./poisson.js":"7FWpL","./stratified.js":"lBUk4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5xKqf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7FWpL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "samplePoisson", ()=>samplePoisson
);
var _isNumber = require("@thi.ng/checks/is-number");
var _system = require("@thi.ng/random/system");
var _jitter = require("@thi.ng/vectors/jitter");
const samplePoisson = (_opts)=>{
    const opts = {
        rnd: _system.SYSTEM,
        iter: 1,
        jitter: 1,
        quality: 500,
        ..._opts
    };
    const { points , index , rnd , jitter , quality , density: _d  } = opts;
    const density = _isNumber.isNumber(_d) ? ()=>_d
     : _d;
    const iter = Math.max(opts.iter, 1);
    const samples = [];
    let failed = 0;
    let pos;
    let d;
    let i;
    outer: for(let num = opts.max; num > 0;){
        pos = points(rnd);
        d = density(pos);
        i = iter;
        while(i-- > 0){
            if (!index.has(pos, d)) {
                index.add(pos, 0);
                samples.push(pos);
                failed = 0;
                num--;
                continue outer;
            }
            _jitter.jitter(null, pos, jitter, rnd);
        }
        if (++failed > quality) break;
    }
    return samples;
};

},{"@thi.ng/checks/is-number":"hNf8P","@thi.ng/random/system":"bSLzr","@thi.ng/vectors/jitter":"aBPSB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bSLzr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A `Math.random()` based {@link IRandom} implementation. Also @see
 * {@link SYSTEM}.
 */ parcelHelpers.export(exports, "SystemRandom", ()=>SystemRandom
);
parcelHelpers.export(exports, "SYSTEM", ()=>SYSTEM
);
var _arandomJs = require("./arandom.js");
const random = Math.random;
class SystemRandom extends _arandomJs.ARandom {
    int() {
        return random() * 4294967296 >>> 0;
    }
    float(norm = 1) {
        return random() * norm;
    }
    norm(norm = 1) {
        return (random() - 0.5) * 2 * norm;
    }
}
const SYSTEM = new SystemRandom();

},{"./arandom.js":"hEnTe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hEnTe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ARandom", ()=>ARandom
);
const INV_MAX = 1 / 2 ** 32;
class ARandom {
    float(norm = 1) {
        return this.int() * INV_MAX * norm;
    }
    norm(norm = 1) {
        return (this.int() * INV_MAX - 0.5) * 2 * norm;
    }
    minmax(min, max) {
        return this.float() * (max - min) + min;
    }
    minmaxInt(min, max) {
        min |= 0;
        max |= 0;
        return min + (this.float() * (max - min) | 0);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aBPSB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "jitter", ()=>jitter
);
var _system = require("@thi.ng/random/system");
var _addJs = require("./add.js");
var _randomJs = require("./random.js");
const jitter = (out, a, n = 1, rnd = _system.SYSTEM)=>_addJs.add(out, a, _randomJs.randNorm(new Array(a.length), n, rnd))
;

},{"@thi.ng/random/system":"bSLzr","./add.js":"6HmvS","./random.js":"8bjGw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6HmvS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "add", ()=>add
);
parcelHelpers.export(exports, "add2", ()=>add2
);
parcelHelpers.export(exports, "add3", ()=>add3
);
parcelHelpers.export(exports, "add4", ()=>add4
);
var _emitJs = require("./compile/emit.js");
const [add, add2, add3, add4] = _emitJs.defMathOp("+");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8bjGw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "random", ()=>random
);
parcelHelpers.export(exports, "random2", ()=>random2
);
parcelHelpers.export(exports, "random3", ()=>random3
);
parcelHelpers.export(exports, "random4", ()=>random4
);
parcelHelpers.export(exports, "randomDistrib", ()=>randomDistrib
);
parcelHelpers.export(exports, "randomDistrib2", ()=>randomDistrib2
);
parcelHelpers.export(exports, "randomDistrib3", ()=>randomDistrib3
);
parcelHelpers.export(exports, "randomDistrib4", ()=>randomDistrib4
);
parcelHelpers.export(exports, "randNorm", ()=>randNorm
);
parcelHelpers.export(exports, "randNorm2", ()=>randNorm2
);
parcelHelpers.export(exports, "randNorm3", ()=>randNorm3
);
parcelHelpers.export(exports, "randNorm4", ()=>randNorm4
);
parcelHelpers.export(exports, "randNormDistrib", ()=>randNormDistrib
);
parcelHelpers.export(exports, "randNormDistrib2", ()=>randNormDistrib2
);
parcelHelpers.export(exports, "randNormDistrib3", ()=>randNormDistrib3
);
parcelHelpers.export(exports, "randNormDistrib4", ()=>randNormDistrib4
);
parcelHelpers.export(exports, "randMinMax", ()=>randMinMax
);
parcelHelpers.export(exports, "randMinMax2", ()=>randMinMax2
);
parcelHelpers.export(exports, "randMinMax3", ()=>randMinMax3
);
parcelHelpers.export(exports, "randMinMax4", ()=>randMinMax4
);
var _normal = require("@thi.ng/random/distributions/normal");
var _system = require("@thi.ng/random/system");
var _emitJs = require("./compile/emit.js");
var _indexJs = require("./index.js");
var _normalizeJs = require("./normalize.js");
const [random, random2, random3, random4] = _emitJs.defHofOp(_system.SYSTEM, ([a])=>`${a}=rnd.minmax(n,m);`
, "a,n=-1,m=1,rnd=op", "a", "a", 0, _indexJs.NEW_OUT_A);
const [randomDistrib, randomDistrib2, randomDistrib3, randomDistrib4] = _emitJs.defHofOp(_normal.normal, ([a])=>`${a}=rnd()*n;`
, "a,rnd=op(),n=1", "a", "a", 0, _indexJs.NEW_OUT_A);
const $norm = (random1)=>(v, n = 1, rnd = _system.SYSTEM)=>_normalizeJs.normalize(null, random1(v, -1, 1, rnd), n)
;
const $normDist = (random5)=>(v, rnd, n = 1)=>_normalizeJs.normalize(null, random5(v, rnd), n)
;
const randNorm = $norm(random);
const randNorm2 = $norm(random2);
const randNorm3 = $norm(random3);
const randNorm4 = $norm(random4);
const randNormDistrib = $normDist(randomDistrib);
const randNormDistrib2 = $normDist(randomDistrib2);
const randNormDistrib3 = $normDist(randomDistrib3);
const randNormDistrib4 = $normDist(randomDistrib4);
const [randMinMax, randMinMax2, randMinMax3, randMinMax4] = _emitJs.defHofOp(_system.SYSTEM, ([o, a, b])=>`${o}=rnd.minmax(${a},${b});`
, "o,a,b,rnd=op", "o,a,b");

},{"@thi.ng/random/distributions/normal":"eJF5A","@thi.ng/random/system":"bSLzr","./compile/emit.js":"hpIek","./index.js":"gLU21","./normalize.js":"9ex3j","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eJF5A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "normal", ()=>normal
);
var _systemJs = require("../system.js");
const normal = (rnd = _systemJs.SYSTEM, bias = 0, sigma = 1)=>{
    let a;
    let b;
    let r;
    return ()=>{
        if (a != null) {
            b = a;
            a = null;
        } else do {
            a = rnd.norm();
            b = rnd.norm();
            r = a * a + b * b;
        }while (r > 1 || r === 0)
        return bias + sigma * b * Math.sqrt(-2 * Math.log(r) / r);
    };
};

},{"../system.js":"bSLzr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gLU21":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _apiJs = require("./api.js");
parcelHelpers.exportAll(_apiJs, exports);
var _iteratorJs = require("./iterator.js");
parcelHelpers.exportAll(_iteratorJs, exports);
var _accessorsJs = require("./compile/accessors.js");
parcelHelpers.exportAll(_accessorsJs, exports);
var _emitJs = require("./compile/emit.js");
parcelHelpers.exportAll(_emitJs, exports);
var _templatesJs = require("./compile/templates.js");
parcelHelpers.exportAll(_templatesJs, exports);
var _avecJs = require("./avec.js");
parcelHelpers.exportAll(_avecJs, exports);
var _vec2Js = require("./vec2.js");
parcelHelpers.exportAll(_vec2Js, exports);
var _vec3Js = require("./vec3.js");
parcelHelpers.exportAll(_vec3Js, exports);
var _vec4Js = require("./vec4.js");
parcelHelpers.exportAll(_vec4Js, exports);
var _vopJs = require("./vop.js");
parcelHelpers.exportAll(_vopJs, exports);
var _absJs = require("./abs.js");
parcelHelpers.exportAll(_absJs, exports);
var _acosJs = require("./acos.js");
parcelHelpers.exportAll(_acosJs, exports);
var _addwJs = require("./addw.js");
parcelHelpers.exportAll(_addwJs, exports);
var _addJs = require("./add.js");
parcelHelpers.exportAll(_addJs, exports);
var _addiJs = require("./addi.js");
parcelHelpers.exportAll(_addiJs, exports);
var _addmJs = require("./addm.js");
parcelHelpers.exportAll(_addmJs, exports);
var _addmnJs = require("./addmn.js");
parcelHelpers.exportAll(_addmnJs, exports);
var _addmsJs = require("./addms.js");
parcelHelpers.exportAll(_addmsJs, exports);
var _addmnsJs = require("./addmns.js");
parcelHelpers.exportAll(_addmnsJs, exports);
var _addnJs = require("./addn.js");
parcelHelpers.exportAll(_addnJs, exports);
var _addsJs = require("./adds.js");
parcelHelpers.exportAll(_addsJs, exports);
var _addnsJs = require("./addns.js");
parcelHelpers.exportAll(_addnsJs, exports);
var _angleBetweenJs = require("./angle-between.js");
parcelHelpers.exportAll(_angleBetweenJs, exports);
var _asinJs = require("./asin.js");
parcelHelpers.exportAll(_asinJs, exports);
var _atanJs = require("./atan.js");
parcelHelpers.exportAll(_atanJs, exports);
var _bisectJs = require("./bisect.js");
parcelHelpers.exportAll(_bisectJs, exports);
var _bitAndJs = require("./bit-and.js");
parcelHelpers.exportAll(_bitAndJs, exports);
var _bitNotJs = require("./bit-not.js");
parcelHelpers.exportAll(_bitNotJs, exports);
var _bitOrJs = require("./bit-or.js");
parcelHelpers.exportAll(_bitOrJs, exports);
var _bitXorJs = require("./bit-xor.js");
parcelHelpers.exportAll(_bitXorJs, exports);
var _bufferJs = require("./buffer.js");
parcelHelpers.exportAll(_bufferJs, exports);
var _cartesianJs = require("./cartesian.js");
parcelHelpers.exportAll(_cartesianJs, exports);
var _ceilJs = require("./ceil.js");
parcelHelpers.exportAll(_ceilJs, exports);
var _centerJs = require("./center.js");
parcelHelpers.exportAll(_centerJs, exports);
var _clampJs = require("./clamp.js");
parcelHelpers.exportAll(_clampJs, exports);
var _clampnJs = require("./clampn.js");
parcelHelpers.exportAll(_clampnJs, exports);
var _clockwiseJs = require("./clockwise.js");
parcelHelpers.exportAll(_clockwiseJs, exports);
var _compareJs = require("./compare.js");
parcelHelpers.exportAll(_compareJs, exports);
var _convertJs = require("./convert.js");
parcelHelpers.exportAll(_convertJs, exports);
var _copyJs = require("./copy.js");
parcelHelpers.exportAll(_copyJs, exports);
var _correlationJs = require("./correlation.js");
parcelHelpers.exportAll(_correlationJs, exports);
var _cosJs = require("./cos.js");
parcelHelpers.exportAll(_cosJs, exports);
var _coshJs = require("./cosh.js");
parcelHelpers.exportAll(_coshJs, exports);
var _covarianceJs = require("./covariance.js");
parcelHelpers.exportAll(_covarianceJs, exports);
var _crossJs = require("./cross.js");
parcelHelpers.exportAll(_crossJs, exports);
var _crosssJs = require("./crosss.js");
parcelHelpers.exportAll(_crosssJs, exports);
var _degreesJs = require("./degrees.js");
parcelHelpers.exportAll(_degreesJs, exports);
var _directionJs = require("./direction.js");
parcelHelpers.exportAll(_directionJs, exports);
var _distJs = require("./dist.js");
parcelHelpers.exportAll(_distJs, exports);
var _distBraycurtisJs = require("./dist-braycurtis.js");
parcelHelpers.exportAll(_distBraycurtisJs, exports);
var _distCanberraJs = require("./dist-canberra.js");
parcelHelpers.exportAll(_distCanberraJs, exports);
var _distChebyshevJs = require("./dist-chebyshev.js");
parcelHelpers.exportAll(_distChebyshevJs, exports);
var _distHammingJs = require("./dist-hamming.js");
parcelHelpers.exportAll(_distHammingJs, exports);
var _distHaversineJs = require("./dist-haversine.js");
parcelHelpers.exportAll(_distHaversineJs, exports);
var _distJaccardJs = require("./dist-jaccard.js");
parcelHelpers.exportAll(_distJaccardJs, exports);
var _distManhattanJs = require("./dist-manhattan.js");
parcelHelpers.exportAll(_distManhattanJs, exports);
var _distMinkowskiJs = require("./dist-minkowski.js");
parcelHelpers.exportAll(_distMinkowskiJs, exports);
var _distSorensendiceJs = require("./dist-sorensendice.js");
parcelHelpers.exportAll(_distSorensendiceJs, exports);
var _distWeightedJs = require("./dist-weighted.js");
parcelHelpers.exportAll(_distWeightedJs, exports);
var _distsqJs = require("./distsq.js");
parcelHelpers.exportAll(_distsqJs, exports);
var _divJs = require("./div.js");
parcelHelpers.exportAll(_divJs, exports);
var _diviJs = require("./divi.js");
parcelHelpers.exportAll(_diviJs, exports);
var _divnJs = require("./divn.js");
parcelHelpers.exportAll(_divnJs, exports);
var _divsJs = require("./divs.js");
parcelHelpers.exportAll(_divsJs, exports);
var _divnsJs = require("./divns.js");
parcelHelpers.exportAll(_divnsJs, exports);
var _dotJs = require("./dot.js");
parcelHelpers.exportAll(_dotJs, exports);
var _dotcJs = require("./dotc.js");
parcelHelpers.exportAll(_dotcJs, exports);
var _dotsJs = require("./dots.js");
parcelHelpers.exportAll(_dotsJs, exports);
var _emptyJs = require("./empty.js");
parcelHelpers.exportAll(_emptyJs, exports);
var _eqdeltaJs = require("./eqdelta.js");
parcelHelpers.exportAll(_eqdeltaJs, exports);
var _equalsJs = require("./equals.js");
parcelHelpers.exportAll(_equalsJs, exports);
var _everyJs = require("./every.js");
parcelHelpers.exportAll(_everyJs, exports);
var _expJs = require("./exp.js");
parcelHelpers.exportAll(_expJs, exports);
var _exp2Js = require("./exp_2.js");
parcelHelpers.exportAll(_exp2Js, exports);
var _faceForwardJs = require("./face-forward.js");
parcelHelpers.exportAll(_faceForwardJs, exports);
var _fillJs = require("./fill.js");
parcelHelpers.exportAll(_fillJs, exports);
var _fitJs = require("./fit.js");
parcelHelpers.exportAll(_fitJs, exports);
var _floorJs = require("./floor.js");
parcelHelpers.exportAll(_floorJs, exports);
var _fmodJs = require("./fmod.js");
parcelHelpers.exportAll(_fmodJs, exports);
var _fmodnJs = require("./fmodn.js");
parcelHelpers.exportAll(_fmodnJs, exports);
var _fractJs = require("./fract.js");
parcelHelpers.exportAll(_fractJs, exports);
var _gvecJs = require("./gvec.js");
parcelHelpers.exportAll(_gvecJs, exports);
var _hashJs = require("./hash.js");
parcelHelpers.exportAll(_hashJs, exports);
var _headingJs = require("./heading.js");
parcelHelpers.exportAll(_headingJs, exports);
var _headingSegmentJs = require("./heading-segment.js");
parcelHelpers.exportAll(_headingSegmentJs, exports);
var _homogeneousJs = require("./homogeneous.js");
parcelHelpers.exportAll(_homogeneousJs, exports);
var _invertJs = require("./invert.js");
parcelHelpers.exportAll(_invertJs, exports);
var _invsqrtJs = require("./invsqrt.js");
parcelHelpers.exportAll(_invsqrtJs, exports);
var _isInfJs = require("./is-inf.js");
parcelHelpers.exportAll(_isInfJs, exports);
var _isNanJs = require("./is-nan.js");
parcelHelpers.exportAll(_isNanJs, exports);
var _jitterJs = require("./jitter.js");
parcelHelpers.exportAll(_jitterJs, exports);
var _limitJs = require("./limit.js");
parcelHelpers.exportAll(_limitJs, exports);
var _logJs = require("./log.js");
parcelHelpers.exportAll(_logJs, exports);
var _log2Js = require("./log_2.js");
parcelHelpers.exportAll(_log2Js, exports);
var _logicAndJs = require("./logic-and.js");
parcelHelpers.exportAll(_logicAndJs, exports);
var _logicNotJs = require("./logic-not.js");
parcelHelpers.exportAll(_logicNotJs, exports);
var _logicOrJs = require("./logic-or.js");
parcelHelpers.exportAll(_logicOrJs, exports);
var _lshiftJs = require("./lshift.js");
parcelHelpers.exportAll(_lshiftJs, exports);
var _maddJs = require("./madd.js");
parcelHelpers.exportAll(_maddJs, exports);
var _maddnJs = require("./maddn.js");
parcelHelpers.exportAll(_maddnJs, exports);
var _maddsJs = require("./madds.js");
parcelHelpers.exportAll(_maddsJs, exports);
var _maddnsJs = require("./maddns.js");
parcelHelpers.exportAll(_maddnsJs, exports);
var _magJs = require("./mag.js");
parcelHelpers.exportAll(_magJs, exports);
var _magsJs = require("./mags.js");
parcelHelpers.exportAll(_magsJs, exports);
var _magsqJs = require("./magsq.js");
parcelHelpers.exportAll(_magsqJs, exports);
var _magsqsJs = require("./magsqs.js");
parcelHelpers.exportAll(_magsqsJs, exports);
var _majorJs = require("./major.js");
parcelHelpers.exportAll(_majorJs, exports);
var _mapJs = require("./map.js");
parcelHelpers.exportAll(_mapJs, exports);
var _mapVectorsJs = require("./map-vectors.js");
parcelHelpers.exportAll(_mapVectorsJs, exports);
var _maxJs = require("./max.js");
parcelHelpers.exportAll(_maxJs, exports);
var _maxBoundsJs = require("./max-bounds.js");
parcelHelpers.exportAll(_maxBoundsJs, exports);
var _meanJs = require("./mean.js");
parcelHelpers.exportAll(_meanJs, exports);
var _medianJs = require("./median.js");
parcelHelpers.exportAll(_medianJs, exports);
var _minJs = require("./min.js");
parcelHelpers.exportAll(_minJs, exports);
var _minBoundsJs = require("./min-bounds.js");
parcelHelpers.exportAll(_minBoundsJs, exports);
var _minorJs = require("./minor.js");
parcelHelpers.exportAll(_minorJs, exports);
var _mixBilinearJs = require("./mix-bilinear.js");
parcelHelpers.exportAll(_mixBilinearJs, exports);
var _mixCubicJs = require("./mix-cubic.js");
parcelHelpers.exportAll(_mixCubicJs, exports);
var _mixHermiteJs = require("./mix-hermite.js");
parcelHelpers.exportAll(_mixHermiteJs, exports);
var _mixQuadraticJs = require("./mix-quadratic.js");
parcelHelpers.exportAll(_mixQuadraticJs, exports);
var _mixJs = require("./mix.js");
parcelHelpers.exportAll(_mixJs, exports);
var _mixnJs = require("./mixn.js");
parcelHelpers.exportAll(_mixnJs, exports);
var _mixsJs = require("./mixs.js");
parcelHelpers.exportAll(_mixsJs, exports);
var _mixnsJs = require("./mixns.js");
parcelHelpers.exportAll(_mixnsJs, exports);
var _modJs = require("./mod.js");
parcelHelpers.exportAll(_modJs, exports);
var _modnJs = require("./modn.js");
parcelHelpers.exportAll(_modnJs, exports);
var _msubJs = require("./msub.js");
parcelHelpers.exportAll(_msubJs, exports);
var _msubnJs = require("./msubn.js");
parcelHelpers.exportAll(_msubnJs, exports);
var _msubsJs = require("./msubs.js");
parcelHelpers.exportAll(_msubsJs, exports);
var _msubnsJs = require("./msubns.js");
parcelHelpers.exportAll(_msubnsJs, exports);
var _mulJs = require("./mul.js");
parcelHelpers.exportAll(_mulJs, exports);
var _muliJs = require("./muli.js");
parcelHelpers.exportAll(_muliJs, exports);
var _mulnJs = require("./muln.js");
parcelHelpers.exportAll(_mulnJs, exports);
var _mulsJs = require("./muls.js");
parcelHelpers.exportAll(_mulsJs, exports);
var _mulnsJs = require("./mulns.js");
parcelHelpers.exportAll(_mulnsJs, exports);
var _negJs = require("./neg.js");
parcelHelpers.exportAll(_negJs, exports);
var _normalJs = require("./normal.js");
parcelHelpers.exportAll(_normalJs, exports);
var _normalizeJs = require("./normalize.js");
parcelHelpers.exportAll(_normalizeJs, exports);
var _normalizesJs = require("./normalizes.js");
parcelHelpers.exportAll(_normalizesJs, exports);
var _notJs = require("./not.js");
parcelHelpers.exportAll(_notJs, exports);
var _orthoNormalJs = require("./ortho-normal.js");
parcelHelpers.exportAll(_orthoNormalJs, exports);
var _perpendicularJs = require("./perpendicular.js");
parcelHelpers.exportAll(_perpendicularJs, exports);
var _pointOnRayJs = require("./point-on-ray.js");
parcelHelpers.exportAll(_pointOnRayJs, exports);
var _polarJs = require("./polar.js");
parcelHelpers.exportAll(_polarJs, exports);
var _powJs = require("./pow.js");
parcelHelpers.exportAll(_powJs, exports);
var _pownJs = require("./pown.js");
parcelHelpers.exportAll(_pownJs, exports);
var _projectJs = require("./project.js");
parcelHelpers.exportAll(_projectJs, exports);
var _radiansJs = require("./radians.js");
parcelHelpers.exportAll(_radiansJs, exports);
var _randomJs = require("./random.js");
parcelHelpers.exportAll(_randomJs, exports);
var _randomsJs = require("./randoms.js");
parcelHelpers.exportAll(_randomsJs, exports);
var _reflectJs = require("./reflect.js");
parcelHelpers.exportAll(_reflectJs, exports);
var _refractJs = require("./refract.js");
parcelHelpers.exportAll(_refractJs, exports);
var _remainderJs = require("./remainder.js");
parcelHelpers.exportAll(_remainderJs, exports);
var _remaindernJs = require("./remaindern.js");
parcelHelpers.exportAll(_remaindernJs, exports);
var _rotateAroundAxisJs = require("./rotate-around-axis.js");
parcelHelpers.exportAll(_rotateAroundAxisJs, exports);
var _rotateAroundPointJs = require("./rotate-around-point.js");
parcelHelpers.exportAll(_rotateAroundPointJs, exports);
var _rotateJs = require("./rotate.js");
parcelHelpers.exportAll(_rotateJs, exports);
var _rotatesJs = require("./rotates.js");
parcelHelpers.exportAll(_rotatesJs, exports);
var _roundJs = require("./round.js");
parcelHelpers.exportAll(_roundJs, exports);
var _rshiftJs = require("./rshift.js");
parcelHelpers.exportAll(_rshiftJs, exports);
var _safeDivJs = require("./safe-div.js");
parcelHelpers.exportAll(_safeDivJs, exports);
var _selectJs = require("./select.js");
parcelHelpers.exportAll(_selectJs, exports);
var _setJs = require("./set.js");
parcelHelpers.exportAll(_setJs, exports);
var _setcJs = require("./setc.js");
parcelHelpers.exportAll(_setcJs, exports);
var _setnJs = require("./setn.js");
parcelHelpers.exportAll(_setnJs, exports);
var _setsJs = require("./sets.js");
parcelHelpers.exportAll(_setsJs, exports);
var _setcsJs = require("./setcs.js");
parcelHelpers.exportAll(_setcsJs, exports);
var _setnsJs = require("./setns.js");
parcelHelpers.exportAll(_setnsJs, exports);
var _setvnJs = require("./setvn.js");
parcelHelpers.exportAll(_setvnJs, exports);
var _setvvJs = require("./setvv.js");
parcelHelpers.exportAll(_setvvJs, exports);
var _signJs = require("./sign.js");
parcelHelpers.exportAll(_signJs, exports);
var _signedAreaJs = require("./signed-area.js");
parcelHelpers.exportAll(_signedAreaJs, exports);
var _signedVolumeJs = require("./signed-volume.js");
parcelHelpers.exportAll(_signedVolumeJs, exports);
var _sinJs = require("./sin.js");
parcelHelpers.exportAll(_sinJs, exports);
var _sinhJs = require("./sinh.js");
parcelHelpers.exportAll(_sinhJs, exports);
var _softmaxJs = require("./softmax.js");
parcelHelpers.exportAll(_softmaxJs, exports);
var _someJs = require("./some.js");
parcelHelpers.exportAll(_someJs, exports);
var _sqrtJs = require("./sqrt.js");
parcelHelpers.exportAll(_sqrtJs, exports);
var _stepJs = require("./step.js");
parcelHelpers.exportAll(_stepJs, exports);
var _smoothstepJs = require("./smoothstep.js");
parcelHelpers.exportAll(_smoothstepJs, exports);
var _standardizeJs = require("./standardize.js");
parcelHelpers.exportAll(_standardizeJs, exports);
var _stringJs = require("./string.js");
parcelHelpers.exportAll(_stringJs, exports);
var _subJs = require("./sub.js");
parcelHelpers.exportAll(_subJs, exports);
var _subiJs = require("./subi.js");
parcelHelpers.exportAll(_subiJs, exports);
var _submJs = require("./subm.js");
parcelHelpers.exportAll(_submJs, exports);
var _submnJs = require("./submn.js");
parcelHelpers.exportAll(_submnJs, exports);
var _submsJs = require("./subms.js");
parcelHelpers.exportAll(_submsJs, exports);
var _submnsJs = require("./submns.js");
parcelHelpers.exportAll(_submnsJs, exports);
var _subnJs = require("./subn.js");
parcelHelpers.exportAll(_subnJs, exports);
var _subsJs = require("./subs.js");
parcelHelpers.exportAll(_subsJs, exports);
var _subnsJs = require("./subns.js");
parcelHelpers.exportAll(_subnsJs, exports);
var _sumJs = require("./sum.js");
parcelHelpers.exportAll(_sumJs, exports);
var _swizzleJs = require("./swizzle.js");
parcelHelpers.exportAll(_swizzleJs, exports);
var _tanJs = require("./tan.js");
parcelHelpers.exportAll(_tanJs, exports);
var _tanhJs = require("./tanh.js");
parcelHelpers.exportAll(_tanhJs, exports);
var _tensorJs = require("./tensor.js");
parcelHelpers.exportAll(_tensorJs, exports);
var _truncJs = require("./trunc.js");
parcelHelpers.exportAll(_truncJs, exports);
var _varianceJs = require("./variance.js");
parcelHelpers.exportAll(_varianceJs, exports);
var _vecOfJs = require("./vec-of.js");
parcelHelpers.exportAll(_vecOfJs, exports);
var _wrapJs = require("./wrap.js");
parcelHelpers.exportAll(_wrapJs, exports);
var _eqJs = require("./eq.js");
parcelHelpers.exportAll(_eqJs, exports);
var _neqJs = require("./neq.js");
parcelHelpers.exportAll(_neqJs, exports);
var _gtJs = require("./gt.js");
parcelHelpers.exportAll(_gtJs, exports);
var _gteJs = require("./gte.js");
parcelHelpers.exportAll(_gteJs, exports);
var _ltJs = require("./lt.js");
parcelHelpers.exportAll(_ltJs, exports);
var _lteJs = require("./lte.js");
parcelHelpers.exportAll(_lteJs, exports);

},{"./api.js":"60HDf","./iterator.js":"dnjxi","./compile/accessors.js":"5h29N","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","./avec.js":"czAXr","./vec2.js":"2P1xq","./vec3.js":"65hPu","./vec4.js":"iQG7M","./vop.js":"4v2k5","./abs.js":"ivhHk","./acos.js":"kPmuu","./addw.js":"cFpxt","./add.js":"6HmvS","./addi.js":"5JekR","./addm.js":"7tmcI","./addmn.js":"9C52h","./addms.js":"cfDqf","./addmns.js":"jvybo","./addn.js":"cecib","./adds.js":"cZbCm","./addns.js":"cDsWw","./angle-between.js":"8OhzV","./asin.js":"fm4pB","./atan.js":"aiYhv","./bisect.js":"bXCEG","./bit-and.js":"ihEMJ","./bit-not.js":"5kBRM","./bit-or.js":"8o6Ie","./bit-xor.js":"7BWzt","./buffer.js":"ecaja","./cartesian.js":"g2NFB","./ceil.js":"2tmeM","./center.js":"2MkSv","./clamp.js":"k99Yr","./clampn.js":"4kXdw","./clockwise.js":"hd0jc","./compare.js":"b5iVX","./convert.js":"hGWRF","./copy.js":"4RdrM","./correlation.js":"5oxGU","./cos.js":"kXrcE","./cosh.js":"O9xPf","./covariance.js":"alatG","./cross.js":"a6Q1x","./crosss.js":"2Nw0k","./degrees.js":"8oHW5","./direction.js":"g7PP7","./dist.js":"kIwBu","./dist-braycurtis.js":"8W4oS","./dist-canberra.js":"bsKNq","./dist-chebyshev.js":"kKt2g","./dist-hamming.js":"gmYUE","./dist-haversine.js":"c8sP5","./dist-jaccard.js":"8rqoi","./dist-manhattan.js":"dV6Jy","./dist-minkowski.js":"85fil","./dist-sorensendice.js":"eyp87","./dist-weighted.js":"btBuC","./distsq.js":"8XCdB","./div.js":"5inb4","./divi.js":"hac1Q","./divn.js":"8VZzE","./divs.js":"c7wQo","./divns.js":"afuXO","./dot.js":"9vV5N","./dotc.js":"cU5Pz","./dots.js":"3KJkk","./empty.js":"5JVqG","./eqdelta.js":"eBVIX","./equals.js":"kCRCM","./every.js":"kHThs","./exp.js":"5Qp2H","./exp_2.js":"9UjlL","./face-forward.js":"iuxjX","./fill.js":"klykq","./fit.js":"dCUuP","./floor.js":"8Bam4","./fmod.js":"5TOiT","./fmodn.js":"bYnoA","./fract.js":"4fVSV","./gvec.js":"1cUXh","./hash.js":"e4rRM","./heading.js":"jM0y9","./heading-segment.js":"a3Qmf","./homogeneous.js":"a3DYy","./invert.js":"hJpMW","./invsqrt.js":"bHU8F","./is-inf.js":"hVJ5w","./is-nan.js":"lmjNR","./jitter.js":"aBPSB","./limit.js":"ceTNs","./log.js":"zFq2X","./log_2.js":"1fpEn","./logic-and.js":"b5AQh","./logic-not.js":"eDW8G","./logic-or.js":"3aaGQ","./lshift.js":"46YJu","./madd.js":"8NYtQ","./maddn.js":"bTkou","./madds.js":"iDF9M","./maddns.js":"iOnQH","./mag.js":"70TCJ","./mags.js":"h4CFH","./magsq.js":"bsMC4","./magsqs.js":"b5N6p","./major.js":"hqWnf","./map.js":"7CzQk","./map-vectors.js":"8KUWS","./max.js":"7CH4J","./max-bounds.js":"l64lm","./mean.js":"7w5sd","./median.js":"k1qXc","./min.js":"gWOyO","./min-bounds.js":"kPgsx","./minor.js":"9omJw","./mix-bilinear.js":"baPCK","./mix-cubic.js":"5OlFY","./mix-hermite.js":"114q9","./mix-quadratic.js":"6mY6C","./mix.js":"hb219","./mixn.js":"jolPM","./mixs.js":"gLg2m","./mixns.js":"glIAb","./mod.js":"fNrmT","./modn.js":"YyBoO","./msub.js":"8UZie","./msubn.js":"9zPln","./msubs.js":"ke6Rd","./msubns.js":"6JEEE","./mul.js":"bTRb3","./muli.js":"aJFBK","./muln.js":"1TKlE","./muls.js":"01xwB","./mulns.js":"b3IkY","./neg.js":"gnwVs","./normal.js":"8RAVI","./normalize.js":"9ex3j","./normalizes.js":"lD3Rj","./not.js":"u5ZXS","./ortho-normal.js":"h0jz9","./perpendicular.js":"dnMKL","./point-on-ray.js":"lDaDN","./polar.js":"hjxag","./pow.js":"ek3Z1","./pown.js":"e4E3E","./project.js":"3Ztzw","./radians.js":"4f5wk","./random.js":"8bjGw","./randoms.js":"jp9qg","./reflect.js":"d5xc2","./refract.js":"1FHgE","./remainder.js":"8QlLp","./remaindern.js":"6YhVp","./rotate-around-axis.js":"bnMmK","./rotate-around-point.js":"fTth1","./rotate.js":"756IA","./rotates.js":"f8Qd6","./round.js":"k0lRR","./rshift.js":"5ezs6","./safe-div.js":"iquHD","./select.js":"e9RWo","./set.js":"bSUB8","./setc.js":"jST0o","./setn.js":"2M6y1","./sets.js":"3jBTJ","./setcs.js":"35qNU","./setns.js":"fEREX","./setvn.js":"8Xxwm","./setvv.js":"bgsN2","./sign.js":"deOCU","./signed-area.js":"2iZFe","./signed-volume.js":"kWxbb","./sin.js":"eQFJ3","./sinh.js":"4FADI","./softmax.js":"awIye","./some.js":"kVDnA","./sqrt.js":"adalI","./step.js":"1iWKd","./smoothstep.js":"95Lq7","./standardize.js":"dbQSi","./string.js":"iiJ6W","./sub.js":"fzaw7","./subi.js":"csHlx","./subm.js":"92Lej","./submn.js":"aIPIo","./subms.js":"1EUBR","./submns.js":"co6Wj","./subn.js":"i3npD","./subs.js":"h2qQr","./subns.js":"hfisH","./sum.js":"2gBvR","./swizzle.js":"8JoUk","./tan.js":"9mqB8","./tanh.js":"cIJ1g","./tensor.js":"coH0v","./trunc.js":"1UHBI","./variance.js":"5Fsvh","./vec-of.js":"1dJsE","./wrap.js":"7bcGS","./eq.js":"XkoMe","./neq.js":"1PSgL","./gt.js":"c6eU8","./gte.js":"h9jv8","./lt.js":"8IIjy","./lte.js":"7gcE2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"60HDf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MIN2", ()=>MIN2
);
parcelHelpers.export(exports, "MAX2", ()=>MAX2
);
parcelHelpers.export(exports, "ONE2", ()=>ONE2
);
parcelHelpers.export(exports, "ZERO2", ()=>ZERO2
);
parcelHelpers.export(exports, "X2", ()=>X2
);
parcelHelpers.export(exports, "Y2", ()=>Y2
);
parcelHelpers.export(exports, "MIN3", ()=>MIN3
);
parcelHelpers.export(exports, "MAX3", ()=>MAX3
);
parcelHelpers.export(exports, "ONE3", ()=>ONE3
);
parcelHelpers.export(exports, "ZERO3", ()=>ZERO3
);
parcelHelpers.export(exports, "X3", ()=>X3
);
parcelHelpers.export(exports, "Y3", ()=>Y3
);
parcelHelpers.export(exports, "Z3", ()=>Z3
);
parcelHelpers.export(exports, "MIN4", ()=>MIN4
);
parcelHelpers.export(exports, "MAX4", ()=>MAX4
);
parcelHelpers.export(exports, "ONE4", ()=>ONE4
);
parcelHelpers.export(exports, "ZERO4", ()=>ZERO4
);
parcelHelpers.export(exports, "X4", ()=>X4
);
parcelHelpers.export(exports, "Y4", ()=>Y4
);
parcelHelpers.export(exports, "Z4", ()=>Z4
);
parcelHelpers.export(exports, "W4", ()=>W4
);
const mi = -Infinity;
const mx = Infinity;
const MIN2 = Object.freeze([
    mi,
    mi
]);
const MAX2 = Object.freeze([
    mx,
    mx
]);
const ONE2 = Object.freeze([
    1,
    1
]);
const ZERO2 = Object.freeze([
    0,
    0
]);
const X2 = Object.freeze([
    1,
    0
]);
const Y2 = Object.freeze([
    0,
    1
]);
const MIN3 = Object.freeze([
    mi,
    mi,
    mi
]);
const MAX3 = Object.freeze([
    mx,
    mx,
    mx
]);
const ONE3 = Object.freeze([
    1,
    1,
    1
]);
const ZERO3 = Object.freeze([
    0,
    0,
    0
]);
const X3 = Object.freeze([
    1,
    0,
    0
]);
const Y3 = Object.freeze([
    0,
    1,
    0
]);
const Z3 = Object.freeze([
    0,
    0,
    1
]);
const MIN4 = Object.freeze([
    mi,
    mi,
    mi,
    mi
]);
const MAX4 = Object.freeze([
    mx,
    mx,
    mx,
    mx
]);
const ONE4 = Object.freeze([
    1,
    1,
    1,
    1
]);
const ZERO4 = Object.freeze([
    0,
    0,
    0,
    0
]);
const X4 = Object.freeze([
    1,
    0,
    0,
    0
]);
const Y4 = Object.freeze([
    0,
    1,
    0,
    0
]);
const Z4 = Object.freeze([
    0,
    0,
    1,
    0
]);
const W4 = Object.freeze([
    0,
    0,
    0,
    1
]);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dnjxi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "vecIterator", ()=>vecIterator
);
parcelHelpers.export(exports, "stridedValues", ()=>stridedValues
);
function* vecIterator(ctor, buf, num, start, cstride, estride) {
    while(num-- > 0){
        yield new ctor(buf, start, cstride);
        start += estride;
    }
}
function* stridedValues(buf, num, start, stride) {
    while(num-- > 0){
        yield buf[start];
        start += stride;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5h29N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "declareIndex", ()=>declareIndex
);
parcelHelpers.export(exports, "declareIndices", ()=>declareIndices
);
const declareIndex = (proto, id, idx, strided = true, defNumeric = true)=>{
    const get = idx > 0 ? strided ? function() {
        return this.buf[this.offset + idx * this.stride];
    } : function() {
        return this.buf[this.offset + idx];
    } : function() {
        return this.buf[this.offset];
    };
    const set = idx > 0 ? strided ? function(n) {
        this.buf[this.offset + idx * this.stride] = n;
    } : function(n) {
        this.buf[this.offset + idx] = n;
    } : function(n) {
        this.buf[this.offset] = n;
    };
    defNumeric && Object.defineProperty(proto, idx, {
        get,
        set,
        enumerable: true
    });
    Object.defineProperty(proto, id, {
        get,
        set,
        enumerable: true
    });
};
const declareIndices = (proto, props, strided, defNumeric)=>props.forEach((id, i)=>declareIndex(proto, id, i, strided, defNumeric)
    )
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"czAXr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AVec", ()=>AVec
);
var _stringJs = require("./string.js");
class AVec {
    constructor(buf, offset = 0, stride = 1){
        this.buf = buf;
        this.offset = offset;
        this.stride = stride;
    }
    toString() {
        return _stringJs.FORMATTER(this);
    }
}

},{"./string.js":"iiJ6W","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iiJ6W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defFormat", ()=>defFormat
);
parcelHelpers.export(exports, "setFormat", ()=>setFormat
);
parcelHelpers.export(exports, "FORMATTER", ()=>FORMATTER
);
var _isFunction = require("@thi.ng/checks/is-function");
var _float = require("@thi.ng/strings/float");
const defFormat = (opts)=>{
    const { prec , width , delim , wrap  } = {
        prec: 3,
        delim: ", ",
        wrap: "[]",
        ...opts
    };
    const fmt = width ? _float.floatFixedWidth(width, prec) : _float.float(prec);
    return (src)=>{
        let res = [];
        for (let x of src)res.push(fmt(x));
        return `${wrap[0]}${res.join(delim)}${wrap[1]}`;
    };
};
const setFormat = (fmt)=>{
    FORMATTER = _isFunction.isFunction(fmt) ? fmt : defFormat(fmt);
};
let FORMATTER = defFormat();

},{"@thi.ng/checks/is-function":"4VSWl","@thi.ng/strings/float":"8t0B1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4VSWl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isFunction", ()=>isFunction
);
const isFunction = (x)=>typeof x === "function"
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8t0B1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "float", ()=>float
);
parcelHelpers.export(exports, "floatFixedWidth", ()=>floatFixedWidth
);
var _memoizej = require("@thi.ng/memoize/memoizej");
var _padLeftJs = require("./pad-left.js");
const float = _memoizej.memoizeJ((prec, special = false)=>special ? (x)=>nanOrInf(x) || x.toFixed(prec)
     : (x)=>x.toFixed(prec)
);
const floatFixedWidth = _memoizej.memoizeJ((width, prec = 3)=>{
    const l = width - prec - 1;
    const pl = Math.pow(10, l);
    const pln = -Math.pow(10, l - 1);
    const pr = Math.pow(10, -(prec - 1));
    const pad = _padLeftJs.padLeft(width);
    return (x)=>{
        const ax = Math.abs(x);
        return pad(nanOrInf(x) || (x === 0 ? "0" : ax < pr || ax >= pl ? exp(x, width) : x.toFixed(prec - (x < pln ? 1 : 0))));
    };
});
const exp = (x, w)=>x.toExponential(Math.max(w - 4 - (Math.log(Math.abs(x)) / Math.LN10 >= 10 ? 2 : 1) - (x < 0 ? 1 : 0), 0))
;
const nanOrInf = (x)=>isNaN(x) ? "NaN" : x === Infinity ? "+∞" : x === -Infinity ? "-∞" : undefined
;

},{"@thi.ng/memoize/memoizej":"kpZq7","./pad-left.js":"jyWQa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kpZq7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "memoizeJ", ()=>memoizeJ
);
function memoizeJ(fn, cache) {
    !cache && (cache = {
    });
    return (...args)=>{
        const key = JSON.stringify(args);
        if (key !== undefined) return key in cache ? cache[key] : cache[key] = fn.apply(null, args);
        return fn.apply(null, args);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jyWQa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "padLeft", ()=>padLeft
);
parcelHelpers.export(exports, "Z2", ()=>Z2
);
parcelHelpers.export(exports, "Z3", ()=>Z3
);
parcelHelpers.export(exports, "Z4", ()=>Z4
);
var _memoizej = require("@thi.ng/memoize/memoizej");
var _repeatJs = require("./repeat.js");
const padLeft = _memoizej.memoizeJ((n, ch = " ")=>{
    const buf = _repeatJs.repeat(String(ch), n);
    return (x, len)=>{
        if (x == null) return buf;
        x = x.toString();
        len = len !== undefined ? len : x.length;
        return len < n ? buf.substring(len) + x : x;
    };
});
const Z2 = padLeft(2, "0");
const Z3 = padLeft(3, "0");
const Z4 = padLeft(4, "0");

},{"@thi.ng/memoize/memoizej":"kpZq7","./repeat.js":"jrSWh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jrSWh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "repeat", ()=>repeat
);
var _memoizej = require("@thi.ng/memoize/memoizej");
const repeat = _memoizej.memoizeJ((ch, n)=>ch.repeat(n)
);

},{"@thi.ng/memoize/memoizej":"kpZq7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2P1xq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Vec2", ()=>Vec2
);
parcelHelpers.export(exports, "vec2", ()=>vec2
);
parcelHelpers.export(exports, "vec2n", ()=>vec2n
);
parcelHelpers.export(exports, "asVec2", ()=>asVec2
);
var _api = require("@thi.ng/math/api");
var _accessorsJs = require("./compile/accessors.js");
var _apiJs = require("./api.js");
var _avecJs = require("./avec.js");
var _bufferJs = require("./buffer.js");
var _eqdeltaJs = require("./eqdelta.js");
var _hashJs = require("./hash.js");
var _iteratorJs = require("./iterator.js");
var _setsJs = require("./sets.js");
class Vec2 extends _avecJs.AVec {
    constructor(buf, offset = 0, stride = 1){
        super(buf || [
            0,
            0
        ], offset, stride);
    }
    /**
     * Returns array of memory mapped {@link Vec2} instances using given
     * backing array and stride settings: The `cstride` is the step size
     * between individual XY vector components. `estride` is the step
     * size between successive vectors. This arrangement allows for
     * different storage approaches, incl. SOA, AOS, striped /
     * interleaved etc.
     *
     * @param buf - backing array
     * @param num - num vectors
     * @param start -  start index
     * @param cstride - component stride
     * @param estride - element stride
     */ static mapBuffer(buf, num = buf.length >> 1, start = 0, cstride = 1, estride = 2) {
        return _bufferJs.mapStridedBuffer(Vec2, buf, num, start, cstride, estride);
    }
    /**
     * Merges given `src` iterable of {@link Vec2}s into single array `buf`.
     * Vectors will be arranged according to given component and element
     * strides, starting at `start` index. It's the user's
     * responsibility to ensure the target buffer has sufficient
     * capacity to hold the input vectors. See `Vec2.mapBuffer` for the
     * inverse operation. Returns `buf`.
     *
     * @param buf -
     * @param src -
     * @param start -
     * @param cstride -
     * @param estride -
     */ static intoBuffer(buf, src, start = 0, cstride = 1, estride = 2) {
        return _bufferJs.intoStridedBuffer(_setsJs.setS2, buf, src, start, cstride, estride);
    }
    static iterator(buf, num, start = 0, cstride = 1, estride = 2) {
        return _iteratorJs.vecIterator(Vec2, buf, num, start, cstride, estride);
    }
    [Symbol.iterator]() {
        return _iteratorJs.stridedValues(this.buf, 2, this.offset, this.stride);
    }
    get length() {
        return 2;
    }
    copy() {
        return new Vec2([
            this.x,
            this.y
        ]);
    }
    copyView() {
        return new Vec2(this.buf, this.offset, this.stride);
    }
    empty() {
        return new Vec2();
    }
    eqDelta(v, eps = _api.EPS) {
        return _eqdeltaJs.eqDelta2(this, v, eps);
    }
    hash() {
        return _hashJs.hash(this);
    }
    toJSON() {
        return [
            this.x,
            this.y
        ];
    }
}
Vec2.X_AXIS = new Vec2(_apiJs.X2);
Vec2.Y_AXIS = new Vec2(_apiJs.Y2);
Vec2.MIN = new Vec2(_apiJs.MIN2);
Vec2.MAX = new Vec2(_apiJs.MAX2);
Vec2.ZERO = new Vec2(_apiJs.ZERO2);
Vec2.ONE = new Vec2(_apiJs.ONE2);
_accessorsJs.declareIndices(Vec2.prototype, [
    "x",
    "y"
]);
const vec2 = (x = 0, y = 0)=>new Vec2([
        x,
        y
    ])
;
const vec2n = (n)=>new Vec2([
        n,
        n
    ])
;
const asVec2 = (x)=>x instanceof Vec2 ? x : new Vec2(x.length >= 2 ? x : [
        x[0] || 0,
        x[1] || 0
    ])
;

},{"@thi.ng/math/api":"4a98p","./compile/accessors.js":"5h29N","./api.js":"60HDf","./avec.js":"czAXr","./buffer.js":"ecaja","./eqdelta.js":"eBVIX","./hash.js":"e4rRM","./iterator.js":"dnjxi","./sets.js":"3jBTJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ecaja":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapBuffer", ()=>mapBuffer
);
parcelHelpers.export(exports, "intoBuffer", ()=>intoBuffer
);
parcelHelpers.export(exports, "mapStridedBuffer", ()=>mapStridedBuffer
);
parcelHelpers.export(exports, "intoStridedBuffer", ()=>intoStridedBuffer
);
var _typedarray = require("@thi.ng/api/typedarray");
const mapBuffer = (type, buf, num, size, byteOffset = 0, byteStride = size * _typedarray.SIZEOF[type])=>{
    const res = [];
    for(; num-- > 0; byteOffset += byteStride)res.push(_typedarray.typedArray(type, buf, byteOffset, size));
    return res;
};
const intoBuffer = (type, buf, src, byteOffset, byteStride)=>{
    const view = _typedarray.typedArray(type, buf);
    const size = _typedarray.SIZEOF[type];
    byteOffset /= size;
    byteStride /= size;
    for (let x of src){
        view.set(x, byteOffset);
        byteOffset += byteStride;
    }
};
const mapStridedBuffer = (ctor, buf, num, start, cstride, estride)=>{
    const res = [];
    while(num-- > 0){
        res.push(new ctor(buf, start, cstride));
        start += estride;
    }
    return res;
};
const intoStridedBuffer = (set, buf, src, start, cstride, estride)=>{
    for (let v of src){
        set(buf, v, start, 0, cstride, 1);
        start += estride;
    }
    return buf;
};

},{"@thi.ng/api/typedarray":"aGQJc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aGQJc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GLType", ()=>GLType
);
parcelHelpers.export(exports, "GL2TYPE", ()=>GL2TYPE
);
parcelHelpers.export(exports, "TYPE2GL", ()=>TYPE2GL
);
parcelHelpers.export(exports, "SIZEOF", ()=>SIZEOF
);
parcelHelpers.export(exports, "FLOAT_ARRAY_CTORS", ()=>FLOAT_ARRAY_CTORS
);
parcelHelpers.export(exports, "INT_ARRAY_CTORS", ()=>INT_ARRAY_CTORS
);
parcelHelpers.export(exports, "UINT_ARRAY_CTORS", ()=>UINT_ARRAY_CTORS
);
parcelHelpers.export(exports, "TYPEDARRAY_CTORS", ()=>TYPEDARRAY_CTORS
);
parcelHelpers.export(exports, "asNativeType", ()=>asNativeType
);
parcelHelpers.export(exports, "asGLType", ()=>asGLType
);
parcelHelpers.export(exports, "asInt", ()=>asInt
);
parcelHelpers.export(exports, "sizeOf", ()=>sizeOf
);
parcelHelpers.export(exports, "typedArray", ()=>typedArray
);
parcelHelpers.export(exports, "typedArrayType", ()=>typedArrayType
);
parcelHelpers.export(exports, "uintTypeForSize", ()=>uintTypeForSize
);
parcelHelpers.export(exports, "intTypeForSize", ()=>intTypeForSize
);
parcelHelpers.export(exports, "uintTypeForBits", ()=>uintTypeForBits
);
parcelHelpers.export(exports, "intTypeForBits", ()=>intTypeForBits
);
var GLType;
(function(GLType1) {
    GLType1[GLType1["I8"] = 5120] = "I8";
    GLType1[GLType1["U8"] = 5121] = "U8";
    GLType1[GLType1["I16"] = 5122] = "I16";
    GLType1[GLType1["U16"] = 5123] = "U16";
    GLType1[GLType1["I32"] = 5124] = "I32";
    GLType1[GLType1["U32"] = 5125] = "U32";
    GLType1[GLType1["F32"] = 5126] = "F32";
})(GLType || (GLType = {
}));
const GL2TYPE = {
    [GLType.I8]: "i8",
    [GLType.U8]: "u8",
    [GLType.I16]: "i16",
    [GLType.U16]: "u16",
    [GLType.I32]: "i32",
    [GLType.U32]: "u32",
    [GLType.F32]: "f32"
};
const TYPE2GL = {
    i8: GLType.I8,
    u8: GLType.U8,
    u8c: GLType.U8,
    i16: GLType.I16,
    u16: GLType.U16,
    i32: GLType.I32,
    u32: GLType.U32,
    f32: GLType.F32,
    f64: undefined
};
const SIZEOF = {
    u8: 1,
    u8c: 1,
    i8: 1,
    u16: 2,
    i16: 2,
    u32: 4,
    i32: 4,
    f32: 4,
    f64: 8
};
const FLOAT_ARRAY_CTORS = {
    f32: Float32Array,
    f64: Float64Array
};
const INT_ARRAY_CTORS = {
    i8: Int8Array,
    i16: Int16Array,
    i32: Int32Array
};
const UINT_ARRAY_CTORS = {
    u8: Uint8Array,
    u8c: Uint8ClampedArray,
    u16: Uint16Array,
    u32: Uint32Array
};
const TYPEDARRAY_CTORS = {
    ...FLOAT_ARRAY_CTORS,
    ...INT_ARRAY_CTORS,
    ...UINT_ARRAY_CTORS
};
const asNativeType = (type)=>{
    const t = GL2TYPE[type];
    return t !== undefined ? t : type;
};
const asGLType = (type)=>{
    const t = TYPE2GL[type];
    return t !== undefined ? t : type;
};
const asInt = (...args)=>args.map((x)=>x | 0
    )
;
const sizeOf = (type)=>SIZEOF[asNativeType(type)]
;
function typedArray(type, ...xs) {
    return new TYPEDARRAY_CTORS[asNativeType(type)](...xs);
}
const typedArrayType = (x)=>{
    if (Array.isArray(x)) return "f64";
    for(let id in TYPEDARRAY_CTORS){
        if (x instanceof TYPEDARRAY_CTORS[id]) return id;
    }
    return "f64";
};
const uintTypeForSize = (x)=>x <= 256 ? "u8" : x <= 65536 ? "u16" : "u32"
;
const intTypeForSize = (x)=>x >= -128 && x < 128 ? "i8" : x >= -32768 && x < 32768 ? "i16" : "i32"
;
const uintTypeForBits = (x)=>x > 16 ? "u32" : x > 8 ? "u16" : "u8"
;
const intTypeForBits = (x)=>x > 16 ? "i32" : x > 8 ? "i16" : "i8"
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eBVIX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eqDelta", ()=>eqDelta
);
parcelHelpers.export(exports, "eqDelta2", ()=>eqDelta2
);
parcelHelpers.export(exports, "eqDelta3", ()=>eqDelta3
);
parcelHelpers.export(exports, "eqDelta4", ()=>eqDelta4
);
parcelHelpers.export(exports, "eqDeltaS", ()=>eqDeltaS
);
parcelHelpers.export(exports, "eqDeltaArray", ()=>eqDeltaArray
);
parcelHelpers.export(exports, "isInArray", ()=>isInArray
);
var _implementsFunction = require("@thi.ng/checks/implements-function");
var _api = require("@thi.ng/math/api");
var _eqdelta = require("@thi.ng/math/eqdelta");
var _emitJs = require("./compile/emit.js");
var _vopJs = require("./vop.js");
const $ = (dim)=>eqDelta.add(dim, _emitJs.compileHOF(dim, [
        _eqdelta.eqDelta,
        _api.EPS
    ], ([a, b])=>`eq(${a},${b},eps)`
    , "eq,_eps", "a,b,eps=_eps", "a,b", "", "&&", "return a.length === b.length && ", ";"))
;
const eqDelta = _vopJs.vop();
eqDelta.default((v1, v2, eps = _api.EPS)=>{
    if (_implementsFunction.implementsFunction(v1, "eqDelta")) return v1.eqDelta(v2, eps);
    if (_implementsFunction.implementsFunction(v2, "eqDelta")) return v2.eqDelta(v1, eps);
    return eqDeltaS(v1, v2, v1.length, eps);
});
const eqDelta2 = $(2);
const eqDelta3 = $(3);
const eqDelta4 = $(4);
const eqDeltaS = (a, b, n, eps = _api.EPS, ia = 0, ib = 0, sa = 1, sb = 1)=>{
    for(; n > 0; n--, ia += sa, ib += sb){
        if (!_eqdelta.eqDelta(a[ia], b[ib], eps)) return false;
    }
    return true;
};
const eqDeltaArray = (a, b, eps = _api.EPS)=>{
    if (a === b) return true;
    if (a.length !== b.length) return false;
    for(let i = a.length; i-- > 0;){
        if (!eqDelta(a[i], b[i], eps)) return false;
    }
    return true;
};
const isInArray = (p, pts, eps = _api.EPS)=>{
    for(let i = pts.length; i-- > 0;){
        if (eqDelta(p, pts[i], eps)) return true;
    }
    return false;
};

},{"@thi.ng/checks/implements-function":"cjrzK","@thi.ng/math/api":"4a98p","@thi.ng/math/eqdelta":"cmNLt","./compile/emit.js":"hpIek","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cmNLt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eqDelta", ()=>eqDelta
);
parcelHelpers.export(exports, "eqDeltaScaled", ()=>eqDeltaScaled
);
var _apiJs = require("./api.js");
const abs = Math.abs;
const max = Math.max;
const eqDelta = (a, b, eps = _apiJs.EPS)=>abs(a - b) <= eps
;
const eqDeltaScaled = (a, b, eps = _apiJs.EPS)=>abs(a - b) <= eps * max(1, abs(a), abs(b))
;

},{"./api.js":"4a98p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e4rRM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hash", ()=>hash
);
var _float = require("@thi.ng/binary/float");
var _rotate = require("@thi.ng/binary/rotate");
const hash = (v, H = 2654435761)=>{
    let hash1 = -1;
    for(let i = v.length; i-- > 0;)hash1 = Math.imul(H, hash1) + mix(hash1, _float.floatToUintBits(v[i])) >>> 0;
    return hash1;
};
const M1 = 3432918353;
const M2 = 461845907;
const M3 = 3864292196;
const mix = (h, k)=>{
    k = Math.imul(_rotate.rotateLeft(Math.imul(k, M1) >>> 0, 15), M2) >>> 0;
    return (Math.imul(_rotate.rotateLeft(h ^ k, 13), 5) >>> 0) + M3 >>> 0;
};

},{"@thi.ng/binary/float":"4OyLt","@thi.ng/binary/rotate":"9tmG6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4OyLt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IS_LE", ()=>IS_LE
);
parcelHelpers.export(exports, "floatToIntBits", ()=>floatToIntBits
);
parcelHelpers.export(exports, "floatToUintBits", ()=>floatToUintBits
);
parcelHelpers.export(exports, "intBitsToFloat", ()=>intBitsToFloat
);
parcelHelpers.export(exports, "uintBitsToFloat", ()=>uintBitsToFloat
);
parcelHelpers.export(exports, "floatToIntBits64", ()=>floatToIntBits64
);
parcelHelpers.export(exports, "floatToUintBits64", ()=>floatToUintBits64
);
parcelHelpers.export(exports, "intBitsToFloat64", ()=>intBitsToFloat64
);
parcelHelpers.export(exports, "uintBitsToFloat64", ()=>uintBitsToFloat64
);
parcelHelpers.export(exports, "floatToSortableInt", ()=>floatToSortableInt
);
parcelHelpers.export(exports, "f32u8", ()=>f32u8
);
parcelHelpers.export(exports, "f32u16", ()=>f32u16
);
parcelHelpers.export(exports, "f32u24", ()=>f32u24
);
parcelHelpers.export(exports, "f32u32", ()=>f32u32
);
parcelHelpers.export(exports, "u8f32", ()=>u8f32
);
parcelHelpers.export(exports, "u16f32", ()=>u16f32
);
parcelHelpers.export(exports, "u24f32", ()=>u24f32
);
parcelHelpers.export(exports, "u32f32", ()=>u32f32
);
const F64 = new Float64Array(1);
const F32 = new Float32Array(F64.buffer);
const I32 = new Int32Array(F64.buffer);
const U32 = new Uint32Array(F64.buffer);
const IS_LE = (F64[0] = 2, U32[1] === 1073741824);
const floatToIntBits = (x)=>(F32[0] = x, I32[0])
;
const floatToUintBits = (x)=>(F32[0] = x, U32[0])
;
const intBitsToFloat = (x)=>(I32[0] = x, F32[0])
;
const uintBitsToFloat = (x)=>(U32[0] = x, F32[0])
;
const floatToIntBits64 = (x)=>(F64[0] = x, IS_LE ? [
        I32[1],
        I32[0]
    ] : [
        I32[0],
        I32[1]
    ])
;
const floatToUintBits64 = (x)=>(F64[0] = x, IS_LE ? [
        U32[1],
        U32[0]
    ] : [
        U32[0],
        U32[1]
    ])
;
const intBitsToFloat64 = (hi, lo)=>{
    IS_LE ? (I32[1] = hi, I32[0] = lo) : (I32[0] = hi, I32[1] = lo);
    return F64[0];
};
const uintBitsToFloat64 = (hi, lo)=>{
    IS_LE ? (U32[1] = hi, U32[0] = lo) : (U32[0] = hi, U32[1] = lo);
    return F64[0];
};
const floatToSortableInt = (x)=>{
    if (x === -0) x = 0;
    const i = floatToIntBits(x);
    return x < 0 ? ~i | -2147483648 : i;
};
const clamp11 = (x)=>x < -1 ? -1 : x > 1 ? 1 : x
;
const f32u8 = (x)=>clamp11(x) * 127 & 255
;
const f32u16 = (x)=>clamp11(x) * 32767 & 65535
;
const f32u24 = (x)=>clamp11(x) * 8388607 & 16777215
;
const f32u32 = (x)=>clamp11(x) * 2147483647 >>> 0
;
const u8f32 = (x)=>(x &= 255, (x | (x >> 7) * 4294967040) / 127)
;
const u16f32 = (x)=>(x &= 65535, (x | (x >> 15) * 4294901760) / 32767)
;
const u24f32 = (x)=>(x &= 16777215, (x | (x >> 23) * 4278190080) / 8388607)
;
const u32f32 = (x)=>(x | 0) / 2147483647
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9tmG6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rotateLeft", ()=>rotateLeft
);
parcelHelpers.export(exports, "rotateRight", ()=>rotateRight
);
parcelHelpers.export(exports, "shiftRL", ()=>shiftRL
);
const rotateLeft = (x, n)=>(x << n | x >>> 32 - n) >>> 0
;
const rotateRight = (x, n)=>(x >>> n | x << 32 - n) >>> 0
;
const shiftRL = (x, n)=>n < 0 ? x << -n : x >>> n
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3jBTJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setS", ()=>setS
);
parcelHelpers.export(exports, "setS2", ()=>setS2
);
parcelHelpers.export(exports, "setS3", ()=>setS3
);
parcelHelpers.export(exports, "setS4", ()=>setS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [setS, setS2, setS3, setS4] = _emitJs.defOpS(_templatesJs.SET, "o,a", _templatesJs.SARGS_V, "o,a", "o", _templatesJs.NEW_OUT);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"65hPu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Vec3", ()=>Vec3
);
parcelHelpers.export(exports, "vec3", ()=>vec3
);
parcelHelpers.export(exports, "vec3n", ()=>vec3n
);
parcelHelpers.export(exports, "asVec3", ()=>asVec3
);
var _api = require("@thi.ng/math/api");
var _accessorsJs = require("./compile/accessors.js");
var _apiJs = require("./api.js");
var _avecJs = require("./avec.js");
var _bufferJs = require("./buffer.js");
var _eqdeltaJs = require("./eqdelta.js");
var _hashJs = require("./hash.js");
var _iteratorJs = require("./iterator.js");
var _setsJs = require("./sets.js");
class Vec3 extends _avecJs.AVec {
    constructor(buf, offset = 0, stride = 1){
        super(buf || [
            0,
            0,
            0
        ], offset, stride);
    }
    /**
     * Returns array of memory mapped {@link Vec3} instances using given
     * backing array and stride settings: The `cstride` is the step size
     * between individual XYZ vector components. `estride` is the step
     * size between successive vectors. This arrangement allows for
     * different storage approaches, incl. SOA, AOS, striped /
     * interleaved etc.
     *
     * @param buf - backing array
     * @param num - num vectors
     * @param start -  start index
     * @param cstride - component stride
     * @param estride - element stride
     */ static mapBuffer(buf, num = buf.length / 3 | 0, start = 0, cstride = 1, estride = 3) {
        return _bufferJs.mapStridedBuffer(Vec3, buf, num, start, cstride, estride);
    }
    /**
     * Merges given `src` iterable of {@link Vec3}s into single array `buf`.
     * Vectors will be arranged according to given component and element
     * strides, starting at `start` index. It's the user's
     * responsibility to ensure the target buffer has sufficient
     * capacity to hold the input vectors. See `Vec3.mapBuffer` for the
     * inverse operation. Returns `buf`.
     *
     * @param buf -
     * @param src -
     * @param start -
     * @param cstride -
     * @param estride -
     */ static intoBuffer(buf, src, start = 0, cstride = 1, estride = 3) {
        return _bufferJs.intoStridedBuffer(_setsJs.setS3, buf, src, start, cstride, estride);
    }
    static iterator(buf, num, start = 0, cstride = 1, estride = 3) {
        return _iteratorJs.vecIterator(Vec3, buf, num, start, cstride, estride);
    }
    [Symbol.iterator]() {
        return _iteratorJs.stridedValues(this.buf, 3, this.offset, this.stride);
    }
    get length() {
        return 3;
    }
    copy() {
        return new Vec3([
            this.x,
            this.y,
            this.z
        ]);
    }
    copyView() {
        return new Vec3(this.buf, this.offset, this.stride);
    }
    empty() {
        return new Vec3();
    }
    eqDelta(v, eps = _api.EPS) {
        return _eqdeltaJs.eqDelta3(this, v, eps);
    }
    hash() {
        return _hashJs.hash(this);
    }
    toJSON() {
        return [
            this.x,
            this.y,
            this.z
        ];
    }
}
Vec3.X_AXIS = new Vec3(_apiJs.X3);
Vec3.Y_AXIS = new Vec3(_apiJs.Y3);
Vec3.Z_AXIS = new Vec3(_apiJs.Z3);
Vec3.MIN = new Vec3(_apiJs.MIN3);
Vec3.MAX = new Vec3(_apiJs.MAX3);
Vec3.ZERO = new Vec3(_apiJs.ZERO3);
Vec3.ONE = new Vec3(_apiJs.ONE3);
_accessorsJs.declareIndices(Vec3.prototype, [
    "x",
    "y",
    "z"
]);
const vec3 = (x = 0, y = 0, z = 0)=>new Vec3([
        x,
        y,
        z
    ])
;
const vec3n = (n)=>new Vec3([
        n,
        n,
        n
    ])
;
const asVec3 = (x)=>x instanceof Vec3 ? x : new Vec3(x.length >= 3 ? x : [
        x[0] || 0,
        x[1] || 0,
        x[2] || 0
    ])
;

},{"@thi.ng/math/api":"4a98p","./compile/accessors.js":"5h29N","./api.js":"60HDf","./avec.js":"czAXr","./buffer.js":"ecaja","./eqdelta.js":"eBVIX","./hash.js":"e4rRM","./iterator.js":"dnjxi","./sets.js":"3jBTJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iQG7M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Vec4", ()=>Vec4
);
parcelHelpers.export(exports, "vec4", ()=>vec4
);
parcelHelpers.export(exports, "vec4n", ()=>vec4n
);
parcelHelpers.export(exports, "asVec4", ()=>asVec4
);
var _api = require("@thi.ng/math/api");
var _accessorsJs = require("./compile/accessors.js");
var _apiJs = require("./api.js");
var _avecJs = require("./avec.js");
var _bufferJs = require("./buffer.js");
var _eqdeltaJs = require("./eqdelta.js");
var _hashJs = require("./hash.js");
var _iteratorJs = require("./iterator.js");
var _setsJs = require("./sets.js");
class Vec4 extends _avecJs.AVec {
    constructor(buf, offset = 0, stride = 1){
        super(buf || [
            0,
            0,
            0,
            0
        ], offset, stride);
    }
    /**
     * Returns array of memory mapped {@link Vec4} instances using given
     * backing array and stride settings: The `cstride` is the step size
     * between individual XYZ vector components. `estride` is the step
     * size between successive vectors. This arrangement allows for
     * different storage approaches, incl. SOA, AOS, striped /
     * interleaved etc.
     *
     * @param buf - backing array
     * @param num - num vectors
     * @param start -  start index
     * @param cstride - component stride
     * @param estride - element stride
     */ static mapBuffer(buf, num = buf.length >> 2, start = 0, cstride = 1, estride = 4) {
        return _bufferJs.mapStridedBuffer(Vec4, buf, num, start, cstride, estride);
    }
    /**
     * Merges given `src` iterable of {@link Vec4}s into single array `buf`.
     * Vectors will be arranged according to given component and element
     * strides, starting at `start` index. It's the user's
     * responsibility to ensure the target buffer has sufficient
     * capacity to hold the input vectors. See `Vec4.mapBuffer` for the
     * inverse operation. Returns `buf`.
     *
     * @param buf -
     * @param src -
     * @param start -
     * @param cstride -
     * @param estride -
     */ static intoBuffer(buf, src, start = 0, cstride = 1, estride = 4) {
        return _bufferJs.intoStridedBuffer(_setsJs.setS4, buf, src, start, cstride, estride);
    }
    static *iterator(buf, num, start = 0, cstride = 1, estride = 4) {
        return _iteratorJs.vecIterator(Vec4, buf, num, start, cstride, estride);
    }
    [Symbol.iterator]() {
        return _iteratorJs.stridedValues(this.buf, 4, this.offset, this.stride);
    }
    get length() {
        return 4;
    }
    copy() {
        return new Vec4([
            this.x,
            this.y,
            this.z,
            this.w
        ]);
    }
    copyView() {
        return new Vec4(this.buf, this.offset, this.stride);
    }
    empty() {
        return new Vec4();
    }
    eqDelta(v, eps = _api.EPS) {
        return _eqdeltaJs.eqDelta4(this, v, eps);
    }
    hash() {
        return _hashJs.hash(this);
    }
    toJSON() {
        return [
            this.x,
            this.y,
            this.z,
            this.w
        ];
    }
}
Vec4.X_AXIS = new Vec4(_apiJs.X4);
Vec4.Y_AXIS = new Vec4(_apiJs.Y4);
Vec4.Z_AXIS = new Vec4(_apiJs.Z4);
Vec4.MIN = new Vec4(_apiJs.MIN4);
Vec4.MAX = new Vec4(_apiJs.MAX4);
Vec4.ZERO = new Vec4(_apiJs.ZERO4);
Vec4.ONE = new Vec4(_apiJs.ONE4);
_accessorsJs.declareIndices(Vec4.prototype, [
    "x",
    "y",
    "z",
    "w"
]);
const vec4 = (x = 0, y = 0, z = 0, w = 0)=>new Vec4([
        x,
        y,
        z,
        w
    ])
;
const vec4n = (n)=>new Vec4([
        n,
        n,
        n,
        n
    ])
;
const asVec4 = (x)=>x instanceof Vec4 ? x : new Vec4(x.length >= 4 ? x : [
        x[0] || 0,
        x[1] || 0,
        x[2] || 0,
        x[3] || 0
    ])
;

},{"@thi.ng/math/api":"4a98p","./compile/accessors.js":"5h29N","./api.js":"60HDf","./avec.js":"czAXr","./buffer.js":"ecaja","./eqdelta.js":"eBVIX","./hash.js":"e4rRM","./iterator.js":"dnjxi","./sets.js":"3jBTJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ivhHk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "abs", ()=>abs
);
parcelHelpers.export(exports, "abs2", ()=>abs2
);
parcelHelpers.export(exports, "abs3", ()=>abs3
);
parcelHelpers.export(exports, "abs4", ()=>abs4
);
var _emitJs = require("./compile/emit.js");
const [abs, abs2, abs3, abs4] = _emitJs.defFnOp("Math.abs");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kPmuu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "acos", ()=>acos
);
parcelHelpers.export(exports, "acos2", ()=>acos2
);
parcelHelpers.export(exports, "acos3", ()=>acos3
);
parcelHelpers.export(exports, "acos4", ()=>acos4
);
var _emitJs = require("./compile/emit.js");
const [acos, acos2, acos3, acos4] = _emitJs.defFnOp("Math.acos");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cFpxt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addW2", ()=>addW2
);
parcelHelpers.export(exports, "addW3", ()=>addW3
);
parcelHelpers.export(exports, "addW4", ()=>addW4
);
parcelHelpers.export(exports, "addW5", ()=>addW5
);
var _maddnJs = require("./maddn.js");
var _mulnJs = require("./muln.js");
const addW2 = (out, a, b, wa, wb)=>(!out && (out = a), _maddnJs.maddN(out, b, wb, _mulnJs.mulN(out, a, wa)))
;
const addW3 = (out, a, b, c, wa, wb, wc)=>(!out && (out = a), _maddnJs.maddN(out, c, wc, _maddnJs.maddN(out, b, wb, _mulnJs.mulN(out, a, wa))))
;
const addW4 = (out, a, b, c, d, wa, wb, wc, wd)=>(!out && (out = a), _maddnJs.maddN(out, d, wd, _maddnJs.maddN(out, c, wc, _maddnJs.maddN(out, b, wb, _mulnJs.mulN(out, a, wa)))))
;
const addW5 = (out, a, b, c, d, e, wa, wb, wc, wd, we)=>(!out && (out = a), _maddnJs.maddN(out, e, we, _maddnJs.maddN(out, d, wd, _maddnJs.maddN(out, c, wc, _maddnJs.maddN(out, b, wb, _mulnJs.mulN(out, a, wa))))))
;

},{"./maddn.js":"bTkou","./muln.js":"1TKlE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bTkou":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "maddN", ()=>maddN
);
parcelHelpers.export(exports, "maddN2", ()=>maddN2
);
parcelHelpers.export(exports, "maddN3", ()=>maddN3
);
parcelHelpers.export(exports, "maddN4", ()=>maddN4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [maddN, maddN2, maddN3, maddN4] = _emitJs.defOp(_templatesJs.MATH2A_N("*", "+"), _templatesJs.ARGS_VNV, _templatesJs.ARGS_VV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5JekR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addI", ()=>addI
);
parcelHelpers.export(exports, "addI2", ()=>addI2
);
parcelHelpers.export(exports, "addI3", ()=>addI3
);
parcelHelpers.export(exports, "addI4", ()=>addI4
);
parcelHelpers.export(exports, "addU", ()=>addU
);
parcelHelpers.export(exports, "addU2", ()=>addU2
);
parcelHelpers.export(exports, "addU3", ()=>addU3
);
parcelHelpers.export(exports, "addU4", ()=>addU4
);
parcelHelpers.export(exports, "addNI", ()=>addNI
);
parcelHelpers.export(exports, "addNI2", ()=>addNI2
);
parcelHelpers.export(exports, "addNI3", ()=>addNI3
);
parcelHelpers.export(exports, "addNI4", ()=>addNI4
);
parcelHelpers.export(exports, "addNU", ()=>addNU
);
parcelHelpers.export(exports, "addNU2", ()=>addNU2
);
parcelHelpers.export(exports, "addNU3", ()=>addNU3
);
parcelHelpers.export(exports, "addNU4", ()=>addNU4
);
var _emitJs = require("./compile/emit.js");
const [addI, addI2, addI3, addI4] = _emitJs.defBitOp("+", true);
const [addU, addU2, addU3, addU4] = _emitJs.defBitOp("+");
const [addNI, addNI2, addNI3, addNI4] = _emitJs.defBitOpN("+", true);
const [addNU, addNU2, addNU3, addNU4] = _emitJs.defBitOpN("+");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7tmcI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addm", ()=>addm
);
parcelHelpers.export(exports, "addm2", ()=>addm2
);
parcelHelpers.export(exports, "addm3", ()=>addm3
);
parcelHelpers.export(exports, "addm4", ()=>addm4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [addm, addm2, addm3, addm4] = _emitJs.defOp(_templatesJs.MATH2("+", "*"), _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cfDqf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addmS", ()=>addmS
);
parcelHelpers.export(exports, "addmS2", ()=>addmS2
);
parcelHelpers.export(exports, "addmS3", ()=>addmS3
);
parcelHelpers.export(exports, "addmS4", ()=>addmS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [addmS, addmS2, addmS3, addmS4] = _emitJs.defOpS(_templatesJs.MATH2("+", "*"), _templatesJs.ARGS_VVV, _templatesJs.SARGS_VVV, _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jvybo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addmNS", ()=>addmNS
);
parcelHelpers.export(exports, "addmNS2", ()=>addmNS2
);
parcelHelpers.export(exports, "addmNS3", ()=>addmNS3
);
parcelHelpers.export(exports, "addmNS4", ()=>addmNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [addmNS, addmNS2, addmNS3, addmNS4] = _emitJs.defOpS(_templatesJs.MATH2_N("+", "*"), _templatesJs.ARGS_VVN, _templatesJs.SARGS_VV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cZbCm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addS", ()=>addS
);
parcelHelpers.export(exports, "addS2", ()=>addS2
);
parcelHelpers.export(exports, "addS3", ()=>addS3
);
parcelHelpers.export(exports, "addS4", ()=>addS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [addS, addS2, addS3, addS4] = _emitJs.defOpS(_templatesJs.MATH("+"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cDsWw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addNS", ()=>addNS
);
parcelHelpers.export(exports, "addNS2", ()=>addNS2
);
parcelHelpers.export(exports, "addNS3", ()=>addNS3
);
parcelHelpers.export(exports, "addNS4", ()=>addNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [addNS, addNS2, addNS3, addNS4] = _emitJs.defOpS(_templatesJs.MATH_N("+"), _templatesJs.ARGS_VN, _templatesJs.SARGS_V, _templatesJs.ARGS_V);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8OhzV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "angleRatio", ()=>angleRatio
);
parcelHelpers.export(exports, "angleBetween2", ()=>angleBetween2
);
parcelHelpers.export(exports, "angleBetween3", ()=>angleBetween3
);
var _angle = require("@thi.ng/math/angle");
var _crossJs = require("./cross.js");
var _dotJs = require("./dot.js");
var _magJs = require("./mag.js");
const angleRatio = (a, b)=>_dotJs.dot(a, b) / (_magJs.mag(a) * _magJs.mag(b))
;
const angleBetween2 = (a, b, absInner = false)=>{
    const t = Math.atan2(_crossJs.cross2(a, b), _dotJs.dot(a, b));
    return absInner ? _angle.absInnerAngle(t) : t;
};
const angleBetween3 = (a, b, normalize = true, absInner = false)=>{
    const t = normalize ? Math.acos(angleRatio(a, b)) : Math.acos(_dotJs.dot(a, b));
    return absInner ? _angle.absInnerAngle(t) : t;
};

},{"@thi.ng/math/angle":"el41q","./cross.js":"a6Q1x","./dot.js":"9vV5N","./mag.js":"70TCJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"el41q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sincos", ()=>sincos
);
parcelHelpers.export(exports, "cossin", ()=>cossin
);
parcelHelpers.export(exports, "absTheta", ()=>absTheta
);
parcelHelpers.export(exports, "absInnerAngle", ()=>absInnerAngle
);
parcelHelpers.export(exports, "angleDist", ()=>angleDist
);
parcelHelpers.export(exports, "atan2Abs", ()=>atan2Abs
);
parcelHelpers.export(exports, "quadrant", ()=>quadrant
);
parcelHelpers.export(exports, "deg", ()=>deg
);
parcelHelpers.export(exports, "rad", ()=>rad
);
parcelHelpers.export(exports, "csc", ()=>csc
);
parcelHelpers.export(exports, "sec", ()=>sec
);
parcelHelpers.export(exports, "cot", ()=>cot
);
parcelHelpers.export(exports, "loc", ()=>loc
);
parcelHelpers.export(exports, "normCos", ()=>normCos
);
parcelHelpers.export(exports, "fastCos", ()=>fastCos
);
parcelHelpers.export(exports, "fastSin", ()=>fastSin
);
var _apiJs = require("./api.js");
const sincos = (theta, n = 1)=>[
        Math.sin(theta) * n,
        Math.cos(theta) * n, 
    ]
;
const cossin = (theta, n = 1)=>[
        Math.cos(theta) * n,
        Math.sin(theta) * n, 
    ]
;
const absTheta = (theta)=>(theta %= _apiJs.TAU, theta < 0 ? _apiJs.TAU + theta : theta)
;
const absInnerAngle = (theta)=>(theta = Math.abs(theta), theta > _apiJs.PI ? _apiJs.TAU - theta : theta)
;
const angleDist = (a, b)=>absInnerAngle(absTheta(b % _apiJs.TAU - a % _apiJs.TAU))
;
const atan2Abs = (y, x)=>absTheta(Math.atan2(y, x))
;
const quadrant = (theta)=>absTheta(theta) * _apiJs.INV_HALF_PI | 0
;
const deg = (theta)=>theta * _apiJs.RAD2DEG
;
const rad = (theta)=>theta * _apiJs.DEG2RAD
;
const csc = (theta)=>1 / Math.sin(theta)
;
const sec = (theta)=>1 / Math.cos(theta)
;
const cot = (theta)=>1 / Math.tan(theta)
;
const loc = (a, b, gamma)=>Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(gamma))
;
const normCos = (x)=>{
    const x2 = x * x;
    return 1 + x2 * (-4 + 2 * x2);
};
const __fastCos = (x)=>{
    const x2 = x * x;
    return 0.99940307 + x2 * (-0.49558072 + 0.03679168 * x2);
};
const fastCos = (theta)=>{
    theta %= _apiJs.TAU;
    theta < 0 && (theta = -theta);
    switch(theta * _apiJs.INV_HALF_PI | 0){
        case 0:
            return __fastCos(theta);
        case 1:
            return -__fastCos(_apiJs.PI - theta);
        case 2:
            return -__fastCos(theta - _apiJs.PI);
        default:
            return __fastCos(_apiJs.TAU - theta);
    }
};
const fastSin = (theta)=>fastCos(_apiJs.HALF_PI - theta)
;

},{"./api.js":"4a98p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a6Q1x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cross2", ()=>cross2
);
parcelHelpers.export(exports, "cross3", ()=>cross3
);
var _setcJs = require("./setc.js");
const cross2 = (a, b)=>a[0] * b[1] - a[1] * b[0]
;
const cross3 = (out, a, b)=>_setcJs.setC3(out || a, a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0])
;

},{"./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jST0o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setC2", ()=>setC2
);
parcelHelpers.export(exports, "setC3", ()=>setC3
);
parcelHelpers.export(exports, "setC4", ()=>setC4
);
parcelHelpers.export(exports, "setC6", ()=>setC6
);
parcelHelpers.export(exports, "setC", ()=>setC
);
const setC2 = (out, x, y)=>(!out && (out = []), out[0] = x, out[1] = y, out)
;
const setC3 = (out, x, y, z)=>(!out && (out = []), out[0] = x, out[1] = y, out[2] = z, out)
;
const setC4 = (out, x, y, z, w)=>(!out && (out = []), out[0] = x, out[1] = y, out[2] = z, out[3] = w, out)
;
const setC6 = (out, a, b, c, d, e, f)=>(!out && (out = []), out[0] = a, out[1] = b, out[2] = c, out[3] = d, out[4] = e, out[5] = f, out)
;
const setC = (out, ...xs)=>{
    !out && (out = []);
    for(let i = 0, n = xs.length; i < n; i++)out[i] = xs[i];
    return out;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"70TCJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mag", ()=>mag
);
var _magsqJs = require("./magsq.js");
const mag = (v)=>Math.sqrt(_magsqJs.magSq(v))
;

},{"./magsq.js":"bsMC4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fm4pB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "asin", ()=>asin
);
parcelHelpers.export(exports, "asin2", ()=>asin2
);
parcelHelpers.export(exports, "asin3", ()=>asin3
);
parcelHelpers.export(exports, "asin4", ()=>asin4
);
var _emitJs = require("./compile/emit.js");
const [asin, asin2, asin3, asin4] = _emitJs.defFnOp("Math.asin");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aiYhv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "atan", ()=>atan
);
parcelHelpers.export(exports, "atan2", ()=>atan2
);
parcelHelpers.export(exports, "atan3", ()=>atan3
);
parcelHelpers.export(exports, "atan4", ()=>atan4
);
parcelHelpers.export(exports, "atan_2", ()=>atan_2
);
parcelHelpers.export(exports, "atan_22", ()=>atan_22
);
parcelHelpers.export(exports, "atan_23", ()=>atan_23
);
parcelHelpers.export(exports, "atan_24", ()=>atan_24
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [atan, atan2, atan3, atan4] = _emitJs.defFnOp("Math.atan");
const [atan_2, atan_22, atan_23, atan_24] = _emitJs.defOp(_templatesJs.FN2("Math.atan2"), _templatesJs.ARGS_VV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bXCEG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bisect2", ()=>bisect2
);
parcelHelpers.export(exports, "cornerBisector", ()=>cornerBisector
);
parcelHelpers.export(exports, "cornerBisector2", ()=>cornerBisector2
);
var _api = require("@thi.ng/math/api");
var _addmnJs = require("./addmn.js");
var _directionJs = require("./direction.js");
var _headingJs = require("./heading.js");
var _mixnJs = require("./mixn.js");
var _normalizeJs = require("./normalize.js");
var _perpendicularJs = require("./perpendicular.js");
var _subJs = require("./sub.js");
const bisect2 = (a, b)=>{
    const theta = (_headingJs.headingXY(a) + _headingJs.headingXY(b)) / 2;
    return theta <= _api.HALF_PI ? theta : _api.PI - theta;
};
const cornerBisector = (out, a, b, c, n = 1)=>(!out && (out = []), _normalizeJs.normalize(out, _addmnJs.addmN(out, _normalizeJs.normalize(out, _subJs.sub(out, a, b)), _normalizeJs.normalize(null, _subJs.sub([], c, b)), 0.5), n))
;
const cornerBisector2 = (out, a, b, c, n = 1)=>(!out && (out = []), _perpendicularJs.perpendicularCCW(out, _normalizeJs.normalize(out, _mixnJs.mixN2(out, _directionJs.direction(out, a, b), _directionJs.direction([], b, c), 0.5), n)))
;

},{"@thi.ng/math/api":"4a98p","./addmn.js":"9C52h","./direction.js":"g7PP7","./heading.js":"jM0y9","./mixn.js":"jolPM","./normalize.js":"9ex3j","./perpendicular.js":"dnMKL","./sub.js":"fzaw7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g7PP7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "direction", ()=>direction
);
var _normalizeJs = require("./normalize.js");
var _subJs = require("./sub.js");
const direction = (out, a, b, n = 1)=>_normalizeJs.normalize(null, _subJs.sub(out || a, b, a), n)
;

},{"./normalize.js":"9ex3j","./sub.js":"fzaw7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9ex3j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "normalize", ()=>normalize
);
var _api = require("@thi.ng/math/api");
var _magJs = require("./mag.js");
var _mulnJs = require("./muln.js");
var _setJs = require("./set.js");
const normalize = (out, v, n = 1)=>{
    !out && (out = v);
    const m = _magJs.mag(v);
    return m >= _api.EPS ? _mulnJs.mulN(out, v, n / m) : out !== v ? _setJs.set(out, v) : out;
};

},{"@thi.ng/math/api":"4a98p","./mag.js":"70TCJ","./muln.js":"1TKlE","./set.js":"bSUB8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jM0y9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "headingXY", ()=>headingXY
);
parcelHelpers.export(exports, "headingXZ", ()=>headingXZ
);
parcelHelpers.export(exports, "headingYZ", ()=>headingYZ
);
parcelHelpers.export(exports, "heading", ()=>heading
);
var _angle = require("@thi.ng/math/angle");
const headingXY = (a)=>_angle.atan2Abs(a[1], a[0])
;
const headingXZ = (a)=>_angle.atan2Abs(a[2], a[0])
;
const headingYZ = (a)=>_angle.atan2Abs(a[2], a[1])
;
const heading = headingXY;

},{"@thi.ng/math/angle":"el41q","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dnMKL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "perpendicularCCW", ()=>perpendicularCCW
);
parcelHelpers.export(exports, "perpendicularCW", ()=>perpendicularCW
);
var _setcJs = require("./setc.js");
const perpendicularCCW = (out, a)=>_setcJs.setC2(out || a, -a[1], a[0])
;
const perpendicularCW = (out, a)=>_setcJs.setC2(out || a, a[1], -a[0])
;

},{"./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ihEMJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bitAndI", ()=>bitAndI
);
parcelHelpers.export(exports, "bitAndI2", ()=>bitAndI2
);
parcelHelpers.export(exports, "bitAndI3", ()=>bitAndI3
);
parcelHelpers.export(exports, "bitAndI4", ()=>bitAndI4
);
parcelHelpers.export(exports, "bitAndU", ()=>bitAndU
);
parcelHelpers.export(exports, "bitAndU2", ()=>bitAndU2
);
parcelHelpers.export(exports, "bitAndU3", ()=>bitAndU3
);
parcelHelpers.export(exports, "bitAndU4", ()=>bitAndU4
);
parcelHelpers.export(exports, "bitAndNI", ()=>bitAndNI
);
parcelHelpers.export(exports, "bitAndNI2", ()=>bitAndNI2
);
parcelHelpers.export(exports, "bitAndNI3", ()=>bitAndNI3
);
parcelHelpers.export(exports, "bitAndNI4", ()=>bitAndNI4
);
parcelHelpers.export(exports, "bitAndNU", ()=>bitAndNU
);
parcelHelpers.export(exports, "bitAndNU2", ()=>bitAndNU2
);
parcelHelpers.export(exports, "bitAndNU3", ()=>bitAndNU3
);
parcelHelpers.export(exports, "bitAndNU4", ()=>bitAndNU4
);
var _emitJs = require("./compile/emit.js");
const [bitAndI, bitAndI2, bitAndI3, bitAndI4] = _emitJs.defBitOp("&", true);
const [bitAndU, bitAndU2, bitAndU3, bitAndU4] = _emitJs.defBitOp("&");
const [bitAndNI, bitAndNI2, bitAndNI3, bitAndNI4] = _emitJs.defBitOpN("&", true);
const [bitAndNU, bitAndNU2, bitAndNU3, bitAndNU4] = _emitJs.defBitOpN("&");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5kBRM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bitNotI", ()=>bitNotI
);
parcelHelpers.export(exports, "bitNotI2", ()=>bitNotI2
);
parcelHelpers.export(exports, "bitNotI3", ()=>bitNotI3
);
parcelHelpers.export(exports, "bitNotI4", ()=>bitNotI4
);
parcelHelpers.export(exports, "bitNotU", ()=>bitNotU
);
parcelHelpers.export(exports, "bitNotU2", ()=>bitNotU2
);
parcelHelpers.export(exports, "bitNotU3", ()=>bitNotU3
);
parcelHelpers.export(exports, "bitNotU4", ()=>bitNotU4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [bitNotI, bitNotI2, bitNotI3, bitNotI4] = _emitJs.defOp(([o, a])=>`${o}=(~${a})|0;`
, _templatesJs.ARGS_V);
const [bitNotU, bitNotU2, bitNotU3, bitNotU4] = _emitJs.defOp(([o, a])=>`${o}=(~${a})>>>0;`
, _templatesJs.ARGS_V);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8o6Ie":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bitOrI", ()=>bitOrI
);
parcelHelpers.export(exports, "bitOrI2", ()=>bitOrI2
);
parcelHelpers.export(exports, "bitOrI3", ()=>bitOrI3
);
parcelHelpers.export(exports, "bitOrI4", ()=>bitOrI4
);
parcelHelpers.export(exports, "bitOrU", ()=>bitOrU
);
parcelHelpers.export(exports, "bitOrU2", ()=>bitOrU2
);
parcelHelpers.export(exports, "bitOrU3", ()=>bitOrU3
);
parcelHelpers.export(exports, "bitOrU4", ()=>bitOrU4
);
parcelHelpers.export(exports, "bitOrNI", ()=>bitOrNI
);
parcelHelpers.export(exports, "bitOrNI2", ()=>bitOrNI2
);
parcelHelpers.export(exports, "bitOrNI3", ()=>bitOrNI3
);
parcelHelpers.export(exports, "bitOrNI4", ()=>bitOrNI4
);
parcelHelpers.export(exports, "bitOrNU", ()=>bitOrNU
);
parcelHelpers.export(exports, "bitOrNU2", ()=>bitOrNU2
);
parcelHelpers.export(exports, "bitOrNU3", ()=>bitOrNU3
);
parcelHelpers.export(exports, "bitOrNU4", ()=>bitOrNU4
);
var _emitJs = require("./compile/emit.js");
const [bitOrI, bitOrI2, bitOrI3, bitOrI4] = _emitJs.defBitOp("|", true);
const [bitOrU, bitOrU2, bitOrU3, bitOrU4] = _emitJs.defBitOp("|");
const [bitOrNI, bitOrNI2, bitOrNI3, bitOrNI4] = _emitJs.defBitOpN("|", true);
const [bitOrNU, bitOrNU2, bitOrNU3, bitOrNU4] = _emitJs.defBitOpN("|");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7BWzt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bitXorI", ()=>bitXorI
);
parcelHelpers.export(exports, "bitXorI2", ()=>bitXorI2
);
parcelHelpers.export(exports, "bitXorI3", ()=>bitXorI3
);
parcelHelpers.export(exports, "bitXorI4", ()=>bitXorI4
);
parcelHelpers.export(exports, "bitXorU", ()=>bitXorU
);
parcelHelpers.export(exports, "bitXorU2", ()=>bitXorU2
);
parcelHelpers.export(exports, "bitXorU3", ()=>bitXorU3
);
parcelHelpers.export(exports, "bitXorU4", ()=>bitXorU4
);
parcelHelpers.export(exports, "bitXorNI", ()=>bitXorNI
);
parcelHelpers.export(exports, "bitXorNI2", ()=>bitXorNI2
);
parcelHelpers.export(exports, "bitXorNI3", ()=>bitXorNI3
);
parcelHelpers.export(exports, "bitXorNI4", ()=>bitXorNI4
);
parcelHelpers.export(exports, "bitXorNU", ()=>bitXorNU
);
parcelHelpers.export(exports, "bitXorNU2", ()=>bitXorNU2
);
parcelHelpers.export(exports, "bitXorNU3", ()=>bitXorNU3
);
parcelHelpers.export(exports, "bitXorNU4", ()=>bitXorNU4
);
var _emitJs = require("./compile/emit.js");
const [bitXorI, bitXorI2, bitXorI3, bitXorI4] = _emitJs.defBitOp("^", true);
const [bitXorU, bitXorU2, bitXorU3, bitXorU4] = _emitJs.defBitOp("^");
const [bitXorNI, bitXorNI2, bitXorNI3, bitXorNI4] = _emitJs.defBitOpN("^", true);
const [bitXorNU, bitXorNU2, bitXorNU3, bitXorNU4] = _emitJs.defBitOpN("^");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g2NFB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cartesian", ()=>cartesian
);
parcelHelpers.export(exports, "cartesian2", ()=>cartesian2
);
parcelHelpers.export(exports, "cartesian3", ()=>cartesian3
);
var _angle = require("@thi.ng/math/angle");
var _addJs = require("./add.js");
var _apiJs = require("./api.js");
var _setcJs = require("./setc.js");
var _vopJs = require("./vop.js");
const cos = Math.cos;
const sin = Math.sin;
const cartesian = _vopJs.vop(1);
const cartesian2 = cartesian.add(2, (out, a, b = _apiJs.ZERO2)=>_addJs.add2(out || a, _angle.cossin(a[1], a[0]), b)
);
const cartesian3 = cartesian.add(3, (out, a, b = _apiJs.ZERO3)=>{
    const r = a[0];
    const theta = a[1];
    const phi = a[2];
    const ct = cos(theta);
    return _setcJs.setC3(out || a, r * ct * cos(phi) + b[0], r * ct * sin(phi) + b[1], r * sin(theta) + b[2]);
});

},{"@thi.ng/math/angle":"el41q","./add.js":"6HmvS","./api.js":"60HDf","./setc.js":"jST0o","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2tmeM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ceil", ()=>ceil
);
parcelHelpers.export(exports, "ceil2", ()=>ceil2
);
parcelHelpers.export(exports, "ceil3", ()=>ceil3
);
parcelHelpers.export(exports, "ceil4", ()=>ceil4
);
var _emitJs = require("./compile/emit.js");
const [ceil, ceil2, ceil3, ceil4] = _emitJs.defFnOp("Math.ceil");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2MkSv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "center", ()=>center
);
var _meanJs = require("./mean.js");
var _subnJs = require("./subn.js");
const center = (out, a)=>_subnJs.subN(out, a, _meanJs.vmean(a))
;

},{"./mean.js":"7w5sd","./subn.js":"i3npD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7w5sd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mean", ()=>mean
);
parcelHelpers.export(exports, "vmean", ()=>vmean
);
var _addJs = require("./add.js");
var _ensureJs = require("./internal/ensure.js");
var _mulnJs = require("./muln.js");
var _setJs = require("./set.js");
var _sumJs = require("./sum.js");
const mean = (out, src)=>{
    _ensureJs.__ensureInputs(src);
    out = _setJs.set(out || [], src[0]);
    for(let i = src.length; i-- > 1;)_addJs.add(out, out, src[i]);
    return _mulnJs.mulN(out, out, 1 / src.length);
};
const vmean = (a)=>a.length > 0 ? _sumJs.sum(a) / a.length : 0
;

},{"./add.js":"6HmvS","./internal/ensure.js":"dq2YU","./muln.js":"1TKlE","./set.js":"bSUB8","./sum.js":"2gBvR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dq2YU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__ensureInputs", ()=>__ensureInputs
);
var _assert = require("@thi.ng/errors/assert");
const __ensureInputs = (src)=>_assert.assert(src.length > 0, `no inputs given`)
;

},{"@thi.ng/errors/assert":"zM8kA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2gBvR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sum", ()=>sum
);
parcelHelpers.export(exports, "sum2", ()=>sum2
);
parcelHelpers.export(exports, "sum3", ()=>sum3
);
parcelHelpers.export(exports, "sum4", ()=>sum4
);
var _add = require("@thi.ng/transducers/add");
var _reduce = require("@thi.ng/transducers/reduce");
var _vopJs = require("./vop.js");
const sum = _vopJs.vop();
sum.default((v)=>_reduce.reduce(_add.add(), v)
);
const sum2 = sum.add(2, (a)=>a[0] + a[1]
);
const sum3 = sum.add(3, (a)=>a[0] + a[1] + a[2]
);
const sum4 = sum.add(4, (a)=>a[0] + a[1] + a[2] + a[3]
);

},{"@thi.ng/transducers/add":"92liA","@thi.ng/transducers/reduce":"hP05c","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"92liA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "add", ()=>add
);
var _mathopJs = require("./internal/mathop.js");
function add(...args) {
    return _mathopJs.__mathop(add, (acc, x)=>acc + x
    , 0, args);
}

},{"./internal/mathop.js":"2ModK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2ModK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__mathop", ()=>__mathop
);
var _reduceJs = require("../reduce.js");
const __mathop = (rfn, fn, initDefault, args)=>{
    const res = _reduceJs.$$reduce(rfn, args);
    if (res !== undefined) return res;
    const init = args[0] || initDefault;
    return _reduceJs.reducer(()=>init
    , fn);
};

},{"../reduce.js":"hP05c","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k99Yr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "clamp", ()=>clamp
);
parcelHelpers.export(exports, "clamp2", ()=>clamp2
);
parcelHelpers.export(exports, "clamp3", ()=>clamp3
);
parcelHelpers.export(exports, "clamp4", ()=>clamp4
);
parcelHelpers.export(exports, "clamp01", ()=>clamp01
);
parcelHelpers.export(exports, "clamp01_2", ()=>clamp01_2
);
parcelHelpers.export(exports, "clamp01_3", ()=>clamp01_3
);
parcelHelpers.export(exports, "clamp01_4", ()=>clamp01_4
);
parcelHelpers.export(exports, "clamp11", ()=>clamp11
);
parcelHelpers.export(exports, "clamp11_2", ()=>clamp11_2
);
parcelHelpers.export(exports, "clamp11_3", ()=>clamp11_3
);
parcelHelpers.export(exports, "clamp11_4", ()=>clamp11_4
);
var _interval = require("@thi.ng/math/interval");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [clamp, clamp2, clamp3, clamp4] = _emitJs.defHofOp(_interval.clamp, _templatesJs.FN3(), _templatesJs.ARGS_VVV);
const [clamp01, clamp01_2, clamp01_3, clamp01_4] = _emitJs.defHofOp(_interval.clamp01, _templatesJs.FN(), _templatesJs.ARGS_V);
const [clamp11, clamp11_2, clamp11_3, clamp11_4] = _emitJs.defHofOp(_interval.clamp11, _templatesJs.FN(), _templatesJs.ARGS_V);

},{"@thi.ng/math/interval":"1TDWA","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4kXdw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "clampN", ()=>clampN
);
parcelHelpers.export(exports, "clampN2", ()=>clampN2
);
parcelHelpers.export(exports, "clampN3", ()=>clampN3
);
parcelHelpers.export(exports, "clampN4", ()=>clampN4
);
var _interval = require("@thi.ng/math/interval");
var _emitJs = require("./compile/emit.js");
const [clampN, clampN2, clampN3, clampN4] = _emitJs.defHofOp(_interval.clamp, ([o, a])=>`${o}=op(${a},n,m);`
, "o,a,n,m", "o,a");

},{"@thi.ng/math/interval":"1TDWA","./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b5iVX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "comparator2", ()=>comparator2
);
parcelHelpers.export(exports, "comparator3", ()=>comparator3
);
parcelHelpers.export(exports, "comparator4", ()=>comparator4
);
const comparator2 = (o1, o2)=>(a, b)=>{
        const ax = a[o1];
        const ay = a[o2];
        const bx = b[o1];
        const by = b[o2];
        return ax === bx ? ay === by ? 0 : ay < by ? -2 : 2 : ax < bx ? -1 : 1;
    }
;
const comparator3 = (o1, o2, o3)=>(a, b)=>{
        const ax = a[o1];
        const ay = a[o2];
        const az = a[o3];
        const bx = b[o1];
        const by = b[o2];
        const bz = b[o3];
        return ax === bx ? ay === by ? az === bz ? 0 : az < bz ? -3 : 3 : ay < by ? -2 : 2 : ax < bx ? -1 : 1;
    }
;
const comparator4 = (o1, o2, o3, o4)=>(a, b)=>{
        const ax = a[o1];
        const ay = a[o2];
        const az = a[o3];
        const aw = b[o4];
        const bx = b[o1];
        const by = b[o2];
        const bz = b[o3];
        const bw = b[o4];
        return ax === bx ? ay === by ? az === bz ? aw === bw ? 0 : aw < bw ? -4 : 4 : az < bz ? -3 : 3 : ay < by ? -2 : 2 : ax < bx ? -1 : 1;
    }
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hGWRF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "asIVec", ()=>asIVec
);
parcelHelpers.export(exports, "asIVec2", ()=>asIVec2
);
parcelHelpers.export(exports, "asIVec3", ()=>asIVec3
);
parcelHelpers.export(exports, "asIVec4", ()=>asIVec4
);
parcelHelpers.export(exports, "asUVec", ()=>asUVec
);
parcelHelpers.export(exports, "asUVec2", ()=>asUVec2
);
parcelHelpers.export(exports, "asUVec3", ()=>asUVec3
);
parcelHelpers.export(exports, "asUVec4", ()=>asUVec4
);
parcelHelpers.export(exports, "asBVec", ()=>asBVec
);
parcelHelpers.export(exports, "asBVec2", ()=>asBVec2
);
parcelHelpers.export(exports, "asBVec3", ()=>asBVec3
);
parcelHelpers.export(exports, "asBVec4", ()=>asBVec4
);
parcelHelpers.export(exports, "fromBVec", ()=>fromBVec
);
parcelHelpers.export(exports, "fromBVec2", ()=>fromBVec2
);
parcelHelpers.export(exports, "fromBVec3", ()=>fromBVec3
);
parcelHelpers.export(exports, "fromBVec4", ()=>fromBVec4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const $ = (tpl, pre = _templatesJs.NEW_OUT)=>_emitJs.defOp(tpl, _templatesJs.ARGS_V, _templatesJs.ARGS_V, "o", 1, pre)
;
const [asIVec, asIVec2, asIVec3, asIVec4] = $(([o, a])=>`${o}=${a}|0;`
);
const [asUVec, asUVec2, asUVec3, asUVec4] = $(([o, a])=>`${o}=${a}>>>0;`
);
const [asBVec, asBVec2, asBVec3, asBVec4] = $(([o, a])=>`${o}=!!${a};`
);
const [fromBVec, fromBVec2, fromBVec3, fromBVec4] = $(([o, a])=>`${o}=~~${a};`
);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4RdrM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "copy", ()=>copy
);
parcelHelpers.export(exports, "copyVectors", ()=>copyVectors
);
var _implementsFunction = require("@thi.ng/checks/implements-function");
var _setJs = require("./set.js");
const copy = (v)=>_implementsFunction.implementsFunction(v, "copy") ? v.copy() : _setJs.set([], v)
;
const copyVectors = (pts)=>pts.map(copy)
;

},{"@thi.ng/checks/implements-function":"cjrzK","./set.js":"bSUB8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5oxGU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "correlation", ()=>correlation
);
var _centerJs = require("./center.js");
var _magJs = require("./mag.js");
var _mulJs = require("./mul.js");
var _sumJs = require("./sum.js");
const correlation = (a, b)=>{
    a = _centerJs.center([], a);
    b = _centerJs.center([], b);
    const m = _magJs.mag(a) * _magJs.mag(b);
    return m !== 0 ? _sumJs.sum(_mulJs.mul(null, a, b)) / m : undefined;
};

},{"./center.js":"2MkSv","./mag.js":"70TCJ","./mul.js":"bTRb3","./sum.js":"2gBvR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bTRb3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "mul2", ()=>mul2
);
parcelHelpers.export(exports, "mul3", ()=>mul3
);
parcelHelpers.export(exports, "mul4", ()=>mul4
);
var _emitJs = require("./compile/emit.js");
const [mul, mul2, mul3, mul4] = _emitJs.defMathOp("*");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kXrcE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cos", ()=>cos
);
parcelHelpers.export(exports, "cos2", ()=>cos2
);
parcelHelpers.export(exports, "cos3", ()=>cos3
);
parcelHelpers.export(exports, "cos4", ()=>cos4
);
var _emitJs = require("./compile/emit.js");
const [cos, cos2, cos3, cos4] = _emitJs.defFnOp("Math.cos");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"O9xPf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cosh", ()=>cosh
);
parcelHelpers.export(exports, "cosh2", ()=>cosh2
);
parcelHelpers.export(exports, "cosh3", ()=>cosh3
);
parcelHelpers.export(exports, "cosh4", ()=>cosh4
);
var _emitJs = require("./compile/emit.js");
const [cosh, cosh2, cosh3, cosh4] = _emitJs.defFnOp("Math.cosh");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"alatG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "covariance", ()=>covariance
);
var _centerJs = require("./center.js");
var _mulJs = require("./mul.js");
var _sumJs = require("./sum.js");
const covariance = (a, b)=>_sumJs.sum(_mulJs.mul(null, _centerJs.center([], a), _centerJs.center([], b))) / (a.length - 1)
;

},{"./center.js":"2MkSv","./mul.js":"bTRb3","./sum.js":"2gBvR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2Nw0k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "crossS2", ()=>crossS2
);
parcelHelpers.export(exports, "crossS3", ()=>crossS3
);
var _setcsJs = require("./setcs.js");
const crossS2 = (a, b, ia = 0, ib = 0, sa = 1, sb = 1)=>a[ia] * b[ib + sb] - a[ia + sa] * b[ib]
;
const crossS3 = (out, a, b, io = 0, ia = 0, ib = 0, so = 1, sa = 1, sb = 1)=>_setcsJs.setCS3(out || a, a[ia + sa] * b[ib + 2 * sb] - a[ia + 2 * sa] * b[ib + sb], a[ia + 2 * sa] * b[ib] - a[ia] * b[ib + 2 * sb], a[ia] * b[ib + sb] - a[ia + sa] * b[ib], io, so)
;

},{"./setcs.js":"35qNU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"35qNU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setCS2", ()=>setCS2
);
parcelHelpers.export(exports, "setCS3", ()=>setCS3
);
parcelHelpers.export(exports, "setCS4", ()=>setCS4
);
const setCS2 = (out, x, y, io = 0, so = 1)=>(!out && (out = []), out[io] = x, out[io + so] = y, out)
;
const setCS3 = (out, x, y, z, io = 0, so = 1)=>(!out && (out = []), out[io] = x, out[io + so] = y, out[io + 2 * so] = z, out)
;
const setCS4 = (out, x, y, z, w, io = 0, so = 1)=>(!out && (out = []), out[io] = x, out[io + so] = y, out[io + 2 * so] = z, out[io + 3 * so] = w, out)
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8oHW5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "degrees", ()=>degrees
);
parcelHelpers.export(exports, "degrees2", ()=>degrees2
);
parcelHelpers.export(exports, "degrees3", ()=>degrees3
);
parcelHelpers.export(exports, "degrees4", ()=>degrees4
);
var _angle = require("@thi.ng/math/angle");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [degrees, degrees2, degrees3, degrees4] = _emitJs.defHofOp(_angle.deg, _templatesJs.FN("op"));

},{"@thi.ng/math/angle":"el41q","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8W4oS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distBrayCurtis", ()=>distBrayCurtis
);
const distBrayCurtis = (a, b)=>{
    let c = 0;
    let s = 0;
    for(let i = a.length; i-- > 0;){
        c += Math.abs(a[i] - b[i]);
        s += Math.abs(a[i] + b[i]);
    }
    return s > 0 ? c / s : 0;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bsKNq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distCanberra", ()=>distCanberra
);
const distCanberra = (a, b)=>{
    let delta = 0;
    for(let i = a.length; i-- > 0;){
        const aa = a[i];
        const bb = b[i];
        const d = Math.abs(aa) + Math.abs(bb);
        d > 0 && (delta += Math.abs(aa - bb) / d);
    }
    return delta;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kKt2g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distChebyshev", ()=>distChebyshev
);
parcelHelpers.export(exports, "distChebyshev2", ()=>distChebyshev2
);
parcelHelpers.export(exports, "distChebyshev3", ()=>distChebyshev3
);
parcelHelpers.export(exports, "distChebyshev4", ()=>distChebyshev4
);
var _emitJs = require("./compile/emit.js");
var _vopJs = require("./vop.js");
const $ = (dim)=>distChebyshev.add(dim, _emitJs.compile(dim, ([a, b])=>`Math.abs(${a}-${b})`
    , "a,b", undefined, "", ",", "return Math.max(", ");"))
;
const distChebyshev = _vopJs.vop();
distChebyshev.default((a, b)=>{
    let max = 0;
    for(let i = a.length; i-- > 0;)max = Math.max(max, Math.abs(a[i] - b[i]));
    return max;
});
const distChebyshev2 = $(2);
const distChebyshev3 = $(3);
const distChebyshev4 = $(4);

},{"./compile/emit.js":"hpIek","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gmYUE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distHamming", ()=>distHamming
);
const distHamming = (a, b)=>{
    let delta = 0;
    for(let i = a.length; i-- > 0;)a[i] !== b[i] && delta++;
    return delta / a.length;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c8sP5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distHaversineLatLon", ()=>distHaversineLatLon
);
parcelHelpers.export(exports, "distHaversineLonLat", ()=>distHaversineLonLat
);
parcelHelpers.export(exports, "distHaversine", ()=>distHaversine
);
var _radiansJs = require("./radians.js");
const distHaversineLatLon = (a, b, r = 6371)=>{
    a = _radiansJs.radians2([], a);
    b = _radiansJs.radians2([], b);
    return dist(a[0], a[1], b[0], b[1], r);
};
const distHaversineLonLat = (a, b, r = 6371)=>{
    a = _radiansJs.radians2([], a);
    b = _radiansJs.radians2([], b);
    return dist(a[1], a[0], b[1], b[0], r);
};
const distHaversine = distHaversineLonLat;
const dist = (lat1, lon1, lat2, lon2, r)=>{
    const dlat = 0.5 - Math.cos(lat2 - lat1) * 0.5;
    const dlon = (1 - Math.cos(lon2 - lon1)) * 0.5;
    const combined = dlat + Math.cos(lat1) * Math.cos(lat2) * dlon;
    return 2 * r * Math.asin(Math.sqrt(combined));
};

},{"./radians.js":"4f5wk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4f5wk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "radians", ()=>radians
);
parcelHelpers.export(exports, "radians2", ()=>radians2
);
parcelHelpers.export(exports, "radians3", ()=>radians3
);
parcelHelpers.export(exports, "radians4", ()=>radians4
);
var _angle = require("@thi.ng/math/angle");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [radians, radians2, radians3, radians4] = _emitJs.defHofOp(_angle.rad, _templatesJs.FN("op"));

},{"@thi.ng/math/angle":"el41q","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8rqoi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distJaccard", ()=>distJaccard
);
const distJaccard = (a, b)=>{
    let numNZ = 0;
    let numEQ = 0;
    for(let i = a.length; i-- > 0;){
        const aa = a[i] !== 0;
        const bb = b[i] !== 0;
        numNZ += ~~(aa || bb);
        numEQ += ~~(aa && bb);
    }
    return numNZ ? (numNZ - numEQ) / numNZ : 0;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dV6Jy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distManhattan", ()=>distManhattan
);
parcelHelpers.export(exports, "distManhattan2", ()=>distManhattan2
);
parcelHelpers.export(exports, "distManhattan3", ()=>distManhattan3
);
parcelHelpers.export(exports, "distManhattan4", ()=>distManhattan4
);
var _emitJs = require("./compile/emit.js");
var _vopJs = require("./vop.js");
const $ = (dim)=>distManhattan.add(dim, _emitJs.compile(dim, ([a, b])=>`Math.abs(${a}-${b})`
    , "a,b", undefined, "", "+", "return ", ";"))
;
const distManhattan = _vopJs.vop();
distManhattan.default(_emitJs.compileG(([a, b])=>`sum+=Math.abs(${a}-${b});`
, "a,b", undefined, "sum", "let sum=0;"));
const distManhattan2 = $(2);
const distManhattan3 = $(3);
const distManhattan4 = $(4);

},{"./compile/emit.js":"hpIek","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"85fil":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distMinkowski", ()=>distMinkowski
);
const distMinkowski = (a, b, p)=>{
    let delta = 0;
    for(let i = a.length; i-- > 0;)delta += Math.abs(a[i] - b[i]) ** p;
    return delta ** (1 / p);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eyp87":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distSorensenDice", ()=>distSorensenDice
);
const distSorensenDice = (a, b)=>{
    let numTP = 0;
    let numFP = 0;
    for(let i = a.length; i-- > 0;){
        const aa = a[i] !== 0;
        const bb = b[i] !== 0;
        numTP += ~~(aa && bb);
        numFP += ~~(aa !== bb);
    }
    return numFP ? numFP / (2 * numTP + numFP) : 0;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"btBuC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "weightedDistance", ()=>weightedDistance
);
var _mulJs = require("./mul.js");
const weightedDistance = (fn, weights)=>(a, b)=>fn(_mulJs.mul([], a, weights), _mulJs.mul([], b, weights))
;

},{"./mul.js":"bTRb3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hac1Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "divI", ()=>divI
);
parcelHelpers.export(exports, "divI2", ()=>divI2
);
parcelHelpers.export(exports, "divI3", ()=>divI3
);
parcelHelpers.export(exports, "divI4", ()=>divI4
);
parcelHelpers.export(exports, "divU", ()=>divU
);
parcelHelpers.export(exports, "divU2", ()=>divU2
);
parcelHelpers.export(exports, "divU3", ()=>divU3
);
parcelHelpers.export(exports, "divU4", ()=>divU4
);
parcelHelpers.export(exports, "divNI", ()=>divNI
);
parcelHelpers.export(exports, "divNI2", ()=>divNI2
);
parcelHelpers.export(exports, "divNI3", ()=>divNI3
);
parcelHelpers.export(exports, "divNI4", ()=>divNI4
);
parcelHelpers.export(exports, "divNU", ()=>divNU
);
parcelHelpers.export(exports, "divNU2", ()=>divNU2
);
parcelHelpers.export(exports, "divNU3", ()=>divNU3
);
parcelHelpers.export(exports, "divNU4", ()=>divNU4
);
var _emitJs = require("./compile/emit.js");
const [divI, divI2, divI3, divI4] = _emitJs.defBitOp("/", true);
const [divU, divU2, divU3, divU4] = _emitJs.defBitOp("/");
const [divNI, divNI2, divNI3, divNI4] = _emitJs.defBitOpN("/", true);
const [divNU, divNU2, divNU3, divNU4] = _emitJs.defBitOpN("/");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8VZzE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "divN", ()=>divN
);
parcelHelpers.export(exports, "divN2", ()=>divN2
);
parcelHelpers.export(exports, "divN3", ()=>divN3
);
parcelHelpers.export(exports, "divN4", ()=>divN4
);
var _emitJs = require("./compile/emit.js");
const [divN, divN2, divN3, divN4] = _emitJs.defMathOpN("/");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c7wQo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "divS", ()=>divS
);
parcelHelpers.export(exports, "divS2", ()=>divS2
);
parcelHelpers.export(exports, "divS3", ()=>divS3
);
parcelHelpers.export(exports, "divS4", ()=>divS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [divS, divS2, divS3, divS4] = _emitJs.defOpS(_templatesJs.MATH("/"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"afuXO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "divNS", ()=>divNS
);
parcelHelpers.export(exports, "divNS2", ()=>divNS2
);
parcelHelpers.export(exports, "divNS3", ()=>divNS3
);
parcelHelpers.export(exports, "divNS4", ()=>divNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [divNS, divNS2, divNS3, divNS4] = _emitJs.defOpS(_templatesJs.MATH_N("/"), _templatesJs.ARGS_VN, _templatesJs.SARGS_V, _templatesJs.ARGS_V);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cU5Pz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dotC4", ()=>dotC4
);
parcelHelpers.export(exports, "dotC6", ()=>dotC6
);
parcelHelpers.export(exports, "dotC8", ()=>dotC8
);
const dotC4 = (a, b, c, d)=>a * b + c * d
;
const dotC6 = (a, b, c, d, e, f)=>a * b + c * d + e * f
;
const dotC8 = (a, b, c, d, e, f, g, h)=>a * b + c * d + e * f + g * h
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3KJkk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dotS", ()=>dotS
);
parcelHelpers.export(exports, "dotS2", ()=>dotS2
);
parcelHelpers.export(exports, "dotS3", ()=>dotS3
);
parcelHelpers.export(exports, "dotS4", ()=>dotS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const dotS = (a, b, n, ia = 0, ib = 0, sa = 1, sb = 1)=>{
    let sum = 0;
    for(; n-- > 0; ia += sa, ib += sb)sum += a[ia] * b[ib];
    return sum;
};
const $ = (dim)=>_emitJs.compile(dim, _templatesJs.DOT, `o,a,${_templatesJs.SARGS_V}`, "o,a", "", "+", "return ", ";", true)
;
const dotS2 = $(2);
const dotS3 = $(3);
const dotS4 = $(4);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kHThs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "every", ()=>every
);
parcelHelpers.export(exports, "every2", ()=>every2
);
parcelHelpers.export(exports, "every3", ()=>every3
);
parcelHelpers.export(exports, "every4", ()=>every4
);
var _vopJs = require("./vop.js");
const every = _vopJs.vop();
every.default((v)=>{
    for(let i = v.length; i-- > 0;){
        if (!v[i]) return false;
    }
    return true;
});
const every2 = every.add(2, (a)=>a[0] && a[1]
);
const every3 = every.add(3, (a)=>a[0] && a[1] && a[2]
);
const every4 = every.add(4, (a)=>a[0] && a[1] && a[2] && a[3]
);

},{"./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Qp2H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "exp", ()=>exp
);
parcelHelpers.export(exports, "exp2", ()=>exp2
);
parcelHelpers.export(exports, "exp3", ()=>exp3
);
parcelHelpers.export(exports, "exp4", ()=>exp4
);
var _emitJs = require("./compile/emit.js");
const [exp, exp2, exp3, exp4] = _emitJs.defFnOp("Math.exp");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9UjlL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "exp_2", ()=>exp_2
);
parcelHelpers.export(exports, "exp_22", ()=>exp_22
);
parcelHelpers.export(exports, "exp_23", ()=>exp_23
);
parcelHelpers.export(exports, "exp_24", ()=>exp_24
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [exp_2, exp_22, exp_23, exp_24] = _emitJs.defOp(([o, a])=>`${o}=Math.pow(2,${a});`
, _templatesJs.ARGS_V);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iuxjX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "faceForward", ()=>faceForward
);
var _dotJs = require("./dot.js");
var _mulnJs = require("./muln.js");
var _setJs = require("./set.js");
const faceForward = (out, n, i, nref)=>{
    !out && (out = n);
    return _dotJs.dot(nref, i) < 0 ? out !== n ? _setJs.set(out, n) : out : _mulnJs.mulN(out, n, -1);
};

},{"./dot.js":"9vV5N","./muln.js":"1TKlE","./set.js":"bSUB8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"klykq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fill", ()=>fill
);
var _mapJs = require("./map.js");
var _setJs = require("./set.js");
const fill = (out, v, num, so = out.length * out.stride)=>_mapJs.mapV(_setJs.set.impl(v.length), out, v, num, so, 0)
;

},{"./map.js":"7CzQk","./set.js":"bSUB8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7CzQk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapVV", ()=>mapVV
);
parcelHelpers.export(exports, "mapV", ()=>mapV
);
parcelHelpers.export(exports, "mapVN", ()=>mapVN
);
parcelHelpers.export(exports, "mapVVV", ()=>mapVVV
);
parcelHelpers.export(exports, "mapVVN", ()=>mapVVN
);
const mapVV = (op, out, a, b, num, so = out.length * out.stride, sa = a.length * a.stride, sb = b.length * b.stride)=>{
    while(num-- > 0){
        op(out, a, b);
        out.offset += so;
        a.offset += sa;
        b.offset += sb;
    }
    return out.buf;
};
const mapV = (op, out, a, num, so = out.length * out.stride, sa = a.length * a.stride)=>{
    while(num-- > 0){
        op(out, a);
        out.offset += so;
        a.offset += sa;
    }
    return out.buf;
};
const mapVN = (op, out, a, n, num, so = out.length * out.stride, sa = a.length * a.stride)=>{
    while(num-- > 0){
        op(out, a, n);
        out.offset += so;
        a.offset += sa;
    }
    return out.buf;
};
const mapVVV = (op, out, a, b, c, num, so = out.length * out.stride, sa = a.length * a.stride, sb = b.length * b.stride, sc = c.length * c.stride)=>{
    while(num-- > 0){
        op(out, a, b, c);
        out.offset += so;
        a.offset += sa;
        b.offset += sb;
        c.offset += sc;
    }
    return out.buf;
};
const mapVVN = (op, out, a, b, n, num, so = out.length * out.stride, sa = a.length * a.stride, sb = b.length * b.stride)=>{
    while(num-- > 0){
        op(out, a, b, n);
        out.offset += so;
        a.offset += sa;
        b.offset += sb;
    }
    return out.buf;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dCUuP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fit", ()=>fit
);
parcelHelpers.export(exports, "fit2", ()=>fit2
);
parcelHelpers.export(exports, "fit3", ()=>fit3
);
parcelHelpers.export(exports, "fit4", ()=>fit4
);
parcelHelpers.export(exports, "fit01", ()=>fit01
);
parcelHelpers.export(exports, "fit01_2", ()=>fit01_2
);
parcelHelpers.export(exports, "fit01_3", ()=>fit01_3
);
parcelHelpers.export(exports, "fit01_4", ()=>fit01_4
);
parcelHelpers.export(exports, "fit11", ()=>fit11
);
parcelHelpers.export(exports, "fit11_2", ()=>fit11_2
);
parcelHelpers.export(exports, "fit11_3", ()=>fit11_3
);
parcelHelpers.export(exports, "fit11_4", ()=>fit11_4
);
var _fit = require("@thi.ng/math/fit");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [fit, fit2, fit3, fit4] = _emitJs.defHofOp(_fit.fit, _templatesJs.FN5(), "o,a,b,c,d,e");
const [fit01, fit01_2, fit01_3, fit01_4] = _emitJs.defHofOp(_fit.fit01, _templatesJs.FN3(), _templatesJs.ARGS_VVV);
const [fit11, fit11_2, fit11_3, fit11_4] = _emitJs.defHofOp(_fit.fit11, _templatesJs.FN3(), _templatesJs.ARGS_VVV);

},{"@thi.ng/math/fit":"8JCov","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8JCov":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "norm", ()=>norm
);
parcelHelpers.export(exports, "fit", ()=>fit
);
parcelHelpers.export(exports, "fitClamped", ()=>fitClamped
);
parcelHelpers.export(exports, "fit01", ()=>fit01
);
parcelHelpers.export(exports, "fit10", ()=>fit10
);
parcelHelpers.export(exports, "fit11", ()=>fit11
);
var _intervalJs = require("./interval.js");
const norm = (x, a, b)=>b !== a ? (x - a) / (b - a) : 0
;
const fit = (x, a, b, c, d)=>c + (d - c) * norm(x, a, b)
;
const fitClamped = (x, a, b, c, d)=>c + (d - c) * _intervalJs.clamp01(norm(x, a, b))
;
const fit01 = (x, a, b)=>a + (b - a) * _intervalJs.clamp01(x)
;
const fit10 = (x, a, b)=>b + (a - b) * _intervalJs.clamp01(x)
;
const fit11 = (x, a, b)=>a + (b - a) * (0.5 + 0.5 * _intervalJs.clamp11(x))
;

},{"./interval.js":"1TDWA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5TOiT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fmod", ()=>fmod
);
parcelHelpers.export(exports, "fmod2", ()=>fmod2
);
parcelHelpers.export(exports, "fmod3", ()=>fmod3
);
parcelHelpers.export(exports, "fmod4", ()=>fmod4
);
var _emitJs = require("./compile/emit.js");
const [fmod, fmod2, fmod3, fmod4] = _emitJs.defMathOp("%");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bYnoA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fmodN", ()=>fmodN
);
parcelHelpers.export(exports, "fmodN2", ()=>fmodN2
);
parcelHelpers.export(exports, "fmodN3", ()=>fmodN3
);
parcelHelpers.export(exports, "fmodN4", ()=>fmodN4
);
var _emitJs = require("./compile/emit.js");
const [fmodN, fmodN2, fmodN3, fmodN4] = _emitJs.defMathOpN("%");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4fVSV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fract", ()=>fract
);
parcelHelpers.export(exports, "fract2", ()=>fract2
);
parcelHelpers.export(exports, "fract3", ()=>fract3
);
parcelHelpers.export(exports, "fract4", ()=>fract4
);
var _prec = require("@thi.ng/math/prec");
var _emitJs = require("./compile/emit.js");
const [fract, fract2, fract3, fract4] = _emitJs.defHofOp(_prec.fract);

},{"@thi.ng/math/prec":"7e7rg","./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7e7rg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mod", ()=>mod
);
parcelHelpers.export(exports, "fract", ()=>fract
);
parcelHelpers.export(exports, "trunc", ()=>trunc
);
parcelHelpers.export(exports, "roundTo", ()=>roundTo
);
parcelHelpers.export(exports, "floorTo", ()=>floorTo
);
parcelHelpers.export(exports, "ceilTo", ()=>ceilTo
);
parcelHelpers.export(exports, "roundEps", ()=>roundEps
);
var _apiJs = require("./api.js");
const mod = (a, b)=>a - b * Math.floor(a / b)
;
const fract = (x)=>x - Math.floor(x)
;
const trunc = (x)=>x < 0 ? Math.ceil(x) : Math.floor(x)
;
const roundTo = (x, prec = 1)=>Math.round(x / prec) * prec
;
const floorTo = (x, prec = 1)=>Math.floor(x / prec) * prec
;
const ceilTo = (x, prec = 1)=>Math.ceil(x / prec) * prec
;
const roundEps = (x, eps = _apiJs.EPS)=>{
    const f = fract(x);
    return f <= eps || f >= 1 - eps ? Math.round(x) : x;
};

},{"./api.js":"4a98p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1cUXh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "gvec", ()=>gvec
);
var _api = require("@thi.ng/math/api");
var _memoize1 = require("@thi.ng/memoize/memoize1");
var _map = require("@thi.ng/transducers/map");
var _range = require("@thi.ng/transducers/range");
var _eqdeltaJs = require("./eqdelta.js");
var _iteratorJs = require("./iterator.js");
var _setnJs = require("./setn.js");
var _setsJs = require("./sets.js");
var _stringJs = require("./string.js");
const SYM_B = "buf";
const SYM_L = "length";
const SYM_O = "offset";
const SYM_S = "stride";
const SYM_C = "copy";
const SYM_CV = "copyView";
const SYM_EMPTY = "empty";
const SYM_EQD = "eqDelta";
const SYM_STR = "toString";
const PROPS = new Set([
    SYM_B,
    SYM_C,
    SYM_CV,
    SYM_EMPTY,
    SYM_EQD,
    SYM_L,
    SYM_O,
    SYM_S,
    SYM_STR,
    Symbol.iterator, 
]);
const keys = _memoize1.memoize1((size)=>[
        ..._map.map(String, _range.range(size)),
        ...PROPS, 
    ]
);
const gvec = (buf, size, offset = 0, stride = 1)=>new Proxy(buf, {
        get (obj, id) {
            switch(id){
                case Symbol.iterator:
                    return ()=>_iteratorJs.stridedValues(obj, size, offset, stride)
                    ;
                case SYM_L:
                    return size;
                case SYM_B:
                    return buf;
                case SYM_O:
                    return offset;
                case SYM_S:
                    return stride;
                case SYM_C:
                    return ()=>_setsJs.setS([], obj, size, 0, offset, 1, stride)
                    ;
                case SYM_CV:
                    return ()=>gvec(obj, size, offset, stride)
                    ;
                case SYM_EMPTY:
                    return ()=>_setnJs.zeroes(size)
                    ;
                case SYM_EQD:
                    return (o, eps = _api.EPS)=>_eqdeltaJs.eqDeltaS(buf, o, size, eps, offset, 0, stride, 1)
                    ;
                case SYM_STR:
                    return ()=>_stringJs.FORMATTER(_iteratorJs.stridedValues(obj, size, offset, stride))
                    ;
                default:
                    const j = parseInt(id);
                    return !isNaN(j) && j >= 0 && j < size ? obj[offset + j * stride] : undefined;
            }
        },
        set (obj, id, value) {
            const j = parseInt(id);
            if (!isNaN(j) && j >= 0 && j < size) obj[offset + (id | 0) * stride] = value;
            else switch(id){
                case SYM_O:
                    offset = value;
                    break;
                case SYM_S:
                    stride = value;
                    break;
                case SYM_L:
                    size = value;
                    break;
                default:
                    return false;
            }
            return true;
        },
        has (_, id) {
            return id >= 0 && id < size || PROPS.has(id);
        },
        ownKeys () {
            return keys(size);
        }
    })
;

},{"@thi.ng/math/api":"4a98p","@thi.ng/memoize/memoize1":"2HM4Q","@thi.ng/transducers/map":"fW6Xn","@thi.ng/transducers/range":"lUHc9","./eqdelta.js":"eBVIX","./iterator.js":"dnjxi","./setn.js":"2M6y1","./sets.js":"3jBTJ","./string.js":"iiJ6W","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2HM4Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "memoize1", ()=>memoize1
);
const memoize1 = (fn, cache)=>{
    !cache && (cache = new Map());
    return (x)=>{
        let res;
        return cache.has(x) ? cache.get(x) : (cache.set(x, res = fn(x)), res);
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a3Qmf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "headingSegmentXY", ()=>headingSegmentXY
);
parcelHelpers.export(exports, "headingSegmentXZ", ()=>headingSegmentXZ
);
parcelHelpers.export(exports, "headingSegmentYZ", ()=>headingSegmentYZ
);
parcelHelpers.export(exports, "headingSegment", ()=>headingSegment
);
var _angle = require("@thi.ng/math/angle");
const $ = (u, v)=>(a, b)=>_angle.atan2Abs(b[u] - a[u], b[v] - a[v])
;
const headingSegmentXY = $(1, 0);
const headingSegmentXZ = $(2, 0);
const headingSegmentYZ = $(2, 1);
const headingSegment = headingSegmentXY;

},{"@thi.ng/math/angle":"el41q","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a3DYy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromHomogeneous", ()=>fromHomogeneous
);
parcelHelpers.export(exports, "fromHomogeneous3", ()=>fromHomogeneous3
);
parcelHelpers.export(exports, "fromHomogeneous4", ()=>fromHomogeneous4
);
var _vopJs = require("./vop.js");
var _setcJs = require("./setc.js");
const fromHomogeneous = _vopJs.vop(1);
const fromHomogeneous3 = fromHomogeneous.add(3, (out, [x, y, w])=>_setcJs.setC2(out || [], x / w, y / w)
);
const fromHomogeneous4 = fromHomogeneous.add(4, (out, [x, y, z, w])=>_setcJs.setC3(out || [], x / w, y / w, z / w)
);

},{"./vop.js":"4v2k5","./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hJpMW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "invert", ()=>invert
);
parcelHelpers.export(exports, "invert2", ()=>invert2
);
parcelHelpers.export(exports, "invert3", ()=>invert3
);
parcelHelpers.export(exports, "invert4", ()=>invert4
);
var _emitJs = require("./compile/emit.js");
const [invert, invert2, invert3, invert4] = _emitJs.defOp(([o, a])=>`${o}=1/${a};`
);

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bHU8F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "invSqrt", ()=>invSqrt
);
parcelHelpers.export(exports, "invSqrt2", ()=>invSqrt2
);
parcelHelpers.export(exports, "invSqrt3", ()=>invSqrt3
);
parcelHelpers.export(exports, "invSqrt4", ()=>invSqrt4
);
var _emitJs = require("./compile/emit.js");
const [invSqrt, invSqrt2, invSqrt3, invSqrt4] = _emitJs.defOp(([o, a])=>`${o}=1/Math.sqrt(${a});`
);

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hVJ5w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isInf", ()=>isInf
);
parcelHelpers.export(exports, "isInf2", ()=>isInf2
);
parcelHelpers.export(exports, "isInf3", ()=>isInf3
);
parcelHelpers.export(exports, "isInf4", ()=>isInf4
);
var _emitJs = require("./compile/emit.js");
const [isInf, isInf2, isInf3, isInf4] = _emitJs.defFnOp("!isFinite");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lmjNR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isNaN", ()=>isNaN
);
parcelHelpers.export(exports, "isNaN2", ()=>isNaN2
);
parcelHelpers.export(exports, "isNaN3", ()=>isNaN3
);
parcelHelpers.export(exports, "isNaN4", ()=>isNaN4
);
var _emitJs = require("./compile/emit.js");
const [isNaN, isNaN2, isNaN3, isNaN4] = _emitJs.defFnOp("isNaN");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ceTNs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "limit", ()=>limit
);
var _magJs = require("./mag.js");
var _mulnJs = require("./muln.js");
var _setJs = require("./set.js");
const limit = (out, v, n)=>{
    !out && (out = v);
    const m = _magJs.mag(v);
    return m > n ? _mulnJs.mulN(out, v, n / m) : out !== v ? _setJs.set(out, v) : out;
};

},{"./mag.js":"70TCJ","./muln.js":"1TKlE","./set.js":"bSUB8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"zFq2X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "log", ()=>log
);
parcelHelpers.export(exports, "log2", ()=>log2
);
parcelHelpers.export(exports, "log3", ()=>log3
);
parcelHelpers.export(exports, "log4", ()=>log4
);
var _emitJs = require("./compile/emit.js");
const [log, log2, log3, log4] = _emitJs.defFnOp("Math.log");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1fpEn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "log_2", ()=>log_2
);
parcelHelpers.export(exports, "log_22", ()=>log_22
);
parcelHelpers.export(exports, "log_23", ()=>log_23
);
parcelHelpers.export(exports, "log_24", ()=>log_24
);
var _emitJs = require("./compile/emit.js");
const [log_2, log_22, log_23, log_24] = _emitJs.defFnOp("Math.log2");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b5AQh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "logicAnd", ()=>logicAnd
);
parcelHelpers.export(exports, "logicAnd2", ()=>logicAnd2
);
parcelHelpers.export(exports, "logicAnd3", ()=>logicAnd3
);
parcelHelpers.export(exports, "logicAnd4", ()=>logicAnd4
);
parcelHelpers.export(exports, "logicAndN", ()=>logicAndN
);
parcelHelpers.export(exports, "logicAndN2", ()=>logicAndN2
);
parcelHelpers.export(exports, "logicAndN3", ()=>logicAndN3
);
parcelHelpers.export(exports, "logicAndN4", ()=>logicAndN4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [logicAnd, logicAnd2, logicAnd3, logicAnd4] = _emitJs.defOp(_templatesJs.MATH("&&"));
const [logicAndN, logicAndN2, logicAndN3, logicAndN4] = _emitJs.defOp(_templatesJs.MATH_N("&&"), _templatesJs.ARGS_VN);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eDW8G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "logicNot", ()=>logicNot
);
parcelHelpers.export(exports, "logicNot2", ()=>logicNot2
);
parcelHelpers.export(exports, "logicNot3", ()=>logicNot3
);
parcelHelpers.export(exports, "logicNot4", ()=>logicNot4
);
var _emitJs = require("./compile/emit.js");
const [logicNot, logicNot2, logicNot3, logicNot4] = _emitJs.defFnOp("!");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3aaGQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "logicOr", ()=>logicOr
);
parcelHelpers.export(exports, "logicOr2", ()=>logicOr2
);
parcelHelpers.export(exports, "logicOr3", ()=>logicOr3
);
parcelHelpers.export(exports, "logicOr4", ()=>logicOr4
);
parcelHelpers.export(exports, "logicOrN", ()=>logicOrN
);
parcelHelpers.export(exports, "logicOrN2", ()=>logicOrN2
);
parcelHelpers.export(exports, "logicOrN3", ()=>logicOrN3
);
parcelHelpers.export(exports, "logicOrN4", ()=>logicOrN4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [logicOr, logicOr2, logicOr3, logicOr4] = _emitJs.defOp(_templatesJs.MATH("||"));
const [logicOrN, logicOrN2, logicOrN3, logicOrN4] = _emitJs.defOp(_templatesJs.MATH_N("||"), _templatesJs.ARGS_VN);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"46YJu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lshiftI", ()=>lshiftI
);
parcelHelpers.export(exports, "lshiftI2", ()=>lshiftI2
);
parcelHelpers.export(exports, "lshiftI3", ()=>lshiftI3
);
parcelHelpers.export(exports, "lshiftI4", ()=>lshiftI4
);
parcelHelpers.export(exports, "lshiftU", ()=>lshiftU
);
parcelHelpers.export(exports, "lshiftU2", ()=>lshiftU2
);
parcelHelpers.export(exports, "lshiftU3", ()=>lshiftU3
);
parcelHelpers.export(exports, "lshiftU4", ()=>lshiftU4
);
parcelHelpers.export(exports, "lshiftNI", ()=>lshiftNI
);
parcelHelpers.export(exports, "lshiftNI2", ()=>lshiftNI2
);
parcelHelpers.export(exports, "lshiftNI3", ()=>lshiftNI3
);
parcelHelpers.export(exports, "lshiftNI4", ()=>lshiftNI4
);
parcelHelpers.export(exports, "lshiftNU", ()=>lshiftNU
);
parcelHelpers.export(exports, "lshiftNU2", ()=>lshiftNU2
);
parcelHelpers.export(exports, "lshiftNU3", ()=>lshiftNU3
);
parcelHelpers.export(exports, "lshiftNU4", ()=>lshiftNU4
);
var _emitJs = require("./compile/emit.js");
const [lshiftI, lshiftI2, lshiftI3, lshiftI4] = _emitJs.defBitOp("<<", true);
const [lshiftU, lshiftU2, lshiftU3, lshiftU4] = _emitJs.defBitOp("<<");
const [lshiftNI, lshiftNI2, lshiftNI3, lshiftNI4] = _emitJs.defBitOpN("<<", true);
const [lshiftNU, lshiftNU2, lshiftNU3, lshiftNU4] = _emitJs.defBitOpN("<<");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iDF9M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "maddS", ()=>maddS
);
parcelHelpers.export(exports, "maddS2", ()=>maddS2
);
parcelHelpers.export(exports, "maddS3", ()=>maddS3
);
parcelHelpers.export(exports, "maddS4", ()=>maddS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [maddS, maddS2, maddS3, maddS4] = _emitJs.defOpS(_templatesJs.MATH2("*", "+"), _templatesJs.ARGS_VVV, _templatesJs.SARGS_VVV, _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iOnQH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "maddNS", ()=>maddNS
);
parcelHelpers.export(exports, "maddNS2", ()=>maddNS2
);
parcelHelpers.export(exports, "maddNS3", ()=>maddNS3
);
parcelHelpers.export(exports, "maddNS4", ()=>maddNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [maddNS, maddNS2, maddNS3, maddNS4] = _emitJs.defOpS(_templatesJs.MATH2A_N("*", "+"), _templatesJs.ARGS_VNV, _templatesJs.SARGS_VV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h4CFH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "magS", ()=>magS
);
parcelHelpers.export(exports, "magS2", ()=>magS2
);
parcelHelpers.export(exports, "magS3", ()=>magS3
);
parcelHelpers.export(exports, "magS4", ()=>magS4
);
var _dotsJs = require("./dots.js");
const magS = (a, num, ia, sa)=>Math.sqrt(_dotsJs.dotS(a, a, num, ia, ia, sa, sa))
;
const magS2 = (a, ia, sa)=>Math.sqrt(_dotsJs.dotS2(a, a, ia, ia, sa, sa))
;
const magS3 = (a, ia, sa)=>Math.sqrt(_dotsJs.dotS3(a, a, ia, ia, sa, sa))
;
const magS4 = (a, ia, sa)=>Math.sqrt(_dotsJs.dotS4(a, a, ia, ia, sa, sa))
;

},{"./dots.js":"3KJkk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b5N6p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "magSqS2", ()=>magSqS2
);
parcelHelpers.export(exports, "magSqS3", ()=>magSqS3
);
parcelHelpers.export(exports, "magSqS4", ()=>magSqS4
);
var _dotsJs = require("./dots.js");
const magSqS2 = (a, ia, sa)=>_dotsJs.dotS2(a, a, ia, ia, sa, sa)
;
const magSqS3 = (a, ia, sa)=>_dotsJs.dotS3(a, a, ia, ia, sa, sa)
;
const magSqS4 = (a, ia, sa)=>_dotsJs.dotS4(a, a, ia, ia, sa, sa)
;

},{"./dots.js":"3KJkk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hqWnf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "major", ()=>major
);
parcelHelpers.export(exports, "major2", ()=>major2
);
parcelHelpers.export(exports, "major3", ()=>major3
);
parcelHelpers.export(exports, "major4", ()=>major4
);
var _interval = require("@thi.ng/math/interval");
var _vopJs = require("./vop.js");
const abs = Math.abs;
const major = _vopJs.vop();
major.default((a)=>{
    let id = -1;
    let max = -Infinity;
    for(let i = a.length; i-- > 0;){
        const x = abs(a[i]);
        if (x > max) {
            max = x;
            id = i;
        }
    }
    return id;
});
const major2 = major.add(2, (a)=>_interval.max2id(abs(a[0]), abs(a[1]))
);
const major3 = major.add(3, (a)=>_interval.max3id(abs(a[0]), abs(a[1]), abs(a[2]))
);
const major4 = major.add(4, (a)=>_interval.max4id(abs(a[0]), abs(a[1]), abs(a[2]), abs(a[3]))
);

},{"@thi.ng/math/interval":"1TDWA","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8KUWS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapVectors", ()=>mapVectors
);
var _isNumber = require("@thi.ng/checks/is-number");
function mapVectors(fn, out, a, b, c) {
    const num = a.length;
    !out && (out = new Array(num));
    c !== undefined ? _isNumber.isNumber(c) ? mapVVN(fn, out, a, b, c) : mapVVV(fn, out, a, b, c) : _isNumber.isNumber(b) ? mapVN(fn, out, a, b) : mapVV(fn, out, a, b);
    return out;
}
const mapVN = (fn, out, a, b)=>{
    for(let i = 0, num = a.length; i < num; i++)out[i] = fn(out[i] || [], a[i], b);
};
const mapVV = (fn, out, a, b)=>{
    for(let i = 0, num = a.length; i < num; i++)out[i] = fn(out[i] || [], a[i], b[i]);
};
const mapVVN = (fn, out, a, b, c)=>{
    for(let i = 0, num = a.length; i < num; i++)out[i] = fn(out[i] || [], a[i], b[i], c);
};
const mapVVV = (fn, out, a, b, c)=>{
    for(let i = 0, num = a.length; i < num; i++)out[i] = fn(out[i] || [], a[i], b[i], c[i]);
};

},{"@thi.ng/checks/is-number":"hNf8P","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7CH4J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "max", ()=>max
);
parcelHelpers.export(exports, "max2", ()=>max2
);
parcelHelpers.export(exports, "max3", ()=>max3
);
parcelHelpers.export(exports, "max4", ()=>max4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [max, max2, max3, max4] = _emitJs.defOp(_templatesJs.FN2("Math.max"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l64lm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "maxBounds", ()=>maxBounds
);
var _ensureJs = require("./internal/ensure.js");
var _maxJs = require("./max.js");
var _setnJs = require("./setn.js");
var _vecOfJs = require("./vec-of.js");
const maxBounds = (out, src)=>{
    _ensureJs.__ensureInputs(src);
    out = out ? _setnJs.setN(out, -Infinity) : _vecOfJs.vecOf(src[0].length, -Infinity);
    for(let i = src.length; i-- > 0;)_maxJs.max(out, out, src[i]);
    return out;
};

},{"./internal/ensure.js":"dq2YU","./max.js":"7CH4J","./setn.js":"2M6y1","./vec-of.js":"1dJsE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1dJsE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "vecOf", ()=>vecOf
);
parcelHelpers.export(exports, "oneHot", ()=>oneHot
);
const vecOf = (size, n = 0)=>new Array(size).fill(n)
;
const oneHot = (size, hot)=>{
    const res = vecOf(size);
    res[hot] = 1;
    return res;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k1qXc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "median", ()=>median
);
parcelHelpers.export(exports, "vmedian", ()=>vmedian
);
var _ensureJs = require("./internal/ensure.js");
const median = (out, src)=>{
    _ensureJs.__ensureInputs(src);
    out = out || [];
    const m = src.length >> 1;
    for(let i = src[0].length; i-- > 0;)out[i] = src.map((x)=>x[i]
    ).sort((a, b)=>a - b
    )[m];
    return out;
};
const vmedian = (a1)=>{
    if (!a1.length) return 0;
    a1 = [
        ...a1
    ].sort((a, b)=>a - b
    );
    return a1[a1.length >> 1];
};

},{"./internal/ensure.js":"dq2YU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gWOyO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "min", ()=>min
);
parcelHelpers.export(exports, "min2", ()=>min2
);
parcelHelpers.export(exports, "min3", ()=>min3
);
parcelHelpers.export(exports, "min4", ()=>min4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [min, min2, min3, min4] = _emitJs.defOp(_templatesJs.FN2("Math.min"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kPgsx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "minBounds", ()=>minBounds
);
var _ensureJs = require("./internal/ensure.js");
var _minJs = require("./min.js");
var _setnJs = require("./setn.js");
var _vecOfJs = require("./vec-of.js");
const minBounds = (out, src)=>{
    _ensureJs.__ensureInputs(src);
    out = out ? _setnJs.setN(out, Infinity) : _vecOfJs.vecOf(src[0].length, Infinity);
    for(let i = src.length; i-- > 0;)_minJs.min(out, out, src[i]);
    return out;
};

},{"./internal/ensure.js":"dq2YU","./min.js":"gWOyO","./setn.js":"2M6y1","./vec-of.js":"1dJsE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9omJw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "minor", ()=>minor
);
parcelHelpers.export(exports, "minor2", ()=>minor2
);
parcelHelpers.export(exports, "minor3", ()=>minor3
);
parcelHelpers.export(exports, "minor4", ()=>minor4
);
var _interval = require("@thi.ng/math/interval");
var _vopJs = require("./vop.js");
const abs = Math.abs;
const minor = _vopJs.vop();
minor.default((a)=>{
    let id = -1;
    let min = Infinity;
    for(let i = a.length; i-- > 0;){
        const x = abs(a[i]);
        if (x < min) {
            min = x;
            id = i;
        }
    }
    return id;
});
const minor2 = minor.add(2, (a)=>_interval.min2id(abs(a[0]), abs(a[1]))
);
const minor3 = minor.add(3, (a)=>_interval.min3id(abs(a[0]), abs(a[1]), abs(a[2]))
);
const minor4 = minor.add(4, (a)=>_interval.min4id(abs(a[0]), abs(a[1]), abs(a[2]), abs(a[3]))
);

},{"@thi.ng/math/interval":"1TDWA","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"baPCK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mixBilinear", ()=>mixBilinear
);
parcelHelpers.export(exports, "mixBilinear2", ()=>mixBilinear2
);
parcelHelpers.export(exports, "mixBilinear3", ()=>mixBilinear3
);
parcelHelpers.export(exports, "mixBilinear4", ()=>mixBilinear4
);
var _mix = require("@thi.ng/math/mix");
var _emitJs = require("./compile/emit.js");
const [mixBilinear, mixBilinear2, mixBilinear3, mixBilinear4] = _emitJs.defHofOp(_mix.mixBilinear, ([o, a, b, c, d])=>`${o}=op(${a},${b},${c},${d},u,v);`
, "o,a,b,c,d,u,v");

},{"@thi.ng/math/mix":"cHjhA","./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cHjhA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mix", ()=>mix
);
parcelHelpers.export(exports, "mixBilinear", ()=>mixBilinear
);
parcelHelpers.export(exports, "mixQuadratic", ()=>mixQuadratic
);
parcelHelpers.export(exports, "mixCubic", ()=>mixCubic
);
parcelHelpers.export(exports, "mixHermite", ()=>mixHermite
);
parcelHelpers.export(exports, "mixCubicHermite", ()=>mixCubicHermite
);
parcelHelpers.export(exports, "mixCubicHermiteFromPoints", ()=>mixCubicHermiteFromPoints
);
parcelHelpers.export(exports, "mixBicubic", ()=>mixBicubic
);
parcelHelpers.export(exports, "tangentCardinal", ()=>tangentCardinal
);
parcelHelpers.export(exports, "tangentDiff3", ()=>tangentDiff3
);
parcelHelpers.export(exports, "tween", ()=>tween
);
parcelHelpers.export(exports, "circular", ()=>circular
);
parcelHelpers.export(exports, "invCircular", ()=>invCircular
);
parcelHelpers.export(exports, "lens", ()=>lens
);
parcelHelpers.export(exports, "cosine", ()=>cosine
);
parcelHelpers.export(exports, "decimated", ()=>decimated
);
parcelHelpers.export(exports, "bounce", ()=>bounce
);
parcelHelpers.export(exports, "ease", ()=>ease
);
parcelHelpers.export(exports, "impulse", ()=>impulse
);
parcelHelpers.export(exports, "gain", ()=>gain
);
parcelHelpers.export(exports, "parabola", ()=>parabola
);
parcelHelpers.export(exports, "cubicPulse", ()=>cubicPulse
);
parcelHelpers.export(exports, "sinc", ()=>sinc
);
parcelHelpers.export(exports, "sincNormalized", ()=>sincNormalized
);
parcelHelpers.export(exports, "lanczos", ()=>lanczos
);
parcelHelpers.export(exports, "sigmoid", ()=>sigmoid
);
parcelHelpers.export(exports, "sigmoid01", ()=>sigmoid01
);
parcelHelpers.export(exports, "sigmoid11", ()=>sigmoid11
);
parcelHelpers.export(exports, "schlick", ()=>schlick
);
parcelHelpers.export(exports, "expFactor", ()=>expFactor
);
parcelHelpers.export(exports, "gaussian", ()=>gaussian
);
var _apiJs = require("./api.js");
const mix = (a, b, t)=>a + (b - a) * t
;
const mixBilinear = (a, b, c, d, u, v)=>{
    const iu = 1 - u;
    const iv = 1 - v;
    return a * iu * iv + b * u * iv + c * iu * v + d * u * v;
};
const mixQuadratic = (a, b, c, t)=>{
    const s = 1 - t;
    return a * s * s + b * 2 * s * t + c * t * t;
};
const mixCubic = (a, b, c, d, t)=>{
    const t2 = t * t;
    const s = 1 - t;
    const s2 = s * s;
    return a * s2 * s + b * 3 * s2 * t + c * 3 * t2 * s + d * t2 * t;
};
const mixHermite = (a, b, c, d, t)=>{
    const y1 = 0.5 * (c - a);
    const y2 = 1.5 * (b - c) + 0.5 * (d - a);
    return ((y2 * t + a - b + y1 - y2) * t + y1) * t + b;
};
const mixCubicHermite = (a, ta, b, tb, t)=>{
    const s = t - 1;
    const t2 = t * t;
    const s2 = s * s;
    const h00 = (1 + 2 * t) * s2;
    const h10 = t * s2;
    const h01 = t2 * (3 - 2 * t);
    const h11 = t2 * s;
    return h00 * a + h10 * ta + h01 * b + h11 * tb;
};
const mixCubicHermiteFromPoints = (a, b, c, d, t)=>{
    d *= 0.5;
    const aa = -0.5 * a + 1.5 * b - 1.5 * c + d;
    const bb = a - 2.5 * b + 2 * c - d;
    const cc = -0.5 * a + 0.5 * c;
    const dd = b;
    const t2 = t * t;
    return t * t2 * aa + t2 * bb + t * cc + dd;
};
const mixBicubic = (s00, s01, s02, s03, s10, s11, s12, s13, s20, s21, s22, s23, s30, s31, s32, s33, u, v)=>mixCubicHermiteFromPoints(mixCubicHermiteFromPoints(s00, s01, s02, s03, u), mixCubicHermiteFromPoints(s10, s11, s12, s13, u), mixCubicHermiteFromPoints(s20, s21, s22, s23, u), mixCubicHermiteFromPoints(s30, s31, s32, s33, u), v)
;
const tangentCardinal = (prev, next, scale = 0.5, ta = 0, tc = 2)=>scale * ((next - prev) / (tc - ta))
;
const tangentDiff3 = (prev, curr, next, ta = 0, tb = 1, tc = 2)=>0.5 * ((next - curr) / (tc - tb) + (curr - prev) / (tb - ta))
;
const tween = (f, from, to)=>(t)=>mix(from, to, f(t))
;
const circular = (t)=>{
    t = 1 - t;
    return Math.sqrt(1 - t * t);
};
const invCircular = (t)=>1 - circular(1 - t)
;
const lens = (pos, strength, t)=>{
    const impl = strength > 0 ? invCircular : circular;
    const tp = 1 - pos;
    const tl = t <= pos ? impl(t / pos) * pos : 1 - impl((1 - t) / tp) * tp;
    return mix(t, tl, Math.abs(strength));
};
const cosine = (t)=>1 - (Math.cos(t * _apiJs.PI) * 0.5 + 0.5)
;
const decimated = (n, t)=>Math.floor(t * n) / n
;
const bounce = (k, amp, t)=>{
    const tk = t * k;
    return 1 - amp * Math.sin(tk) / tk * Math.cos(t * _apiJs.HALF_PI);
};
const ease = (ease1, t)=>Math.pow(t, ease1)
;
const impulse = (k, t)=>{
    const h = k * t;
    return h * Math.exp(1 - h);
};
const gain = (k, t)=>t < 0.5 ? 0.5 * Math.pow(2 * t, k) : 1 - 0.5 * Math.pow(2 - 2 * t, k)
;
const parabola = (k, t)=>Math.pow(4 * t * (1 - t), k)
;
const cubicPulse = (w, c, t)=>{
    t = Math.abs(t - c);
    return t > w ? 0 : (t /= w, 1 - t * t * (3 - 2 * t));
};
const sinc = (t)=>t !== 0 ? Math.sin(t) / t : 1
;
const sincNormalized = (k, t)=>sinc(_apiJs.PI * k * t)
;
const lanczos = (a, t)=>t !== 0 ? -a < t && t < a ? sinc(_apiJs.PI * t) * sinc(_apiJs.PI * t / a) : 0 : 1
;
const sigmoid = (bias, k, t)=>t != bias ? 1 / (1 + Math.exp(-k * (t - bias))) : 0.5
;
const sigmoid01 = (k, t)=>sigmoid(0.5, k, t)
;
const sigmoid11 = (k, t)=>sigmoid(0, k, t)
;
const schlick = (a, b, t)=>t <= b ? b * t / (t + a * (b - t) + _apiJs.EPS) : (1 - b) * (t - 1) / (1 - t - a * (b - t) + _apiJs.EPS) + 1
;
const expFactor = (a, b, num)=>(b / a) ** (1 / num)
;
const gaussian = (bias, sigma, t)=>Math.exp(-((t - bias) ** 2) / (2 * sigma * sigma))
;

},{"./api.js":"4a98p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5OlFY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mixCubic", ()=>mixCubic
);
var _addwJs = require("./addw.js");
const mixCubic = (out, a, b, c, d, t)=>{
    const s = 1 - t;
    const s2 = s * s;
    const t2 = t * t;
    return _addwJs.addW4(out, a, b, c, d, s2 * s, 3 * s2 * t, 3 * t2 * s, t2 * t);
};

},{"./addw.js":"cFpxt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"114q9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mixCubicHermite", ()=>mixCubicHermite
);
parcelHelpers.export(exports, "mixHermiteCardinal", ()=>mixHermiteCardinal
);
parcelHelpers.export(exports, "mixHermiteDiff3", ()=>mixHermiteDiff3
);
parcelHelpers.export(exports, "tangentCardinal", ()=>tangentCardinal
);
parcelHelpers.export(exports, "tangentDiff3", ()=>tangentDiff3
);
var _addmnJs = require("./addmn.js");
var _addwJs = require("./addw.js");
var _submnJs = require("./submn.js");
const mixCubicHermite = (out, a, ta, b, tb, t)=>{
    const s = t - 1;
    const t2 = t * t;
    const s2 = s * s;
    return _addwJs.addW4(out, a, ta, b, tb, (1 + 2 * t) * s2, t * s2, t2 * (3 - 2 * t), t2 * s);
};
const mixHermiteCardinal = (out, a, b, c, d, t, scale = 0.5)=>mixCubicHermite(out, b, tangentCardinal([], a, c, scale), c, tangentCardinal([], b, d, scale), t)
;
const mixHermiteDiff3 = (out, a, b, c, d, t)=>mixCubicHermite(out, b, tangentDiff3([], a, b, c), c, tangentDiff3([], b, c, d), t)
;
const tangentCardinal = (out, prev, next, scale = 0.5, ta = 0, tc = 2)=>_submnJs.submN(out, next, prev, scale / (tc - ta))
;
const tangentDiff3 = (out, prev, curr, next, ta = 0, tb = 1, tc = 2)=>_addmnJs.addmN(out, _submnJs.submN(out, curr, prev, 1 / (tb - ta)), _submnJs.submN([], next, curr, 1 / (tc - tb)), 0.5)
;

},{"./addmn.js":"9C52h","./addw.js":"cFpxt","./submn.js":"aIPIo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6mY6C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mixQuadratic", ()=>mixQuadratic
);
var _addwJs = require("./addw.js");
const mixQuadratic = (out, a, b, c, t)=>{
    const s = 1 - t;
    return _addwJs.addW3(out, a, b, c, s * s, 2 * s * t, t * t);
};

},{"./addw.js":"cFpxt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hb219":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mix", ()=>mix
);
parcelHelpers.export(exports, "mix2", ()=>mix2
);
parcelHelpers.export(exports, "mix3", ()=>mix3
);
parcelHelpers.export(exports, "mix4", ()=>mix4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [mix, mix2, mix3, mix4] = _emitJs.defOp(_templatesJs.MIX, _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gLg2m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mixS", ()=>mixS
);
parcelHelpers.export(exports, "mixS2", ()=>mixS2
);
parcelHelpers.export(exports, "mixS3", ()=>mixS3
);
parcelHelpers.export(exports, "mixS4", ()=>mixS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [mixS, mixS2, mixS3, mixS4] = _emitJs.defOpS(_templatesJs.MIX, _templatesJs.ARGS_VVV, _templatesJs.SARGS_VVV, _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"glIAb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mixNS", ()=>mixNS
);
parcelHelpers.export(exports, "mixNS2", ()=>mixNS2
);
parcelHelpers.export(exports, "mixNS3", ()=>mixNS3
);
parcelHelpers.export(exports, "mixNS4", ()=>mixNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [mixNS, mixNS2, mixNS3, mixNS4] = _emitJs.defOpS(_templatesJs.MIX_N, _templatesJs.ARGS_VVN, _templatesJs.SARGS_VV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fNrmT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mod", ()=>mod
);
parcelHelpers.export(exports, "mod2", ()=>mod2
);
parcelHelpers.export(exports, "mod3", ()=>mod3
);
parcelHelpers.export(exports, "mod4", ()=>mod4
);
var _prec = require("@thi.ng/math/prec");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [mod, mod2, mod3, mod4] = _emitJs.defHofOp(_prec.mod, _templatesJs.FN2("op"), _templatesJs.ARGS_VV);

},{"@thi.ng/math/prec":"7e7rg","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"YyBoO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "modN", ()=>modN
);
parcelHelpers.export(exports, "modN2", ()=>modN2
);
parcelHelpers.export(exports, "modN3", ()=>modN3
);
parcelHelpers.export(exports, "modN4", ()=>modN4
);
var _prec = require("@thi.ng/math/prec");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [modN, modN2, modN3, modN4] = _emitJs.defHofOp(_prec.mod, _templatesJs.FN_N("op"), _templatesJs.ARGS_VN, _templatesJs.ARGS_V);

},{"@thi.ng/math/prec":"7e7rg","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8UZie":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "msub", ()=>msub
);
parcelHelpers.export(exports, "msub2", ()=>msub2
);
parcelHelpers.export(exports, "msub3", ()=>msub3
);
parcelHelpers.export(exports, "msub4", ()=>msub4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [msub, msub2, msub3, msub4] = _emitJs.defOp(_templatesJs.MATH2("*", "-"), _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9zPln":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "msubN", ()=>msubN
);
parcelHelpers.export(exports, "msubN2", ()=>msubN2
);
parcelHelpers.export(exports, "msubN3", ()=>msubN3
);
parcelHelpers.export(exports, "msubN4", ()=>msubN4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [msubN, msubN2, msubN3, msubN4] = _emitJs.defOp(_templatesJs.MATH2A_N("*", "-"), _templatesJs.ARGS_VNV, _templatesJs.ARGS_VV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ke6Rd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "msubS", ()=>msubS
);
parcelHelpers.export(exports, "msubS2", ()=>msubS2
);
parcelHelpers.export(exports, "msubS3", ()=>msubS3
);
parcelHelpers.export(exports, "msubS4", ()=>msubS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [msubS, msubS2, msubS3, msubS4] = _emitJs.defOpS(_templatesJs.MATH2("*", "-"), _templatesJs.ARGS_VVV, _templatesJs.SARGS_VVV, _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6JEEE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "msubNS", ()=>msubNS
);
parcelHelpers.export(exports, "msubNS2", ()=>msubNS2
);
parcelHelpers.export(exports, "msubNS3", ()=>msubNS3
);
parcelHelpers.export(exports, "msubNS4", ()=>msubNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [msubNS, msubNS2, msubNS3, msubNS4] = _emitJs.defOpS(_templatesJs.MATH2A_N("*", "-"), _templatesJs.ARGS_VNV, _templatesJs.SARGS_VV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aJFBK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mulI", ()=>mulI
);
parcelHelpers.export(exports, "mulI2", ()=>mulI2
);
parcelHelpers.export(exports, "mulI3", ()=>mulI3
);
parcelHelpers.export(exports, "mulI4", ()=>mulI4
);
parcelHelpers.export(exports, "mulU", ()=>mulU
);
parcelHelpers.export(exports, "mulU2", ()=>mulU2
);
parcelHelpers.export(exports, "mulU3", ()=>mulU3
);
parcelHelpers.export(exports, "mulU4", ()=>mulU4
);
parcelHelpers.export(exports, "mulNI", ()=>mulNI
);
parcelHelpers.export(exports, "mulNI2", ()=>mulNI2
);
parcelHelpers.export(exports, "mulNI3", ()=>mulNI3
);
parcelHelpers.export(exports, "mulNI4", ()=>mulNI4
);
parcelHelpers.export(exports, "mulNU", ()=>mulNU
);
parcelHelpers.export(exports, "mulNU2", ()=>mulNU2
);
parcelHelpers.export(exports, "mulNU3", ()=>mulNU3
);
parcelHelpers.export(exports, "mulNU4", ()=>mulNU4
);
var _emitJs = require("./compile/emit.js");
const [mulI, mulI2, mulI3, mulI4] = _emitJs.defBitOp("*", true);
const [mulU, mulU2, mulU3, mulU4] = _emitJs.defBitOp("*");
const [mulNI, mulNI2, mulNI3, mulNI4] = _emitJs.defBitOpN("*", true);
const [mulNU, mulNU2, mulNU3, mulNU4] = _emitJs.defBitOpN("*");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"01xwB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mulS", ()=>mulS
);
parcelHelpers.export(exports, "mulS2", ()=>mulS2
);
parcelHelpers.export(exports, "mulS3", ()=>mulS3
);
parcelHelpers.export(exports, "mulS4", ()=>mulS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [mulS, mulS2, mulS3, mulS4] = _emitJs.defOpS(_templatesJs.MATH("*"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b3IkY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mulNS", ()=>mulNS
);
parcelHelpers.export(exports, "mulNS2", ()=>mulNS2
);
parcelHelpers.export(exports, "mulNS3", ()=>mulNS3
);
parcelHelpers.export(exports, "mulNS4", ()=>mulNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [mulNS, mulNS2, mulNS3, mulNS4] = _emitJs.defOpS(_templatesJs.MATH_N("*"), _templatesJs.ARGS_VN, _templatesJs.SARGS_V, _templatesJs.ARGS_V);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gnwVs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "neg", ()=>neg
);
var _mulnJs = require("./muln.js");
const neg = (out, v)=>_mulnJs.mulN(out, v, -1)
;

},{"./muln.js":"1TKlE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8RAVI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "normalCCW", ()=>normalCCW
);
parcelHelpers.export(exports, "normalCW", ()=>normalCW
);
var _directionJs = require("./direction.js");
var _perpendicularJs = require("./perpendicular.js");
const normalCCW = (out, a, b, n = 1)=>_perpendicularJs.perpendicularCCW(null, _directionJs.direction(out || [], a, b, n))
;
const normalCW = (out, a, b, n = 1)=>_perpendicularJs.perpendicularCW(null, _directionJs.direction(out || [], a, b, n))
;

},{"./direction.js":"g7PP7","./perpendicular.js":"dnMKL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lD3Rj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "normalizeS", ()=>normalizeS
);
parcelHelpers.export(exports, "normalizeS2", ()=>normalizeS2
);
parcelHelpers.export(exports, "normalizeS3", ()=>normalizeS3
);
parcelHelpers.export(exports, "normalizeS4", ()=>normalizeS4
);
var _api = require("@thi.ng/math/api");
var _magsJs = require("./mags.js");
var _mulnsJs = require("./mulns.js");
var _setsJs = require("./sets.js");
const normalizeS = (out, v, num, n = 1, io = 0, ia = 0, so = 1, sa = 1)=>{
    !out && (out = v);
    const m = _magsJs.magS(v, num, ia, sa);
    return m >= _api.EPS ? _mulnsJs.mulNS(out, v, n / m, num, io, ia, so, sa) : out !== v ? _setsJs.setS(out, v, num, io, ia, so, sa) : out;
};
const normalizeS2 = (out, v, n = 1, io = 0, ia = 0, so = 1, sa = 1)=>{
    !out && (out = v);
    const m = _magsJs.magS2(v, ia, sa);
    return m >= _api.EPS ? _mulnsJs.mulNS2(out, v, n / m, io, ia, so, sa) : out !== v ? _setsJs.setS2(out, v, io, ia, so, sa) : out;
};
const normalizeS3 = (out, v, n = 1, io = 0, ia = 0, so = 1, sa = 1)=>{
    !out && (out = v);
    const m = _magsJs.magS3(v, ia, sa);
    return m >= _api.EPS ? _mulnsJs.mulNS3(out, v, n / m, io, ia, so, sa) : out !== v ? _setsJs.setS3(out, v, io, ia, so, sa) : out;
};
const normalizeS4 = (out, v, n = 1, io = 0, ia = 0, so = 1, sa = 1)=>{
    !out && (out = v);
    const m = _magsJs.magS4(v, ia, sa);
    return m >= _api.EPS ? _mulnsJs.mulNS4(out, v, n / m, io, ia, so, sa) : out !== v ? _setsJs.setS4(out, v, io, ia, so, sa) : out;
};

},{"@thi.ng/math/api":"4a98p","./mags.js":"h4CFH","./mulns.js":"b3IkY","./sets.js":"3jBTJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"u5ZXS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "not", ()=>not
);
parcelHelpers.export(exports, "not2", ()=>not2
);
parcelHelpers.export(exports, "not3", ()=>not3
);
parcelHelpers.export(exports, "not4", ()=>not4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [not, not2, not3, not4] = _emitJs.defOp(([o, a])=>`${o}=!${a};`
, _templatesJs.ARGS_V, _templatesJs.ARGS_V, "o", 1, _templatesJs.NEW_OUT);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h0jz9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "orthoNormal3", ()=>orthoNormal3
);
var _crossJs = require("./cross.js");
var _normalizeJs = require("./normalize.js");
var _subJs = require("./sub.js");
const orthoNormal3 = (out, a, b, c, doNormalize = true)=>{
    out = _crossJs.cross3(null, _subJs.sub3(out || a, b, a), _subJs.sub3([], c, a));
    return doNormalize ? _normalizeJs.normalize(out, out) : out;
};

},{"./cross.js":"a6Q1x","./normalize.js":"9ex3j","./sub.js":"fzaw7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lDaDN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pointOnRay", ()=>pointOnRay
);
parcelHelpers.export(exports, "pointOnRay2", ()=>pointOnRay2
);
parcelHelpers.export(exports, "pointOnRay3", ()=>pointOnRay3
);
var _maddnJs = require("./maddn.js");
const pointOnRay = (out, rayOrigin, rayDir, dist)=>_maddnJs.maddN(out, rayDir, dist, rayOrigin)
;
const pointOnRay2 = (out, rayOrigin, rayDir, dist)=>_maddnJs.maddN2(out, rayDir, dist, rayOrigin)
;
const pointOnRay3 = (out, rayOrigin, rayDir, dist)=>_maddnJs.maddN3(out, rayDir, dist, rayOrigin)
;

},{"./maddn.js":"bTkou","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hjxag":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "polar", ()=>polar
);
parcelHelpers.export(exports, "polar2", ()=>polar2
);
parcelHelpers.export(exports, "polar3", ()=>polar3
);
var _vopJs = require("./vop.js");
var _magJs = require("./mag.js");
var _setcJs = require("./setc.js");
const sqrt = Math.sqrt;
const asin = Math.asin;
const atan2 = Math.atan2;
const polar = _vopJs.vop(1);
const polar2 = polar.add(2, (out, a)=>_setcJs.setC2(out || a, _magJs.mag(a), atan2(a[1], a[0]))
);
const polar3 = polar.add(3, (out, a)=>{
    const x = a[0];
    const y = a[1];
    const z = a[2];
    const r = sqrt(x * x + y * y + z * z);
    return _setcJs.setC3(out || a, r, asin(z / r), atan2(y, x));
});

},{"./vop.js":"4v2k5","./mag.js":"70TCJ","./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ek3Z1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pow", ()=>pow
);
parcelHelpers.export(exports, "pow2", ()=>pow2
);
parcelHelpers.export(exports, "pow3", ()=>pow3
);
parcelHelpers.export(exports, "pow4", ()=>pow4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [pow, pow2, pow3, pow4] = _emitJs.defOp(_templatesJs.FN2("Math.pow"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e4E3E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "powN", ()=>powN
);
parcelHelpers.export(exports, "powN2", ()=>powN2
);
parcelHelpers.export(exports, "powN3", ()=>powN3
);
parcelHelpers.export(exports, "powN4", ()=>powN4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [powN, powN2, powN3, powN4] = _emitJs.defOp(_templatesJs.FN_N("Math.pow"), _templatesJs.ARGS_VN);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Ztzw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "project", ()=>project
);
var _dotJs = require("./dot.js");
var _magsqJs = require("./magsq.js");
var _mulnJs = require("./muln.js");
const project = (out, v, dir)=>_mulnJs.mulN(out || v, dir, _dotJs.dot(v, dir) / _magsqJs.magSq(dir))
;

},{"./dot.js":"9vV5N","./magsq.js":"bsMC4","./muln.js":"1TKlE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jp9qg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "randomS", ()=>randomS
);
parcelHelpers.export(exports, "randomS2", ()=>randomS2
);
parcelHelpers.export(exports, "randomS3", ()=>randomS3
);
parcelHelpers.export(exports, "randomS4", ()=>randomS4
);
parcelHelpers.export(exports, "randomDistribS", ()=>randomDistribS
);
parcelHelpers.export(exports, "randomDistribS2", ()=>randomDistribS2
);
parcelHelpers.export(exports, "randomDistribS3", ()=>randomDistribS3
);
parcelHelpers.export(exports, "randomDistribS4", ()=>randomDistribS4
);
parcelHelpers.export(exports, "randNormS", ()=>randNormS
);
parcelHelpers.export(exports, "randNormS2", ()=>randNormS2
);
parcelHelpers.export(exports, "randNormS3", ()=>randNormS3
);
parcelHelpers.export(exports, "randNormS4", ()=>randNormS4
);
parcelHelpers.export(exports, "randNormDistribS", ()=>randNormDistribS
);
parcelHelpers.export(exports, "randNormDistribS2", ()=>randNormDistribS2
);
parcelHelpers.export(exports, "randNormDistribS3", ()=>randNormDistribS3
);
parcelHelpers.export(exports, "randNormDistribS4", ()=>randNormDistribS4
);
parcelHelpers.export(exports, "randMinMaxS", ()=>randMinMaxS
);
parcelHelpers.export(exports, "randMinMaxS2", ()=>randMinMaxS2
);
parcelHelpers.export(exports, "randMinMaxS3", ()=>randMinMaxS3
);
parcelHelpers.export(exports, "randMinMaxS4", ()=>randMinMaxS4
);
var _normal = require("@thi.ng/random/distributions/normal");
var _system = require("@thi.ng/random/system");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
var _normalizesJs = require("./normalizes.js");
const [randomS, randomS2, randomS3, randomS4] = _emitJs.defHofOpS(_system.SYSTEM, ([a])=>`${a}=rnd.minmax(n,m);`
, "a", "n=-1,m=1,rnd=op,ia=0,sa=1", "a", "a", _templatesJs.NEW_OUT_A);
const [randomDistribS, randomDistribS2, randomDistribS3, randomDistribS4, ] = _emitJs.defHofOpS(_normal.normal, ([a])=>`${a}=rnd()*n;`
, "a", "rnd=op(),n=1,ia=0,sa=1", "a", "a", _templatesJs.NEW_OUT_A);
const $norm = (normalize, random)=>(a, n = 1, rnd, ia = 0, sa = 1)=>normalize(null, random(a, -1, 1, rnd, ia, sa), n, ia, ia, sa, sa)
;
const $normDist = (normalize, random)=>(a, rnd, n = 1, ia = 0, sa = 1)=>normalize(null, random(a, rnd, 1, ia, sa), n, ia, ia, sa, sa)
;
const randNormS = (a, num, n = 1, rnd, ia = 0, sa = 1)=>_normalizesJs.normalizeS(a = randomS(a, num, -1, 1, rnd, ia, sa), a, num, n, ia, ia, sa, sa)
;
const randNormS2 = $norm(_normalizesJs.normalizeS2, randomS2);
const randNormS3 = $norm(_normalizesJs.normalizeS3, randomS3);
const randNormS4 = $norm(_normalizesJs.normalizeS4, randomS4);
const randNormDistribS = (a, num, rnd, n = 1, ia = 0, sa = 1)=>_normalizesJs.normalizeS(null, randomDistribS(a, num, rnd, 1, ia, sa), num, n, ia, ia, sa, sa)
;
const randNormDistribS2 = $normDist(_normalizesJs.normalizeS2, randomDistribS2);
const randNormDistribS3 = $normDist(_normalizesJs.normalizeS3, randomDistribS3);
const randNormDistribS4 = $normDist(_normalizesJs.normalizeS4, randomDistribS4);
const [randMinMaxS, randMinMaxS2, randMinMaxS3, randMinMaxS4] = _emitJs.defHofOpS(_system.SYSTEM, ([o, a, b])=>`${o}=rnd.minmax(${a},${b});`
, "o,a,b", `rnd=op,${_templatesJs.SARGS_VV}`, "o,a,b");

},{"@thi.ng/random/distributions/normal":"eJF5A","@thi.ng/random/system":"bSLzr","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","./normalizes.js":"lD3Rj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d5xc2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "reflect", ()=>reflect
);
var _dotJs = require("./dot.js");
var _maddnJs = require("./maddn.js");
const reflect = (out, a, b)=>_maddnJs.maddN(out || a, b, -2 * _dotJs.dot(a, b), a)
;

},{"./dot.js":"9vV5N","./maddn.js":"bTkou","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1FHgE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "refract", ()=>refract
);
var _dotJs = require("./dot.js");
var _maddnJs = require("./maddn.js");
var _mulnJs = require("./muln.js");
var _setnJs = require("./setn.js");
const refract = (out, a, n, eta)=>{
    !out && (out = a);
    const d = _dotJs.dot(a, n);
    const k = 1 - eta * eta * (1 - d * d);
    return k < 0 ? _setnJs.zero(out) : _maddnJs.maddN(out, n, -(eta * d + Math.sqrt(k)), _mulnJs.mulN(out, a, eta));
};

},{"./dot.js":"9vV5N","./maddn.js":"bTkou","./muln.js":"1TKlE","./setn.js":"2M6y1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8QlLp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "remainder", ()=>remainder
);
parcelHelpers.export(exports, "remainder2", ()=>remainder2
);
parcelHelpers.export(exports, "remainder3", ()=>remainder3
);
parcelHelpers.export(exports, "remainder4", ()=>remainder4
);
var _libc = require("@thi.ng/math/libc");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [remainder, remainder2, remainder3, remainder4] = _emitJs.defHofOp(_libc.remainder, _templatesJs.FN2("op"), _templatesJs.ARGS_VV);

},{"@thi.ng/math/libc":"6VBft","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6VBft":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "copysign", ()=>copysign
);
parcelHelpers.export(exports, "exp2", ()=>exp2
);
parcelHelpers.export(exports, "fdim", ()=>fdim
);
parcelHelpers.export(exports, "fma", ()=>fma
);
parcelHelpers.export(exports, "fmod", ()=>fmod
);
parcelHelpers.export(exports, "frexp", ()=>frexp
);
parcelHelpers.export(exports, "ldexp", ()=>ldexp
);
parcelHelpers.export(exports, "remainder", ()=>remainder
);
parcelHelpers.export(exports, "ldiv", ()=>ldiv
);
const copysign = (x, y)=>Math.sign(y) * Math.abs(x)
;
const exp2 = (x)=>2 ** x
;
const fdim = (x, y)=>Math.max(x - y, 0)
;
const fma = (x, y, z)=>x * y + z
;
const fmod = (x, y)=>x % y
;
const frexp = (x)=>{
    if (x === 0 || !isFinite(x)) return [
        x,
        0
    ];
    const abs = Math.abs(x);
    let exp = Math.max(-1023, Math.floor(Math.log2(abs)) + 1);
    let y = abs * 2 ** -exp;
    while(y < 0.5){
        y *= 2;
        exp--;
    }
    while(y >= 1){
        y *= 0.5;
        exp++;
    }
    return [
        x < 0 ? -y : y,
        exp
    ];
};
const ldexp = (x, exp)=>x * 2 ** exp
;
const remainder = (x, y)=>x - y * Math.round(x / y)
;
const ldiv = (x, y)=>{
    x |= 0;
    y |= 0;
    const q = x / y | 0;
    return [
        q,
        x - q * y
    ];
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6YhVp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "remainderN", ()=>remainderN
);
parcelHelpers.export(exports, "remainderN2", ()=>remainderN2
);
parcelHelpers.export(exports, "remainderN3", ()=>remainderN3
);
parcelHelpers.export(exports, "remainderN4", ()=>remainderN4
);
var _libc = require("@thi.ng/math/libc");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [remainderN, remainderN2, remainderN3, remainderN4] = _emitJs.defHofOp(_libc.remainder, _templatesJs.FN_N("op"), _templatesJs.ARGS_VN, _templatesJs.ARGS_V);

},{"@thi.ng/math/libc":"6VBft","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bnMmK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rotateAroundAxis3", ()=>rotateAroundAxis3
);
var _setcJs = require("./setc.js");
const rotateAroundAxis3 = (out, v, axis, theta)=>{
    const x = v[0];
    const y = v[1];
    const z = v[2];
    const ax = axis[0];
    const ay = axis[1];
    const az = axis[2];
    const ux = ax * x;
    const uy = ax * y;
    const uz = ax * z;
    const vx = ay * x;
    const vy = ay * y;
    const vz = ay * z;
    const wx = az * x;
    const wy = az * y;
    const wz = az * z;
    const uvw = ux + vy + wz;
    const s = Math.sin(theta);
    const c = Math.cos(theta);
    return _setcJs.setC3(out || v, ax * uvw + (x * (ay * ay + az * az) - ax * (vy + wz)) * c + (-wy + vz) * s, ay * uvw + (y * (ax * ax + az * az) - ay * (ux + wz)) * c + (wx - uz) * s, az * uvw + (z * (ax * ax + ay * ay) - az * (ux + vy)) * c + (-vx + uy) * s);
};

},{"./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fTth1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rotateAroundPoint2", ()=>rotateAroundPoint2
);
var _setcJs = require("./setc.js");
const rotateAroundPoint2 = (out, v, p, theta)=>{
    const x = v[0] - p[0];
    const y = v[1] - p[1];
    const s = Math.sin(theta);
    const c = Math.cos(theta);
    return _setcJs.setC2(out || v, x * c - y * s + p[0], x * s + y * c + p[1]);
};

},{"./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"756IA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
parcelHelpers.export(exports, "rotate", ()=>rotate
);
var _setJs = require("./set.js");
const _rotate = (u, v)=>(out, a, theta)=>{
        out ? out !== a && _setJs.set(out, a) : out = a;
        const s = Math.sin(theta);
        const c = Math.cos(theta);
        const x = a[u];
        const y = a[v];
        out[u] = x * c - y * s;
        out[v] = x * s + y * c;
        return out;
    }
;
const rotateX = _rotate(1, 2);
const rotateY = _rotate(2, 0);
const rotateZ = _rotate(0, 1);
const rotate = rotateZ;

},{"./set.js":"bSUB8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f8Qd6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rotateS2", ()=>rotateS2
);
parcelHelpers.export(exports, "rotateXS3", ()=>rotateXS3
);
parcelHelpers.export(exports, "rotateYS3", ()=>rotateYS3
);
parcelHelpers.export(exports, "rotateZS3", ()=>rotateZS3
);
var _setsJs = require("./sets.js");
const _rotate = (set, u, v)=>(out, a, theta, io = 0, ia = 0, so = 1, sa = 1)=>{
        out ? out !== a && set(out, a, io, ia, so, sa) : out = a;
        const s = Math.sin(theta);
        const c = Math.cos(theta);
        const x = a[ia + u * sa];
        const y = a[ia + v * sa];
        out[io + u * so] = x * c - y * s;
        out[io + v * so] = x * s + y * c;
        return out;
    }
;
const rotateS2 = _rotate(_setsJs.setS2, 0, 1);
const rotateXS3 = _rotate(_setsJs.setS3, 1, 2);
const rotateYS3 = _rotate(_setsJs.setS3, 2, 0);
const rotateZS3 = _rotate(_setsJs.setS3, 0, 1);

},{"./sets.js":"3jBTJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k0lRR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "round", ()=>round
);
parcelHelpers.export(exports, "round2", ()=>round2
);
parcelHelpers.export(exports, "round3", ()=>round3
);
parcelHelpers.export(exports, "round4", ()=>round4
);
parcelHelpers.export(exports, "roundN", ()=>roundN
);
parcelHelpers.export(exports, "roundN2", ()=>roundN2
);
parcelHelpers.export(exports, "roundN3", ()=>roundN3
);
parcelHelpers.export(exports, "roundN4", ()=>roundN4
);
var _prec = require("@thi.ng/math/prec");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [round, round2, round3, round4] = _emitJs.defHofOp(_prec.roundTo, _templatesJs.FN2("op"), _templatesJs.ARGS_VV);
const [roundN, roundN2, roundN3, roundN4] = _emitJs.defHofOp(_prec.roundTo, _templatesJs.FN_N("op"), "o,a,n=1", "o,a");

},{"@thi.ng/math/prec":"7e7rg","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5ezs6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rshiftI", ()=>rshiftI
);
parcelHelpers.export(exports, "rshiftI2", ()=>rshiftI2
);
parcelHelpers.export(exports, "rshiftI3", ()=>rshiftI3
);
parcelHelpers.export(exports, "rshiftI4", ()=>rshiftI4
);
parcelHelpers.export(exports, "rshiftU", ()=>rshiftU
);
parcelHelpers.export(exports, "rshiftU2", ()=>rshiftU2
);
parcelHelpers.export(exports, "rshiftU3", ()=>rshiftU3
);
parcelHelpers.export(exports, "rshiftU4", ()=>rshiftU4
);
parcelHelpers.export(exports, "rshiftNI", ()=>rshiftNI
);
parcelHelpers.export(exports, "rshiftNI2", ()=>rshiftNI2
);
parcelHelpers.export(exports, "rshiftNI3", ()=>rshiftNI3
);
parcelHelpers.export(exports, "rshiftNI4", ()=>rshiftNI4
);
parcelHelpers.export(exports, "rshiftNU", ()=>rshiftNU
);
parcelHelpers.export(exports, "rshiftNU2", ()=>rshiftNU2
);
parcelHelpers.export(exports, "rshiftNU3", ()=>rshiftNU3
);
parcelHelpers.export(exports, "rshiftNU4", ()=>rshiftNU4
);
var _emitJs = require("./compile/emit.js");
const [rshiftI, rshiftI2, rshiftI3, rshiftI4] = _emitJs.defBitOp(">>", true);
const [rshiftU, rshiftU2, rshiftU3, rshiftU4] = _emitJs.defBitOp(">>>");
const [rshiftNI, rshiftNI2, rshiftNI3, rshiftNI4] = _emitJs.defBitOpN(">>", true);
const [rshiftNU, rshiftNU2, rshiftNU3, rshiftNU4] = _emitJs.defBitOpN(">>>");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iquHD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "safeDiv", ()=>safeDiv
);
parcelHelpers.export(exports, "safeDiv2", ()=>safeDiv2
);
parcelHelpers.export(exports, "safeDiv3", ()=>safeDiv3
);
parcelHelpers.export(exports, "safeDiv4", ()=>safeDiv4
);
var _safeDiv = require("@thi.ng/math/safe-div");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [safeDiv, safeDiv2, safeDiv3, safeDiv4] = _emitJs.defHofOp(_safeDiv.safeDiv, _templatesJs.FN2("op"), _templatesJs.ARGS_VV);

},{"@thi.ng/math/safe-div":"5Hm6P","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Hm6P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "safeDiv", ()=>safeDiv
);
const safeDiv = (a, b)=>b !== 0 ? a / b : 0
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e9RWo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "select", ()=>select
);
const select = (out, a, b, mask)=>{
    out = out || a;
    for(let i = a.length; i-- > 0;)out[i] = mask[i] ? b[i] : a[i];
    return out;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fEREX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setNS", ()=>setNS
);
parcelHelpers.export(exports, "setNS2", ()=>setNS2
);
parcelHelpers.export(exports, "setNS3", ()=>setNS3
);
parcelHelpers.export(exports, "setNS4", ()=>setNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [setNS, setNS2, setNS3, setNS4] = _emitJs.defOpS(_templatesJs.SET_N, "o,n", "io=0,so=1", "o", "o", "");

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Xxwm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setVN3", ()=>setVN3
);
parcelHelpers.export(exports, "setVN4", ()=>setVN4
);
var _setcJs = require("./setc.js");
const setVN3 = (out, a, n)=>_setcJs.setC3(out, a[0], a[1], n)
;
const setVN4 = (out, a, n)=>_setcJs.setC4(out, a[0], a[1], a[2], n)
;

},{"./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bgsN2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setVV4", ()=>setVV4
);
parcelHelpers.export(exports, "setVV6", ()=>setVV6
);
parcelHelpers.export(exports, "setVV9", ()=>setVV9
);
parcelHelpers.export(exports, "setVV16", ()=>setVV16
);
var _setcJs = require("./setc.js");
const setVV4 = (out, a, b)=>_setcJs.setC4(out, a[0], a[1], b[0], b[1])
;
const setVV6 = (out, a, b, c)=>_setcJs.setC6(out, a[0], a[1], b[0], b[1], c[0], c[1])
;
const setVV9 = (out, a, b, c)=>_setcJs.setC(out, a[0], a[1], a[2], b[0], b[1], b[2], c[0], c[1], c[2])
;
const setVV16 = (out, a, b, c, d)=>_setcJs.setC(out, a[0], a[1], a[2], a[3], b[0], b[1], b[2], b[3], c[0], c[1], c[2], c[3], d[0], d[1], d[2], d[3])
;

},{"./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"deOCU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sign", ()=>sign
);
parcelHelpers.export(exports, "sign2", ()=>sign2
);
parcelHelpers.export(exports, "sign3", ()=>sign3
);
parcelHelpers.export(exports, "sign4", ()=>sign4
);
var _emitJs = require("./compile/emit.js");
const [sign, sign2, sign3, sign4] = _emitJs.defFnOp("Math.sign");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kWxbb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "signedVolume", ()=>signedVolume
);
const signedVolume = (a, b, c, [dx, dy, dz])=>{
    const ady = a[1] - dy;
    const bdy = b[1] - dy;
    const cdy = c[1] - dy;
    const adz = a[2] - dz;
    const bdz = b[2] - dz;
    const cdz = c[2] - dz;
    return (a[0] - dx) * (bdy * cdz - bdz * cdy) + (b[0] - dx) * (cdy * adz - cdz * ady) + (c[0] - dx) * (ady * bdz - adz * bdy);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eQFJ3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sin", ()=>sin
);
parcelHelpers.export(exports, "sin2", ()=>sin2
);
parcelHelpers.export(exports, "sin3", ()=>sin3
);
parcelHelpers.export(exports, "sin4", ()=>sin4
);
var _emitJs = require("./compile/emit.js");
const [sin, sin2, sin3, sin4] = _emitJs.defFnOp("Math.sin");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4FADI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sinh", ()=>sinh
);
parcelHelpers.export(exports, "sinh2", ()=>sinh2
);
parcelHelpers.export(exports, "sinh3", ()=>sinh3
);
parcelHelpers.export(exports, "sinh4", ()=>sinh4
);
var _emitJs = require("./compile/emit.js");
const [sinh, sinh2, sinh3, sinh4] = _emitJs.defFnOp("Math.sinh");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"awIye":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "softMax", ()=>softMax
);
var _divnJs = require("./divn.js");
var _expJs = require("./exp.js");
var _sumJs = require("./sum.js");
const softMax = (out, src)=>{
    const e = _expJs.exp([], src);
    return _divnJs.divN(out || src, e, _sumJs.sum(e));
};

},{"./divn.js":"8VZzE","./exp.js":"5Qp2H","./sum.js":"2gBvR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kVDnA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "some", ()=>some
);
parcelHelpers.export(exports, "some2", ()=>some2
);
parcelHelpers.export(exports, "some3", ()=>some3
);
parcelHelpers.export(exports, "some4", ()=>some4
);
var _vopJs = require("./vop.js");
const some = _vopJs.vop();
some.default((v)=>{
    for(let i = v.length; i-- > 0;){
        if (v[i]) return true;
    }
    return false;
});
const some2 = some.add(2, (a)=>a[0] || a[1]
);
const some3 = some.add(3, (a)=>a[0] || a[1] || a[2]
);
const some4 = some.add(4, (a)=>a[0] || a[1] || a[2] || a[3]
);

},{"./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"adalI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sqrt", ()=>sqrt
);
parcelHelpers.export(exports, "sqrt2", ()=>sqrt2
);
parcelHelpers.export(exports, "sqrt3", ()=>sqrt3
);
parcelHelpers.export(exports, "sqrt4", ()=>sqrt4
);
var _emitJs = require("./compile/emit.js");
const [sqrt, sqrt2, sqrt3, sqrt4] = _emitJs.defFnOp("Math.sqrt");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1iWKd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "step", ()=>step
);
parcelHelpers.export(exports, "step2", ()=>step2
);
parcelHelpers.export(exports, "step3", ()=>step3
);
parcelHelpers.export(exports, "step4", ()=>step4
);
var _step = require("@thi.ng/math/step");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [step, step2, step3, step4] = _emitJs.defHofOp(_step.step, _templatesJs.FN2("op"), "o,e,a", undefined, "o", 2, _templatesJs.DEFAULT_OUT);

},{"@thi.ng/math/step":"kmNpH","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kmNpH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "step", ()=>step
);
parcelHelpers.export(exports, "smoothStep", ()=>smoothStep
);
parcelHelpers.export(exports, "smootherStep", ()=>smootherStep
);
parcelHelpers.export(exports, "expStep", ()=>expStep
);
var _intervalJs = require("./interval.js");
const step = (edge, x)=>x < edge ? 0 : 1
;
const smoothStep = (edge, edge2, x)=>{
    x = _intervalJs.clamp01((x - edge) / (edge2 - edge));
    return (3 - 2 * x) * x * x;
};
const smootherStep = (edge, edge2, x)=>{
    x = _intervalJs.clamp01((x - edge) / (edge2 - edge));
    return x * x * x * (x * (x * 6 - 15) + 10);
};
const expStep = (k, n, x)=>1 - Math.exp(-k * Math.pow(x, n))
;

},{"./interval.js":"1TDWA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"95Lq7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "smoothStep", ()=>smoothStep
);
parcelHelpers.export(exports, "smoothStep2", ()=>smoothStep2
);
parcelHelpers.export(exports, "smoothStep3", ()=>smoothStep3
);
parcelHelpers.export(exports, "smoothStep4", ()=>smoothStep4
);
var _step = require("@thi.ng/math/step");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [smoothStep, smoothStep2, smoothStep3, smoothStep4] = _emitJs.defHofOp(_step.smoothStep, _templatesJs.FN3(), "o,e1,e2,a", undefined, "o", 3, _templatesJs.DEFAULT_OUT);

},{"@thi.ng/math/step":"kmNpH","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dbQSi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "standardize", ()=>standardize
);
var _centerJs = require("./center.js");
var _mulnJs = require("./muln.js");
var _setJs = require("./set.js");
var _varianceJs = require("./variance.js");
const standardize = (out, a, isCentered = false)=>{
    out = !isCentered ? _centerJs.center(out, a) : !out ? a : _setJs.set(out, a);
    const d = _varianceJs.sd(out, true);
    return d > 0 ? _mulnJs.mulN(null, out, 1 / d) : out;
};

},{"./center.js":"2MkSv","./muln.js":"1TKlE","./set.js":"bSUB8","./variance.js":"5Fsvh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Fsvh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "variance", ()=>variance
);
parcelHelpers.export(exports, "sd", ()=>sd
);
parcelHelpers.export(exports, "sdError", ()=>sdError
);
var _centerJs = require("./center.js");
var _magsqJs = require("./magsq.js");
const variance = (a, isCentered = false)=>a.length > 0 ? _magsqJs.magSq(isCentered ? a : _centerJs.center([], a)) / a.length : 0
;
const sd = (a, isCentered = false)=>a.length > 1 ? Math.sqrt(_magsqJs.magSq(isCentered ? a : _centerJs.center([], a)) / (a.length - 1)) : 0
;
const sdError = (a, isCentered = false)=>a.length > 1 ? sd(a, isCentered) / Math.sqrt(a.length) : 0
;

},{"./center.js":"2MkSv","./magsq.js":"bsMC4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"csHlx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subI", ()=>subI
);
parcelHelpers.export(exports, "subI2", ()=>subI2
);
parcelHelpers.export(exports, "subI3", ()=>subI3
);
parcelHelpers.export(exports, "subI4", ()=>subI4
);
parcelHelpers.export(exports, "subU", ()=>subU
);
parcelHelpers.export(exports, "subU2", ()=>subU2
);
parcelHelpers.export(exports, "subU3", ()=>subU3
);
parcelHelpers.export(exports, "subU4", ()=>subU4
);
parcelHelpers.export(exports, "subNI", ()=>subNI
);
parcelHelpers.export(exports, "subNI2", ()=>subNI2
);
parcelHelpers.export(exports, "subNI3", ()=>subNI3
);
parcelHelpers.export(exports, "subNI4", ()=>subNI4
);
parcelHelpers.export(exports, "subNU", ()=>subNU
);
parcelHelpers.export(exports, "subNU2", ()=>subNU2
);
parcelHelpers.export(exports, "subNU3", ()=>subNU3
);
parcelHelpers.export(exports, "subNU4", ()=>subNU4
);
var _emitJs = require("./compile/emit.js");
const [subI, subI2, subI3, subI4] = _emitJs.defBitOp("-", true);
const [subU, subU2, subU3, subU4] = _emitJs.defBitOp("-");
const [subNI, subNI2, subNI3, subNI4] = _emitJs.defBitOpN("-", true);
const [subNU, subNU2, subNU3, subNU4] = _emitJs.defBitOpN("-");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"92Lej":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subm", ()=>subm
);
parcelHelpers.export(exports, "subm2", ()=>subm2
);
parcelHelpers.export(exports, "subm3", ()=>subm3
);
parcelHelpers.export(exports, "subm4", ()=>subm4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [subm, subm2, subm3, subm4] = _emitJs.defOp(_templatesJs.MATH2("-", "*"), _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1EUBR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "submS", ()=>submS
);
parcelHelpers.export(exports, "submS2", ()=>submS2
);
parcelHelpers.export(exports, "submS3", ()=>submS3
);
parcelHelpers.export(exports, "submS4", ()=>submS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [submS, submS2, submS3, submS4] = _emitJs.defOpS(_templatesJs.MATH2("-", "*"), _templatesJs.ARGS_VVV, _templatesJs.SARGS_VVV, _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"co6Wj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "submNS", ()=>submNS
);
parcelHelpers.export(exports, "submNS2", ()=>submNS2
);
parcelHelpers.export(exports, "submNS3", ()=>submNS3
);
parcelHelpers.export(exports, "submNS4", ()=>submNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [submNS, submNS2, submNS3, submNS4] = _emitJs.defOpS(_templatesJs.MATH2_N("-", "*"), _templatesJs.ARGS_VVN, _templatesJs.SARGS_VV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h2qQr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subS", ()=>subS
);
parcelHelpers.export(exports, "subS2", ()=>subS2
);
parcelHelpers.export(exports, "subS3", ()=>subS3
);
parcelHelpers.export(exports, "subS4", ()=>subS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [subS, subS2, subS3, subS4] = _emitJs.defOpS(_templatesJs.MATH("-"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hfisH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subNS", ()=>subNS
);
parcelHelpers.export(exports, "subNS2", ()=>subNS2
);
parcelHelpers.export(exports, "subNS3", ()=>subNS3
);
parcelHelpers.export(exports, "subNS4", ()=>subNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [subNS, subNS2, subNS3, subNS4] = _emitJs.defOpS(_templatesJs.MATH_N("-"), _templatesJs.ARGS_VN, _templatesJs.SARGS_V, _templatesJs.ARGS_V);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8JoUk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "swizzle2", ()=>swizzle2
);
parcelHelpers.export(exports, "swizzle3", ()=>swizzle3
);
parcelHelpers.export(exports, "swizzle4", ()=>swizzle4
);
parcelHelpers.export(exports, "swapXY", ()=>swapXY
);
parcelHelpers.export(exports, "swapXZ", ()=>swapXZ
);
parcelHelpers.export(exports, "swapYZ", ()=>swapYZ
);
parcelHelpers.export(exports, "setSwizzle1", ()=>setSwizzle1
);
parcelHelpers.export(exports, "setSwizzle2", ()=>setSwizzle2
);
parcelHelpers.export(exports, "setSwizzle3", ()=>setSwizzle3
);
parcelHelpers.export(exports, "setSwizzle4", ()=>setSwizzle4
);
var _setcJs = require("./setc.js");
const swizzle2 = (out, a, x, y)=>_setcJs.setC2(out || a, a[x] || 0, a[y] || 0)
;
const swizzle3 = (out, a, x, y, z)=>_setcJs.setC3(out || a, a[x] || 0, a[y] || 0, a[z] || 0)
;
const swizzle4 = (out, a, x, y, z, w)=>_setcJs.setC4(out || a, a[x] || 0, a[y] || 0, a[z] || 0, a[w] || 0)
;
const swapXY = (out, v)=>swizzle3(out, v, 1, 0, 2)
;
const swapXZ = (out, v)=>swizzle3(out, v, 2, 1, 0)
;
const swapYZ = (out, v)=>swizzle3(out, v, 0, 2, 1)
;
const setSwizzle1 = (out, n, a)=>(out[a] = n, out)
;
const setSwizzle2 = (out, v, a, b)=>(out[a] = v[0], out[b] = v[1], out)
;
const setSwizzle3 = (out, v, a, b, c)=>(out[a] = v[0], out[b] = v[1], out[c] = v[2], out)
;
const setSwizzle4 = (out, v, a, b, c, d)=>(out[a] = v[0], out[b] = v[1], out[c] = v[2], out[d] = v[3], out)
;

},{"./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9mqB8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tan", ()=>tan
);
parcelHelpers.export(exports, "tan2", ()=>tan2
);
parcelHelpers.export(exports, "tan3", ()=>tan3
);
parcelHelpers.export(exports, "tan4", ()=>tan4
);
var _emitJs = require("./compile/emit.js");
const [tan, tan2, tan3, tan4] = _emitJs.defFnOp("Math.tan");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cIJ1g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tanh", ()=>tanh
);
parcelHelpers.export(exports, "tanh2", ()=>tanh2
);
parcelHelpers.export(exports, "tanh3", ()=>tanh3
);
parcelHelpers.export(exports, "tanh4", ()=>tanh4
);
var _emitJs = require("./compile/emit.js");
const [tanh, tanh2, tanh3, tanh4] = _emitJs.defFnOp("Math.tanh");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"coH0v":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tensor", ()=>tensor
);
const tensor = (out, a, b)=>{
    out = out || [];
    const n = a.length;
    const m = b.length;
    for(let i = 0, k = 0; i < m; i++){
        const bb = b[i];
        for(let j = 0; j < n; j++)out[k++] = a[j] * bb;
    }
    return out;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1UHBI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "trunc", ()=>trunc
);
parcelHelpers.export(exports, "trunc2", ()=>trunc2
);
parcelHelpers.export(exports, "trunc3", ()=>trunc3
);
parcelHelpers.export(exports, "trunc4", ()=>trunc4
);
var _emitJs = require("./compile/emit.js");
const [trunc, trunc2, trunc3, trunc4] = _emitJs.defFnOp("Math.trunc");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7bcGS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "wrap", ()=>wrap
);
parcelHelpers.export(exports, "wrap2", ()=>wrap2
);
parcelHelpers.export(exports, "wrap3", ()=>wrap3
);
parcelHelpers.export(exports, "wrap4", ()=>wrap4
);
var _interval = require("@thi.ng/math/interval");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [wrap, wrap2, wrap3, wrap4] = _emitJs.defHofOp(_interval.wrap, _templatesJs.FN3(), _templatesJs.ARGS_VVV);

},{"@thi.ng/math/interval":"1TDWA","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"XkoMe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eq", ()=>eq
);
parcelHelpers.export(exports, "eq2", ()=>eq2
);
parcelHelpers.export(exports, "eq3", ()=>eq3
);
parcelHelpers.export(exports, "eq4", ()=>eq4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [eq, eq2, eq3, eq4] = _emitJs.defOp(_templatesJs.MATH("==="));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1PSgL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "neq", ()=>neq
);
parcelHelpers.export(exports, "neq2", ()=>neq2
);
parcelHelpers.export(exports, "neq3", ()=>neq3
);
parcelHelpers.export(exports, "neq4", ()=>neq4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [neq, neq2, neq3, neq4] = _emitJs.defOp(_templatesJs.MATH("!=="));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c6eU8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "gt", ()=>gt
);
parcelHelpers.export(exports, "gt2", ()=>gt2
);
parcelHelpers.export(exports, "gt3", ()=>gt3
);
parcelHelpers.export(exports, "gt4", ()=>gt4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [gt, gt2, gt3, gt4] = _emitJs.defOp(_templatesJs.MATH(">"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h9jv8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "gte", ()=>gte
);
parcelHelpers.export(exports, "gte2", ()=>gte2
);
parcelHelpers.export(exports, "gte3", ()=>gte3
);
parcelHelpers.export(exports, "gte4", ()=>gte4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [gte, gte2, gte3, gte4] = _emitJs.defOp(_templatesJs.MATH(">="));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8IIjy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lt", ()=>lt
);
parcelHelpers.export(exports, "lt2", ()=>lt2
);
parcelHelpers.export(exports, "lt3", ()=>lt3
);
parcelHelpers.export(exports, "lt4", ()=>lt4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [lt, lt2, lt3, lt4] = _emitJs.defOp(_templatesJs.MATH("<"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7gcE2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lte", ()=>lte
);
parcelHelpers.export(exports, "lte2", ()=>lte2
);
parcelHelpers.export(exports, "lte3", ()=>lte3
);
parcelHelpers.export(exports, "lte4", ()=>lte4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [lte, lte2, lte3, lte4] = _emitJs.defOp(_templatesJs.MATH("<="));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lBUk4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stratifiedGrid", ()=>stratifiedGrid
);
var _system = require("@thi.ng/random/system");
var _mapcat = require("@thi.ng/transducers/mapcat");
var _rangeNd = require("@thi.ng/transducers/range-nd");
var _repeatedly = require("@thi.ng/transducers/repeatedly");
var _add = require("@thi.ng/vectors/add");
var _random = require("@thi.ng/vectors/random");
const stratifiedGrid = (opts)=>{
    const { rnd , samples  } = {
        samples: 1,
        rnd: _system.SYSTEM,
        ...opts
    };
    const tmp = new Array(opts.dim.length);
    return _mapcat.mapcat((p)=>_repeatedly.repeatedly(()=>_add.add([], p, _random.random(tmp, 0, 1, rnd))
        , samples)
    , _rangeNd.rangeNd(opts.dim));
};

},{"@thi.ng/random/system":"bSLzr","@thi.ng/transducers/mapcat":"9sxcu","@thi.ng/transducers/range-nd":"aQxOa","@thi.ng/transducers/repeatedly":"4kJU5","@thi.ng/vectors/add":"6HmvS","@thi.ng/vectors/random":"8bjGw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9sxcu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapcat", ()=>mapcat
);
var _isIterable = require("@thi.ng/checks/is-iterable");
var _catJs = require("./cat.js");
var _compJs = require("./comp.js");
var _iteratorJs = require("./iterator.js");
var _mapJs = require("./map.js");
function mapcat(fn, src) {
    return _isIterable.isIterable(src) ? _iteratorJs.iterator(mapcat(fn), src) : _compJs.comp(_mapJs.map(fn), _catJs.cat());
}

},{"@thi.ng/checks/is-iterable":"bDbbO","./cat.js":"8F4Zk","./comp.js":"7g4yM","./iterator.js":"8km8L","./map.js":"fW6Xn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8F4Zk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cat", ()=>cat
);
var _comprJs = require("./compr.js");
var _reducedJs = require("./reduced.js");
const cat = ()=>(rfn)=>{
        const r = rfn[2];
        return _comprJs.compR(rfn, (acc, x)=>{
            if (x) for (let y of _reducedJs.unreduced(x)){
                acc = r(acc, y);
                if (_reducedJs.isReduced(acc)) break;
            }
            return _reducedJs.isReduced(x) ? _reducedJs.ensureReduced(acc) : acc;
        });
    }
;

},{"./compr.js":"ePFjm","./reduced.js":"cAjrZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aQxOa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rangeNd", ()=>rangeNd
);
var _mapJs = require("./map.js");
var _permutationsJs = require("./permutations.js");
var _rangeJs = require("./range.js");
var _zipJs = require("./zip.js");
const rangeNd = (min, max)=>_permutationsJs.permutations.apply(null, max ? [
        ..._mapJs.map(([a, b])=>_rangeJs.range(a, b)
        , _zipJs.zip(min, max))
    ] : [
        ..._mapJs.map(_rangeJs.range, min)
    ])
;

},{"./map.js":"fW6Xn","./permutations.js":"jj5MK","./range.js":"lUHc9","./zip.js":"ithYS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4kJU5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Iterator yielding return values of given single-arg function `fn` (called
 * with `i`, current iteration count). If `n` is given, only that many values
 * will be produced, else the iterator is infinite.
 *
 * @example
 * ```ts
 * [...repeatedly(() => Math.floor(Math.random() * 10), 5)]
 * // [7, 0, 9, 3, 1]
 *
 * [...repeatedly((i) => i, 5)]
 * // [0, 1, 2, 3, 4]
 * ```
 *
 * @param fn - value producer
 * @param n - num values (default: ∞)
 */ parcelHelpers.export(exports, "repeatedly", ()=>repeatedly
);
function* repeatedly(fn, n = Infinity) {
    for(let i = 0; i < n; i++)yield fn(i);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cdKXu":[function(require,module,exports) {
'use strict';
module.exports = barycentric;
var solve = require('robust-linear-solve');
function reduce(x) {
    var r = 0;
    for(var i = 0; i < x.length; ++i)r += x[i];
    return r;
}
function barycentric(simplex, point) {
    var d = point.length;
    var A = new Array(d + 1);
    for(var i = 0; i < d; ++i){
        var row = new Array(d + 1);
        for(var j = 0; j <= d; ++j)row[j] = simplex[j][i];
        A[i] = row;
    }
    A[d] = new Array(d + 1);
    for(var i = 0; i <= d; ++i)A[d][i] = 1;
    var b = new Array(d + 1);
    for(var i = 0; i < d; ++i)b[i] = point[i];
    b[d] = 1;
    var x = solve(A, b);
    var w = reduce(x[d + 1]);
    if (w === 0) w = 1;
    var y = new Array(d + 1);
    for(var i = 0; i <= d; ++i)y[i] = reduce(x[i]) / w;
    return y;
}

},{"robust-linear-solve":"iYZGk"}],"iYZGk":[function(require,module,exports) {
"use strict";
var determinant = require("robust-determinant");
var NUM_EXPAND = 6;
function generateSolver(n) {
    var funcName = "robustLinearSolve" + n + "d";
    var code = [
        "function ",
        funcName,
        "(A,b){return ["
    ];
    for(var i = 0; i < n; ++i){
        code.push("det([");
        for(var j = 0; j < n; ++j){
            if (j > 0) code.push(",");
            code.push("[");
            for(var k = 0; k < n; ++k){
                if (k > 0) code.push(",");
                if (k === i) code.push("+b[", j, "]");
                else code.push("+A[", j, "][", k, "]");
            }
            code.push("]");
        }
        code.push("]),");
    }
    code.push("det(A)]}return ", funcName);
    var proc = new Function("det", code.join(""));
    if (n < 6) return proc(determinant[n]);
    return proc(determinant);
}
function robustLinearSolve0d() {
    return [
        0
    ];
}
function robustLinearSolve1d(A, b) {
    return [
        [
            b[0]
        ],
        [
            A[0][0]
        ]
    ];
}
var CACHE = [
    robustLinearSolve0d,
    robustLinearSolve1d
];
function generateDispatch() {
    while(CACHE.length < NUM_EXPAND)CACHE.push(generateSolver(CACHE.length));
    var procArgs = [];
    var code = [
        "function dispatchLinearSolve(A,b){switch(A.length){"
    ];
    for(var i = 0; i < NUM_EXPAND; ++i){
        procArgs.push("s" + i);
        code.push("case ", i, ":return s", i, "(A,b);");
    }
    code.push("}var s=CACHE[A.length];if(!s)s=CACHE[A.length]=g(A.length);return s(A,b)}return dispatchLinearSolve");
    procArgs.push("CACHE", "g", code.join(""));
    var proc = Function.apply(undefined, procArgs);
    module.exports = proc.apply(undefined, CACHE.concat([
        CACHE,
        generateSolver
    ]));
    for(var i = 0; i < NUM_EXPAND; ++i)module.exports[i] = CACHE[i];
}
generateDispatch();

},{"robust-determinant":"8JpWu"}],"8JpWu":[function(require,module,exports) {
"use strict";
var twoProduct = require("two-product");
var robustSum = require("robust-sum");
var robustScale = require("robust-scale");
var compress = require("robust-compress");
var NUM_EXPANDED = 6;
function cofactor(m, c) {
    var result = new Array(m.length - 1);
    for(var i = 1; i < m.length; ++i){
        var r = result[i - 1] = new Array(m.length - 1);
        for(var j = 0, k = 0; j < m.length; ++j){
            if (j === c) continue;
            r[k++] = m[i][j];
        }
    }
    return result;
}
function matrix(n) {
    var result = new Array(n);
    for(var i = 0; i < n; ++i){
        result[i] = new Array(n);
        for(var j = 0; j < n; ++j)result[i][j] = [
            "m[",
            i,
            "][",
            j,
            "]"
        ].join("");
    }
    return result;
}
function sign(n) {
    if (n & 1) return "-";
    return "";
}
function generateSum(expr) {
    if (expr.length === 1) return expr[0];
    else if (expr.length === 2) return [
        "sum(",
        expr[0],
        ",",
        expr[1],
        ")"
    ].join("");
    else {
        var m = expr.length >> 1;
        return [
            "sum(",
            generateSum(expr.slice(0, m)),
            ",",
            generateSum(expr.slice(m)),
            ")"
        ].join("");
    }
}
function determinant(m) {
    if (m.length === 2) return [
        "sum(prod(",
        m[0][0],
        ",",
        m[1][1],
        "),prod(-",
        m[0][1],
        ",",
        m[1][0],
        "))"
    ].join("");
    else {
        var expr = [];
        for(var i = 0; i < m.length; ++i)expr.push([
            "scale(",
            determinant(cofactor(m, i)),
            ",",
            sign(i),
            m[0][i],
            ")"
        ].join(""));
        return generateSum(expr);
    }
}
function compileDeterminant(n) {
    var proc = new Function("sum", "scale", "prod", "compress", [
        "function robustDeterminant",
        n,
        "(m){return compress(",
        determinant(matrix(n)),
        ")};return robustDeterminant",
        n
    ].join(""));
    return proc(robustSum, robustScale, twoProduct, compress);
}
var CACHE = [
    function robustDeterminant0() {
        return [
            0
        ];
    },
    function robustDeterminant1(m) {
        return [
            m[0][0]
        ];
    }
];
function generateDispatch() {
    while(CACHE.length < NUM_EXPANDED)CACHE.push(compileDeterminant(CACHE.length));
    var procArgs = [];
    var code = [
        "function robustDeterminant(m){switch(m.length){"
    ];
    for(var i = 0; i < NUM_EXPANDED; ++i){
        procArgs.push("det" + i);
        code.push("case ", i, ":return det", i, "(m);");
    }
    code.push("}\
var det=CACHE[m.length];\
if(!det)\
det=CACHE[m.length]=gen(m.length);\
return det(m);\
}\
return robustDeterminant");
    procArgs.push("CACHE", "gen", code.join(""));
    var proc = Function.apply(undefined, procArgs);
    module.exports = proc.apply(undefined, CACHE.concat([
        CACHE,
        compileDeterminant
    ]));
    for(var i = 0; i < CACHE.length; ++i)module.exports[i] = CACHE[i];
}
generateDispatch();

},{"two-product":"5JWSk","robust-sum":"dv3pE","robust-scale":"ipmvR","robust-compress":"kRFyX"}],"5JWSk":[function(require,module,exports) {
"use strict";
module.exports = twoProduct;
var SPLITTER = +(Math.pow(2, 27) + 1);
function twoProduct(a, b, result) {
    var x = a * b;
    var c = SPLITTER * a;
    var abig = c - a;
    var ahi = c - abig;
    var alo = a - ahi;
    var d = SPLITTER * b;
    var bbig = d - b;
    var bhi = d - bbig;
    var blo = b - bhi;
    var err1 = x - ahi * bhi;
    var err2 = err1 - alo * bhi;
    var err3 = err2 - ahi * blo;
    var y = alo * blo - err3;
    if (result) {
        result[0] = y;
        result[1] = x;
        return result;
    }
    return [
        y,
        x
    ];
}

},{}],"dv3pE":[function(require,module,exports) {
"use strict";
module.exports = linearExpansionSum;
//Easy case: Add two scalars
function scalarScalar(a, b) {
    var x = a + b;
    var bv = x - a;
    var av = x - bv;
    var br = b - bv;
    var ar = a - av;
    var y = ar + br;
    if (y) return [
        y,
        x
    ];
    return [
        x
    ];
}
function linearExpansionSum(e, f) {
    var ne = e.length | 0;
    var nf = f.length | 0;
    if (ne === 1 && nf === 1) return scalarScalar(e[0], f[0]);
    var n = ne + nf;
    var g = new Array(n);
    var count = 0;
    var eptr = 0;
    var fptr = 0;
    var abs = Math.abs;
    var ei = e[eptr];
    var ea = abs(ei);
    var fi = f[fptr];
    var fa = abs(fi);
    var a, b;
    if (ea < fa) {
        b = ei;
        eptr += 1;
        if (eptr < ne) {
            ei = e[eptr];
            ea = abs(ei);
        }
    } else {
        b = fi;
        fptr += 1;
        if (fptr < nf) {
            fi = f[fptr];
            fa = abs(fi);
        }
    }
    if (eptr < ne && ea < fa || fptr >= nf) {
        a = ei;
        eptr += 1;
        if (eptr < ne) {
            ei = e[eptr];
            ea = abs(ei);
        }
    } else {
        a = fi;
        fptr += 1;
        if (fptr < nf) {
            fi = f[fptr];
            fa = abs(fi);
        }
    }
    var x = a + b;
    var bv = x - a;
    var y = b - bv;
    var q0 = y;
    var q1 = x;
    var _x, _bv, _av, _br, _ar;
    while(eptr < ne && fptr < nf){
        if (ea < fa) {
            a = ei;
            eptr += 1;
            if (eptr < ne) {
                ei = e[eptr];
                ea = abs(ei);
            }
        } else {
            a = fi;
            fptr += 1;
            if (fptr < nf) {
                fi = f[fptr];
                fa = abs(fi);
            }
        }
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) g[count++] = y;
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
    }
    while(eptr < ne){
        a = ei;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) g[count++] = y;
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        eptr += 1;
        if (eptr < ne) ei = e[eptr];
    }
    while(fptr < nf){
        a = fi;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) g[count++] = y;
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        fptr += 1;
        if (fptr < nf) fi = f[fptr];
    }
    if (q0) g[count++] = q0;
    if (q1) g[count++] = q1;
    if (!count) g[count++] = 0;
    g.length = count;
    return g;
}

},{}],"ipmvR":[function(require,module,exports) {
"use strict";
var twoProduct = require("two-product");
var twoSum = require("two-sum");
module.exports = scaleLinearExpansion;
function scaleLinearExpansion(e, scale) {
    var n = e.length;
    if (n === 1) {
        var ts = twoProduct(e[0], scale);
        if (ts[0]) return ts;
        return [
            ts[1]
        ];
    }
    var g = new Array(2 * n);
    var q = [
        0.1,
        0.1
    ];
    var t = [
        0.1,
        0.1
    ];
    var count = 0;
    twoProduct(e[0], scale, q);
    if (q[0]) g[count++] = q[0];
    for(var i = 1; i < n; ++i){
        twoProduct(e[i], scale, t);
        var pq = q[1];
        twoSum(pq, t[0], q);
        if (q[0]) g[count++] = q[0];
        var a = t[1];
        var b = q[1];
        var x = a + b;
        var bv = x - a;
        var y = b - bv;
        q[1] = x;
        if (y) g[count++] = y;
    }
    if (q[1]) g[count++] = q[1];
    if (count === 0) g[count++] = 0;
    g.length = count;
    return g;
}

},{"two-product":"5JWSk","two-sum":"bwaTN"}],"bwaTN":[function(require,module,exports) {
"use strict";
module.exports = fastTwoSum;
function fastTwoSum(a, b, result) {
    var x = a + b;
    var bv = x - a;
    var av = x - bv;
    var br = b - bv;
    var ar = a - av;
    if (result) {
        result[0] = ar + br;
        result[1] = x;
        return result;
    }
    return [
        ar + br,
        x
    ];
}

},{}],"kRFyX":[function(require,module,exports) {
"use strict";
module.exports = compressExpansion;
function compressExpansion(e) {
    var m = e.length;
    var Q = e[e.length - 1];
    var bottom = m;
    for(var i = m - 2; i >= 0; --i){
        var a = Q;
        var b = e[i];
        Q = a + b;
        var bv = Q - a;
        var q = b - bv;
        if (q) {
            e[--bottom] = Q;
            Q = q;
        }
    }
    var top = 0;
    for(var i = bottom; i < m; ++i){
        var a = e[i];
        var b = Q;
        Q = a + b;
        var bv = Q - a;
        var q = b - bv;
        if (q) e[top++] = q;
    }
    e[top++] = Q;
    e.length = top;
    return e;
}

},{}],"1U5NA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _robustPredicates = require("robust-predicates");
const EPSILON = Math.pow(2, -52);
const EDGE_STACK = new Uint32Array(512);
class Delaunator {
    static from(points, getX = defaultGetX, getY = defaultGetY) {
        const n = points.length;
        const coords = new Float64Array(n * 2);
        for(let i = 0; i < n; i++){
            const p = points[i];
            coords[2 * i] = getX(p);
            coords[2 * i + 1] = getY(p);
        }
        return new Delaunator(coords);
    }
    constructor(coords){
        const n = coords.length >> 1;
        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');
        this.coords = coords;
        // arrays that will store the triangulation graph
        const maxTriangles = Math.max(2 * n - 5, 0);
        this._triangles = new Uint32Array(maxTriangles * 3);
        this._halfedges = new Int32Array(maxTriangles * 3);
        // temporary arrays for tracking the edges of the advancing convex hull
        this._hashSize = Math.ceil(Math.sqrt(n));
        this._hullPrev = new Uint32Array(n); // edge to prev edge
        this._hullNext = new Uint32Array(n); // edge to next edge
        this._hullTri = new Uint32Array(n); // edge to adjacent triangle
        this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash
        // temporary arrays for sorting points
        this._ids = new Uint32Array(n);
        this._dists = new Float64Array(n);
        this.update();
    }
    update() {
        const { coords , _hullPrev: hullPrev , _hullNext: hullNext , _hullTri: hullTri , _hullHash: hullHash  } = this;
        const n = coords.length >> 1;
        // populate an array of point indices; calculate input data bbox
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        for(let i = 0; i < n; i++){
            const x = coords[2 * i];
            const y = coords[2 * i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            this._ids[i] = i;
        }
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;
        let minDist = Infinity;
        let i0, i1, i2;
        // pick a seed point close to the center
        for(let i3 = 0; i3 < n; i3++){
            const d = dist(cx, cy, coords[2 * i3], coords[2 * i3 + 1]);
            if (d < minDist) {
                i0 = i3;
                minDist = d;
            }
        }
        const i0x = coords[2 * i0];
        const i0y = coords[2 * i0 + 1];
        minDist = Infinity;
        // find the point closest to the seed
        for(let i4 = 0; i4 < n; i4++){
            if (i4 === i0) continue;
            const d = dist(i0x, i0y, coords[2 * i4], coords[2 * i4 + 1]);
            if (d < minDist && d > 0) {
                i1 = i4;
                minDist = d;
            }
        }
        let i1x = coords[2 * i1];
        let i1y = coords[2 * i1 + 1];
        let minRadius = Infinity;
        // find the third point which forms the smallest circumcircle with the first two
        for(let i5 = 0; i5 < n; i5++){
            if (i5 === i0 || i5 === i1) continue;
            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i5], coords[2 * i5 + 1]);
            if (r < minRadius) {
                i2 = i5;
                minRadius = r;
            }
        }
        let i2x = coords[2 * i2];
        let i2y = coords[2 * i2 + 1];
        if (minRadius === Infinity) {
            // order collinear points by dx (or dy if all x are identical)
            // and return the list as a hull
            for(let i = 0; i < n; i++)this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
            quicksort(this._ids, this._dists, 0, n - 1);
            const hull = new Uint32Array(n);
            let j = 0;
            for(let i8 = 0, d0 = -Infinity; i8 < n; i8++){
                const id = this._ids[i8];
                if (this._dists[id] > d0) {
                    hull[j++] = id;
                    d0 = this._dists[id];
                }
            }
            this.hull = hull.subarray(0, j);
            this.triangles = new Uint32Array(0);
            this.halfedges = new Uint32Array(0);
            return;
        }
        // swap the order of the seed points for counter-clockwise orientation
        if (_robustPredicates.orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
            const i = i1;
            const x = i1x;
            const y = i1y;
            i1 = i2;
            i1x = i2x;
            i1y = i2y;
            i2 = i;
            i2x = x;
            i2y = y;
        }
        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
        this._cx = center.x;
        this._cy = center.y;
        for(let i6 = 0; i6 < n; i6++)this._dists[i6] = dist(coords[2 * i6], coords[2 * i6 + 1], center.x, center.y);
        // sort the points by distance from the seed triangle circumcenter
        quicksort(this._ids, this._dists, 0, n - 1);
        // set up the seed triangle as the starting hull
        this._hullStart = i0;
        let hullSize = 3;
        hullNext[i0] = hullPrev[i2] = i1;
        hullNext[i1] = hullPrev[i0] = i2;
        hullNext[i2] = hullPrev[i1] = i0;
        hullTri[i0] = 0;
        hullTri[i1] = 1;
        hullTri[i2] = 2;
        hullHash.fill(-1);
        hullHash[this._hashKey(i0x, i0y)] = i0;
        hullHash[this._hashKey(i1x, i1y)] = i1;
        hullHash[this._hashKey(i2x, i2y)] = i2;
        this.trianglesLen = 0;
        this._addTriangle(i0, i1, i2, -1, -1, -1);
        for(let k = 0, xp, yp; k < this._ids.length; k++){
            const i = this._ids[k];
            const x = coords[2 * i];
            const y = coords[2 * i + 1];
            // skip near-duplicate points
            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
            xp = x;
            yp = y;
            // skip seed triangle points
            if (i === i0 || i === i1 || i === i2) continue;
            // find a visible edge on the convex hull using edge hash
            let start = 0;
            for(let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++){
                start = hullHash[(key + j) % this._hashSize];
                if (start !== -1 && start !== hullNext[start]) break;
            }
            start = hullPrev[start];
            let e = start, q;
            while(q = hullNext[e], _robustPredicates.orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0){
                e = q;
                if (e === start) {
                    e = -1;
                    break;
                }
            }
            if (e === -1) continue; // likely a near-duplicate point; skip it
            // add the first triangle from the point
            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);
            // recursively flip triangles from the point until they satisfy the Delaunay condition
            hullTri[i] = this._legalize(t + 2);
            hullTri[e] = t; // keep track of boundary triangles on the hull
            hullSize++;
            // walk forward through the hull, adding more triangles and flipping recursively
            let n = hullNext[e];
            while(q = hullNext[n], _robustPredicates.orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0){
                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                hullTri[i] = this._legalize(t + 2);
                hullNext[n] = n; // mark as removed
                hullSize--;
                n = q;
            }
            // walk backward from the other side, adding more triangles and flipping
            if (e === start) while(q = hullPrev[e], _robustPredicates.orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0){
                t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                this._legalize(t + 2);
                hullTri[q] = t;
                hullNext[e] = e; // mark as removed
                hullSize--;
                e = q;
            }
            // update the hull indices
            this._hullStart = hullPrev[i] = e;
            hullNext[e] = hullPrev[n] = i;
            hullNext[i] = n;
            // save the two new edges in the hash table
            hullHash[this._hashKey(x, y)] = i;
            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
        }
        this.hull = new Uint32Array(hullSize);
        for(let i7 = 0, e = this._hullStart; i7 < hullSize; i7++){
            this.hull[i7] = e;
            e = hullNext[e];
        }
        // trim typed triangle mesh arrays
        this.triangles = this._triangles.subarray(0, this.trianglesLen);
        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
    }
    _hashKey(x, y) {
        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
    }
    _legalize(a) {
        const { _triangles: triangles , _halfedges: halfedges , coords  } = this;
        let i = 0;
        let ar = 0;
        // recursion eliminated with a fixed-size stack
        while(true){
            const b = halfedges[a];
            /* if the pair of triangles doesn't satisfy the Delaunay condition
             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
             * then do the same check/flip recursively for the new pair of triangles
             *
             *           pl                    pl
             *          /||\                  /  \
             *       al/ || \bl            al/    \a
             *        /  ||  \              /      \
             *       /  a||b  \    flip    /___ar___\
             *     p0\   ||   /p1   =>   p0\---bl---/p1
             *        \  ||  /              \      /
             *       ar\ || /br             b\    /br
             *          \||/                  \  /
             *           pr                    pr
             */ const a0 = a - a % 3;
            ar = a0 + (a + 2) % 3;
            if (b === -1) {
                if (i === 0) break;
                a = EDGE_STACK[--i];
                continue;
            }
            const b0 = b - b % 3;
            const al = a0 + (a + 1) % 3;
            const bl = b0 + (b + 2) % 3;
            const p0 = triangles[ar];
            const pr = triangles[a];
            const pl = triangles[al];
            const p1 = triangles[bl];
            const illegal = inCircle(coords[2 * p0], coords[2 * p0 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1]);
            if (illegal) {
                triangles[a] = p1;
                triangles[b] = p0;
                const hbl = halfedges[bl];
                // edge swapped on the other side of the hull (rare); fix the halfedge reference
                if (hbl === -1) {
                    let e = this._hullStart;
                    do {
                        if (this._hullTri[e] === bl) {
                            this._hullTri[e] = a;
                            break;
                        }
                        e = this._hullPrev[e];
                    }while (e !== this._hullStart)
                }
                this._link(a, hbl);
                this._link(b, halfedges[ar]);
                this._link(ar, bl);
                const br = b0 + (b + 1) % 3;
                // don't worry about hitting the cap: it can only happen on extremely degenerate input
                if (i < EDGE_STACK.length) EDGE_STACK[i++] = br;
            } else {
                if (i === 0) break;
                a = EDGE_STACK[--i];
            }
        }
        return ar;
    }
    _link(a, b) {
        this._halfedges[a] = b;
        if (b !== -1) this._halfedges[b] = a;
    }
    // add a new triangle given vertex indices and adjacent half-edge ids
    _addTriangle(i0, i1, i2, a, b, c) {
        const t = this.trianglesLen;
        this._triangles[t] = i0;
        this._triangles[t + 1] = i1;
        this._triangles[t + 2] = i2;
        this._link(t, a);
        this._link(t + 1, b);
        this._link(t + 2, c);
        this.trianglesLen += 3;
        return t;
    }
}
exports.default = Delaunator;
// monotonically increases with real angle, but doesn't need expensive trigonometry
function pseudoAngle(dx, dy) {
    const p = dx / (Math.abs(dx) + Math.abs(dy));
    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
}
function dist(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx * dx + dy * dy;
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
    const dx = ax - px;
    const dy = ay - py;
    const ex = bx - px;
    const ey = by - py;
    const fx = cx - px;
    const fy = cy - py;
    const ap = dx * dx + dy * dy;
    const bp = ex * ex + ey * ey;
    const cp = fx * fx + fy * fy;
    return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;
    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);
    const x = (ey * bl - dy * cl) * d;
    const y = (dx * cl - ex * bl) * d;
    return x * x + y * y;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;
    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);
    const x = ax + (ey * bl - dy * cl) * d;
    const y = ay + (dx * cl - ex * bl) * d;
    return {
        x,
        y
    };
}
function quicksort(ids, dists, left, right) {
    if (right - left <= 20) for(let i = left + 1; i <= right; i++){
        const temp = ids[i];
        const tempDist = dists[temp];
        let j = i - 1;
        while(j >= left && dists[ids[j]] > tempDist)ids[j + 1] = ids[j--];
        ids[j + 1] = temp;
    }
    else {
        const median = left + right >> 1;
        let i = left + 1;
        let j = right;
        swap(ids, median, i);
        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);
        const temp = ids[i];
        const tempDist = dists[temp];
        while(true){
            do i++;
            while (dists[ids[i]] < tempDist)
            do j--;
            while (dists[ids[j]] > tempDist)
            if (j < i) break;
            swap(ids, i, j);
        }
        ids[left + 1] = ids[j];
        ids[j] = temp;
        if (right - i + 1 >= j - left) {
            quicksort(ids, dists, i, right);
            quicksort(ids, dists, left, j - 1);
        } else {
            quicksort(ids, dists, left, j - 1);
            quicksort(ids, dists, i, right);
        }
    }
}
function swap(arr, i, j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
function defaultGetX(p) {
    return p[0];
}
function defaultGetY(p) {
    return p[1];
}

},{"robust-predicates":"7e0QE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7e0QE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "orient2d", ()=>_orient2DJs.orient2d
);
parcelHelpers.export(exports, "orient2dfast", ()=>_orient2DJs.orient2dfast
);
parcelHelpers.export(exports, "orient3d", ()=>_orient3DJs.orient3d
);
parcelHelpers.export(exports, "orient3dfast", ()=>_orient3DJs.orient3dfast
);
parcelHelpers.export(exports, "incircle", ()=>_incircleJs.incircle
);
parcelHelpers.export(exports, "incirclefast", ()=>_incircleJs.incirclefast
);
parcelHelpers.export(exports, "insphere", ()=>_insphereJs.insphere
);
parcelHelpers.export(exports, "inspherefast", ()=>_insphereJs.inspherefast
);
var _orient2DJs = require("./esm/orient2d.js");
var _orient3DJs = require("./esm/orient3d.js");
var _incircleJs = require("./esm/incircle.js");
var _insphereJs = require("./esm/insphere.js");

},{"./esm/orient2d.js":"gHqC4","./esm/orient3d.js":"dt5pN","./esm/incircle.js":"6yBsv","./esm/insphere.js":"6qjhA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gHqC4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "orient2d", ()=>orient2d
);
parcelHelpers.export(exports, "orient2dfast", ()=>orient2dfast
);
var _utilJs = require("./util.js");
const ccwerrboundA = (3 + 16 * _utilJs.epsilon) * _utilJs.epsilon;
const ccwerrboundB = (2 + 12 * _utilJs.epsilon) * _utilJs.epsilon;
const ccwerrboundC = (9 + 64 * _utilJs.epsilon) * _utilJs.epsilon * _utilJs.epsilon;
const B = _utilJs.vec(4);
const C1 = _utilJs.vec(8);
const C2 = _utilJs.vec(12);
const D = _utilJs.vec(16);
const u = _utilJs.vec(4);
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
    let acxtail, acytail, bcxtail, bcytail;
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;
    const acx = ax - cx;
    const bcx = bx - cx;
    const acy = ay - cy;
    const bcy = by - cy;
    s1 = acx * bcy;
    c = _utilJs.splitter * acx;
    ahi = c - (c - acx);
    alo = acx - ahi;
    c = _utilJs.splitter * bcy;
    bhi = c - (c - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acy * bcx;
    c = _utilJs.splitter * acy;
    ahi = c - (c - acy);
    alo = acy - ahi;
    c = _utilJs.splitter * bcx;
    bhi = c - (c - bcx);
    blo = bcx - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    B[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    B[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    B[2] = _j - (u3 - bvirt) + (_i - bvirt);
    B[3] = u3;
    let det = _utilJs.estimate(4, B);
    let errbound = ccwerrboundB * detsum;
    if (det >= errbound || -det >= errbound) return det;
    bvirt = ax - acx;
    acxtail = ax - (acx + bvirt) + (bvirt - cx);
    bvirt = bx - bcx;
    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
    bvirt = ay - acy;
    acytail = ay - (acy + bvirt) + (bvirt - cy);
    bvirt = by - bcy;
    bcytail = by - (bcy + bvirt) + (bvirt - cy);
    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) return det;
    errbound = ccwerrboundC * detsum + _utilJs.resulterrbound * Math.abs(det);
    det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
    if (det >= errbound || -det >= errbound) return det;
    s1 = acxtail * bcy;
    c = _utilJs.splitter * acxtail;
    ahi = c - (c - acxtail);
    alo = acxtail - ahi;
    c = _utilJs.splitter * bcy;
    bhi = c - (c - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acytail * bcx;
    c = _utilJs.splitter * acytail;
    ahi = c - (c - acytail);
    alo = acytail - ahi;
    c = _utilJs.splitter * bcx;
    bhi = c - (c - bcx);
    blo = bcx - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const C1len = _utilJs.sum(4, B, 4, u, C1);
    s1 = acx * bcytail;
    c = _utilJs.splitter * acx;
    ahi = c - (c - acx);
    alo = acx - ahi;
    c = _utilJs.splitter * bcytail;
    bhi = c - (c - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acy * bcxtail;
    c = _utilJs.splitter * acy;
    ahi = c - (c - acy);
    alo = acy - ahi;
    c = _utilJs.splitter * bcxtail;
    bhi = c - (c - bcxtail);
    blo = bcxtail - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const C2len = _utilJs.sum(C1len, C1, 4, u, C2);
    s1 = acxtail * bcytail;
    c = _utilJs.splitter * acxtail;
    ahi = c - (c - acxtail);
    alo = acxtail - ahi;
    c = _utilJs.splitter * bcytail;
    bhi = c - (c - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acytail * bcxtail;
    c = _utilJs.splitter * acytail;
    ahi = c - (c - acytail);
    alo = acytail - ahi;
    c = _utilJs.splitter * bcxtail;
    bhi = c - (c - bcxtail);
    blo = bcxtail - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const Dlen = _utilJs.sum(C2len, C2, 4, u, D);
    return D[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
    const detleft = (ay - cy) * (bx - cx);
    const detright = (ax - cx) * (by - cy);
    const det = detleft - detright;
    if (detleft === 0 || detright === 0 || detleft > 0 !== detright > 0) return det;
    const detsum = Math.abs(detleft + detright);
    if (Math.abs(det) >= ccwerrboundA * detsum) return det;
    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}
function orient2dfast(ax, ay, bx, by, cx, cy) {
    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);
}

},{"./util.js":"3OxkP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3OxkP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "epsilon", ()=>epsilon
);
parcelHelpers.export(exports, "splitter", ()=>splitter
);
parcelHelpers.export(exports, "resulterrbound", ()=>resulterrbound
);
// fast_expansion_sum_zeroelim routine from oritinal code
parcelHelpers.export(exports, "sum", ()=>sum
);
parcelHelpers.export(exports, "sum_three", ()=>sum_three
);
// scale_expansion_zeroelim routine from oritinal code
parcelHelpers.export(exports, "scale", ()=>scale
);
parcelHelpers.export(exports, "negate", ()=>negate
);
parcelHelpers.export(exports, "estimate", ()=>estimate
);
parcelHelpers.export(exports, "vec", ()=>vec
);
const epsilon = 0.00000000000000011102230246251565;
const splitter = 134217729;
const resulterrbound = (3 + 8 * epsilon) * epsilon;
function sum(elen, e, flen, f, h) {
    let Q, Qnew, hh, bvirt;
    let enow = e[0];
    let fnow = f[0];
    let eindex = 0;
    let findex = 0;
    if (fnow > enow === fnow > -enow) {
        Q = enow;
        enow = e[++eindex];
    } else {
        Q = fnow;
        fnow = f[++findex];
    }
    let hindex = 0;
    if (eindex < elen && findex < flen) {
        if (fnow > enow === fnow > -enow) {
            Qnew = enow + Q;
            hh = Q - (Qnew - enow);
            enow = e[++eindex];
        } else {
            Qnew = fnow + Q;
            hh = Q - (Qnew - fnow);
            fnow = f[++findex];
        }
        Q = Qnew;
        if (hh !== 0) h[hindex++] = hh;
        while(eindex < elen && findex < flen){
            if (fnow > enow === fnow > -enow) {
                Qnew = Q + enow;
                bvirt = Qnew - Q;
                hh = Q - (Qnew - bvirt) + (enow - bvirt);
                enow = e[++eindex];
            } else {
                Qnew = Q + fnow;
                bvirt = Qnew - Q;
                hh = Q - (Qnew - bvirt) + (fnow - bvirt);
                fnow = f[++findex];
            }
            Q = Qnew;
            if (hh !== 0) h[hindex++] = hh;
        }
    }
    while(eindex < elen){
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
        Q = Qnew;
        if (hh !== 0) h[hindex++] = hh;
    }
    while(findex < flen){
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
        Q = Qnew;
        if (hh !== 0) h[hindex++] = hh;
    }
    if (Q !== 0 || hindex === 0) h[hindex++] = Q;
    return hindex;
}
function sum_three(alen, a, blen, b, clen, c, tmp, out) {
    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);
}
function scale(elen, e, b, h) {
    let Q, sum1, hh, product1, product0;
    let bvirt, c, ahi, alo, bhi, blo;
    c = splitter * b;
    bhi = c - (c - b);
    blo = b - bhi;
    let enow = e[0];
    Q = enow * b;
    c = splitter * enow;
    ahi = c - (c - enow);
    alo = enow - ahi;
    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);
    let hindex = 0;
    if (hh !== 0) h[hindex++] = hh;
    for(let i = 1; i < elen; i++){
        enow = e[i];
        product1 = enow * b;
        c = splitter * enow;
        ahi = c - (c - enow);
        alo = enow - ahi;
        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);
        sum1 = Q + product0;
        bvirt = sum1 - Q;
        hh = Q - (sum1 - bvirt) + (product0 - bvirt);
        if (hh !== 0) h[hindex++] = hh;
        Q = product1 + sum1;
        hh = sum1 - (Q - product1);
        if (hh !== 0) h[hindex++] = hh;
    }
    if (Q !== 0 || hindex === 0) h[hindex++] = Q;
    return hindex;
}
function negate(elen, e) {
    for(let i = 0; i < elen; i++)e[i] = -e[i];
    return elen;
}
function estimate(elen, e) {
    let Q = e[0];
    for(let i = 1; i < elen; i++)Q += e[i];
    return Q;
}
function vec(n) {
    return new Float64Array(n);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dt5pN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "orient3d", ()=>orient3d
);
parcelHelpers.export(exports, "orient3dfast", ()=>orient3dfast
);
var _utilJs = require("./util.js");
const o3derrboundA = (7 + 56 * _utilJs.epsilon) * _utilJs.epsilon;
const o3derrboundB = (3 + 28 * _utilJs.epsilon) * _utilJs.epsilon;
const o3derrboundC = (26 + 288 * _utilJs.epsilon) * _utilJs.epsilon * _utilJs.epsilon;
const bc = _utilJs.vec(4);
const ca = _utilJs.vec(4);
const ab = _utilJs.vec(4);
const at_b = _utilJs.vec(4);
const at_c = _utilJs.vec(4);
const bt_c = _utilJs.vec(4);
const bt_a = _utilJs.vec(4);
const ct_a = _utilJs.vec(4);
const ct_b = _utilJs.vec(4);
const bct = _utilJs.vec(8);
const cat = _utilJs.vec(8);
const abt = _utilJs.vec(8);
const u = _utilJs.vec(4);
const _8 = _utilJs.vec(8);
const _8b = _utilJs.vec(8);
const _16 = _utilJs.vec(8);
const _12 = _utilJs.vec(12);
let fin = _utilJs.vec(192);
let fin2 = _utilJs.vec(192);
function finadd(finlen, alen, a) {
    finlen = _utilJs.sum(finlen, fin, alen, a, fin2);
    const tmp = fin;
    fin = fin2;
    fin2 = tmp;
    return finlen;
}
function tailinit(xtail, ytail, ax, ay, bx, by, a, b) {
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, t1, t0, u3, negate;
    if (xtail === 0) {
        if (ytail === 0) {
            a[0] = 0;
            b[0] = 0;
            return 1;
        } else {
            negate = -ytail;
            s1 = negate * ax;
            c = _utilJs.splitter * negate;
            ahi = c - (c - negate);
            alo = negate - ahi;
            c = _utilJs.splitter * ax;
            bhi = c - (c - ax);
            blo = ax - bhi;
            a[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            a[1] = s1;
            s1 = ytail * bx;
            c = _utilJs.splitter * ytail;
            ahi = c - (c - ytail);
            alo = ytail - ahi;
            c = _utilJs.splitter * bx;
            bhi = c - (c - bx);
            blo = bx - bhi;
            b[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            b[1] = s1;
            return 2;
        }
    } else if (ytail === 0) {
        s1 = xtail * ay;
        c = _utilJs.splitter * xtail;
        ahi = c - (c - xtail);
        alo = xtail - ahi;
        c = _utilJs.splitter * ay;
        bhi = c - (c - ay);
        blo = ay - bhi;
        a[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        a[1] = s1;
        negate = -xtail;
        s1 = negate * by;
        c = _utilJs.splitter * negate;
        ahi = c - (c - negate);
        alo = negate - ahi;
        c = _utilJs.splitter * by;
        bhi = c - (c - by);
        blo = by - bhi;
        b[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        b[1] = s1;
        return 2;
    } else {
        s1 = xtail * ay;
        c = _utilJs.splitter * xtail;
        ahi = c - (c - xtail);
        alo = xtail - ahi;
        c = _utilJs.splitter * ay;
        bhi = c - (c - ay);
        blo = ay - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = ytail * ax;
        c = _utilJs.splitter * ytail;
        ahi = c - (c - ytail);
        alo = ytail - ahi;
        c = _utilJs.splitter * ax;
        bhi = c - (c - ax);
        blo = ax - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        a[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        a[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        a[2] = _j - (u3 - bvirt) + (_i - bvirt);
        a[3] = u3;
        s1 = ytail * bx;
        c = _utilJs.splitter * ytail;
        ahi = c - (c - ytail);
        alo = ytail - ahi;
        c = _utilJs.splitter * bx;
        bhi = c - (c - bx);
        blo = bx - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = xtail * by;
        c = _utilJs.splitter * xtail;
        ahi = c - (c - xtail);
        alo = xtail - ahi;
        c = _utilJs.splitter * by;
        bhi = c - (c - by);
        blo = by - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        b[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        b[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        b[2] = _j - (u3 - bvirt) + (_i - bvirt);
        b[3] = u3;
        return 4;
    }
}
function tailadd(finlen, a, b, k, z) {
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, u3;
    s1 = a * b;
    c = _utilJs.splitter * a;
    ahi = c - (c - a);
    alo = a - ahi;
    c = _utilJs.splitter * b;
    bhi = c - (c - b);
    blo = b - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    c = _utilJs.splitter * k;
    bhi = c - (c - k);
    blo = k - bhi;
    _i = s0 * k;
    c = _utilJs.splitter * s0;
    ahi = c - (c - s0);
    alo = s0 - ahi;
    u[0] = alo * blo - (_i - ahi * bhi - alo * bhi - ahi * blo);
    _j = s1 * k;
    c = _utilJs.splitter * s1;
    ahi = c - (c - s1);
    alo = s1 - ahi;
    _0 = alo * blo - (_j - ahi * bhi - alo * bhi - ahi * blo);
    _k = _i + _0;
    bvirt = _k - _i;
    u[1] = _i - (_k - bvirt) + (_0 - bvirt);
    u3 = _j + _k;
    u[2] = _k - (u3 - _j);
    u[3] = u3;
    finlen = finadd(finlen, 4, u);
    if (z !== 0) {
        c = _utilJs.splitter * z;
        bhi = c - (c - z);
        blo = z - bhi;
        _i = s0 * z;
        c = _utilJs.splitter * s0;
        ahi = c - (c - s0);
        alo = s0 - ahi;
        u[0] = alo * blo - (_i - ahi * bhi - alo * bhi - ahi * blo);
        _j = s1 * z;
        c = _utilJs.splitter * s1;
        ahi = c - (c - s1);
        alo = s1 - ahi;
        _0 = alo * blo - (_j - ahi * bhi - alo * bhi - ahi * blo);
        _k = _i + _0;
        bvirt = _k - _i;
        u[1] = _i - (_k - bvirt) + (_0 - bvirt);
        u3 = _j + _k;
        u[2] = _k - (u3 - _j);
        u[3] = u3;
        finlen = finadd(finlen, 4, u);
    }
    return finlen;
}
function orient3dadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, permanent) {
    let finlen;
    let adxtail, bdxtail, cdxtail;
    let adytail, bdytail, cdytail;
    let adztail, bdztail, cdztail;
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, t1, t0, u3;
    const adx = ax - dx;
    const bdx = bx - dx;
    const cdx = cx - dx;
    const ady = ay - dy;
    const bdy = by - dy;
    const cdy = cy - dy;
    const adz = az - dz;
    const bdz = bz - dz;
    const cdz = cz - dz;
    s1 = bdx * cdy;
    c = _utilJs.splitter * bdx;
    ahi = c - (c - bdx);
    alo = bdx - ahi;
    c = _utilJs.splitter * cdy;
    bhi = c - (c - cdy);
    blo = cdy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = cdx * bdy;
    c = _utilJs.splitter * cdx;
    ahi = c - (c - cdx);
    alo = cdx - ahi;
    c = _utilJs.splitter * bdy;
    bhi = c - (c - bdy);
    blo = bdy - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    bc[2] = _j - (u3 - bvirt) + (_i - bvirt);
    bc[3] = u3;
    s1 = cdx * ady;
    c = _utilJs.splitter * cdx;
    ahi = c - (c - cdx);
    alo = cdx - ahi;
    c = _utilJs.splitter * ady;
    bhi = c - (c - ady);
    blo = ady - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = adx * cdy;
    c = _utilJs.splitter * adx;
    ahi = c - (c - adx);
    alo = adx - ahi;
    c = _utilJs.splitter * cdy;
    bhi = c - (c - cdy);
    blo = cdy - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ca[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ca[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    ca[2] = _j - (u3 - bvirt) + (_i - bvirt);
    ca[3] = u3;
    s1 = adx * bdy;
    c = _utilJs.splitter * adx;
    ahi = c - (c - adx);
    alo = adx - ahi;
    c = _utilJs.splitter * bdy;
    bhi = c - (c - bdy);
    blo = bdy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = bdx * ady;
    c = _utilJs.splitter * bdx;
    ahi = c - (c - bdx);
    alo = bdx - ahi;
    c = _utilJs.splitter * ady;
    bhi = c - (c - ady);
    blo = ady - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    ab[2] = _j - (u3 - bvirt) + (_i - bvirt);
    ab[3] = u3;
    finlen = _utilJs.sum(_utilJs.sum(_utilJs.scale(4, bc, adz, _8), _8, _utilJs.scale(4, ca, bdz, _8b), _8b, _16), _16, _utilJs.scale(4, ab, cdz, _8), _8, fin);
    let det = _utilJs.estimate(finlen, fin);
    let errbound = o3derrboundB * permanent;
    if (det >= errbound || -det >= errbound) return det;
    bvirt = ax - adx;
    adxtail = ax - (adx + bvirt) + (bvirt - dx);
    bvirt = bx - bdx;
    bdxtail = bx - (bdx + bvirt) + (bvirt - dx);
    bvirt = cx - cdx;
    cdxtail = cx - (cdx + bvirt) + (bvirt - dx);
    bvirt = ay - ady;
    adytail = ay - (ady + bvirt) + (bvirt - dy);
    bvirt = by - bdy;
    bdytail = by - (bdy + bvirt) + (bvirt - dy);
    bvirt = cy - cdy;
    cdytail = cy - (cdy + bvirt) + (bvirt - dy);
    bvirt = az - adz;
    adztail = az - (adz + bvirt) + (bvirt - dz);
    bvirt = bz - bdz;
    bdztail = bz - (bdz + bvirt) + (bvirt - dz);
    bvirt = cz - cdz;
    cdztail = cz - (cdz + bvirt) + (bvirt - dz);
    if (adxtail === 0 && bdxtail === 0 && cdxtail === 0 && adytail === 0 && bdytail === 0 && cdytail === 0 && adztail === 0 && bdztail === 0 && cdztail === 0) return det;
    errbound = o3derrboundC * permanent + _utilJs.resulterrbound * Math.abs(det);
    det += adz * (bdx * cdytail + cdy * bdxtail - (bdy * cdxtail + cdx * bdytail)) + adztail * (bdx * cdy - bdy * cdx) + bdz * (cdx * adytail + ady * cdxtail - (cdy * adxtail + adx * cdytail)) + bdztail * (cdx * ady - cdy * adx) + cdz * (adx * bdytail + bdy * adxtail - (ady * bdxtail + bdx * adytail)) + cdztail * (adx * bdy - ady * bdx);
    if (det >= errbound || -det >= errbound) return det;
    const at_len = tailinit(adxtail, adytail, bdx, bdy, cdx, cdy, at_b, at_c);
    const bt_len = tailinit(bdxtail, bdytail, cdx, cdy, adx, ady, bt_c, bt_a);
    const ct_len = tailinit(cdxtail, cdytail, adx, ady, bdx, bdy, ct_a, ct_b);
    const bctlen = _utilJs.sum(bt_len, bt_c, ct_len, ct_b, bct);
    finlen = finadd(finlen, _utilJs.scale(bctlen, bct, adz, _16), _16);
    const catlen = _utilJs.sum(ct_len, ct_a, at_len, at_c, cat);
    finlen = finadd(finlen, _utilJs.scale(catlen, cat, bdz, _16), _16);
    const abtlen = _utilJs.sum(at_len, at_b, bt_len, bt_a, abt);
    finlen = finadd(finlen, _utilJs.scale(abtlen, abt, cdz, _16), _16);
    if (adztail !== 0) {
        finlen = finadd(finlen, _utilJs.scale(4, bc, adztail, _12), _12);
        finlen = finadd(finlen, _utilJs.scale(bctlen, bct, adztail, _16), _16);
    }
    if (bdztail !== 0) {
        finlen = finadd(finlen, _utilJs.scale(4, ca, bdztail, _12), _12);
        finlen = finadd(finlen, _utilJs.scale(catlen, cat, bdztail, _16), _16);
    }
    if (cdztail !== 0) {
        finlen = finadd(finlen, _utilJs.scale(4, ab, cdztail, _12), _12);
        finlen = finadd(finlen, _utilJs.scale(abtlen, abt, cdztail, _16), _16);
    }
    if (adxtail !== 0) {
        if (bdytail !== 0) finlen = tailadd(finlen, adxtail, bdytail, cdz, cdztail);
        if (cdytail !== 0) finlen = tailadd(finlen, -adxtail, cdytail, bdz, bdztail);
    }
    if (bdxtail !== 0) {
        if (cdytail !== 0) finlen = tailadd(finlen, bdxtail, cdytail, adz, adztail);
        if (adytail !== 0) finlen = tailadd(finlen, -bdxtail, adytail, cdz, cdztail);
    }
    if (cdxtail !== 0) {
        if (adytail !== 0) finlen = tailadd(finlen, cdxtail, adytail, bdz, bdztail);
        if (bdytail !== 0) finlen = tailadd(finlen, -cdxtail, bdytail, adz, adztail);
    }
    return fin[finlen - 1];
}
function orient3d(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz) {
    const adx = ax - dx;
    const bdx = bx - dx;
    const cdx = cx - dx;
    const ady = ay - dy;
    const bdy = by - dy;
    const cdy = cy - dy;
    const adz = az - dz;
    const bdz = bz - dz;
    const cdz = cz - dz;
    const bdxcdy = bdx * cdy;
    const cdxbdy = cdx * bdy;
    const cdxady = cdx * ady;
    const adxcdy = adx * cdy;
    const adxbdy = adx * bdy;
    const bdxady = bdx * ady;
    const det = adz * (bdxcdy - cdxbdy) + bdz * (cdxady - adxcdy) + cdz * (adxbdy - bdxady);
    const permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz) + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz) + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz);
    const errbound = o3derrboundA * permanent;
    if (det > errbound || -det > errbound) return det;
    return orient3dadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, permanent);
}
function orient3dfast(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz) {
    const adx = ax - dx;
    const bdx = bx - dx;
    const cdx = cx - dx;
    const ady = ay - dy;
    const bdy = by - dy;
    const cdy = cy - dy;
    const adz = az - dz;
    const bdz = bz - dz;
    const cdz = cz - dz;
    return adx * (bdy * cdz - bdz * cdy) + bdx * (cdy * adz - cdz * ady) + cdx * (ady * bdz - adz * bdy);
}

},{"./util.js":"3OxkP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6yBsv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "incircle", ()=>incircle
);
parcelHelpers.export(exports, "incirclefast", ()=>incirclefast
);
var _utilJs = require("./util.js");
const iccerrboundA = (10 + 96 * _utilJs.epsilon) * _utilJs.epsilon;
const iccerrboundB = (4 + 48 * _utilJs.epsilon) * _utilJs.epsilon;
const iccerrboundC = (44 + 576 * _utilJs.epsilon) * _utilJs.epsilon * _utilJs.epsilon;
const bc = _utilJs.vec(4);
const ca = _utilJs.vec(4);
const ab = _utilJs.vec(4);
const aa = _utilJs.vec(4);
const bb = _utilJs.vec(4);
const cc = _utilJs.vec(4);
const u = _utilJs.vec(4);
const v = _utilJs.vec(4);
const axtbc = _utilJs.vec(8);
const aytbc = _utilJs.vec(8);
const bxtca = _utilJs.vec(8);
const bytca = _utilJs.vec(8);
const cxtab = _utilJs.vec(8);
const cytab = _utilJs.vec(8);
const abt = _utilJs.vec(8);
const bct = _utilJs.vec(8);
const cat = _utilJs.vec(8);
const abtt = _utilJs.vec(4);
const bctt = _utilJs.vec(4);
const catt = _utilJs.vec(4);
const _8 = _utilJs.vec(8);
const _16 = _utilJs.vec(16);
const _16b = _utilJs.vec(16);
const _16c = _utilJs.vec(16);
const _32 = _utilJs.vec(32);
const _32b = _utilJs.vec(32);
const _48 = _utilJs.vec(48);
const _64 = _utilJs.vec(64);
let fin = _utilJs.vec(1152);
let fin2 = _utilJs.vec(1152);
function finadd(finlen, a, alen) {
    finlen = _utilJs.sum(finlen, fin, a, alen, fin2);
    const tmp = fin;
    fin = fin2;
    fin2 = tmp;
    return finlen;
}
function incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent) {
    let finlen;
    let adxtail, bdxtail, cdxtail, adytail, bdytail, cdytail;
    let axtbclen, aytbclen, bxtcalen, bytcalen, cxtablen, cytablen;
    let abtlen, bctlen, catlen;
    let abttlen, bcttlen, cattlen;
    let n1, n0;
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;
    const adx = ax - dx;
    const bdx = bx - dx;
    const cdx = cx - dx;
    const ady = ay - dy;
    const bdy = by - dy;
    const cdy = cy - dy;
    s1 = bdx * cdy;
    c = _utilJs.splitter * bdx;
    ahi = c - (c - bdx);
    alo = bdx - ahi;
    c = _utilJs.splitter * cdy;
    bhi = c - (c - cdy);
    blo = cdy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = cdx * bdy;
    c = _utilJs.splitter * cdx;
    ahi = c - (c - cdx);
    alo = cdx - ahi;
    c = _utilJs.splitter * bdy;
    bhi = c - (c - bdy);
    blo = bdy - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    bc[2] = _j - (u3 - bvirt) + (_i - bvirt);
    bc[3] = u3;
    s1 = cdx * ady;
    c = _utilJs.splitter * cdx;
    ahi = c - (c - cdx);
    alo = cdx - ahi;
    c = _utilJs.splitter * ady;
    bhi = c - (c - ady);
    blo = ady - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = adx * cdy;
    c = _utilJs.splitter * adx;
    ahi = c - (c - adx);
    alo = adx - ahi;
    c = _utilJs.splitter * cdy;
    bhi = c - (c - cdy);
    blo = cdy - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ca[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ca[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    ca[2] = _j - (u3 - bvirt) + (_i - bvirt);
    ca[3] = u3;
    s1 = adx * bdy;
    c = _utilJs.splitter * adx;
    ahi = c - (c - adx);
    alo = adx - ahi;
    c = _utilJs.splitter * bdy;
    bhi = c - (c - bdy);
    blo = bdy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = bdx * ady;
    c = _utilJs.splitter * bdx;
    ahi = c - (c - bdx);
    alo = bdx - ahi;
    c = _utilJs.splitter * ady;
    bhi = c - (c - ady);
    blo = ady - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    ab[2] = _j - (u3 - bvirt) + (_i - bvirt);
    ab[3] = u3;
    finlen = _utilJs.sum(_utilJs.sum(_utilJs.sum(_utilJs.scale(_utilJs.scale(4, bc, adx, _8), _8, adx, _16), _16, _utilJs.scale(_utilJs.scale(4, bc, ady, _8), _8, ady, _16b), _16b, _32), _32, _utilJs.sum(_utilJs.scale(_utilJs.scale(4, ca, bdx, _8), _8, bdx, _16), _16, _utilJs.scale(_utilJs.scale(4, ca, bdy, _8), _8, bdy, _16b), _16b, _32b), _32b, _64), _64, _utilJs.sum(_utilJs.scale(_utilJs.scale(4, ab, cdx, _8), _8, cdx, _16), _16, _utilJs.scale(_utilJs.scale(4, ab, cdy, _8), _8, cdy, _16b), _16b, _32), _32, fin);
    let det = _utilJs.estimate(finlen, fin);
    let errbound = iccerrboundB * permanent;
    if (det >= errbound || -det >= errbound) return det;
    bvirt = ax - adx;
    adxtail = ax - (adx + bvirt) + (bvirt - dx);
    bvirt = ay - ady;
    adytail = ay - (ady + bvirt) + (bvirt - dy);
    bvirt = bx - bdx;
    bdxtail = bx - (bdx + bvirt) + (bvirt - dx);
    bvirt = by - bdy;
    bdytail = by - (bdy + bvirt) + (bvirt - dy);
    bvirt = cx - cdx;
    cdxtail = cx - (cdx + bvirt) + (bvirt - dx);
    bvirt = cy - cdy;
    cdytail = cy - (cdy + bvirt) + (bvirt - dy);
    if (adxtail === 0 && bdxtail === 0 && cdxtail === 0 && adytail === 0 && bdytail === 0 && cdytail === 0) return det;
    errbound = iccerrboundC * permanent + _utilJs.resulterrbound * Math.abs(det);
    det += (adx * adx + ady * ady) * (bdx * cdytail + cdy * bdxtail - (bdy * cdxtail + cdx * bdytail)) + 2 * (adx * adxtail + ady * adytail) * (bdx * cdy - bdy * cdx) + ((bdx * bdx + bdy * bdy) * (cdx * adytail + ady * cdxtail - (cdy * adxtail + adx * cdytail)) + 2 * (bdx * bdxtail + bdy * bdytail) * (cdx * ady - cdy * adx)) + ((cdx * cdx + cdy * cdy) * (adx * bdytail + bdy * adxtail - (ady * bdxtail + bdx * adytail)) + 2 * (cdx * cdxtail + cdy * cdytail) * (adx * bdy - ady * bdx));
    if (det >= errbound || -det >= errbound) return det;
    if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {
        s1 = adx * adx;
        c = _utilJs.splitter * adx;
        ahi = c - (c - adx);
        alo = adx - ahi;
        s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
        t1 = ady * ady;
        c = _utilJs.splitter * ady;
        ahi = c - (c - ady);
        alo = ady - ahi;
        t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
        _i = s0 + t0;
        bvirt = _i - s0;
        aa[0] = s0 - (_i - bvirt) + (t0 - bvirt);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 + t1;
        bvirt = _i - _0;
        aa[1] = _0 - (_i - bvirt) + (t1 - bvirt);
        u3 = _j + _i;
        bvirt = u3 - _j;
        aa[2] = _j - (u3 - bvirt) + (_i - bvirt);
        aa[3] = u3;
    }
    if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {
        s1 = bdx * bdx;
        c = _utilJs.splitter * bdx;
        ahi = c - (c - bdx);
        alo = bdx - ahi;
        s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
        t1 = bdy * bdy;
        c = _utilJs.splitter * bdy;
        ahi = c - (c - bdy);
        alo = bdy - ahi;
        t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
        _i = s0 + t0;
        bvirt = _i - s0;
        bb[0] = s0 - (_i - bvirt) + (t0 - bvirt);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 + t1;
        bvirt = _i - _0;
        bb[1] = _0 - (_i - bvirt) + (t1 - bvirt);
        u3 = _j + _i;
        bvirt = u3 - _j;
        bb[2] = _j - (u3 - bvirt) + (_i - bvirt);
        bb[3] = u3;
    }
    if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {
        s1 = cdx * cdx;
        c = _utilJs.splitter * cdx;
        ahi = c - (c - cdx);
        alo = cdx - ahi;
        s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
        t1 = cdy * cdy;
        c = _utilJs.splitter * cdy;
        ahi = c - (c - cdy);
        alo = cdy - ahi;
        t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
        _i = s0 + t0;
        bvirt = _i - s0;
        cc[0] = s0 - (_i - bvirt) + (t0 - bvirt);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 + t1;
        bvirt = _i - _0;
        cc[1] = _0 - (_i - bvirt) + (t1 - bvirt);
        u3 = _j + _i;
        bvirt = u3 - _j;
        cc[2] = _j - (u3 - bvirt) + (_i - bvirt);
        cc[3] = u3;
    }
    if (adxtail !== 0) {
        axtbclen = _utilJs.scale(4, bc, adxtail, axtbc);
        finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(axtbclen, axtbc, 2 * adx, _16), _16, _utilJs.scale(_utilJs.scale(4, cc, adxtail, _8), _8, bdy, _16b), _16b, _utilJs.scale(_utilJs.scale(4, bb, adxtail, _8), _8, -cdy, _16c), _16c, _32, _48), _48);
    }
    if (adytail !== 0) {
        aytbclen = _utilJs.scale(4, bc, adytail, aytbc);
        finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(aytbclen, aytbc, 2 * ady, _16), _16, _utilJs.scale(_utilJs.scale(4, bb, adytail, _8), _8, cdx, _16b), _16b, _utilJs.scale(_utilJs.scale(4, cc, adytail, _8), _8, -bdx, _16c), _16c, _32, _48), _48);
    }
    if (bdxtail !== 0) {
        bxtcalen = _utilJs.scale(4, ca, bdxtail, bxtca);
        finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(bxtcalen, bxtca, 2 * bdx, _16), _16, _utilJs.scale(_utilJs.scale(4, aa, bdxtail, _8), _8, cdy, _16b), _16b, _utilJs.scale(_utilJs.scale(4, cc, bdxtail, _8), _8, -ady, _16c), _16c, _32, _48), _48);
    }
    if (bdytail !== 0) {
        bytcalen = _utilJs.scale(4, ca, bdytail, bytca);
        finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(bytcalen, bytca, 2 * bdy, _16), _16, _utilJs.scale(_utilJs.scale(4, cc, bdytail, _8), _8, adx, _16b), _16b, _utilJs.scale(_utilJs.scale(4, aa, bdytail, _8), _8, -cdx, _16c), _16c, _32, _48), _48);
    }
    if (cdxtail !== 0) {
        cxtablen = _utilJs.scale(4, ab, cdxtail, cxtab);
        finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(cxtablen, cxtab, 2 * cdx, _16), _16, _utilJs.scale(_utilJs.scale(4, bb, cdxtail, _8), _8, ady, _16b), _16b, _utilJs.scale(_utilJs.scale(4, aa, cdxtail, _8), _8, -bdy, _16c), _16c, _32, _48), _48);
    }
    if (cdytail !== 0) {
        cytablen = _utilJs.scale(4, ab, cdytail, cytab);
        finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(cytablen, cytab, 2 * cdy, _16), _16, _utilJs.scale(_utilJs.scale(4, aa, cdytail, _8), _8, bdx, _16b), _16b, _utilJs.scale(_utilJs.scale(4, bb, cdytail, _8), _8, -adx, _16c), _16c, _32, _48), _48);
    }
    if (adxtail !== 0 || adytail !== 0) {
        if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {
            s1 = bdxtail * cdy;
            c = _utilJs.splitter * bdxtail;
            ahi = c - (c - bdxtail);
            alo = bdxtail - ahi;
            c = _utilJs.splitter * cdy;
            bhi = c - (c - cdy);
            blo = cdy - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = bdx * cdytail;
            c = _utilJs.splitter * bdx;
            ahi = c - (c - bdx);
            alo = bdx - ahi;
            c = _utilJs.splitter * cdytail;
            bhi = c - (c - cdytail);
            blo = cdytail - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 + t0;
            bvirt = _i - s0;
            u[0] = s0 - (_i - bvirt) + (t0 - bvirt);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 + t1;
            bvirt = _i - _0;
            u[1] = _0 - (_i - bvirt) + (t1 - bvirt);
            u3 = _j + _i;
            bvirt = u3 - _j;
            u[2] = _j - (u3 - bvirt) + (_i - bvirt);
            u[3] = u3;
            s1 = cdxtail * -bdy;
            c = _utilJs.splitter * cdxtail;
            ahi = c - (c - cdxtail);
            alo = cdxtail - ahi;
            c = _utilJs.splitter * -bdy;
            bhi = c - (c - -bdy);
            blo = -bdy - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = cdx * -bdytail;
            c = _utilJs.splitter * cdx;
            ahi = c - (c - cdx);
            alo = cdx - ahi;
            c = _utilJs.splitter * -bdytail;
            bhi = c - (c - -bdytail);
            blo = -bdytail - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 + t0;
            bvirt = _i - s0;
            v[0] = s0 - (_i - bvirt) + (t0 - bvirt);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 + t1;
            bvirt = _i - _0;
            v[1] = _0 - (_i - bvirt) + (t1 - bvirt);
            u3 = _j + _i;
            bvirt = u3 - _j;
            v[2] = _j - (u3 - bvirt) + (_i - bvirt);
            v[3] = u3;
            bctlen = _utilJs.sum(4, u, 4, v, bct);
            s1 = bdxtail * cdytail;
            c = _utilJs.splitter * bdxtail;
            ahi = c - (c - bdxtail);
            alo = bdxtail - ahi;
            c = _utilJs.splitter * cdytail;
            bhi = c - (c - cdytail);
            blo = cdytail - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = cdxtail * bdytail;
            c = _utilJs.splitter * cdxtail;
            ahi = c - (c - cdxtail);
            alo = cdxtail - ahi;
            c = _utilJs.splitter * bdytail;
            bhi = c - (c - bdytail);
            blo = bdytail - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 - t0;
            bvirt = s0 - _i;
            bctt[0] = s0 - (_i + bvirt) + (bvirt - t0);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 - t1;
            bvirt = _0 - _i;
            bctt[1] = _0 - (_i + bvirt) + (bvirt - t1);
            u3 = _j + _i;
            bvirt = u3 - _j;
            bctt[2] = _j - (u3 - bvirt) + (_i - bvirt);
            bctt[3] = u3;
            bcttlen = 4;
        } else {
            bct[0] = 0;
            bctlen = 1;
            bctt[0] = 0;
            bcttlen = 1;
        }
        if (adxtail !== 0) {
            const len = _utilJs.scale(bctlen, bct, adxtail, _16c);
            finlen = finadd(finlen, _utilJs.sum(_utilJs.scale(axtbclen, axtbc, adxtail, _16), _16, _utilJs.scale(len, _16c, 2 * adx, _32), _32, _48), _48);
            const len2 = _utilJs.scale(bcttlen, bctt, adxtail, _8);
            finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(len2, _8, 2 * adx, _16), _16, _utilJs.scale(len2, _8, adxtail, _16b), _16b, _utilJs.scale(len, _16c, adxtail, _32), _32, _32b, _64), _64);
            if (bdytail !== 0) finlen = finadd(finlen, _utilJs.scale(_utilJs.scale(4, cc, adxtail, _8), _8, bdytail, _16), _16);
            if (cdytail !== 0) finlen = finadd(finlen, _utilJs.scale(_utilJs.scale(4, bb, -adxtail, _8), _8, cdytail, _16), _16);
        }
        if (adytail !== 0) {
            const len = _utilJs.scale(bctlen, bct, adytail, _16c);
            finlen = finadd(finlen, _utilJs.sum(_utilJs.scale(aytbclen, aytbc, adytail, _16), _16, _utilJs.scale(len, _16c, 2 * ady, _32), _32, _48), _48);
            const len2 = _utilJs.scale(bcttlen, bctt, adytail, _8);
            finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(len2, _8, 2 * ady, _16), _16, _utilJs.scale(len2, _8, adytail, _16b), _16b, _utilJs.scale(len, _16c, adytail, _32), _32, _32b, _64), _64);
        }
    }
    if (bdxtail !== 0 || bdytail !== 0) {
        if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {
            s1 = cdxtail * ady;
            c = _utilJs.splitter * cdxtail;
            ahi = c - (c - cdxtail);
            alo = cdxtail - ahi;
            c = _utilJs.splitter * ady;
            bhi = c - (c - ady);
            blo = ady - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = cdx * adytail;
            c = _utilJs.splitter * cdx;
            ahi = c - (c - cdx);
            alo = cdx - ahi;
            c = _utilJs.splitter * adytail;
            bhi = c - (c - adytail);
            blo = adytail - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 + t0;
            bvirt = _i - s0;
            u[0] = s0 - (_i - bvirt) + (t0 - bvirt);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 + t1;
            bvirt = _i - _0;
            u[1] = _0 - (_i - bvirt) + (t1 - bvirt);
            u3 = _j + _i;
            bvirt = u3 - _j;
            u[2] = _j - (u3 - bvirt) + (_i - bvirt);
            u[3] = u3;
            n1 = -cdy;
            n0 = -cdytail;
            s1 = adxtail * n1;
            c = _utilJs.splitter * adxtail;
            ahi = c - (c - adxtail);
            alo = adxtail - ahi;
            c = _utilJs.splitter * n1;
            bhi = c - (c - n1);
            blo = n1 - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = adx * n0;
            c = _utilJs.splitter * adx;
            ahi = c - (c - adx);
            alo = adx - ahi;
            c = _utilJs.splitter * n0;
            bhi = c - (c - n0);
            blo = n0 - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 + t0;
            bvirt = _i - s0;
            v[0] = s0 - (_i - bvirt) + (t0 - bvirt);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 + t1;
            bvirt = _i - _0;
            v[1] = _0 - (_i - bvirt) + (t1 - bvirt);
            u3 = _j + _i;
            bvirt = u3 - _j;
            v[2] = _j - (u3 - bvirt) + (_i - bvirt);
            v[3] = u3;
            catlen = _utilJs.sum(4, u, 4, v, cat);
            s1 = cdxtail * adytail;
            c = _utilJs.splitter * cdxtail;
            ahi = c - (c - cdxtail);
            alo = cdxtail - ahi;
            c = _utilJs.splitter * adytail;
            bhi = c - (c - adytail);
            blo = adytail - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = adxtail * cdytail;
            c = _utilJs.splitter * adxtail;
            ahi = c - (c - adxtail);
            alo = adxtail - ahi;
            c = _utilJs.splitter * cdytail;
            bhi = c - (c - cdytail);
            blo = cdytail - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 - t0;
            bvirt = s0 - _i;
            catt[0] = s0 - (_i + bvirt) + (bvirt - t0);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 - t1;
            bvirt = _0 - _i;
            catt[1] = _0 - (_i + bvirt) + (bvirt - t1);
            u3 = _j + _i;
            bvirt = u3 - _j;
            catt[2] = _j - (u3 - bvirt) + (_i - bvirt);
            catt[3] = u3;
            cattlen = 4;
        } else {
            cat[0] = 0;
            catlen = 1;
            catt[0] = 0;
            cattlen = 1;
        }
        if (bdxtail !== 0) {
            const len = _utilJs.scale(catlen, cat, bdxtail, _16c);
            finlen = finadd(finlen, _utilJs.sum(_utilJs.scale(bxtcalen, bxtca, bdxtail, _16), _16, _utilJs.scale(len, _16c, 2 * bdx, _32), _32, _48), _48);
            const len2 = _utilJs.scale(cattlen, catt, bdxtail, _8);
            finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(len2, _8, 2 * bdx, _16), _16, _utilJs.scale(len2, _8, bdxtail, _16b), _16b, _utilJs.scale(len, _16c, bdxtail, _32), _32, _32b, _64), _64);
            if (cdytail !== 0) finlen = finadd(finlen, _utilJs.scale(_utilJs.scale(4, aa, bdxtail, _8), _8, cdytail, _16), _16);
            if (adytail !== 0) finlen = finadd(finlen, _utilJs.scale(_utilJs.scale(4, cc, -bdxtail, _8), _8, adytail, _16), _16);
        }
        if (bdytail !== 0) {
            const len = _utilJs.scale(catlen, cat, bdytail, _16c);
            finlen = finadd(finlen, _utilJs.sum(_utilJs.scale(bytcalen, bytca, bdytail, _16), _16, _utilJs.scale(len, _16c, 2 * bdy, _32), _32, _48), _48);
            const len2 = _utilJs.scale(cattlen, catt, bdytail, _8);
            finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(len2, _8, 2 * bdy, _16), _16, _utilJs.scale(len2, _8, bdytail, _16b), _16b, _utilJs.scale(len, _16c, bdytail, _32), _32, _32b, _64), _64);
        }
    }
    if (cdxtail !== 0 || cdytail !== 0) {
        if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {
            s1 = adxtail * bdy;
            c = _utilJs.splitter * adxtail;
            ahi = c - (c - adxtail);
            alo = adxtail - ahi;
            c = _utilJs.splitter * bdy;
            bhi = c - (c - bdy);
            blo = bdy - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = adx * bdytail;
            c = _utilJs.splitter * adx;
            ahi = c - (c - adx);
            alo = adx - ahi;
            c = _utilJs.splitter * bdytail;
            bhi = c - (c - bdytail);
            blo = bdytail - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 + t0;
            bvirt = _i - s0;
            u[0] = s0 - (_i - bvirt) + (t0 - bvirt);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 + t1;
            bvirt = _i - _0;
            u[1] = _0 - (_i - bvirt) + (t1 - bvirt);
            u3 = _j + _i;
            bvirt = u3 - _j;
            u[2] = _j - (u3 - bvirt) + (_i - bvirt);
            u[3] = u3;
            n1 = -ady;
            n0 = -adytail;
            s1 = bdxtail * n1;
            c = _utilJs.splitter * bdxtail;
            ahi = c - (c - bdxtail);
            alo = bdxtail - ahi;
            c = _utilJs.splitter * n1;
            bhi = c - (c - n1);
            blo = n1 - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = bdx * n0;
            c = _utilJs.splitter * bdx;
            ahi = c - (c - bdx);
            alo = bdx - ahi;
            c = _utilJs.splitter * n0;
            bhi = c - (c - n0);
            blo = n0 - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 + t0;
            bvirt = _i - s0;
            v[0] = s0 - (_i - bvirt) + (t0 - bvirt);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 + t1;
            bvirt = _i - _0;
            v[1] = _0 - (_i - bvirt) + (t1 - bvirt);
            u3 = _j + _i;
            bvirt = u3 - _j;
            v[2] = _j - (u3 - bvirt) + (_i - bvirt);
            v[3] = u3;
            abtlen = _utilJs.sum(4, u, 4, v, abt);
            s1 = adxtail * bdytail;
            c = _utilJs.splitter * adxtail;
            ahi = c - (c - adxtail);
            alo = adxtail - ahi;
            c = _utilJs.splitter * bdytail;
            bhi = c - (c - bdytail);
            blo = bdytail - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = bdxtail * adytail;
            c = _utilJs.splitter * bdxtail;
            ahi = c - (c - bdxtail);
            alo = bdxtail - ahi;
            c = _utilJs.splitter * adytail;
            bhi = c - (c - adytail);
            blo = adytail - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 - t0;
            bvirt = s0 - _i;
            abtt[0] = s0 - (_i + bvirt) + (bvirt - t0);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 - t1;
            bvirt = _0 - _i;
            abtt[1] = _0 - (_i + bvirt) + (bvirt - t1);
            u3 = _j + _i;
            bvirt = u3 - _j;
            abtt[2] = _j - (u3 - bvirt) + (_i - bvirt);
            abtt[3] = u3;
            abttlen = 4;
        } else {
            abt[0] = 0;
            abtlen = 1;
            abtt[0] = 0;
            abttlen = 1;
        }
        if (cdxtail !== 0) {
            const len = _utilJs.scale(abtlen, abt, cdxtail, _16c);
            finlen = finadd(finlen, _utilJs.sum(_utilJs.scale(cxtablen, cxtab, cdxtail, _16), _16, _utilJs.scale(len, _16c, 2 * cdx, _32), _32, _48), _48);
            const len2 = _utilJs.scale(abttlen, abtt, cdxtail, _8);
            finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(len2, _8, 2 * cdx, _16), _16, _utilJs.scale(len2, _8, cdxtail, _16b), _16b, _utilJs.scale(len, _16c, cdxtail, _32), _32, _32b, _64), _64);
            if (adytail !== 0) finlen = finadd(finlen, _utilJs.scale(_utilJs.scale(4, bb, cdxtail, _8), _8, adytail, _16), _16);
            if (bdytail !== 0) finlen = finadd(finlen, _utilJs.scale(_utilJs.scale(4, aa, -cdxtail, _8), _8, bdytail, _16), _16);
        }
        if (cdytail !== 0) {
            const len = _utilJs.scale(abtlen, abt, cdytail, _16c);
            finlen = finadd(finlen, _utilJs.sum(_utilJs.scale(cytablen, cytab, cdytail, _16), _16, _utilJs.scale(len, _16c, 2 * cdy, _32), _32, _48), _48);
            const len2 = _utilJs.scale(abttlen, abtt, cdytail, _8);
            finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(len2, _8, 2 * cdy, _16), _16, _utilJs.scale(len2, _8, cdytail, _16b), _16b, _utilJs.scale(len, _16c, cdytail, _32), _32, _32b, _64), _64);
        }
    }
    return fin[finlen - 1];
}
function incircle(ax, ay, bx, by, cx, cy, dx, dy) {
    const adx = ax - dx;
    const bdx = bx - dx;
    const cdx = cx - dx;
    const ady = ay - dy;
    const bdy = by - dy;
    const cdy = cy - dy;
    const bdxcdy = bdx * cdy;
    const cdxbdy = cdx * bdy;
    const alift = adx * adx + ady * ady;
    const cdxady = cdx * ady;
    const adxcdy = adx * cdy;
    const blift = bdx * bdx + bdy * bdy;
    const adxbdy = adx * bdy;
    const bdxady = bdx * ady;
    const clift = cdx * cdx + cdy * cdy;
    const det = alift * (bdxcdy - cdxbdy) + blift * (cdxady - adxcdy) + clift * (adxbdy - bdxady);
    const permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * alift + (Math.abs(cdxady) + Math.abs(adxcdy)) * blift + (Math.abs(adxbdy) + Math.abs(bdxady)) * clift;
    const errbound = iccerrboundA * permanent;
    if (det > errbound || -det > errbound) return det;
    return incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent);
}
function incirclefast(ax, ay, bx, by, cx, cy, dx, dy) {
    const adx = ax - dx;
    const ady = ay - dy;
    const bdx = bx - dx;
    const bdy = by - dy;
    const cdx = cx - dx;
    const cdy = cy - dy;
    const abdet = adx * bdy - bdx * ady;
    const bcdet = bdx * cdy - cdx * bdy;
    const cadet = cdx * ady - adx * cdy;
    const alift = adx * adx + ady * ady;
    const blift = bdx * bdx + bdy * bdy;
    const clift = cdx * cdx + cdy * cdy;
    return alift * bcdet + blift * cadet + clift * abdet;
}

},{"./util.js":"3OxkP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6qjhA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "insphere", ()=>insphere
);
parcelHelpers.export(exports, "inspherefast", ()=>inspherefast
);
var _utilJs = require("./util.js");
const isperrboundA = (16 + 224 * _utilJs.epsilon) * _utilJs.epsilon;
const isperrboundB = (5 + 72 * _utilJs.epsilon) * _utilJs.epsilon;
const isperrboundC = (71 + 1408 * _utilJs.epsilon) * _utilJs.epsilon * _utilJs.epsilon;
const ab = _utilJs.vec(4);
const bc = _utilJs.vec(4);
const cd = _utilJs.vec(4);
const de = _utilJs.vec(4);
const ea = _utilJs.vec(4);
const ac = _utilJs.vec(4);
const bd = _utilJs.vec(4);
const ce = _utilJs.vec(4);
const da = _utilJs.vec(4);
const eb = _utilJs.vec(4);
const abc = _utilJs.vec(24);
const bcd = _utilJs.vec(24);
const cde = _utilJs.vec(24);
const dea = _utilJs.vec(24);
const eab = _utilJs.vec(24);
const abd = _utilJs.vec(24);
const bce = _utilJs.vec(24);
const cda = _utilJs.vec(24);
const deb = _utilJs.vec(24);
const eac = _utilJs.vec(24);
const adet = _utilJs.vec(1152);
const bdet = _utilJs.vec(1152);
const cdet = _utilJs.vec(1152);
const ddet = _utilJs.vec(1152);
const edet = _utilJs.vec(1152);
const abdet = _utilJs.vec(2304);
const cddet = _utilJs.vec(2304);
const cdedet = _utilJs.vec(3456);
const deter = _utilJs.vec(5760);
const _8 = _utilJs.vec(8);
const _8b = _utilJs.vec(8);
const _8c = _utilJs.vec(8);
const _16 = _utilJs.vec(16);
const _24 = _utilJs.vec(24);
const _48 = _utilJs.vec(48);
const _48b = _utilJs.vec(48);
const _96 = _utilJs.vec(96);
const _192 = _utilJs.vec(192);
const _384x = _utilJs.vec(384);
const _384y = _utilJs.vec(384);
const _384z = _utilJs.vec(384);
const _768 = _utilJs.vec(768);
function sum_three_scale(a, b, c, az, bz, cz, out) {
    return _utilJs.sum_three(_utilJs.scale(4, a, az, _8), _8, _utilJs.scale(4, b, bz, _8b), _8b, _utilJs.scale(4, c, cz, _8c), _8c, _16, out);
}
function liftexact(alen, a, blen, b, clen, c, dlen, d, x, y, z, out) {
    const len = _utilJs.sum(_utilJs.sum(alen, a, blen, b, _48), _48, _utilJs.negate(_utilJs.sum(clen, c, dlen, d, _48b), _48b), _48b, _96);
    return _utilJs.sum_three(_utilJs.scale(_utilJs.scale(len, _96, x, _192), _192, x, _384x), _384x, _utilJs.scale(_utilJs.scale(len, _96, y, _192), _192, y, _384y), _384y, _utilJs.scale(_utilJs.scale(len, _96, z, _192), _192, z, _384z), _384z, _768, out);
}
function insphereexact(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez) {
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;
    s1 = ax * by;
    c = _utilJs.splitter * ax;
    ahi = c - (c - ax);
    alo = ax - ahi;
    c = _utilJs.splitter * by;
    bhi = c - (c - by);
    blo = by - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = bx * ay;
    c = _utilJs.splitter * bx;
    ahi = c - (c - bx);
    alo = bx - ahi;
    c = _utilJs.splitter * ay;
    bhi = c - (c - ay);
    blo = ay - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    ab[2] = _j - (u3 - bvirt) + (_i - bvirt);
    ab[3] = u3;
    s1 = bx * cy;
    c = _utilJs.splitter * bx;
    ahi = c - (c - bx);
    alo = bx - ahi;
    c = _utilJs.splitter * cy;
    bhi = c - (c - cy);
    blo = cy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = cx * by;
    c = _utilJs.splitter * cx;
    ahi = c - (c - cx);
    alo = cx - ahi;
    c = _utilJs.splitter * by;
    bhi = c - (c - by);
    blo = by - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    bc[2] = _j - (u3 - bvirt) + (_i - bvirt);
    bc[3] = u3;
    s1 = cx * dy;
    c = _utilJs.splitter * cx;
    ahi = c - (c - cx);
    alo = cx - ahi;
    c = _utilJs.splitter * dy;
    bhi = c - (c - dy);
    blo = dy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = dx * cy;
    c = _utilJs.splitter * dx;
    ahi = c - (c - dx);
    alo = dx - ahi;
    c = _utilJs.splitter * cy;
    bhi = c - (c - cy);
    blo = cy - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    cd[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    cd[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    cd[2] = _j - (u3 - bvirt) + (_i - bvirt);
    cd[3] = u3;
    s1 = dx * ey;
    c = _utilJs.splitter * dx;
    ahi = c - (c - dx);
    alo = dx - ahi;
    c = _utilJs.splitter * ey;
    bhi = c - (c - ey);
    blo = ey - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = ex * dy;
    c = _utilJs.splitter * ex;
    ahi = c - (c - ex);
    alo = ex - ahi;
    c = _utilJs.splitter * dy;
    bhi = c - (c - dy);
    blo = dy - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    de[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    de[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    de[2] = _j - (u3 - bvirt) + (_i - bvirt);
    de[3] = u3;
    s1 = ex * ay;
    c = _utilJs.splitter * ex;
    ahi = c - (c - ex);
    alo = ex - ahi;
    c = _utilJs.splitter * ay;
    bhi = c - (c - ay);
    blo = ay - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = ax * ey;
    c = _utilJs.splitter * ax;
    ahi = c - (c - ax);
    alo = ax - ahi;
    c = _utilJs.splitter * ey;
    bhi = c - (c - ey);
    blo = ey - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ea[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ea[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    ea[2] = _j - (u3 - bvirt) + (_i - bvirt);
    ea[3] = u3;
    s1 = ax * cy;
    c = _utilJs.splitter * ax;
    ahi = c - (c - ax);
    alo = ax - ahi;
    c = _utilJs.splitter * cy;
    bhi = c - (c - cy);
    blo = cy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = cx * ay;
    c = _utilJs.splitter * cx;
    ahi = c - (c - cx);
    alo = cx - ahi;
    c = _utilJs.splitter * ay;
    bhi = c - (c - ay);
    blo = ay - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ac[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ac[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    ac[2] = _j - (u3 - bvirt) + (_i - bvirt);
    ac[3] = u3;
    s1 = bx * dy;
    c = _utilJs.splitter * bx;
    ahi = c - (c - bx);
    alo = bx - ahi;
    c = _utilJs.splitter * dy;
    bhi = c - (c - dy);
    blo = dy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = dx * by;
    c = _utilJs.splitter * dx;
    ahi = c - (c - dx);
    alo = dx - ahi;
    c = _utilJs.splitter * by;
    bhi = c - (c - by);
    blo = by - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    bd[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    bd[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    bd[2] = _j - (u3 - bvirt) + (_i - bvirt);
    bd[3] = u3;
    s1 = cx * ey;
    c = _utilJs.splitter * cx;
    ahi = c - (c - cx);
    alo = cx - ahi;
    c = _utilJs.splitter * ey;
    bhi = c - (c - ey);
    blo = ey - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = ex * cy;
    c = _utilJs.splitter * ex;
    ahi = c - (c - ex);
    alo = ex - ahi;
    c = _utilJs.splitter * cy;
    bhi = c - (c - cy);
    blo = cy - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ce[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ce[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    ce[2] = _j - (u3 - bvirt) + (_i - bvirt);
    ce[3] = u3;
    s1 = dx * ay;
    c = _utilJs.splitter * dx;
    ahi = c - (c - dx);
    alo = dx - ahi;
    c = _utilJs.splitter * ay;
    bhi = c - (c - ay);
    blo = ay - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = ax * dy;
    c = _utilJs.splitter * ax;
    ahi = c - (c - ax);
    alo = ax - ahi;
    c = _utilJs.splitter * dy;
    bhi = c - (c - dy);
    blo = dy - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    da[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    da[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    da[2] = _j - (u3 - bvirt) + (_i - bvirt);
    da[3] = u3;
    s1 = ex * by;
    c = _utilJs.splitter * ex;
    ahi = c - (c - ex);
    alo = ex - ahi;
    c = _utilJs.splitter * by;
    bhi = c - (c - by);
    blo = by - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = bx * ey;
    c = _utilJs.splitter * bx;
    ahi = c - (c - bx);
    alo = bx - ahi;
    c = _utilJs.splitter * ey;
    bhi = c - (c - ey);
    blo = ey - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    eb[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    eb[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    eb[2] = _j - (u3 - bvirt) + (_i - bvirt);
    eb[3] = u3;
    const abclen = sum_three_scale(ab, bc, ac, cz, az, -bz, abc);
    const bcdlen = sum_three_scale(bc, cd, bd, dz, bz, -cz, bcd);
    const cdelen = sum_three_scale(cd, de, ce, ez, cz, -dz, cde);
    const dealen = sum_three_scale(de, ea, da, az, dz, -ez, dea);
    const eablen = sum_three_scale(ea, ab, eb, bz, ez, -az, eab);
    const abdlen = sum_three_scale(ab, bd, da, dz, az, bz, abd);
    const bcelen = sum_three_scale(bc, ce, eb, ez, bz, cz, bce);
    const cdalen = sum_three_scale(cd, da, ac, az, cz, dz, cda);
    const deblen = sum_three_scale(de, eb, bd, bz, dz, ez, deb);
    const eaclen = sum_three_scale(ea, ac, ce, cz, ez, az, eac);
    const deterlen = _utilJs.sum_three(liftexact(cdelen, cde, bcelen, bce, deblen, deb, bcdlen, bcd, ax, ay, az, adet), adet, liftexact(dealen, dea, cdalen, cda, eaclen, eac, cdelen, cde, bx, by, bz, bdet), bdet, _utilJs.sum_three(liftexact(eablen, eab, deblen, deb, abdlen, abd, dealen, dea, cx, cy, cz, cdet), cdet, liftexact(abclen, abc, eaclen, eac, bcelen, bce, eablen, eab, dx, dy, dz, ddet), ddet, liftexact(bcdlen, bcd, abdlen, abd, cdalen, cda, abclen, abc, ex, ey, ez, edet), edet, cddet, cdedet), cdedet, abdet, deter);
    return deter[deterlen - 1];
}
const xdet = _utilJs.vec(96);
const ydet = _utilJs.vec(96);
const zdet = _utilJs.vec(96);
const fin = _utilJs.vec(1152);
function liftadapt(a, b, c, az, bz, cz, x, y, z, out) {
    const len = sum_three_scale(a, b, c, az, bz, cz, _24);
    return _utilJs.sum_three(_utilJs.scale(_utilJs.scale(len, _24, x, _48), _48, x, xdet), xdet, _utilJs.scale(_utilJs.scale(len, _24, y, _48), _48, y, ydet), ydet, _utilJs.scale(_utilJs.scale(len, _24, z, _48), _48, z, zdet), zdet, _192, out);
}
function insphereadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez, permanent) {
    let ab3, bc3, cd3, da3, ac3, bd3;
    let aextail, bextail, cextail, dextail;
    let aeytail, beytail, ceytail, deytail;
    let aeztail, beztail, ceztail, deztail;
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0;
    const aex = ax - ex;
    const bex = bx - ex;
    const cex = cx - ex;
    const dex = dx - ex;
    const aey = ay - ey;
    const bey = by - ey;
    const cey = cy - ey;
    const dey = dy - ey;
    const aez = az - ez;
    const bez = bz - ez;
    const cez = cz - ez;
    const dez = dz - ez;
    s1 = aex * bey;
    c = _utilJs.splitter * aex;
    ahi = c - (c - aex);
    alo = aex - ahi;
    c = _utilJs.splitter * bey;
    bhi = c - (c - bey);
    blo = bey - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = bex * aey;
    c = _utilJs.splitter * bex;
    ahi = c - (c - bex);
    alo = bex - ahi;
    c = _utilJs.splitter * aey;
    bhi = c - (c - aey);
    blo = aey - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);
    ab3 = _j + _i;
    bvirt = ab3 - _j;
    ab[2] = _j - (ab3 - bvirt) + (_i - bvirt);
    ab[3] = ab3;
    s1 = bex * cey;
    c = _utilJs.splitter * bex;
    ahi = c - (c - bex);
    alo = bex - ahi;
    c = _utilJs.splitter * cey;
    bhi = c - (c - cey);
    blo = cey - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = cex * bey;
    c = _utilJs.splitter * cex;
    ahi = c - (c - cex);
    alo = cex - ahi;
    c = _utilJs.splitter * bey;
    bhi = c - (c - bey);
    blo = bey - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);
    bc3 = _j + _i;
    bvirt = bc3 - _j;
    bc[2] = _j - (bc3 - bvirt) + (_i - bvirt);
    bc[3] = bc3;
    s1 = cex * dey;
    c = _utilJs.splitter * cex;
    ahi = c - (c - cex);
    alo = cex - ahi;
    c = _utilJs.splitter * dey;
    bhi = c - (c - dey);
    blo = dey - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = dex * cey;
    c = _utilJs.splitter * dex;
    ahi = c - (c - dex);
    alo = dex - ahi;
    c = _utilJs.splitter * cey;
    bhi = c - (c - cey);
    blo = cey - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    cd[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    cd[1] = _0 - (_i + bvirt) + (bvirt - t1);
    cd3 = _j + _i;
    bvirt = cd3 - _j;
    cd[2] = _j - (cd3 - bvirt) + (_i - bvirt);
    cd[3] = cd3;
    s1 = dex * aey;
    c = _utilJs.splitter * dex;
    ahi = c - (c - dex);
    alo = dex - ahi;
    c = _utilJs.splitter * aey;
    bhi = c - (c - aey);
    blo = aey - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = aex * dey;
    c = _utilJs.splitter * aex;
    ahi = c - (c - aex);
    alo = aex - ahi;
    c = _utilJs.splitter * dey;
    bhi = c - (c - dey);
    blo = dey - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    da[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    da[1] = _0 - (_i + bvirt) + (bvirt - t1);
    da3 = _j + _i;
    bvirt = da3 - _j;
    da[2] = _j - (da3 - bvirt) + (_i - bvirt);
    da[3] = da3;
    s1 = aex * cey;
    c = _utilJs.splitter * aex;
    ahi = c - (c - aex);
    alo = aex - ahi;
    c = _utilJs.splitter * cey;
    bhi = c - (c - cey);
    blo = cey - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = cex * aey;
    c = _utilJs.splitter * cex;
    ahi = c - (c - cex);
    alo = cex - ahi;
    c = _utilJs.splitter * aey;
    bhi = c - (c - aey);
    blo = aey - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ac[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ac[1] = _0 - (_i + bvirt) + (bvirt - t1);
    ac3 = _j + _i;
    bvirt = ac3 - _j;
    ac[2] = _j - (ac3 - bvirt) + (_i - bvirt);
    ac[3] = ac3;
    s1 = bex * dey;
    c = _utilJs.splitter * bex;
    ahi = c - (c - bex);
    alo = bex - ahi;
    c = _utilJs.splitter * dey;
    bhi = c - (c - dey);
    blo = dey - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = dex * bey;
    c = _utilJs.splitter * dex;
    ahi = c - (c - dex);
    alo = dex - ahi;
    c = _utilJs.splitter * bey;
    bhi = c - (c - bey);
    blo = bey - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    bd[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    bd[1] = _0 - (_i + bvirt) + (bvirt - t1);
    bd3 = _j + _i;
    bvirt = bd3 - _j;
    bd[2] = _j - (bd3 - bvirt) + (_i - bvirt);
    bd[3] = bd3;
    const finlen = _utilJs.sum(_utilJs.sum(_utilJs.negate(liftadapt(bc, cd, bd, dez, bez, -cez, aex, aey, aez, adet), adet), adet, liftadapt(cd, da, ac, aez, cez, dez, bex, bey, bez, bdet), bdet, abdet), abdet, _utilJs.sum(_utilJs.negate(liftadapt(da, ab, bd, bez, dez, aez, cex, cey, cez, cdet), cdet), cdet, liftadapt(ab, bc, ac, cez, aez, -bez, dex, dey, dez, ddet), ddet, cddet), cddet, fin);
    let det = _utilJs.estimate(finlen, fin);
    let errbound = isperrboundB * permanent;
    if (det >= errbound || -det >= errbound) return det;
    bvirt = ax - aex;
    aextail = ax - (aex + bvirt) + (bvirt - ex);
    bvirt = ay - aey;
    aeytail = ay - (aey + bvirt) + (bvirt - ey);
    bvirt = az - aez;
    aeztail = az - (aez + bvirt) + (bvirt - ez);
    bvirt = bx - bex;
    bextail = bx - (bex + bvirt) + (bvirt - ex);
    bvirt = by - bey;
    beytail = by - (bey + bvirt) + (bvirt - ey);
    bvirt = bz - bez;
    beztail = bz - (bez + bvirt) + (bvirt - ez);
    bvirt = cx - cex;
    cextail = cx - (cex + bvirt) + (bvirt - ex);
    bvirt = cy - cey;
    ceytail = cy - (cey + bvirt) + (bvirt - ey);
    bvirt = cz - cez;
    ceztail = cz - (cez + bvirt) + (bvirt - ez);
    bvirt = dx - dex;
    dextail = dx - (dex + bvirt) + (bvirt - ex);
    bvirt = dy - dey;
    deytail = dy - (dey + bvirt) + (bvirt - ey);
    bvirt = dz - dez;
    deztail = dz - (dez + bvirt) + (bvirt - ez);
    if (aextail === 0 && aeytail === 0 && aeztail === 0 && bextail === 0 && beytail === 0 && beztail === 0 && cextail === 0 && ceytail === 0 && ceztail === 0 && dextail === 0 && deytail === 0 && deztail === 0) return det;
    errbound = isperrboundC * permanent + _utilJs.resulterrbound * Math.abs(det);
    const abeps = aex * beytail + bey * aextail - (aey * bextail + bex * aeytail);
    const bceps = bex * ceytail + cey * bextail - (bey * cextail + cex * beytail);
    const cdeps = cex * deytail + dey * cextail - (cey * dextail + dex * ceytail);
    const daeps = dex * aeytail + aey * dextail - (dey * aextail + aex * deytail);
    const aceps = aex * ceytail + cey * aextail - (aey * cextail + cex * aeytail);
    const bdeps = bex * deytail + dey * bextail - (bey * dextail + dex * beytail);
    det += (bex * bex + bey * bey + bez * bez) * (cez * daeps + dez * aceps + aez * cdeps + (ceztail * da3 + deztail * ac3 + aeztail * cd3)) + (dex * dex + dey * dey + dez * dez) * (aez * bceps - bez * aceps + cez * abeps + (aeztail * bc3 - beztail * ac3 + ceztail * ab3)) - ((aex * aex + aey * aey + aez * aez) * (bez * cdeps - cez * bdeps + dez * bceps + (beztail * cd3 - ceztail * bd3 + deztail * bc3)) + (cex * cex + cey * cey + cez * cez) * (dez * abeps + aez * bdeps + bez * daeps + (deztail * ab3 + aeztail * bd3 + beztail * da3))) + 2 * ((bex * bextail + bey * beytail + bez * beztail) * (cez * da3 + dez * ac3 + aez * cd3) + (dex * dextail + dey * deytail + dez * deztail) * (aez * bc3 - bez * ac3 + cez * ab3) - ((aex * aextail + aey * aeytail + aez * aeztail) * (bez * cd3 - cez * bd3 + dez * bc3) + (cex * cextail + cey * ceytail + cez * ceztail) * (dez * ab3 + aez * bd3 + bez * da3)));
    if (det >= errbound || -det >= errbound) return det;
    return insphereexact(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez);
}
function insphere(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez) {
    const aex = ax - ex;
    const bex = bx - ex;
    const cex = cx - ex;
    const dex = dx - ex;
    const aey = ay - ey;
    const bey = by - ey;
    const cey = cy - ey;
    const dey = dy - ey;
    const aez = az - ez;
    const bez = bz - ez;
    const cez = cz - ez;
    const dez = dz - ez;
    const aexbey = aex * bey;
    const bexaey = bex * aey;
    const ab1 = aexbey - bexaey;
    const bexcey = bex * cey;
    const cexbey = cex * bey;
    const bc1 = bexcey - cexbey;
    const cexdey = cex * dey;
    const dexcey = dex * cey;
    const cd1 = cexdey - dexcey;
    const dexaey = dex * aey;
    const aexdey = aex * dey;
    const da1 = dexaey - aexdey;
    const aexcey = aex * cey;
    const cexaey = cex * aey;
    const ac1 = aexcey - cexaey;
    const bexdey = bex * dey;
    const dexbey = dex * bey;
    const bd1 = bexdey - dexbey;
    const abc1 = aez * bc1 - bez * ac1 + cez * ab1;
    const bcd1 = bez * cd1 - cez * bd1 + dez * bc1;
    const cda1 = cez * da1 + dez * ac1 + aez * cd1;
    const dab = dez * ab1 + aez * bd1 + bez * da1;
    const alift = aex * aex + aey * aey + aez * aez;
    const blift = bex * bex + bey * bey + bez * bez;
    const clift = cex * cex + cey * cey + cez * cez;
    const dlift = dex * dex + dey * dey + dez * dez;
    const det = clift * dab - dlift * abc1 + (alift * bcd1 - blift * cda1);
    const aezplus = Math.abs(aez);
    const bezplus = Math.abs(bez);
    const cezplus = Math.abs(cez);
    const dezplus = Math.abs(dez);
    const aexbeyplus = Math.abs(aexbey);
    const bexaeyplus = Math.abs(bexaey);
    const bexceyplus = Math.abs(bexcey);
    const cexbeyplus = Math.abs(cexbey);
    const cexdeyplus = Math.abs(cexdey);
    const dexceyplus = Math.abs(dexcey);
    const dexaeyplus = Math.abs(dexaey);
    const aexdeyplus = Math.abs(aexdey);
    const aexceyplus = Math.abs(aexcey);
    const cexaeyplus = Math.abs(cexaey);
    const bexdeyplus = Math.abs(bexdey);
    const dexbeyplus = Math.abs(dexbey);
    const permanent = ((cexdeyplus + dexceyplus) * bezplus + (dexbeyplus + bexdeyplus) * cezplus + (bexceyplus + cexbeyplus) * dezplus) * alift + ((dexaeyplus + aexdeyplus) * cezplus + (aexceyplus + cexaeyplus) * dezplus + (cexdeyplus + dexceyplus) * aezplus) * blift + ((aexbeyplus + bexaeyplus) * dezplus + (bexdeyplus + dexbeyplus) * aezplus + (dexaeyplus + aexdeyplus) * bezplus) * clift + ((bexceyplus + cexbeyplus) * aezplus + (cexaeyplus + aexceyplus) * bezplus + (aexbeyplus + bexaeyplus) * cezplus) * dlift;
    const errbound = isperrboundA * permanent;
    if (det > errbound || -det > errbound) return det;
    return -insphereadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez, permanent);
}
function inspherefast(pax, pay, paz, pbx, pby, pbz, pcx, pcy, pcz, pdx, pdy, pdz, pex, pey, pez) {
    const aex = pax - pex;
    const bex = pbx - pex;
    const cex = pcx - pex;
    const dex = pdx - pex;
    const aey = pay - pey;
    const bey = pby - pey;
    const cey = pcy - pey;
    const dey = pdy - pey;
    const aez = paz - pez;
    const bez = pbz - pez;
    const cez = pcz - pez;
    const dez = pdz - pez;
    const ab2 = aex * bey - bex * aey;
    const bc2 = bex * cey - cex * bey;
    const cd2 = cex * dey - dex * cey;
    const da2 = dex * aey - aex * dey;
    const ac2 = aex * cey - cex * aey;
    const bd2 = bex * dey - dex * bey;
    const abc2 = aez * bc2 - bez * ac2 + cez * ab2;
    const bcd2 = bez * cd2 - cez * bd2 + dez * bc2;
    const cda2 = cez * da2 + dez * ac2 + aez * cd2;
    const dab = dez * ab2 + aez * bd2 + bez * da2;
    const alift = aex * aex + aey * aey + aez * aez;
    const blift = bex * bex + bey * bey + bez * bez;
    const clift = cex * cex + cey * cey + cez * cez;
    const dlift = dex * dex + dey * dey + dez * dez;
    return clift * dab - dlift * abc2 + (alift * bcd2 - blift * cda2);
}

},{"./util.js":"3OxkP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bXNwz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="es" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ parcelHelpers.export(exports, "add", ()=>_addJsDefault.default
);
parcelHelpers.export(exports, "after", ()=>_afterJsDefault.default
);
parcelHelpers.export(exports, "ary", ()=>_aryJsDefault.default
);
parcelHelpers.export(exports, "assign", ()=>_assignJsDefault.default
);
parcelHelpers.export(exports, "assignIn", ()=>_assignInJsDefault.default
);
parcelHelpers.export(exports, "assignInWith", ()=>_assignInWithJsDefault.default
);
parcelHelpers.export(exports, "assignWith", ()=>_assignWithJsDefault.default
);
parcelHelpers.export(exports, "at", ()=>_atJsDefault.default
);
parcelHelpers.export(exports, "attempt", ()=>_attemptJsDefault.default
);
parcelHelpers.export(exports, "before", ()=>_beforeJsDefault.default
);
parcelHelpers.export(exports, "bind", ()=>_bindJsDefault.default
);
parcelHelpers.export(exports, "bindAll", ()=>_bindAllJsDefault.default
);
parcelHelpers.export(exports, "bindKey", ()=>_bindKeyJsDefault.default
);
parcelHelpers.export(exports, "camelCase", ()=>_camelCaseJsDefault.default
);
parcelHelpers.export(exports, "capitalize", ()=>_capitalizeJsDefault.default
);
parcelHelpers.export(exports, "castArray", ()=>_castArrayJsDefault.default
);
parcelHelpers.export(exports, "ceil", ()=>_ceilJsDefault.default
);
parcelHelpers.export(exports, "chain", ()=>_chainJsDefault.default
);
parcelHelpers.export(exports, "chunk", ()=>_chunkJsDefault.default
);
parcelHelpers.export(exports, "clamp", ()=>_clampJsDefault.default
);
parcelHelpers.export(exports, "clone", ()=>_cloneJsDefault.default
);
parcelHelpers.export(exports, "cloneDeep", ()=>_cloneDeepJsDefault.default
);
parcelHelpers.export(exports, "cloneDeepWith", ()=>_cloneDeepWithJsDefault.default
);
parcelHelpers.export(exports, "cloneWith", ()=>_cloneWithJsDefault.default
);
parcelHelpers.export(exports, "commit", ()=>_commitJsDefault.default
);
parcelHelpers.export(exports, "compact", ()=>_compactJsDefault.default
);
parcelHelpers.export(exports, "concat", ()=>_concatJsDefault.default
);
parcelHelpers.export(exports, "cond", ()=>_condJsDefault.default
);
parcelHelpers.export(exports, "conforms", ()=>_conformsJsDefault.default
);
parcelHelpers.export(exports, "conformsTo", ()=>_conformsToJsDefault.default
);
parcelHelpers.export(exports, "constant", ()=>_constantJsDefault.default
);
parcelHelpers.export(exports, "countBy", ()=>_countByJsDefault.default
);
parcelHelpers.export(exports, "create", ()=>_createJsDefault.default
);
parcelHelpers.export(exports, "curry", ()=>_curryJsDefault.default
);
parcelHelpers.export(exports, "curryRight", ()=>_curryRightJsDefault.default
);
parcelHelpers.export(exports, "debounce", ()=>_debounceJsDefault.default
);
parcelHelpers.export(exports, "deburr", ()=>_deburrJsDefault.default
);
parcelHelpers.export(exports, "defaultTo", ()=>_defaultToJsDefault.default
);
parcelHelpers.export(exports, "defaults", ()=>_defaultsJsDefault.default
);
parcelHelpers.export(exports, "defaultsDeep", ()=>_defaultsDeepJsDefault.default
);
parcelHelpers.export(exports, "defer", ()=>_deferJsDefault.default
);
parcelHelpers.export(exports, "delay", ()=>_delayJsDefault.default
);
parcelHelpers.export(exports, "difference", ()=>_differenceJsDefault.default
);
parcelHelpers.export(exports, "differenceBy", ()=>_differenceByJsDefault.default
);
parcelHelpers.export(exports, "differenceWith", ()=>_differenceWithJsDefault.default
);
parcelHelpers.export(exports, "divide", ()=>_divideJsDefault.default
);
parcelHelpers.export(exports, "drop", ()=>_dropJsDefault.default
);
parcelHelpers.export(exports, "dropRight", ()=>_dropRightJsDefault.default
);
parcelHelpers.export(exports, "dropRightWhile", ()=>_dropRightWhileJsDefault.default
);
parcelHelpers.export(exports, "dropWhile", ()=>_dropWhileJsDefault.default
);
parcelHelpers.export(exports, "each", ()=>_eachJsDefault.default
);
parcelHelpers.export(exports, "eachRight", ()=>_eachRightJsDefault.default
);
parcelHelpers.export(exports, "endsWith", ()=>_endsWithJsDefault.default
);
parcelHelpers.export(exports, "entries", ()=>_entriesJsDefault.default
);
parcelHelpers.export(exports, "entriesIn", ()=>_entriesInJsDefault.default
);
parcelHelpers.export(exports, "eq", ()=>_eqJsDefault.default
);
parcelHelpers.export(exports, "escape", ()=>_escapeJsDefault.default
);
parcelHelpers.export(exports, "escapeRegExp", ()=>_escapeRegExpJsDefault.default
);
parcelHelpers.export(exports, "every", ()=>_everyJsDefault.default
);
parcelHelpers.export(exports, "extend", ()=>_extendJsDefault.default
);
parcelHelpers.export(exports, "extendWith", ()=>_extendWithJsDefault.default
);
parcelHelpers.export(exports, "fill", ()=>_fillJsDefault.default
);
parcelHelpers.export(exports, "filter", ()=>_filterJsDefault.default
);
parcelHelpers.export(exports, "find", ()=>_findJsDefault.default
);
parcelHelpers.export(exports, "findIndex", ()=>_findIndexJsDefault.default
);
parcelHelpers.export(exports, "findKey", ()=>_findKeyJsDefault.default
);
parcelHelpers.export(exports, "findLast", ()=>_findLastJsDefault.default
);
parcelHelpers.export(exports, "findLastIndex", ()=>_findLastIndexJsDefault.default
);
parcelHelpers.export(exports, "findLastKey", ()=>_findLastKeyJsDefault.default
);
parcelHelpers.export(exports, "first", ()=>_firstJsDefault.default
);
parcelHelpers.export(exports, "flatMap", ()=>_flatMapJsDefault.default
);
parcelHelpers.export(exports, "flatMapDeep", ()=>_flatMapDeepJsDefault.default
);
parcelHelpers.export(exports, "flatMapDepth", ()=>_flatMapDepthJsDefault.default
);
parcelHelpers.export(exports, "flatten", ()=>_flattenJsDefault.default
);
parcelHelpers.export(exports, "flattenDeep", ()=>_flattenDeepJsDefault.default
);
parcelHelpers.export(exports, "flattenDepth", ()=>_flattenDepthJsDefault.default
);
parcelHelpers.export(exports, "flip", ()=>_flipJsDefault.default
);
parcelHelpers.export(exports, "floor", ()=>_floorJsDefault.default
);
parcelHelpers.export(exports, "flow", ()=>_flowJsDefault.default
);
parcelHelpers.export(exports, "flowRight", ()=>_flowRightJsDefault.default
);
parcelHelpers.export(exports, "forEach", ()=>_forEachJsDefault.default
);
parcelHelpers.export(exports, "forEachRight", ()=>_forEachRightJsDefault.default
);
parcelHelpers.export(exports, "forIn", ()=>_forInJsDefault.default
);
parcelHelpers.export(exports, "forInRight", ()=>_forInRightJsDefault.default
);
parcelHelpers.export(exports, "forOwn", ()=>_forOwnJsDefault.default
);
parcelHelpers.export(exports, "forOwnRight", ()=>_forOwnRightJsDefault.default
);
parcelHelpers.export(exports, "fromPairs", ()=>_fromPairsJsDefault.default
);
parcelHelpers.export(exports, "functions", ()=>_functionsJsDefault.default
);
parcelHelpers.export(exports, "functionsIn", ()=>_functionsInJsDefault.default
);
parcelHelpers.export(exports, "get", ()=>_getJsDefault.default
);
parcelHelpers.export(exports, "groupBy", ()=>_groupByJsDefault.default
);
parcelHelpers.export(exports, "gt", ()=>_gtJsDefault.default
);
parcelHelpers.export(exports, "gte", ()=>_gteJsDefault.default
);
parcelHelpers.export(exports, "has", ()=>_hasJsDefault.default
);
parcelHelpers.export(exports, "hasIn", ()=>_hasInJsDefault.default
);
parcelHelpers.export(exports, "head", ()=>_headJsDefault.default
);
parcelHelpers.export(exports, "identity", ()=>_identityJsDefault.default
);
parcelHelpers.export(exports, "inRange", ()=>_inRangeJsDefault.default
);
parcelHelpers.export(exports, "includes", ()=>_includesJsDefault.default
);
parcelHelpers.export(exports, "indexOf", ()=>_indexOfJsDefault.default
);
parcelHelpers.export(exports, "initial", ()=>_initialJsDefault.default
);
parcelHelpers.export(exports, "intersection", ()=>_intersectionJsDefault.default
);
parcelHelpers.export(exports, "intersectionBy", ()=>_intersectionByJsDefault.default
);
parcelHelpers.export(exports, "intersectionWith", ()=>_intersectionWithJsDefault.default
);
parcelHelpers.export(exports, "invert", ()=>_invertJsDefault.default
);
parcelHelpers.export(exports, "invertBy", ()=>_invertByJsDefault.default
);
parcelHelpers.export(exports, "invoke", ()=>_invokeJsDefault.default
);
parcelHelpers.export(exports, "invokeMap", ()=>_invokeMapJsDefault.default
);
parcelHelpers.export(exports, "isArguments", ()=>_isArgumentsJsDefault.default
);
parcelHelpers.export(exports, "isArray", ()=>_isArrayJsDefault.default
);
parcelHelpers.export(exports, "isArrayBuffer", ()=>_isArrayBufferJsDefault.default
);
parcelHelpers.export(exports, "isArrayLike", ()=>_isArrayLikeJsDefault.default
);
parcelHelpers.export(exports, "isArrayLikeObject", ()=>_isArrayLikeObjectJsDefault.default
);
parcelHelpers.export(exports, "isBoolean", ()=>_isBooleanJsDefault.default
);
parcelHelpers.export(exports, "isBuffer", ()=>_isBufferJsDefault.default
);
parcelHelpers.export(exports, "isDate", ()=>_isDateJsDefault.default
);
parcelHelpers.export(exports, "isElement", ()=>_isElementJsDefault.default
);
parcelHelpers.export(exports, "isEmpty", ()=>_isEmptyJsDefault.default
);
parcelHelpers.export(exports, "isEqual", ()=>_isEqualJsDefault.default
);
parcelHelpers.export(exports, "isEqualWith", ()=>_isEqualWithJsDefault.default
);
parcelHelpers.export(exports, "isError", ()=>_isErrorJsDefault.default
);
parcelHelpers.export(exports, "isFinite", ()=>_isFiniteJsDefault.default
);
parcelHelpers.export(exports, "isFunction", ()=>_isFunctionJsDefault.default
);
parcelHelpers.export(exports, "isInteger", ()=>_isIntegerJsDefault.default
);
parcelHelpers.export(exports, "isLength", ()=>_isLengthJsDefault.default
);
parcelHelpers.export(exports, "isMap", ()=>_isMapJsDefault.default
);
parcelHelpers.export(exports, "isMatch", ()=>_isMatchJsDefault.default
);
parcelHelpers.export(exports, "isMatchWith", ()=>_isMatchWithJsDefault.default
);
parcelHelpers.export(exports, "isNaN", ()=>_isNaNJsDefault.default
);
parcelHelpers.export(exports, "isNative", ()=>_isNativeJsDefault.default
);
parcelHelpers.export(exports, "isNil", ()=>_isNilJsDefault.default
);
parcelHelpers.export(exports, "isNull", ()=>_isNullJsDefault.default
);
parcelHelpers.export(exports, "isNumber", ()=>_isNumberJsDefault.default
);
parcelHelpers.export(exports, "isObject", ()=>_isObjectJsDefault.default
);
parcelHelpers.export(exports, "isObjectLike", ()=>_isObjectLikeJsDefault.default
);
parcelHelpers.export(exports, "isPlainObject", ()=>_isPlainObjectJsDefault.default
);
parcelHelpers.export(exports, "isRegExp", ()=>_isRegExpJsDefault.default
);
parcelHelpers.export(exports, "isSafeInteger", ()=>_isSafeIntegerJsDefault.default
);
parcelHelpers.export(exports, "isSet", ()=>_isSetJsDefault.default
);
parcelHelpers.export(exports, "isString", ()=>_isStringJsDefault.default
);
parcelHelpers.export(exports, "isSymbol", ()=>_isSymbolJsDefault.default
);
parcelHelpers.export(exports, "isTypedArray", ()=>_isTypedArrayJsDefault.default
);
parcelHelpers.export(exports, "isUndefined", ()=>_isUndefinedJsDefault.default
);
parcelHelpers.export(exports, "isWeakMap", ()=>_isWeakMapJsDefault.default
);
parcelHelpers.export(exports, "isWeakSet", ()=>_isWeakSetJsDefault.default
);
parcelHelpers.export(exports, "iteratee", ()=>_iterateeJsDefault.default
);
parcelHelpers.export(exports, "join", ()=>_joinJsDefault.default
);
parcelHelpers.export(exports, "kebabCase", ()=>_kebabCaseJsDefault.default
);
parcelHelpers.export(exports, "keyBy", ()=>_keyByJsDefault.default
);
parcelHelpers.export(exports, "keys", ()=>_keysJsDefault.default
);
parcelHelpers.export(exports, "keysIn", ()=>_keysInJsDefault.default
);
parcelHelpers.export(exports, "last", ()=>_lastJsDefault.default
);
parcelHelpers.export(exports, "lastIndexOf", ()=>_lastIndexOfJsDefault.default
);
parcelHelpers.export(exports, "lodash", ()=>_wrapperLodashJsDefault.default
);
parcelHelpers.export(exports, "lowerCase", ()=>_lowerCaseJsDefault.default
);
parcelHelpers.export(exports, "lowerFirst", ()=>_lowerFirstJsDefault.default
);
parcelHelpers.export(exports, "lt", ()=>_ltJsDefault.default
);
parcelHelpers.export(exports, "lte", ()=>_lteJsDefault.default
);
parcelHelpers.export(exports, "map", ()=>_mapJsDefault.default
);
parcelHelpers.export(exports, "mapKeys", ()=>_mapKeysJsDefault.default
);
parcelHelpers.export(exports, "mapValues", ()=>_mapValuesJsDefault.default
);
parcelHelpers.export(exports, "matches", ()=>_matchesJsDefault.default
);
parcelHelpers.export(exports, "matchesProperty", ()=>_matchesPropertyJsDefault.default
);
parcelHelpers.export(exports, "max", ()=>_maxJsDefault.default
);
parcelHelpers.export(exports, "maxBy", ()=>_maxByJsDefault.default
);
parcelHelpers.export(exports, "mean", ()=>_meanJsDefault.default
);
parcelHelpers.export(exports, "meanBy", ()=>_meanByJsDefault.default
);
parcelHelpers.export(exports, "memoize", ()=>_memoizeJsDefault.default
);
parcelHelpers.export(exports, "merge", ()=>_mergeJsDefault.default
);
parcelHelpers.export(exports, "mergeWith", ()=>_mergeWithJsDefault.default
);
parcelHelpers.export(exports, "method", ()=>_methodJsDefault.default
);
parcelHelpers.export(exports, "methodOf", ()=>_methodOfJsDefault.default
);
parcelHelpers.export(exports, "min", ()=>_minJsDefault.default
);
parcelHelpers.export(exports, "minBy", ()=>_minByJsDefault.default
);
parcelHelpers.export(exports, "mixin", ()=>_mixinJsDefault.default
);
parcelHelpers.export(exports, "multiply", ()=>_multiplyJsDefault.default
);
parcelHelpers.export(exports, "negate", ()=>_negateJsDefault.default
);
parcelHelpers.export(exports, "next", ()=>_nextJsDefault.default
);
parcelHelpers.export(exports, "noop", ()=>_noopJsDefault.default
);
parcelHelpers.export(exports, "now", ()=>_nowJsDefault.default
);
parcelHelpers.export(exports, "nth", ()=>_nthJsDefault.default
);
parcelHelpers.export(exports, "nthArg", ()=>_nthArgJsDefault.default
);
parcelHelpers.export(exports, "omit", ()=>_omitJsDefault.default
);
parcelHelpers.export(exports, "omitBy", ()=>_omitByJsDefault.default
);
parcelHelpers.export(exports, "once", ()=>_onceJsDefault.default
);
parcelHelpers.export(exports, "orderBy", ()=>_orderByJsDefault.default
);
parcelHelpers.export(exports, "over", ()=>_overJsDefault.default
);
parcelHelpers.export(exports, "overArgs", ()=>_overArgsJsDefault.default
);
parcelHelpers.export(exports, "overEvery", ()=>_overEveryJsDefault.default
);
parcelHelpers.export(exports, "overSome", ()=>_overSomeJsDefault.default
);
parcelHelpers.export(exports, "pad", ()=>_padJsDefault.default
);
parcelHelpers.export(exports, "padEnd", ()=>_padEndJsDefault.default
);
parcelHelpers.export(exports, "padStart", ()=>_padStartJsDefault.default
);
parcelHelpers.export(exports, "parseInt", ()=>_parseIntJsDefault.default
);
parcelHelpers.export(exports, "partial", ()=>_partialJsDefault.default
);
parcelHelpers.export(exports, "partialRight", ()=>_partialRightJsDefault.default
);
parcelHelpers.export(exports, "partition", ()=>_partitionJsDefault.default
);
parcelHelpers.export(exports, "pick", ()=>_pickJsDefault.default
);
parcelHelpers.export(exports, "pickBy", ()=>_pickByJsDefault.default
);
parcelHelpers.export(exports, "plant", ()=>_plantJsDefault.default
);
parcelHelpers.export(exports, "property", ()=>_propertyJsDefault.default
);
parcelHelpers.export(exports, "propertyOf", ()=>_propertyOfJsDefault.default
);
parcelHelpers.export(exports, "pull", ()=>_pullJsDefault.default
);
parcelHelpers.export(exports, "pullAll", ()=>_pullAllJsDefault.default
);
parcelHelpers.export(exports, "pullAllBy", ()=>_pullAllByJsDefault.default
);
parcelHelpers.export(exports, "pullAllWith", ()=>_pullAllWithJsDefault.default
);
parcelHelpers.export(exports, "pullAt", ()=>_pullAtJsDefault.default
);
parcelHelpers.export(exports, "random", ()=>_randomJsDefault.default
);
parcelHelpers.export(exports, "range", ()=>_rangeJsDefault.default
);
parcelHelpers.export(exports, "rangeRight", ()=>_rangeRightJsDefault.default
);
parcelHelpers.export(exports, "rearg", ()=>_reargJsDefault.default
);
parcelHelpers.export(exports, "reduce", ()=>_reduceJsDefault.default
);
parcelHelpers.export(exports, "reduceRight", ()=>_reduceRightJsDefault.default
);
parcelHelpers.export(exports, "reject", ()=>_rejectJsDefault.default
);
parcelHelpers.export(exports, "remove", ()=>_removeJsDefault.default
);
parcelHelpers.export(exports, "repeat", ()=>_repeatJsDefault.default
);
parcelHelpers.export(exports, "replace", ()=>_replaceJsDefault.default
);
parcelHelpers.export(exports, "rest", ()=>_restJsDefault.default
);
parcelHelpers.export(exports, "result", ()=>_resultJsDefault.default
);
parcelHelpers.export(exports, "reverse", ()=>_reverseJsDefault.default
);
parcelHelpers.export(exports, "round", ()=>_roundJsDefault.default
);
parcelHelpers.export(exports, "sample", ()=>_sampleJsDefault.default
);
parcelHelpers.export(exports, "sampleSize", ()=>_sampleSizeJsDefault.default
);
parcelHelpers.export(exports, "set", ()=>_setJsDefault.default
);
parcelHelpers.export(exports, "setWith", ()=>_setWithJsDefault.default
);
parcelHelpers.export(exports, "shuffle", ()=>_shuffleJsDefault.default
);
parcelHelpers.export(exports, "size", ()=>_sizeJsDefault.default
);
parcelHelpers.export(exports, "slice", ()=>_sliceJsDefault.default
);
parcelHelpers.export(exports, "snakeCase", ()=>_snakeCaseJsDefault.default
);
parcelHelpers.export(exports, "some", ()=>_someJsDefault.default
);
parcelHelpers.export(exports, "sortBy", ()=>_sortByJsDefault.default
);
parcelHelpers.export(exports, "sortedIndex", ()=>_sortedIndexJsDefault.default
);
parcelHelpers.export(exports, "sortedIndexBy", ()=>_sortedIndexByJsDefault.default
);
parcelHelpers.export(exports, "sortedIndexOf", ()=>_sortedIndexOfJsDefault.default
);
parcelHelpers.export(exports, "sortedLastIndex", ()=>_sortedLastIndexJsDefault.default
);
parcelHelpers.export(exports, "sortedLastIndexBy", ()=>_sortedLastIndexByJsDefault.default
);
parcelHelpers.export(exports, "sortedLastIndexOf", ()=>_sortedLastIndexOfJsDefault.default
);
parcelHelpers.export(exports, "sortedUniq", ()=>_sortedUniqJsDefault.default
);
parcelHelpers.export(exports, "sortedUniqBy", ()=>_sortedUniqByJsDefault.default
);
parcelHelpers.export(exports, "split", ()=>_splitJsDefault.default
);
parcelHelpers.export(exports, "spread", ()=>_spreadJsDefault.default
);
parcelHelpers.export(exports, "startCase", ()=>_startCaseJsDefault.default
);
parcelHelpers.export(exports, "startsWith", ()=>_startsWithJsDefault.default
);
parcelHelpers.export(exports, "stubArray", ()=>_stubArrayJsDefault.default
);
parcelHelpers.export(exports, "stubFalse", ()=>_stubFalseJsDefault.default
);
parcelHelpers.export(exports, "stubObject", ()=>_stubObjectJsDefault.default
);
parcelHelpers.export(exports, "stubString", ()=>_stubStringJsDefault.default
);
parcelHelpers.export(exports, "stubTrue", ()=>_stubTrueJsDefault.default
);
parcelHelpers.export(exports, "subtract", ()=>_subtractJsDefault.default
);
parcelHelpers.export(exports, "sum", ()=>_sumJsDefault.default
);
parcelHelpers.export(exports, "sumBy", ()=>_sumByJsDefault.default
);
parcelHelpers.export(exports, "tail", ()=>_tailJsDefault.default
);
parcelHelpers.export(exports, "take", ()=>_takeJsDefault.default
);
parcelHelpers.export(exports, "takeRight", ()=>_takeRightJsDefault.default
);
parcelHelpers.export(exports, "takeRightWhile", ()=>_takeRightWhileJsDefault.default
);
parcelHelpers.export(exports, "takeWhile", ()=>_takeWhileJsDefault.default
);
parcelHelpers.export(exports, "tap", ()=>_tapJsDefault.default
);
parcelHelpers.export(exports, "template", ()=>_templateJsDefault.default
);
parcelHelpers.export(exports, "templateSettings", ()=>_templateSettingsJsDefault.default
);
parcelHelpers.export(exports, "throttle", ()=>_throttleJsDefault.default
);
parcelHelpers.export(exports, "thru", ()=>_thruJsDefault.default
);
parcelHelpers.export(exports, "times", ()=>_timesJsDefault.default
);
parcelHelpers.export(exports, "toArray", ()=>_toArrayJsDefault.default
);
parcelHelpers.export(exports, "toFinite", ()=>_toFiniteJsDefault.default
);
parcelHelpers.export(exports, "toInteger", ()=>_toIntegerJsDefault.default
);
parcelHelpers.export(exports, "toIterator", ()=>_toIteratorJsDefault.default
);
parcelHelpers.export(exports, "toJSON", ()=>_toJSONJsDefault.default
);
parcelHelpers.export(exports, "toLength", ()=>_toLengthJsDefault.default
);
parcelHelpers.export(exports, "toLower", ()=>_toLowerJsDefault.default
);
parcelHelpers.export(exports, "toNumber", ()=>_toNumberJsDefault.default
);
parcelHelpers.export(exports, "toPairs", ()=>_toPairsJsDefault.default
);
parcelHelpers.export(exports, "toPairsIn", ()=>_toPairsInJsDefault.default
);
parcelHelpers.export(exports, "toPath", ()=>_toPathJsDefault.default
);
parcelHelpers.export(exports, "toPlainObject", ()=>_toPlainObjectJsDefault.default
);
parcelHelpers.export(exports, "toSafeInteger", ()=>_toSafeIntegerJsDefault.default
);
parcelHelpers.export(exports, "toString", ()=>_toStringJsDefault.default
);
parcelHelpers.export(exports, "toUpper", ()=>_toUpperJsDefault.default
);
parcelHelpers.export(exports, "transform", ()=>_transformJsDefault.default
);
parcelHelpers.export(exports, "trim", ()=>_trimJsDefault.default
);
parcelHelpers.export(exports, "trimEnd", ()=>_trimEndJsDefault.default
);
parcelHelpers.export(exports, "trimStart", ()=>_trimStartJsDefault.default
);
parcelHelpers.export(exports, "truncate", ()=>_truncateJsDefault.default
);
parcelHelpers.export(exports, "unary", ()=>_unaryJsDefault.default
);
parcelHelpers.export(exports, "unescape", ()=>_unescapeJsDefault.default
);
parcelHelpers.export(exports, "union", ()=>_unionJsDefault.default
);
parcelHelpers.export(exports, "unionBy", ()=>_unionByJsDefault.default
);
parcelHelpers.export(exports, "unionWith", ()=>_unionWithJsDefault.default
);
parcelHelpers.export(exports, "uniq", ()=>_uniqJsDefault.default
);
parcelHelpers.export(exports, "uniqBy", ()=>_uniqByJsDefault.default
);
parcelHelpers.export(exports, "uniqWith", ()=>_uniqWithJsDefault.default
);
parcelHelpers.export(exports, "uniqueId", ()=>_uniqueIdJsDefault.default
);
parcelHelpers.export(exports, "unset", ()=>_unsetJsDefault.default
);
parcelHelpers.export(exports, "unzip", ()=>_unzipJsDefault.default
);
parcelHelpers.export(exports, "unzipWith", ()=>_unzipWithJsDefault.default
);
parcelHelpers.export(exports, "update", ()=>_updateJsDefault.default
);
parcelHelpers.export(exports, "updateWith", ()=>_updateWithJsDefault.default
);
parcelHelpers.export(exports, "upperCase", ()=>_upperCaseJsDefault.default
);
parcelHelpers.export(exports, "upperFirst", ()=>_upperFirstJsDefault.default
);
parcelHelpers.export(exports, "value", ()=>_valueJsDefault.default
);
parcelHelpers.export(exports, "valueOf", ()=>_valueOfJsDefault.default
);
parcelHelpers.export(exports, "values", ()=>_valuesJsDefault.default
);
parcelHelpers.export(exports, "valuesIn", ()=>_valuesInJsDefault.default
);
parcelHelpers.export(exports, "without", ()=>_withoutJsDefault.default
);
parcelHelpers.export(exports, "words", ()=>_wordsJsDefault.default
);
parcelHelpers.export(exports, "wrap", ()=>_wrapJsDefault.default
);
parcelHelpers.export(exports, "wrapperAt", ()=>_wrapperAtJsDefault.default
);
parcelHelpers.export(exports, "wrapperChain", ()=>_wrapperChainJsDefault.default
);
parcelHelpers.export(exports, "wrapperCommit", ()=>_commitJsDefault.default
);
parcelHelpers.export(exports, "wrapperLodash", ()=>_wrapperLodashJsDefault.default
);
parcelHelpers.export(exports, "wrapperNext", ()=>_nextJsDefault.default
);
parcelHelpers.export(exports, "wrapperPlant", ()=>_plantJsDefault.default
);
parcelHelpers.export(exports, "wrapperReverse", ()=>_wrapperReverseJsDefault.default
);
parcelHelpers.export(exports, "wrapperToIterator", ()=>_toIteratorJsDefault.default
);
parcelHelpers.export(exports, "wrapperValue", ()=>_wrapperValueJsDefault.default
);
parcelHelpers.export(exports, "xor", ()=>_xorJsDefault.default
);
parcelHelpers.export(exports, "xorBy", ()=>_xorByJsDefault.default
);
parcelHelpers.export(exports, "xorWith", ()=>_xorWithJsDefault.default
);
parcelHelpers.export(exports, "zip", ()=>_zipJsDefault.default
);
parcelHelpers.export(exports, "zipObject", ()=>_zipObjectJsDefault.default
);
parcelHelpers.export(exports, "zipObjectDeep", ()=>_zipObjectDeepJsDefault.default
);
parcelHelpers.export(exports, "zipWith", ()=>_zipWithJsDefault.default
);
parcelHelpers.export(exports, "default", ()=>_lodashDefaultJsDefault.default
);
var _addJs = require("./add.js");
var _addJsDefault = parcelHelpers.interopDefault(_addJs);
var _afterJs = require("./after.js");
var _afterJsDefault = parcelHelpers.interopDefault(_afterJs);
var _aryJs = require("./ary.js");
var _aryJsDefault = parcelHelpers.interopDefault(_aryJs);
var _assignJs = require("./assign.js");
var _assignJsDefault = parcelHelpers.interopDefault(_assignJs);
var _assignInJs = require("./assignIn.js");
var _assignInJsDefault = parcelHelpers.interopDefault(_assignInJs);
var _assignInWithJs = require("./assignInWith.js");
var _assignInWithJsDefault = parcelHelpers.interopDefault(_assignInWithJs);
var _assignWithJs = require("./assignWith.js");
var _assignWithJsDefault = parcelHelpers.interopDefault(_assignWithJs);
var _atJs = require("./at.js");
var _atJsDefault = parcelHelpers.interopDefault(_atJs);
var _attemptJs = require("./attempt.js");
var _attemptJsDefault = parcelHelpers.interopDefault(_attemptJs);
var _beforeJs = require("./before.js");
var _beforeJsDefault = parcelHelpers.interopDefault(_beforeJs);
var _bindJs = require("./bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var _bindAllJs = require("./bindAll.js");
var _bindAllJsDefault = parcelHelpers.interopDefault(_bindAllJs);
var _bindKeyJs = require("./bindKey.js");
var _bindKeyJsDefault = parcelHelpers.interopDefault(_bindKeyJs);
var _camelCaseJs = require("./camelCase.js");
var _camelCaseJsDefault = parcelHelpers.interopDefault(_camelCaseJs);
var _capitalizeJs = require("./capitalize.js");
var _capitalizeJsDefault = parcelHelpers.interopDefault(_capitalizeJs);
var _castArrayJs = require("./castArray.js");
var _castArrayJsDefault = parcelHelpers.interopDefault(_castArrayJs);
var _ceilJs = require("./ceil.js");
var _ceilJsDefault = parcelHelpers.interopDefault(_ceilJs);
var _chainJs = require("./chain.js");
var _chainJsDefault = parcelHelpers.interopDefault(_chainJs);
var _chunkJs = require("./chunk.js");
var _chunkJsDefault = parcelHelpers.interopDefault(_chunkJs);
var _clampJs = require("./clamp.js");
var _clampJsDefault = parcelHelpers.interopDefault(_clampJs);
var _cloneJs = require("./clone.js");
var _cloneJsDefault = parcelHelpers.interopDefault(_cloneJs);
var _cloneDeepJs = require("./cloneDeep.js");
var _cloneDeepJsDefault = parcelHelpers.interopDefault(_cloneDeepJs);
var _cloneDeepWithJs = require("./cloneDeepWith.js");
var _cloneDeepWithJsDefault = parcelHelpers.interopDefault(_cloneDeepWithJs);
var _cloneWithJs = require("./cloneWith.js");
var _cloneWithJsDefault = parcelHelpers.interopDefault(_cloneWithJs);
var _commitJs = require("./commit.js");
var _commitJsDefault = parcelHelpers.interopDefault(_commitJs);
var _compactJs = require("./compact.js");
var _compactJsDefault = parcelHelpers.interopDefault(_compactJs);
var _concatJs = require("./concat.js");
var _concatJsDefault = parcelHelpers.interopDefault(_concatJs);
var _condJs = require("./cond.js");
var _condJsDefault = parcelHelpers.interopDefault(_condJs);
var _conformsJs = require("./conforms.js");
var _conformsJsDefault = parcelHelpers.interopDefault(_conformsJs);
var _conformsToJs = require("./conformsTo.js");
var _conformsToJsDefault = parcelHelpers.interopDefault(_conformsToJs);
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _countByJs = require("./countBy.js");
var _countByJsDefault = parcelHelpers.interopDefault(_countByJs);
var _createJs = require("./create.js");
var _createJsDefault = parcelHelpers.interopDefault(_createJs);
var _curryJs = require("./curry.js");
var _curryJsDefault = parcelHelpers.interopDefault(_curryJs);
var _curryRightJs = require("./curryRight.js");
var _curryRightJsDefault = parcelHelpers.interopDefault(_curryRightJs);
var _debounceJs = require("./debounce.js");
var _debounceJsDefault = parcelHelpers.interopDefault(_debounceJs);
var _deburrJs = require("./deburr.js");
var _deburrJsDefault = parcelHelpers.interopDefault(_deburrJs);
var _defaultToJs = require("./defaultTo.js");
var _defaultToJsDefault = parcelHelpers.interopDefault(_defaultToJs);
var _defaultsJs = require("./defaults.js");
var _defaultsJsDefault = parcelHelpers.interopDefault(_defaultsJs);
var _defaultsDeepJs = require("./defaultsDeep.js");
var _defaultsDeepJsDefault = parcelHelpers.interopDefault(_defaultsDeepJs);
var _deferJs = require("./defer.js");
var _deferJsDefault = parcelHelpers.interopDefault(_deferJs);
var _delayJs = require("./delay.js");
var _delayJsDefault = parcelHelpers.interopDefault(_delayJs);
var _differenceJs = require("./difference.js");
var _differenceJsDefault = parcelHelpers.interopDefault(_differenceJs);
var _differenceByJs = require("./differenceBy.js");
var _differenceByJsDefault = parcelHelpers.interopDefault(_differenceByJs);
var _differenceWithJs = require("./differenceWith.js");
var _differenceWithJsDefault = parcelHelpers.interopDefault(_differenceWithJs);
var _divideJs = require("./divide.js");
var _divideJsDefault = parcelHelpers.interopDefault(_divideJs);
var _dropJs = require("./drop.js");
var _dropJsDefault = parcelHelpers.interopDefault(_dropJs);
var _dropRightJs = require("./dropRight.js");
var _dropRightJsDefault = parcelHelpers.interopDefault(_dropRightJs);
var _dropRightWhileJs = require("./dropRightWhile.js");
var _dropRightWhileJsDefault = parcelHelpers.interopDefault(_dropRightWhileJs);
var _dropWhileJs = require("./dropWhile.js");
var _dropWhileJsDefault = parcelHelpers.interopDefault(_dropWhileJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
var _eachRightJs = require("./eachRight.js");
var _eachRightJsDefault = parcelHelpers.interopDefault(_eachRightJs);
var _endsWithJs = require("./endsWith.js");
var _endsWithJsDefault = parcelHelpers.interopDefault(_endsWithJs);
var _entriesJs = require("./entries.js");
var _entriesJsDefault = parcelHelpers.interopDefault(_entriesJs);
var _entriesInJs = require("./entriesIn.js");
var _entriesInJsDefault = parcelHelpers.interopDefault(_entriesInJs);
var _eqJs = require("./eq.js");
var _eqJsDefault = parcelHelpers.interopDefault(_eqJs);
var _escapeJs = require("./escape.js");
var _escapeJsDefault = parcelHelpers.interopDefault(_escapeJs);
var _escapeRegExpJs = require("./escapeRegExp.js");
var _escapeRegExpJsDefault = parcelHelpers.interopDefault(_escapeRegExpJs);
var _everyJs = require("./every.js");
var _everyJsDefault = parcelHelpers.interopDefault(_everyJs);
var _extendJs = require("./extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _extendWithJs = require("./extendWith.js");
var _extendWithJsDefault = parcelHelpers.interopDefault(_extendWithJs);
var _fillJs = require("./fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
var _findJs = require("./find.js");
var _findJsDefault = parcelHelpers.interopDefault(_findJs);
var _findIndexJs = require("./findIndex.js");
var _findIndexJsDefault = parcelHelpers.interopDefault(_findIndexJs);
var _findKeyJs = require("./findKey.js");
var _findKeyJsDefault = parcelHelpers.interopDefault(_findKeyJs);
var _findLastJs = require("./findLast.js");
var _findLastJsDefault = parcelHelpers.interopDefault(_findLastJs);
var _findLastIndexJs = require("./findLastIndex.js");
var _findLastIndexJsDefault = parcelHelpers.interopDefault(_findLastIndexJs);
var _findLastKeyJs = require("./findLastKey.js");
var _findLastKeyJsDefault = parcelHelpers.interopDefault(_findLastKeyJs);
var _firstJs = require("./first.js");
var _firstJsDefault = parcelHelpers.interopDefault(_firstJs);
var _flatMapJs = require("./flatMap.js");
var _flatMapJsDefault = parcelHelpers.interopDefault(_flatMapJs);
var _flatMapDeepJs = require("./flatMapDeep.js");
var _flatMapDeepJsDefault = parcelHelpers.interopDefault(_flatMapDeepJs);
var _flatMapDepthJs = require("./flatMapDepth.js");
var _flatMapDepthJsDefault = parcelHelpers.interopDefault(_flatMapDepthJs);
var _flattenJs = require("./flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
var _flattenDeepJs = require("./flattenDeep.js");
var _flattenDeepJsDefault = parcelHelpers.interopDefault(_flattenDeepJs);
var _flattenDepthJs = require("./flattenDepth.js");
var _flattenDepthJsDefault = parcelHelpers.interopDefault(_flattenDepthJs);
var _flipJs = require("./flip.js");
var _flipJsDefault = parcelHelpers.interopDefault(_flipJs);
var _floorJs = require("./floor.js");
var _floorJsDefault = parcelHelpers.interopDefault(_floorJs);
var _flowJs = require("./flow.js");
var _flowJsDefault = parcelHelpers.interopDefault(_flowJs);
var _flowRightJs = require("./flowRight.js");
var _flowRightJsDefault = parcelHelpers.interopDefault(_flowRightJs);
var _forEachJs = require("./forEach.js");
var _forEachJsDefault = parcelHelpers.interopDefault(_forEachJs);
var _forEachRightJs = require("./forEachRight.js");
var _forEachRightJsDefault = parcelHelpers.interopDefault(_forEachRightJs);
var _forInJs = require("./forIn.js");
var _forInJsDefault = parcelHelpers.interopDefault(_forInJs);
var _forInRightJs = require("./forInRight.js");
var _forInRightJsDefault = parcelHelpers.interopDefault(_forInRightJs);
var _forOwnJs = require("./forOwn.js");
var _forOwnJsDefault = parcelHelpers.interopDefault(_forOwnJs);
var _forOwnRightJs = require("./forOwnRight.js");
var _forOwnRightJsDefault = parcelHelpers.interopDefault(_forOwnRightJs);
var _fromPairsJs = require("./fromPairs.js");
var _fromPairsJsDefault = parcelHelpers.interopDefault(_fromPairsJs);
var _functionsJs = require("./functions.js");
var _functionsJsDefault = parcelHelpers.interopDefault(_functionsJs);
var _functionsInJs = require("./functionsIn.js");
var _functionsInJsDefault = parcelHelpers.interopDefault(_functionsInJs);
var _getJs = require("./get.js");
var _getJsDefault = parcelHelpers.interopDefault(_getJs);
var _groupByJs = require("./groupBy.js");
var _groupByJsDefault = parcelHelpers.interopDefault(_groupByJs);
var _gtJs = require("./gt.js");
var _gtJsDefault = parcelHelpers.interopDefault(_gtJs);
var _gteJs = require("./gte.js");
var _gteJsDefault = parcelHelpers.interopDefault(_gteJs);
var _hasJs = require("./has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
var _hasInJs = require("./hasIn.js");
var _hasInJsDefault = parcelHelpers.interopDefault(_hasInJs);
var _headJs = require("./head.js");
var _headJsDefault = parcelHelpers.interopDefault(_headJs);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _inRangeJs = require("./inRange.js");
var _inRangeJsDefault = parcelHelpers.interopDefault(_inRangeJs);
var _includesJs = require("./includes.js");
var _includesJsDefault = parcelHelpers.interopDefault(_includesJs);
var _indexOfJs = require("./indexOf.js");
var _indexOfJsDefault = parcelHelpers.interopDefault(_indexOfJs);
var _initialJs = require("./initial.js");
var _initialJsDefault = parcelHelpers.interopDefault(_initialJs);
var _intersectionJs = require("./intersection.js");
var _intersectionJsDefault = parcelHelpers.interopDefault(_intersectionJs);
var _intersectionByJs = require("./intersectionBy.js");
var _intersectionByJsDefault = parcelHelpers.interopDefault(_intersectionByJs);
var _intersectionWithJs = require("./intersectionWith.js");
var _intersectionWithJsDefault = parcelHelpers.interopDefault(_intersectionWithJs);
var _invertJs = require("./invert.js");
var _invertJsDefault = parcelHelpers.interopDefault(_invertJs);
var _invertByJs = require("./invertBy.js");
var _invertByJsDefault = parcelHelpers.interopDefault(_invertByJs);
var _invokeJs = require("./invoke.js");
var _invokeJsDefault = parcelHelpers.interopDefault(_invokeJs);
var _invokeMapJs = require("./invokeMap.js");
var _invokeMapJsDefault = parcelHelpers.interopDefault(_invokeMapJs);
var _isArgumentsJs = require("./isArguments.js");
var _isArgumentsJsDefault = parcelHelpers.interopDefault(_isArgumentsJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isArrayBufferJs = require("./isArrayBuffer.js");
var _isArrayBufferJsDefault = parcelHelpers.interopDefault(_isArrayBufferJs);
var _isArrayLikeJs = require("./isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _isArrayLikeObjectJs = require("./isArrayLikeObject.js");
var _isArrayLikeObjectJsDefault = parcelHelpers.interopDefault(_isArrayLikeObjectJs);
var _isBooleanJs = require("./isBoolean.js");
var _isBooleanJsDefault = parcelHelpers.interopDefault(_isBooleanJs);
var _isBufferJs = require("./isBuffer.js");
var _isBufferJsDefault = parcelHelpers.interopDefault(_isBufferJs);
var _isDateJs = require("./isDate.js");
var _isDateJsDefault = parcelHelpers.interopDefault(_isDateJs);
var _isElementJs = require("./isElement.js");
var _isElementJsDefault = parcelHelpers.interopDefault(_isElementJs);
var _isEmptyJs = require("./isEmpty.js");
var _isEmptyJsDefault = parcelHelpers.interopDefault(_isEmptyJs);
var _isEqualJs = require("./isEqual.js");
var _isEqualJsDefault = parcelHelpers.interopDefault(_isEqualJs);
var _isEqualWithJs = require("./isEqualWith.js");
var _isEqualWithJsDefault = parcelHelpers.interopDefault(_isEqualWithJs);
var _isErrorJs = require("./isError.js");
var _isErrorJsDefault = parcelHelpers.interopDefault(_isErrorJs);
var _isFiniteJs = require("./isFinite.js");
var _isFiniteJsDefault = parcelHelpers.interopDefault(_isFiniteJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _isIntegerJs = require("./isInteger.js");
var _isIntegerJsDefault = parcelHelpers.interopDefault(_isIntegerJs);
var _isLengthJs = require("./isLength.js");
var _isLengthJsDefault = parcelHelpers.interopDefault(_isLengthJs);
var _isMapJs = require("./isMap.js");
var _isMapJsDefault = parcelHelpers.interopDefault(_isMapJs);
var _isMatchJs = require("./isMatch.js");
var _isMatchJsDefault = parcelHelpers.interopDefault(_isMatchJs);
var _isMatchWithJs = require("./isMatchWith.js");
var _isMatchWithJsDefault = parcelHelpers.interopDefault(_isMatchWithJs);
var _isNaNJs = require("./isNaN.js");
var _isNaNJsDefault = parcelHelpers.interopDefault(_isNaNJs);
var _isNativeJs = require("./isNative.js");
var _isNativeJsDefault = parcelHelpers.interopDefault(_isNativeJs);
var _isNilJs = require("./isNil.js");
var _isNilJsDefault = parcelHelpers.interopDefault(_isNilJs);
var _isNullJs = require("./isNull.js");
var _isNullJsDefault = parcelHelpers.interopDefault(_isNullJs);
var _isNumberJs = require("./isNumber.js");
var _isNumberJsDefault = parcelHelpers.interopDefault(_isNumberJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _isObjectLikeJs = require("./isObjectLike.js");
var _isObjectLikeJsDefault = parcelHelpers.interopDefault(_isObjectLikeJs);
var _isPlainObjectJs = require("./isPlainObject.js");
var _isPlainObjectJsDefault = parcelHelpers.interopDefault(_isPlainObjectJs);
var _isRegExpJs = require("./isRegExp.js");
var _isRegExpJsDefault = parcelHelpers.interopDefault(_isRegExpJs);
var _isSafeIntegerJs = require("./isSafeInteger.js");
var _isSafeIntegerJsDefault = parcelHelpers.interopDefault(_isSafeIntegerJs);
var _isSetJs = require("./isSet.js");
var _isSetJsDefault = parcelHelpers.interopDefault(_isSetJs);
var _isStringJs = require("./isString.js");
var _isStringJsDefault = parcelHelpers.interopDefault(_isStringJs);
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
var _isTypedArrayJs = require("./isTypedArray.js");
var _isTypedArrayJsDefault = parcelHelpers.interopDefault(_isTypedArrayJs);
var _isUndefinedJs = require("./isUndefined.js");
var _isUndefinedJsDefault = parcelHelpers.interopDefault(_isUndefinedJs);
var _isWeakMapJs = require("./isWeakMap.js");
var _isWeakMapJsDefault = parcelHelpers.interopDefault(_isWeakMapJs);
var _isWeakSetJs = require("./isWeakSet.js");
var _isWeakSetJsDefault = parcelHelpers.interopDefault(_isWeakSetJs);
var _iterateeJs = require("./iteratee.js");
var _iterateeJsDefault = parcelHelpers.interopDefault(_iterateeJs);
var _joinJs = require("./join.js");
var _joinJsDefault = parcelHelpers.interopDefault(_joinJs);
var _kebabCaseJs = require("./kebabCase.js");
var _kebabCaseJsDefault = parcelHelpers.interopDefault(_kebabCaseJs);
var _keyByJs = require("./keyBy.js");
var _keyByJsDefault = parcelHelpers.interopDefault(_keyByJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
var _keysInJs = require("./keysIn.js");
var _keysInJsDefault = parcelHelpers.interopDefault(_keysInJs);
var _lastJs = require("./last.js");
var _lastJsDefault = parcelHelpers.interopDefault(_lastJs);
var _lastIndexOfJs = require("./lastIndexOf.js");
var _lastIndexOfJsDefault = parcelHelpers.interopDefault(_lastIndexOfJs);
var _wrapperLodashJs = require("./wrapperLodash.js");
var _wrapperLodashJsDefault = parcelHelpers.interopDefault(_wrapperLodashJs);
var _lowerCaseJs = require("./lowerCase.js");
var _lowerCaseJsDefault = parcelHelpers.interopDefault(_lowerCaseJs);
var _lowerFirstJs = require("./lowerFirst.js");
var _lowerFirstJsDefault = parcelHelpers.interopDefault(_lowerFirstJs);
var _ltJs = require("./lt.js");
var _ltJsDefault = parcelHelpers.interopDefault(_ltJs);
var _lteJs = require("./lte.js");
var _lteJsDefault = parcelHelpers.interopDefault(_lteJs);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _mapKeysJs = require("./mapKeys.js");
var _mapKeysJsDefault = parcelHelpers.interopDefault(_mapKeysJs);
var _mapValuesJs = require("./mapValues.js");
var _mapValuesJsDefault = parcelHelpers.interopDefault(_mapValuesJs);
var _matchesJs = require("./matches.js");
var _matchesJsDefault = parcelHelpers.interopDefault(_matchesJs);
var _matchesPropertyJs = require("./matchesProperty.js");
var _matchesPropertyJsDefault = parcelHelpers.interopDefault(_matchesPropertyJs);
var _maxJs = require("./max.js");
var _maxJsDefault = parcelHelpers.interopDefault(_maxJs);
var _maxByJs = require("./maxBy.js");
var _maxByJsDefault = parcelHelpers.interopDefault(_maxByJs);
var _meanJs = require("./mean.js");
var _meanJsDefault = parcelHelpers.interopDefault(_meanJs);
var _meanByJs = require("./meanBy.js");
var _meanByJsDefault = parcelHelpers.interopDefault(_meanByJs);
var _memoizeJs = require("./memoize.js");
var _memoizeJsDefault = parcelHelpers.interopDefault(_memoizeJs);
var _mergeJs = require("./merge.js");
var _mergeJsDefault = parcelHelpers.interopDefault(_mergeJs);
var _mergeWithJs = require("./mergeWith.js");
var _mergeWithJsDefault = parcelHelpers.interopDefault(_mergeWithJs);
var _methodJs = require("./method.js");
var _methodJsDefault = parcelHelpers.interopDefault(_methodJs);
var _methodOfJs = require("./methodOf.js");
var _methodOfJsDefault = parcelHelpers.interopDefault(_methodOfJs);
var _minJs = require("./min.js");
var _minJsDefault = parcelHelpers.interopDefault(_minJs);
var _minByJs = require("./minBy.js");
var _minByJsDefault = parcelHelpers.interopDefault(_minByJs);
var _mixinJs = require("./mixin.js");
var _mixinJsDefault = parcelHelpers.interopDefault(_mixinJs);
var _multiplyJs = require("./multiply.js");
var _multiplyJsDefault = parcelHelpers.interopDefault(_multiplyJs);
var _negateJs = require("./negate.js");
var _negateJsDefault = parcelHelpers.interopDefault(_negateJs);
var _nextJs = require("./next.js");
var _nextJsDefault = parcelHelpers.interopDefault(_nextJs);
var _noopJs = require("./noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var _nowJs = require("./now.js");
var _nowJsDefault = parcelHelpers.interopDefault(_nowJs);
var _nthJs = require("./nth.js");
var _nthJsDefault = parcelHelpers.interopDefault(_nthJs);
var _nthArgJs = require("./nthArg.js");
var _nthArgJsDefault = parcelHelpers.interopDefault(_nthArgJs);
var _omitJs = require("./omit.js");
var _omitJsDefault = parcelHelpers.interopDefault(_omitJs);
var _omitByJs = require("./omitBy.js");
var _omitByJsDefault = parcelHelpers.interopDefault(_omitByJs);
var _onceJs = require("./once.js");
var _onceJsDefault = parcelHelpers.interopDefault(_onceJs);
var _orderByJs = require("./orderBy.js");
var _orderByJsDefault = parcelHelpers.interopDefault(_orderByJs);
var _overJs = require("./over.js");
var _overJsDefault = parcelHelpers.interopDefault(_overJs);
var _overArgsJs = require("./overArgs.js");
var _overArgsJsDefault = parcelHelpers.interopDefault(_overArgsJs);
var _overEveryJs = require("./overEvery.js");
var _overEveryJsDefault = parcelHelpers.interopDefault(_overEveryJs);
var _overSomeJs = require("./overSome.js");
var _overSomeJsDefault = parcelHelpers.interopDefault(_overSomeJs);
var _padJs = require("./pad.js");
var _padJsDefault = parcelHelpers.interopDefault(_padJs);
var _padEndJs = require("./padEnd.js");
var _padEndJsDefault = parcelHelpers.interopDefault(_padEndJs);
var _padStartJs = require("./padStart.js");
var _padStartJsDefault = parcelHelpers.interopDefault(_padStartJs);
var _parseIntJs = require("./parseInt.js");
var _parseIntJsDefault = parcelHelpers.interopDefault(_parseIntJs);
var _partialJs = require("./partial.js");
var _partialJsDefault = parcelHelpers.interopDefault(_partialJs);
var _partialRightJs = require("./partialRight.js");
var _partialRightJsDefault = parcelHelpers.interopDefault(_partialRightJs);
var _partitionJs = require("./partition.js");
var _partitionJsDefault = parcelHelpers.interopDefault(_partitionJs);
var _pickJs = require("./pick.js");
var _pickJsDefault = parcelHelpers.interopDefault(_pickJs);
var _pickByJs = require("./pickBy.js");
var _pickByJsDefault = parcelHelpers.interopDefault(_pickByJs);
var _plantJs = require("./plant.js");
var _plantJsDefault = parcelHelpers.interopDefault(_plantJs);
var _propertyJs = require("./property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _propertyOfJs = require("./propertyOf.js");
var _propertyOfJsDefault = parcelHelpers.interopDefault(_propertyOfJs);
var _pullJs = require("./pull.js");
var _pullJsDefault = parcelHelpers.interopDefault(_pullJs);
var _pullAllJs = require("./pullAll.js");
var _pullAllJsDefault = parcelHelpers.interopDefault(_pullAllJs);
var _pullAllByJs = require("./pullAllBy.js");
var _pullAllByJsDefault = parcelHelpers.interopDefault(_pullAllByJs);
var _pullAllWithJs = require("./pullAllWith.js");
var _pullAllWithJsDefault = parcelHelpers.interopDefault(_pullAllWithJs);
var _pullAtJs = require("./pullAt.js");
var _pullAtJsDefault = parcelHelpers.interopDefault(_pullAtJs);
var _randomJs = require("./random.js");
var _randomJsDefault = parcelHelpers.interopDefault(_randomJs);
var _rangeJs = require("./range.js");
var _rangeJsDefault = parcelHelpers.interopDefault(_rangeJs);
var _rangeRightJs = require("./rangeRight.js");
var _rangeRightJsDefault = parcelHelpers.interopDefault(_rangeRightJs);
var _reargJs = require("./rearg.js");
var _reargJsDefault = parcelHelpers.interopDefault(_reargJs);
var _reduceJs = require("./reduce.js");
var _reduceJsDefault = parcelHelpers.interopDefault(_reduceJs);
var _reduceRightJs = require("./reduceRight.js");
var _reduceRightJsDefault = parcelHelpers.interopDefault(_reduceRightJs);
var _rejectJs = require("./reject.js");
var _rejectJsDefault = parcelHelpers.interopDefault(_rejectJs);
var _removeJs = require("./remove.js");
var _removeJsDefault = parcelHelpers.interopDefault(_removeJs);
var _repeatJs = require("./repeat.js");
var _repeatJsDefault = parcelHelpers.interopDefault(_repeatJs);
var _replaceJs = require("./replace.js");
var _replaceJsDefault = parcelHelpers.interopDefault(_replaceJs);
var _restJs = require("./rest.js");
var _restJsDefault = parcelHelpers.interopDefault(_restJs);
var _resultJs = require("./result.js");
var _resultJsDefault = parcelHelpers.interopDefault(_resultJs);
var _reverseJs = require("./reverse.js");
var _reverseJsDefault = parcelHelpers.interopDefault(_reverseJs);
var _roundJs = require("./round.js");
var _roundJsDefault = parcelHelpers.interopDefault(_roundJs);
var _sampleJs = require("./sample.js");
var _sampleJsDefault = parcelHelpers.interopDefault(_sampleJs);
var _sampleSizeJs = require("./sampleSize.js");
var _sampleSizeJsDefault = parcelHelpers.interopDefault(_sampleSizeJs);
var _setJs = require("./set.js");
var _setJsDefault = parcelHelpers.interopDefault(_setJs);
var _setWithJs = require("./setWith.js");
var _setWithJsDefault = parcelHelpers.interopDefault(_setWithJs);
var _shuffleJs = require("./shuffle.js");
var _shuffleJsDefault = parcelHelpers.interopDefault(_shuffleJs);
var _sizeJs = require("./size.js");
var _sizeJsDefault = parcelHelpers.interopDefault(_sizeJs);
var _sliceJs = require("./slice.js");
var _sliceJsDefault = parcelHelpers.interopDefault(_sliceJs);
var _snakeCaseJs = require("./snakeCase.js");
var _snakeCaseJsDefault = parcelHelpers.interopDefault(_snakeCaseJs);
var _someJs = require("./some.js");
var _someJsDefault = parcelHelpers.interopDefault(_someJs);
var _sortByJs = require("./sortBy.js");
var _sortByJsDefault = parcelHelpers.interopDefault(_sortByJs);
var _sortedIndexJs = require("./sortedIndex.js");
var _sortedIndexJsDefault = parcelHelpers.interopDefault(_sortedIndexJs);
var _sortedIndexByJs = require("./sortedIndexBy.js");
var _sortedIndexByJsDefault = parcelHelpers.interopDefault(_sortedIndexByJs);
var _sortedIndexOfJs = require("./sortedIndexOf.js");
var _sortedIndexOfJsDefault = parcelHelpers.interopDefault(_sortedIndexOfJs);
var _sortedLastIndexJs = require("./sortedLastIndex.js");
var _sortedLastIndexJsDefault = parcelHelpers.interopDefault(_sortedLastIndexJs);
var _sortedLastIndexByJs = require("./sortedLastIndexBy.js");
var _sortedLastIndexByJsDefault = parcelHelpers.interopDefault(_sortedLastIndexByJs);
var _sortedLastIndexOfJs = require("./sortedLastIndexOf.js");
var _sortedLastIndexOfJsDefault = parcelHelpers.interopDefault(_sortedLastIndexOfJs);
var _sortedUniqJs = require("./sortedUniq.js");
var _sortedUniqJsDefault = parcelHelpers.interopDefault(_sortedUniqJs);
var _sortedUniqByJs = require("./sortedUniqBy.js");
var _sortedUniqByJsDefault = parcelHelpers.interopDefault(_sortedUniqByJs);
var _splitJs = require("./split.js");
var _splitJsDefault = parcelHelpers.interopDefault(_splitJs);
var _spreadJs = require("./spread.js");
var _spreadJsDefault = parcelHelpers.interopDefault(_spreadJs);
var _startCaseJs = require("./startCase.js");
var _startCaseJsDefault = parcelHelpers.interopDefault(_startCaseJs);
var _startsWithJs = require("./startsWith.js");
var _startsWithJsDefault = parcelHelpers.interopDefault(_startsWithJs);
var _stubArrayJs = require("./stubArray.js");
var _stubArrayJsDefault = parcelHelpers.interopDefault(_stubArrayJs);
var _stubFalseJs = require("./stubFalse.js");
var _stubFalseJsDefault = parcelHelpers.interopDefault(_stubFalseJs);
var _stubObjectJs = require("./stubObject.js");
var _stubObjectJsDefault = parcelHelpers.interopDefault(_stubObjectJs);
var _stubStringJs = require("./stubString.js");
var _stubStringJsDefault = parcelHelpers.interopDefault(_stubStringJs);
var _stubTrueJs = require("./stubTrue.js");
var _stubTrueJsDefault = parcelHelpers.interopDefault(_stubTrueJs);
var _subtractJs = require("./subtract.js");
var _subtractJsDefault = parcelHelpers.interopDefault(_subtractJs);
var _sumJs = require("./sum.js");
var _sumJsDefault = parcelHelpers.interopDefault(_sumJs);
var _sumByJs = require("./sumBy.js");
var _sumByJsDefault = parcelHelpers.interopDefault(_sumByJs);
var _tailJs = require("./tail.js");
var _tailJsDefault = parcelHelpers.interopDefault(_tailJs);
var _takeJs = require("./take.js");
var _takeJsDefault = parcelHelpers.interopDefault(_takeJs);
var _takeRightJs = require("./takeRight.js");
var _takeRightJsDefault = parcelHelpers.interopDefault(_takeRightJs);
var _takeRightWhileJs = require("./takeRightWhile.js");
var _takeRightWhileJsDefault = parcelHelpers.interopDefault(_takeRightWhileJs);
var _takeWhileJs = require("./takeWhile.js");
var _takeWhileJsDefault = parcelHelpers.interopDefault(_takeWhileJs);
var _tapJs = require("./tap.js");
var _tapJsDefault = parcelHelpers.interopDefault(_tapJs);
var _templateJs = require("./template.js");
var _templateJsDefault = parcelHelpers.interopDefault(_templateJs);
var _templateSettingsJs = require("./templateSettings.js");
var _templateSettingsJsDefault = parcelHelpers.interopDefault(_templateSettingsJs);
var _throttleJs = require("./throttle.js");
var _throttleJsDefault = parcelHelpers.interopDefault(_throttleJs);
var _thruJs = require("./thru.js");
var _thruJsDefault = parcelHelpers.interopDefault(_thruJs);
var _timesJs = require("./times.js");
var _timesJsDefault = parcelHelpers.interopDefault(_timesJs);
var _toArrayJs = require("./toArray.js");
var _toArrayJsDefault = parcelHelpers.interopDefault(_toArrayJs);
var _toFiniteJs = require("./toFinite.js");
var _toFiniteJsDefault = parcelHelpers.interopDefault(_toFiniteJs);
var _toIntegerJs = require("./toInteger.js");
var _toIntegerJsDefault = parcelHelpers.interopDefault(_toIntegerJs);
var _toIteratorJs = require("./toIterator.js");
var _toIteratorJsDefault = parcelHelpers.interopDefault(_toIteratorJs);
var _toJSONJs = require("./toJSON.js");
var _toJSONJsDefault = parcelHelpers.interopDefault(_toJSONJs);
var _toLengthJs = require("./toLength.js");
var _toLengthJsDefault = parcelHelpers.interopDefault(_toLengthJs);
var _toLowerJs = require("./toLower.js");
var _toLowerJsDefault = parcelHelpers.interopDefault(_toLowerJs);
var _toNumberJs = require("./toNumber.js");
var _toNumberJsDefault = parcelHelpers.interopDefault(_toNumberJs);
var _toPairsJs = require("./toPairs.js");
var _toPairsJsDefault = parcelHelpers.interopDefault(_toPairsJs);
var _toPairsInJs = require("./toPairsIn.js");
var _toPairsInJsDefault = parcelHelpers.interopDefault(_toPairsInJs);
var _toPathJs = require("./toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
var _toPlainObjectJs = require("./toPlainObject.js");
var _toPlainObjectJsDefault = parcelHelpers.interopDefault(_toPlainObjectJs);
var _toSafeIntegerJs = require("./toSafeInteger.js");
var _toSafeIntegerJsDefault = parcelHelpers.interopDefault(_toSafeIntegerJs);
var _toStringJs = require("./toString.js");
var _toStringJsDefault = parcelHelpers.interopDefault(_toStringJs);
var _toUpperJs = require("./toUpper.js");
var _toUpperJsDefault = parcelHelpers.interopDefault(_toUpperJs);
var _transformJs = require("./transform.js");
var _transformJsDefault = parcelHelpers.interopDefault(_transformJs);
var _trimJs = require("./trim.js");
var _trimJsDefault = parcelHelpers.interopDefault(_trimJs);
var _trimEndJs = require("./trimEnd.js");
var _trimEndJsDefault = parcelHelpers.interopDefault(_trimEndJs);
var _trimStartJs = require("./trimStart.js");
var _trimStartJsDefault = parcelHelpers.interopDefault(_trimStartJs);
var _truncateJs = require("./truncate.js");
var _truncateJsDefault = parcelHelpers.interopDefault(_truncateJs);
var _unaryJs = require("./unary.js");
var _unaryJsDefault = parcelHelpers.interopDefault(_unaryJs);
var _unescapeJs = require("./unescape.js");
var _unescapeJsDefault = parcelHelpers.interopDefault(_unescapeJs);
var _unionJs = require("./union.js");
var _unionJsDefault = parcelHelpers.interopDefault(_unionJs);
var _unionByJs = require("./unionBy.js");
var _unionByJsDefault = parcelHelpers.interopDefault(_unionByJs);
var _unionWithJs = require("./unionWith.js");
var _unionWithJsDefault = parcelHelpers.interopDefault(_unionWithJs);
var _uniqJs = require("./uniq.js");
var _uniqJsDefault = parcelHelpers.interopDefault(_uniqJs);
var _uniqByJs = require("./uniqBy.js");
var _uniqByJsDefault = parcelHelpers.interopDefault(_uniqByJs);
var _uniqWithJs = require("./uniqWith.js");
var _uniqWithJsDefault = parcelHelpers.interopDefault(_uniqWithJs);
var _uniqueIdJs = require("./uniqueId.js");
var _uniqueIdJsDefault = parcelHelpers.interopDefault(_uniqueIdJs);
var _unsetJs = require("./unset.js");
var _unsetJsDefault = parcelHelpers.interopDefault(_unsetJs);
var _unzipJs = require("./unzip.js");
var _unzipJsDefault = parcelHelpers.interopDefault(_unzipJs);
var _unzipWithJs = require("./unzipWith.js");
var _unzipWithJsDefault = parcelHelpers.interopDefault(_unzipWithJs);
var _updateJs = require("./update.js");
var _updateJsDefault = parcelHelpers.interopDefault(_updateJs);
var _updateWithJs = require("./updateWith.js");
var _updateWithJsDefault = parcelHelpers.interopDefault(_updateWithJs);
var _upperCaseJs = require("./upperCase.js");
var _upperCaseJsDefault = parcelHelpers.interopDefault(_upperCaseJs);
var _upperFirstJs = require("./upperFirst.js");
var _upperFirstJsDefault = parcelHelpers.interopDefault(_upperFirstJs);
var _valueJs = require("./value.js");
var _valueJsDefault = parcelHelpers.interopDefault(_valueJs);
var _valueOfJs = require("./valueOf.js");
var _valueOfJsDefault = parcelHelpers.interopDefault(_valueOfJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _valuesInJs = require("./valuesIn.js");
var _valuesInJsDefault = parcelHelpers.interopDefault(_valuesInJs);
var _withoutJs = require("./without.js");
var _withoutJsDefault = parcelHelpers.interopDefault(_withoutJs);
var _wordsJs = require("./words.js");
var _wordsJsDefault = parcelHelpers.interopDefault(_wordsJs);
var _wrapJs = require("./wrap.js");
var _wrapJsDefault = parcelHelpers.interopDefault(_wrapJs);
var _wrapperAtJs = require("./wrapperAt.js");
var _wrapperAtJsDefault = parcelHelpers.interopDefault(_wrapperAtJs);
var _wrapperChainJs = require("./wrapperChain.js");
var _wrapperChainJsDefault = parcelHelpers.interopDefault(_wrapperChainJs);
var _wrapperReverseJs = require("./wrapperReverse.js");
var _wrapperReverseJsDefault = parcelHelpers.interopDefault(_wrapperReverseJs);
var _wrapperValueJs = require("./wrapperValue.js");
var _wrapperValueJsDefault = parcelHelpers.interopDefault(_wrapperValueJs);
var _xorJs = require("./xor.js");
var _xorJsDefault = parcelHelpers.interopDefault(_xorJs);
var _xorByJs = require("./xorBy.js");
var _xorByJsDefault = parcelHelpers.interopDefault(_xorByJs);
var _xorWithJs = require("./xorWith.js");
var _xorWithJsDefault = parcelHelpers.interopDefault(_xorWithJs);
var _zipJs = require("./zip.js");
var _zipJsDefault = parcelHelpers.interopDefault(_zipJs);
var _zipObjectJs = require("./zipObject.js");
var _zipObjectJsDefault = parcelHelpers.interopDefault(_zipObjectJs);
var _zipObjectDeepJs = require("./zipObjectDeep.js");
var _zipObjectDeepJsDefault = parcelHelpers.interopDefault(_zipObjectDeepJs);
var _zipWithJs = require("./zipWith.js");
var _zipWithJsDefault = parcelHelpers.interopDefault(_zipWithJs);
var _lodashDefaultJs = require("./lodash.default.js");
var _lodashDefaultJsDefault = parcelHelpers.interopDefault(_lodashDefaultJs);

},{"./add.js":false,"./after.js":false,"./ary.js":false,"./assign.js":false,"./assignIn.js":false,"./assignInWith.js":false,"./assignWith.js":false,"./at.js":false,"./attempt.js":false,"./before.js":false,"./bind.js":false,"./bindAll.js":false,"./bindKey.js":false,"./camelCase.js":false,"./capitalize.js":false,"./castArray.js":false,"./ceil.js":false,"./chain.js":false,"./chunk.js":"fPV8N","./clamp.js":false,"./clone.js":false,"./cloneDeep.js":false,"./cloneDeepWith.js":false,"./cloneWith.js":false,"./commit.js":false,"./compact.js":false,"./concat.js":false,"./cond.js":false,"./conforms.js":false,"./conformsTo.js":false,"./constant.js":"a5s7V","./countBy.js":false,"./create.js":false,"./curry.js":false,"./curryRight.js":false,"./debounce.js":false,"./deburr.js":false,"./defaultTo.js":false,"./defaults.js":false,"./defaultsDeep.js":false,"./defer.js":false,"./delay.js":false,"./difference.js":false,"./differenceBy.js":false,"./differenceWith.js":false,"./divide.js":false,"./drop.js":false,"./dropRight.js":false,"./dropRightWhile.js":false,"./dropWhile.js":false,"./each.js":false,"./eachRight.js":false,"./endsWith.js":false,"./entries.js":false,"./entriesIn.js":false,"./eq.js":"7el3s","./escape.js":false,"./escapeRegExp.js":false,"./every.js":false,"./extend.js":false,"./extendWith.js":false,"./fill.js":false,"./filter.js":false,"./find.js":false,"./findIndex.js":false,"./findKey.js":false,"./findLast.js":false,"./findLastIndex.js":false,"./findLastKey.js":false,"./first.js":false,"./flatMap.js":false,"./flatMapDeep.js":false,"./flatMapDepth.js":false,"./flatten.js":"7cRZC","./flattenDeep.js":false,"./flattenDepth.js":false,"./flip.js":false,"./floor.js":false,"./flow.js":"leTwE","./flowRight.js":false,"./forEach.js":false,"./forEachRight.js":false,"./forIn.js":false,"./forInRight.js":false,"./forOwn.js":false,"./forOwnRight.js":false,"./fromPairs.js":"2o9tn","./functions.js":false,"./functionsIn.js":false,"./get.js":"9ZP5X","./groupBy.js":false,"./gt.js":false,"./gte.js":false,"./has.js":false,"./hasIn.js":"jfq4F","./head.js":false,"./identity.js":"1Y0KA","./inRange.js":false,"./includes.js":false,"./indexOf.js":false,"./initial.js":false,"./intersection.js":false,"./intersectionBy.js":false,"./intersectionWith.js":false,"./invert.js":false,"./invertBy.js":false,"./invoke.js":false,"./invokeMap.js":false,"./isArguments.js":"9k91Y","./isArray.js":"ETPQ1","./isArrayBuffer.js":false,"./isArrayLike.js":"8SdiO","./isArrayLikeObject.js":"gArhC","./isBoolean.js":false,"./isBuffer.js":"llpEE","./isDate.js":false,"./isElement.js":false,"./isEmpty.js":false,"./isEqual.js":"eNhTn","./isEqualWith.js":false,"./isError.js":false,"./isFinite.js":false,"./isFunction.js":"e5kis","./isInteger.js":false,"./isLength.js":"bItM0","./isMap.js":false,"./isMatch.js":false,"./isMatchWith.js":false,"./isNaN.js":false,"./isNative.js":false,"./isNil.js":false,"./isNull.js":false,"./isNumber.js":false,"./isObject.js":"dHhyW","./isObjectLike.js":"iad76","./isPlainObject.js":false,"./isRegExp.js":false,"./isSafeInteger.js":false,"./isSet.js":false,"./isString.js":false,"./isSymbol.js":"gCyRJ","./isTypedArray.js":"2LIMs","./isUndefined.js":false,"./isWeakMap.js":false,"./isWeakSet.js":false,"./iteratee.js":false,"./join.js":false,"./kebabCase.js":false,"./keyBy.js":false,"./keys.js":"lbEZV","./keysIn.js":false,"./last.js":false,"./lastIndexOf.js":false,"./wrapperLodash.js":"2iNJx","./lowerCase.js":false,"./lowerFirst.js":false,"./lt.js":false,"./lte.js":false,"./map.js":false,"./mapKeys.js":false,"./mapValues.js":false,"./matches.js":false,"./matchesProperty.js":false,"./max.js":false,"./maxBy.js":false,"./mean.js":false,"./meanBy.js":false,"./memoize.js":"5zdei","./merge.js":false,"./mergeWith.js":false,"./method.js":false,"./methodOf.js":false,"./min.js":false,"./minBy.js":false,"./mixin.js":false,"./multiply.js":false,"./negate.js":false,"./next.js":false,"./noop.js":"9q6VJ","./now.js":false,"./nth.js":false,"./nthArg.js":false,"./omit.js":false,"./omitBy.js":false,"./once.js":false,"./orderBy.js":false,"./over.js":false,"./overArgs.js":false,"./overEvery.js":false,"./overSome.js":false,"./pad.js":false,"./padEnd.js":false,"./padStart.js":false,"./parseInt.js":false,"./partial.js":false,"./partialRight.js":false,"./partition.js":false,"./pick.js":false,"./pickBy.js":false,"./plant.js":false,"./property.js":"kwvYw","./propertyOf.js":false,"./pull.js":false,"./pullAll.js":false,"./pullAllBy.js":false,"./pullAllWith.js":false,"./pullAt.js":false,"./random.js":false,"./range.js":"2xup9","./rangeRight.js":false,"./rearg.js":false,"./reduce.js":false,"./reduceRight.js":false,"./reject.js":false,"./remove.js":false,"./repeat.js":false,"./replace.js":false,"./rest.js":false,"./result.js":false,"./reverse.js":false,"./round.js":false,"./sample.js":"b6mtE","./sampleSize.js":false,"./set.js":false,"./setWith.js":false,"./shuffle.js":false,"./size.js":false,"./slice.js":false,"./snakeCase.js":false,"./some.js":false,"./sortBy.js":"42BZ9","./sortedIndex.js":false,"./sortedIndexBy.js":false,"./sortedIndexOf.js":false,"./sortedLastIndex.js":false,"./sortedLastIndexBy.js":false,"./sortedLastIndexOf.js":false,"./sortedUniq.js":false,"./sortedUniqBy.js":false,"./split.js":false,"./spread.js":false,"./startCase.js":false,"./startsWith.js":false,"./stubArray.js":"iwLLL","./stubFalse.js":"fF5mf","./stubObject.js":false,"./stubString.js":false,"./stubTrue.js":false,"./subtract.js":false,"./sum.js":"feLWk","./sumBy.js":false,"./tail.js":false,"./take.js":false,"./takeRight.js":false,"./takeRightWhile.js":false,"./takeWhile.js":false,"./tap.js":false,"./template.js":false,"./templateSettings.js":false,"./throttle.js":false,"./thru.js":false,"./times.js":false,"./toArray.js":false,"./toFinite.js":"FJR8i","./toInteger.js":"1tdUD","./toIterator.js":false,"./toJSON.js":false,"./toLength.js":false,"./toLower.js":false,"./toNumber.js":"4CrK2","./toPairs.js":false,"./toPairsIn.js":false,"./toPath.js":false,"./toPlainObject.js":false,"./toSafeInteger.js":false,"./toString.js":"hF0LJ","./toUpper.js":false,"./transform.js":false,"./trim.js":false,"./trimEnd.js":false,"./trimStart.js":false,"./truncate.js":false,"./unary.js":false,"./unescape.js":false,"./union.js":false,"./unionBy.js":false,"./unionWith.js":false,"./uniq.js":"57kq6","./uniqBy.js":"eZnwu","./uniqWith.js":"6UDxA","./uniqueId.js":false,"./unset.js":false,"./unzip.js":"j1DxS","./unzipWith.js":"bc76B","./update.js":false,"./updateWith.js":false,"./upperCase.js":false,"./upperFirst.js":false,"./value.js":false,"./valueOf.js":false,"./values.js":"bjkOg","./valuesIn.js":false,"./without.js":false,"./words.js":false,"./wrap.js":false,"./wrapperAt.js":false,"./wrapperChain.js":false,"./wrapperReverse.js":false,"./wrapperValue.js":false,"./xor.js":false,"./xorBy.js":false,"./xorWith.js":false,"./zip.js":false,"./zipObject.js":false,"./zipObjectDeep.js":false,"./zipWith.js":"1agvX","./lodash.default.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fPV8N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseSliceJs = require("./_baseSlice.js");
var _baseSliceJsDefault = parcelHelpers.interopDefault(_baseSliceJs);
var _isIterateeCallJs = require("./_isIterateeCall.js");
var _isIterateeCallJsDefault = parcelHelpers.interopDefault(_isIterateeCallJs);
var _toIntegerJs = require("./toInteger.js");
var _toIntegerJsDefault = parcelHelpers.interopDefault(_toIntegerJs);
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeCeil = Math.ceil, nativeMax = Math.max;
/**
 * Creates an array of elements split into groups the length of `size`.
 * If `array` can't be split evenly, the final chunk will be the remaining
 * elements.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to process.
 * @param {number} [size=1] The length of each chunk
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the new array of chunks.
 * @example
 *
 * _.chunk(['a', 'b', 'c', 'd'], 2);
 * // => [['a', 'b'], ['c', 'd']]
 *
 * _.chunk(['a', 'b', 'c', 'd'], 3);
 * // => [['a', 'b', 'c'], ['d']]
 */ function chunk(array, size, guard) {
    if (guard ? _isIterateeCallJsDefault.default(array, size, guard) : size === undefined) size = 1;
    else size = nativeMax(_toIntegerJsDefault.default(size), 0);
    var length = array == null ? 0 : array.length;
    if (!length || size < 1) return [];
    var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
    while(index < length)result[resIndex++] = _baseSliceJsDefault.default(array, index, index += size);
    return result;
}
exports.default = chunk;

},{"./_baseSlice.js":"aUyi1","./_isIterateeCall.js":"1jM1r","./toInteger.js":"1tdUD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aUyi1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */ function baseSlice(array, start, end) {
    var index = -1, length = array.length;
    if (start < 0) start = -start > length ? 0 : length + start;
    end = end > length ? length : end;
    if (end < 0) end += length;
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while(++index < length)result[index] = array[index + start];
    return result;
}
exports.default = baseSlice;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1jM1r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eqJs = require("./eq.js");
var _eqJsDefault = parcelHelpers.interopDefault(_eqJs);
var _isArrayLikeJs = require("./isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _isIndexJs = require("./_isIndex.js");
var _isIndexJsDefault = parcelHelpers.interopDefault(_isIndexJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */ function isIterateeCall(value, index, object) {
    if (!_isObjectJsDefault.default(object)) return false;
    var type = typeof index;
    if (type == 'number' ? _isArrayLikeJsDefault.default(object) && _isIndexJsDefault.default(index, object.length) : type == 'string' && index in object) return _eqJsDefault.default(object[index], value);
    return false;
}
exports.default = isIterateeCall;

},{"./eq.js":"7el3s","./isArrayLike.js":"8SdiO","./_isIndex.js":"5DS1K","./isObject.js":"dHhyW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7el3s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
exports.default = eq;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8SdiO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _isLengthJs = require("./isLength.js");
var _isLengthJsDefault = parcelHelpers.interopDefault(_isLengthJs);
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && _isLengthJsDefault.default(value.length) && !_isFunctionJsDefault.default(value);
}
exports.default = isArrayLike;

},{"./isFunction.js":"e5kis","./isLength.js":"bItM0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e5kis":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseGetTagJs = require("./_baseGetTag.js");
var _baseGetTagJsDefault = parcelHelpers.interopDefault(_baseGetTagJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
/** `Object#toString` result references. */ var asyncTag = '[object AsyncFunction]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    if (!_isObjectJsDefault.default(value)) return false;
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = _baseGetTagJsDefault.default(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
exports.default = isFunction;

},{"./_baseGetTag.js":"gVDfP","./isObject.js":"dHhyW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gVDfP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _symbolJs = require("./_Symbol.js");
var _symbolJsDefault = parcelHelpers.interopDefault(_symbolJs);
var _getRawTagJs = require("./_getRawTag.js");
var _getRawTagJsDefault = parcelHelpers.interopDefault(_getRawTagJs);
var _objectToStringJs = require("./_objectToString.js");
var _objectToStringJsDefault = parcelHelpers.interopDefault(_objectToStringJs);
/** `Object#toString` result references. */ var nullTag = '[object Null]', undefinedTag = '[object Undefined]';
/** Built-in value references. */ var symToStringTag = _symbolJsDefault.default ? _symbolJsDefault.default.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    if (value == null) return value === undefined ? undefinedTag : nullTag;
    return symToStringTag && symToStringTag in Object(value) ? _getRawTagJsDefault.default(value) : _objectToStringJsDefault.default(value);
}
exports.default = baseGetTag;

},{"./_Symbol.js":"jx216","./_getRawTag.js":"ijXom","./_objectToString.js":"fTkTn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jx216":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/** Built-in value references. */ var Symbol = _rootJsDefault.default.Symbol;
exports.default = Symbol;

},{"./_root.js":"8yvCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8yvCA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _freeGlobalJs = require("./_freeGlobal.js");
var _freeGlobalJsDefault = parcelHelpers.interopDefault(_freeGlobalJs);
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = _freeGlobalJsDefault.default || freeSelf || Function('return this')();
exports.default = root;

},{"./_freeGlobal.js":"98hMd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"98hMd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var global = arguments[3];
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
exports.default = freeGlobal;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ijXom":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _symbolJs = require("./_Symbol.js");
var _symbolJsDefault = parcelHelpers.interopDefault(_symbolJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/** Built-in value references. */ var symToStringTag = _symbolJsDefault.default ? _symbolJsDefault.default.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */ function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
        value[symToStringTag] = undefined;
        var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) value[symToStringTag] = tag;
        else delete value[symToStringTag];
    }
    return result;
}
exports.default = getRawTag;

},{"./_Symbol.js":"jx216","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fTkTn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */ function objectToString(value) {
    return nativeObjectToString.call(value);
}
exports.default = objectToString;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dHhyW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
}
exports.default = isObject;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bItM0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
exports.default = isLength;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5DS1K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
exports.default = isIndex;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1tdUD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _toFiniteJs = require("./toFinite.js");
var _toFiniteJsDefault = parcelHelpers.interopDefault(_toFiniteJs);
/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */ function toInteger(value) {
    var result = _toFiniteJsDefault.default(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
}
exports.default = toInteger;

},{"./toFinite.js":"FJR8i","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"FJR8i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _toNumberJs = require("./toNumber.js");
var _toNumberJsDefault = parcelHelpers.interopDefault(_toNumberJs);
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0, MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */ function toFinite(value) {
    if (!value) return value === 0 ? value : 0;
    value = _toNumberJsDefault.default(value);
    if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
}
exports.default = toFinite;

},{"./toNumber.js":"4CrK2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4CrK2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseTrimJs = require("./_baseTrim.js");
var _baseTrimJsDefault = parcelHelpers.interopDefault(_baseTrimJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
/** Used as references for various `Number` constants. */ var NAN = 0 / 0;
/** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */ function toNumber(value) {
    if (typeof value == 'number') return value;
    if (_isSymbolJsDefault.default(value)) return NAN;
    if (_isObjectJsDefault.default(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = _isObjectJsDefault.default(other) ? other + '' : other;
    }
    if (typeof value != 'string') return value === 0 ? value : +value;
    value = _baseTrimJsDefault.default(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
exports.default = toNumber;

},{"./_baseTrim.js":"4X9xl","./isObject.js":"dHhyW","./isSymbol.js":"gCyRJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4X9xl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _trimmedEndIndexJs = require("./_trimmedEndIndex.js");
var _trimmedEndIndexJsDefault = parcelHelpers.interopDefault(_trimmedEndIndexJs);
/** Used to match leading whitespace. */ var reTrimStart = /^\s+/;
/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */ function baseTrim(string) {
    return string ? string.slice(0, _trimmedEndIndexJsDefault.default(string) + 1).replace(reTrimStart, '') : string;
}
exports.default = baseTrim;

},{"./_trimmedEndIndex.js":"lXShQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lXShQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used to match a single whitespace character. */ var reWhitespace = /\s/;
/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */ function trimmedEndIndex(string) {
    var index = string.length;
    while(index-- && reWhitespace.test(string.charAt(index)));
    return index;
}
exports.default = trimmedEndIndex;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gCyRJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseGetTagJs = require("./_baseGetTag.js");
var _baseGetTagJsDefault = parcelHelpers.interopDefault(_baseGetTagJs);
var _isObjectLikeJs = require("./isObjectLike.js");
var _isObjectLikeJsDefault = parcelHelpers.interopDefault(_isObjectLikeJs);
/** `Object#toString` result references. */ var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == 'symbol' || _isObjectLikeJsDefault.default(value) && _baseGetTagJsDefault.default(value) == symbolTag;
}
exports.default = isSymbol;

},{"./_baseGetTag.js":"gVDfP","./isObjectLike.js":"iad76","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iad76":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return value != null && typeof value == 'object';
}
exports.default = isObjectLike;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a5s7V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */ function constant(value) {
    return function() {
        return value;
    };
}
exports.default = constant;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7cRZC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseFlattenJs = require("./_baseFlatten.js");
var _baseFlattenJsDefault = parcelHelpers.interopDefault(_baseFlattenJs);
/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */ function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? _baseFlattenJsDefault.default(array, 1) : [];
}
exports.default = flatten;

},{"./_baseFlatten.js":"92emb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"92emb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayPushJs = require("./_arrayPush.js");
var _arrayPushJsDefault = parcelHelpers.interopDefault(_arrayPushJs);
var _isFlattenableJs = require("./_isFlattenable.js");
var _isFlattenableJsDefault = parcelHelpers.interopDefault(_isFlattenableJs);
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */ function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = _isFlattenableJsDefault.default);
    result || (result = []);
    while(++index < length){
        var value = array[index];
        if (depth > 0 && predicate(value)) {
            if (depth > 1) // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
            else _arrayPushJsDefault.default(result, value);
        } else if (!isStrict) result[result.length] = value;
    }
    return result;
}
exports.default = baseFlatten;

},{"./_arrayPush.js":"4BTrx","./_isFlattenable.js":"69qoZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4BTrx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length)array[offset + index] = values[index];
    return array;
}
exports.default = arrayPush;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"69qoZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _symbolJs = require("./_Symbol.js");
var _symbolJsDefault = parcelHelpers.interopDefault(_symbolJs);
var _isArgumentsJs = require("./isArguments.js");
var _isArgumentsJsDefault = parcelHelpers.interopDefault(_isArgumentsJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
/** Built-in value references. */ var spreadableSymbol = _symbolJsDefault.default ? _symbolJsDefault.default.isConcatSpreadable : undefined;
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */ function isFlattenable(value) {
    return _isArrayJsDefault.default(value) || _isArgumentsJsDefault.default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
exports.default = isFlattenable;

},{"./_Symbol.js":"jx216","./isArguments.js":"9k91Y","./isArray.js":"ETPQ1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9k91Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIsArgumentsJs = require("./_baseIsArguments.js");
var _baseIsArgumentsJsDefault = parcelHelpers.interopDefault(_baseIsArgumentsJs);
var _isObjectLikeJs = require("./isObjectLike.js");
var _isObjectLikeJsDefault = parcelHelpers.interopDefault(_isObjectLikeJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */ var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ var isArguments = _baseIsArgumentsJsDefault.default(function() {
    return arguments;
}()) ? _baseIsArgumentsJsDefault.default : function(value) {
    return _isObjectLikeJsDefault.default(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
exports.default = isArguments;

},{"./_baseIsArguments.js":"bnUuB","./isObjectLike.js":"iad76","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bnUuB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseGetTagJs = require("./_baseGetTag.js");
var _baseGetTagJsDefault = parcelHelpers.interopDefault(_baseGetTagJs);
var _isObjectLikeJs = require("./isObjectLike.js");
var _isObjectLikeJsDefault = parcelHelpers.interopDefault(_isObjectLikeJs);
/** `Object#toString` result references. */ var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */ function baseIsArguments(value) {
    return _isObjectLikeJsDefault.default(value) && _baseGetTagJsDefault.default(value) == argsTag;
}
exports.default = baseIsArguments;

},{"./_baseGetTag.js":"gVDfP","./isObjectLike.js":"iad76","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ETPQ1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
exports.default = isArray;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"leTwE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createFlowJs = require("./_createFlow.js");
var _createFlowJsDefault = parcelHelpers.interopDefault(_createFlowJs);
/**
 * Creates a function that returns the result of invoking the given functions
 * with the `this` binding of the created function, where each successive
 * invocation is supplied the return value of the previous.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {...(Function|Function[])} [funcs] The functions to invoke.
 * @returns {Function} Returns the new composite function.
 * @see _.flowRight
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var addSquare = _.flow([_.add, square]);
 * addSquare(1, 2);
 * // => 9
 */ var flow = _createFlowJsDefault.default();
exports.default = flow;

},{"./_createFlow.js":"l2aJ2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l2aJ2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashWrapperJs = require("./_LodashWrapper.js");
var _lodashWrapperJsDefault = parcelHelpers.interopDefault(_lodashWrapperJs);
var _flatRestJs = require("./_flatRest.js");
var _flatRestJsDefault = parcelHelpers.interopDefault(_flatRestJs);
var _getDataJs = require("./_getData.js");
var _getDataJsDefault = parcelHelpers.interopDefault(_getDataJs);
var _getFuncNameJs = require("./_getFuncName.js");
var _getFuncNameJsDefault = parcelHelpers.interopDefault(_getFuncNameJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isLaziableJs = require("./_isLaziable.js");
var _isLaziableJsDefault = parcelHelpers.interopDefault(_isLaziableJs);
/** Error message constants. */ var FUNC_ERROR_TEXT = 'Expected a function';
/** Used to compose bitmasks for function metadata. */ var WRAP_CURRY_FLAG = 8, WRAP_PARTIAL_FLAG = 32, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256;
/**
 * Creates a `_.flow` or `_.flowRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new flow function.
 */ function createFlow(fromRight) {
    return _flatRestJsDefault.default(function(funcs) {
        var length = funcs.length, index1 = length, prereq = _lodashWrapperJsDefault.default.prototype.thru;
        if (fromRight) funcs.reverse();
        while(index1--){
            var func = funcs[index1];
            if (typeof func != 'function') throw new TypeError(FUNC_ERROR_TEXT);
            if (prereq && !wrapper && _getFuncNameJsDefault.default(func) == 'wrapper') var wrapper = new _lodashWrapperJsDefault.default([], true);
        }
        index1 = wrapper ? index1 : length;
        while(++index1 < length){
            func = funcs[index1];
            var funcName = _getFuncNameJsDefault.default(func), data = funcName == 'wrapper' ? _getDataJsDefault.default(func) : undefined;
            if (data && _isLaziableJsDefault.default(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) wrapper = wrapper[_getFuncNameJsDefault.default(data[0])].apply(wrapper, data[3]);
            else wrapper = func.length == 1 && _isLaziableJsDefault.default(func) ? wrapper[funcName]() : wrapper.thru(func);
        }
        return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && _isArrayJsDefault.default(value)) return wrapper.plant(value).value();
            var index = 0, result = length ? funcs[index].apply(this, args) : value;
            while(++index < length)result = funcs[index].call(this, result);
            return result;
        };
    });
}
exports.default = createFlow;

},{"./_LodashWrapper.js":"iTw7d","./_flatRest.js":"iF6bf","./_getData.js":"7fRqS","./_getFuncName.js":"7lA3N","./isArray.js":"ETPQ1","./_isLaziable.js":"4XpWq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iTw7d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseCreateJs = require("./_baseCreate.js");
var _baseCreateJsDefault = parcelHelpers.interopDefault(_baseCreateJs);
var _baseLodashJs = require("./_baseLodash.js");
var _baseLodashJsDefault = parcelHelpers.interopDefault(_baseLodashJs);
/**
 * The base constructor for creating `lodash` wrapper objects.
 *
 * @private
 * @param {*} value The value to wrap.
 * @param {boolean} [chainAll] Enable explicit method chain sequences.
 */ function LodashWrapper(value, chainAll) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__chain__ = !!chainAll;
    this.__index__ = 0;
    this.__values__ = undefined;
}
LodashWrapper.prototype = _baseCreateJsDefault.default(_baseLodashJsDefault.default.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;
exports.default = LodashWrapper;

},{"./_baseCreate.js":"aq4aU","./_baseLodash.js":"dU7Kx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aq4aU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
/** Built-in value references. */ var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */ var baseCreate = function() {
    function object() {
    }
    return function(proto) {
        if (!_isObjectJsDefault.default(proto)) return {
        };
        if (objectCreate) return objectCreate(proto);
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
    };
}();
exports.default = baseCreate;

},{"./isObject.js":"dHhyW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dU7Kx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The function whose prototype chain sequence wrappers inherit from.
 *
 * @private
 */ function baseLodash() {
// No operation performed.
}
exports.default = baseLodash;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iF6bf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _flattenJs = require("./flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
var _overRestJs = require("./_overRest.js");
var _overRestJsDefault = parcelHelpers.interopDefault(_overRestJs);
var _setToStringJs = require("./_setToString.js");
var _setToStringJsDefault = parcelHelpers.interopDefault(_setToStringJs);
/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */ function flatRest(func) {
    return _setToStringJsDefault.default(_overRestJsDefault.default(func, undefined, _flattenJsDefault.default), func + '');
}
exports.default = flatRest;

},{"./flatten.js":"7cRZC","./_overRest.js":"d1Uaz","./_setToString.js":"3GXSg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d1Uaz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _applyJs = require("./_apply.js");
var _applyJsDefault = parcelHelpers.interopDefault(_applyJs);
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */ function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while(++index < length)array[index] = args[start + index];
        index = -1;
        var otherArgs = Array(start + 1);
        while(++index < start)otherArgs[index] = args[index];
        otherArgs[start] = transform(array);
        return _applyJsDefault.default(func, this, otherArgs);
    };
}
exports.default = overRest;

},{"./_apply.js":"kqJ3H","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kqJ3H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */ function apply(func, thisArg, args) {
    switch(args.length){
        case 0:
            return func.call(thisArg);
        case 1:
            return func.call(thisArg, args[0]);
        case 2:
            return func.call(thisArg, args[0], args[1]);
        case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
exports.default = apply;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3GXSg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseSetToStringJs = require("./_baseSetToString.js");
var _baseSetToStringJsDefault = parcelHelpers.interopDefault(_baseSetToStringJs);
var _shortOutJs = require("./_shortOut.js");
var _shortOutJsDefault = parcelHelpers.interopDefault(_shortOutJs);
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */ var setToString = _shortOutJsDefault.default(_baseSetToStringJsDefault.default);
exports.default = setToString;

},{"./_baseSetToString.js":"lc4dY","./_shortOut.js":"dmiNi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lc4dY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _definePropertyJs = require("./_defineProperty.js");
var _definePropertyJsDefault = parcelHelpers.interopDefault(_definePropertyJs);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */ var baseSetToString = !_definePropertyJsDefault.default ? _identityJsDefault.default : function(func, string) {
    return _definePropertyJsDefault.default(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': _constantJsDefault.default(string),
        'writable': true
    });
};
exports.default = baseSetToString;

},{"./constant.js":"a5s7V","./_defineProperty.js":"8u8dH","./identity.js":"1Y0KA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8u8dH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNativeJs = require("./_getNative.js");
var _getNativeJsDefault = parcelHelpers.interopDefault(_getNativeJs);
var defineProperty = function() {
    try {
        var func = _getNativeJsDefault.default(Object, 'defineProperty');
        func({
        }, '', {
        });
        return func;
    } catch (e) {
    }
}();
exports.default = defineProperty;

},{"./_getNative.js":"bQrQL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bQrQL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIsNativeJs = require("./_baseIsNative.js");
var _baseIsNativeJsDefault = parcelHelpers.interopDefault(_baseIsNativeJs);
var _getValueJs = require("./_getValue.js");
var _getValueJsDefault = parcelHelpers.interopDefault(_getValueJs);
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = _getValueJsDefault.default(object, key);
    return _baseIsNativeJsDefault.default(value) ? value : undefined;
}
exports.default = getNative;

},{"./_baseIsNative.js":"eZuBv","./_getValue.js":"dHb8j","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eZuBv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _isMaskedJs = require("./_isMasked.js");
var _isMaskedJsDefault = parcelHelpers.interopDefault(_isMaskedJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _toSourceJs = require("./_toSource.js");
var _toSourceJsDefault = parcelHelpers.interopDefault(_toSourceJs);
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */ var funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!_isObjectJsDefault.default(value) || _isMaskedJsDefault.default(value)) return false;
    var pattern = _isFunctionJsDefault.default(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSourceJsDefault.default(value));
}
exports.default = baseIsNative;

},{"./isFunction.js":"e5kis","./_isMasked.js":"8rXmg","./isObject.js":"dHhyW","./_toSource.js":"4wd66","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8rXmg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coreJsDataJs = require("./_coreJsData.js");
var _coreJsDataJsDefault = parcelHelpers.interopDefault(_coreJsDataJs);
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(_coreJsDataJsDefault.default && _coreJsDataJsDefault.default.keys && _coreJsDataJsDefault.default.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
exports.default = isMasked;

},{"./_coreJsData.js":"jb15d","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jb15d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/** Used to detect overreaching core-js shims. */ var coreJsData = _rootJsDefault.default['__core-js_shared__'];
exports.default = coreJsData;

},{"./_root.js":"8yvCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4wd66":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used for built-in method references. */ var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {
        }
        try {
            return func + '';
        } catch (e1) {
        }
    }
    return '';
}
exports.default = toSource;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dHb8j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
exports.default = getValue;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Y0KA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */ function identity(value) {
    return value;
}
exports.default = identity;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dmiNi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used to detect hot functions by number of calls within a span of milliseconds. */ var HOT_COUNT = 800, HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */ function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
            if (++count >= HOT_COUNT) return arguments[0];
        } else count = 0;
        return func.apply(undefined, arguments);
    };
}
exports.default = shortOut;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7fRqS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _metaMapJs = require("./_metaMap.js");
var _metaMapJsDefault = parcelHelpers.interopDefault(_metaMapJs);
var _noopJs = require("./noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
/**
 * Gets metadata for `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {*} Returns the metadata for `func`.
 */ var getData = !_metaMapJsDefault.default ? _noopJsDefault.default : function(func) {
    return _metaMapJsDefault.default.get(func);
};
exports.default = getData;

},{"./_metaMap.js":"2XktW","./noop.js":"9q6VJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2XktW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _weakMapJs = require("./_WeakMap.js");
var _weakMapJsDefault = parcelHelpers.interopDefault(_weakMapJs);
/** Used to store function metadata. */ var metaMap = _weakMapJsDefault.default && new _weakMapJsDefault.default;
exports.default = metaMap;

},{"./_WeakMap.js":"52eE0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"52eE0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNativeJs = require("./_getNative.js");
var _getNativeJsDefault = parcelHelpers.interopDefault(_getNativeJs);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/* Built-in method references that are verified to be native. */ var WeakMap = _getNativeJsDefault.default(_rootJsDefault.default, 'WeakMap');
exports.default = WeakMap;

},{"./_getNative.js":"bQrQL","./_root.js":"8yvCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9q6VJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */ function noop() {
// No operation performed.
}
exports.default = noop;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7lA3N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _realNamesJs = require("./_realNames.js");
var _realNamesJsDefault = parcelHelpers.interopDefault(_realNamesJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the name of `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {string} Returns the function name.
 */ function getFuncName(func) {
    var result = func.name + '', array = _realNamesJsDefault.default[result], length = hasOwnProperty.call(_realNamesJsDefault.default, result) ? array.length : 0;
    while(length--){
        var data = array[length], otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) return data.name;
    }
    return result;
}
exports.default = getFuncName;

},{"./_realNames.js":"gQChE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gQChE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used to lookup unminified function names. */ var realNames = {
};
exports.default = realNames;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4XpWq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lazyWrapperJs = require("./_LazyWrapper.js");
var _lazyWrapperJsDefault = parcelHelpers.interopDefault(_lazyWrapperJs);
var _getDataJs = require("./_getData.js");
var _getDataJsDefault = parcelHelpers.interopDefault(_getDataJs);
var _getFuncNameJs = require("./_getFuncName.js");
var _getFuncNameJsDefault = parcelHelpers.interopDefault(_getFuncNameJs);
var _wrapperLodashJs = require("./wrapperLodash.js");
var _wrapperLodashJsDefault = parcelHelpers.interopDefault(_wrapperLodashJs);
/**
 * Checks if `func` has a lazy counterpart.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
 *  else `false`.
 */ function isLaziable(func) {
    var funcName = _getFuncNameJsDefault.default(func), other = _wrapperLodashJsDefault.default[funcName];
    if (typeof other != 'function' || !(funcName in _lazyWrapperJsDefault.default.prototype)) return false;
    if (func === other) return true;
    var data = _getDataJsDefault.default(other);
    return !!data && func === data[0];
}
exports.default = isLaziable;

},{"./_LazyWrapper.js":"k5itv","./_getData.js":"7fRqS","./_getFuncName.js":"7lA3N","./wrapperLodash.js":"2iNJx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k5itv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseCreateJs = require("./_baseCreate.js");
var _baseCreateJsDefault = parcelHelpers.interopDefault(_baseCreateJs);
var _baseLodashJs = require("./_baseLodash.js");
var _baseLodashJsDefault = parcelHelpers.interopDefault(_baseLodashJs);
/** Used as references for the maximum length and index of an array. */ var MAX_ARRAY_LENGTH = 4294967295;
/**
 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
 *
 * @private
 * @constructor
 * @param {*} value The value to wrap.
 */ function LazyWrapper(value) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__dir__ = 1;
    this.__filtered__ = false;
    this.__iteratees__ = [];
    this.__takeCount__ = MAX_ARRAY_LENGTH;
    this.__views__ = [];
}
// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype = _baseCreateJsDefault.default(_baseLodashJsDefault.default.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;
exports.default = LazyWrapper;

},{"./_baseCreate.js":"aq4aU","./_baseLodash.js":"dU7Kx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2iNJx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lazyWrapperJs = require("./_LazyWrapper.js");
var _lazyWrapperJsDefault = parcelHelpers.interopDefault(_lazyWrapperJs);
var _lodashWrapperJs = require("./_LodashWrapper.js");
var _lodashWrapperJsDefault = parcelHelpers.interopDefault(_lodashWrapperJs);
var _baseLodashJs = require("./_baseLodash.js");
var _baseLodashJsDefault = parcelHelpers.interopDefault(_baseLodashJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isObjectLikeJs = require("./isObjectLike.js");
var _isObjectLikeJsDefault = parcelHelpers.interopDefault(_isObjectLikeJs);
var _wrapperCloneJs = require("./_wrapperClone.js");
var _wrapperCloneJsDefault = parcelHelpers.interopDefault(_wrapperCloneJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates a `lodash` object which wraps `value` to enable implicit method
 * chain sequences. Methods that operate on and return arrays, collections,
 * and functions can be chained together. Methods that retrieve a single value
 * or may return a primitive value will automatically end the chain sequence
 * and return the unwrapped value. Otherwise, the value must be unwrapped
 * with `_#value`.
 *
 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
 * enabled using `_.chain`.
 *
 * The execution of chained methods is lazy, that is, it's deferred until
 * `_#value` is implicitly or explicitly called.
 *
 * Lazy evaluation allows several methods to support shortcut fusion.
 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
 * the creation of intermediate arrays and can greatly reduce the number of
 * iteratee executions. Sections of a chain sequence qualify for shortcut
 * fusion if the section is applied to an array and iteratees accept only
 * one argument. The heuristic for whether a section qualifies for shortcut
 * fusion is subject to change.
 *
 * Chaining is supported in custom builds as long as the `_#value` method is
 * directly or indirectly included in the build.
 *
 * In addition to lodash methods, wrappers have `Array` and `String` methods.
 *
 * The wrapper `Array` methods are:
 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
 *
 * The wrapper `String` methods are:
 * `replace` and `split`
 *
 * The wrapper methods that support shortcut fusion are:
 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
 *
 * The chainable wrapper methods are:
 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
 * `zipObject`, `zipObjectDeep`, and `zipWith`
 *
 * The wrapper methods that are **not** chainable by default are:
 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
 * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
 * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
 * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
 * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
 * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
 * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
 * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
 * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
 * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
 * `upperFirst`, `value`, and `words`
 *
 * @name _
 * @constructor
 * @category Seq
 * @param {*} value The value to wrap in a `lodash` instance.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var wrapped = _([1, 2, 3]);
 *
 * // Returns an unwrapped value.
 * wrapped.reduce(_.add);
 * // => 6
 *
 * // Returns a wrapped value.
 * var squares = wrapped.map(square);
 *
 * _.isArray(squares);
 * // => false
 *
 * _.isArray(squares.value());
 * // => true
 */ function lodash(value) {
    if (_isObjectLikeJsDefault.default(value) && !_isArrayJsDefault.default(value) && !(value instanceof _lazyWrapperJsDefault.default)) {
        if (value instanceof _lodashWrapperJsDefault.default) return value;
        if (hasOwnProperty.call(value, '__wrapped__')) return _wrapperCloneJsDefault.default(value);
    }
    return new _lodashWrapperJsDefault.default(value);
}
// Ensure wrappers are instances of `baseLodash`.
lodash.prototype = _baseLodashJsDefault.default.prototype;
lodash.prototype.constructor = lodash;
exports.default = lodash;

},{"./_LazyWrapper.js":"k5itv","./_LodashWrapper.js":"iTw7d","./_baseLodash.js":"dU7Kx","./isArray.js":"ETPQ1","./isObjectLike.js":"iad76","./_wrapperClone.js":"2BZzZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2BZzZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lazyWrapperJs = require("./_LazyWrapper.js");
var _lazyWrapperJsDefault = parcelHelpers.interopDefault(_lazyWrapperJs);
var _lodashWrapperJs = require("./_LodashWrapper.js");
var _lodashWrapperJsDefault = parcelHelpers.interopDefault(_lodashWrapperJs);
var _copyArrayJs = require("./_copyArray.js");
var _copyArrayJsDefault = parcelHelpers.interopDefault(_copyArrayJs);
/**
 * Creates a clone of `wrapper`.
 *
 * @private
 * @param {Object} wrapper The wrapper to clone.
 * @returns {Object} Returns the cloned wrapper.
 */ function wrapperClone(wrapper) {
    if (wrapper instanceof _lazyWrapperJsDefault.default) return wrapper.clone();
    var result = new _lodashWrapperJsDefault.default(wrapper.__wrapped__, wrapper.__chain__);
    result.__actions__ = _copyArrayJsDefault.default(wrapper.__actions__);
    result.__index__ = wrapper.__index__;
    result.__values__ = wrapper.__values__;
    return result;
}
exports.default = wrapperClone;

},{"./_LazyWrapper.js":"k5itv","./_LodashWrapper.js":"iTw7d","./_copyArray.js":"9islt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9islt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */ function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while(++index < length)array[index] = source[index];
    return array;
}
exports.default = copyArray;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2o9tn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The inverse of `_.toPairs`; this method returns an object composed
 * from key-value `pairs`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} pairs The key-value pairs.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.fromPairs([['a', 1], ['b', 2]]);
 * // => { 'a': 1, 'b': 2 }
 */ function fromPairs(pairs) {
    var index = -1, length = pairs == null ? 0 : pairs.length, result = {
    };
    while(++index < length){
        var pair = pairs[index];
        result[pair[0]] = pair[1];
    }
    return result;
}
exports.default = fromPairs;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9ZP5X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseGetJs = require("./_baseGet.js");
var _baseGetJsDefault = parcelHelpers.interopDefault(_baseGetJs);
/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */ function get(object, path, defaultValue) {
    var result = object == null ? undefined : _baseGetJsDefault.default(object, path);
    return result === undefined ? defaultValue : result;
}
exports.default = get;

},{"./_baseGet.js":"3IUaj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3IUaj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _castPathJs = require("./_castPath.js");
var _castPathJsDefault = parcelHelpers.interopDefault(_castPathJs);
var _toKeyJs = require("./_toKey.js");
var _toKeyJsDefault = parcelHelpers.interopDefault(_toKeyJs);
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */ function baseGet(object, path) {
    path = _castPathJsDefault.default(path, object);
    var index = 0, length = path.length;
    while(object != null && index < length)object = object[_toKeyJsDefault.default(path[index++])];
    return index && index == length ? object : undefined;
}
exports.default = baseGet;

},{"./_castPath.js":"g21zK","./_toKey.js":"Zo68s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g21zK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isKeyJs = require("./_isKey.js");
var _isKeyJsDefault = parcelHelpers.interopDefault(_isKeyJs);
var _stringToPathJs = require("./_stringToPath.js");
var _stringToPathJsDefault = parcelHelpers.interopDefault(_stringToPathJs);
var _toStringJs = require("./toString.js");
var _toStringJsDefault = parcelHelpers.interopDefault(_toStringJs);
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */ function castPath(value, object) {
    if (_isArrayJsDefault.default(value)) return value;
    return _isKeyJsDefault.default(value, object) ? [
        value
    ] : _stringToPathJsDefault.default(_toStringJsDefault.default(value));
}
exports.default = castPath;

},{"./isArray.js":"ETPQ1","./_isKey.js":"h7SfK","./_stringToPath.js":"cgxmj","./toString.js":"hF0LJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h7SfK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
/** Used to match property names within property paths. */ var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */ function isKey(value, object) {
    if (_isArrayJsDefault.default(value)) return false;
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || _isSymbolJsDefault.default(value)) return true;
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
exports.default = isKey;

},{"./isArray.js":"ETPQ1","./isSymbol.js":"gCyRJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cgxmj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _memoizeCappedJs = require("./_memoizeCapped.js");
var _memoizeCappedJsDefault = parcelHelpers.interopDefault(_memoizeCappedJs);
/** Used to match property names within property paths. */ var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */ var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */ var stringToPath = _memoizeCappedJsDefault.default(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */ ) result.push('');
    string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
});
exports.default = stringToPath;

},{"./_memoizeCapped.js":"2kD71","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2kD71":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _memoizeJs = require("./memoize.js");
var _memoizeJsDefault = parcelHelpers.interopDefault(_memoizeJs);
/** Used as the maximum memoize cache size. */ var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */ function memoizeCapped(func) {
    var result = _memoizeJsDefault.default(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) cache.clear();
        return key;
    });
    var cache = result.cache;
    return result;
}
exports.default = memoizeCapped;

},{"./memoize.js":"5zdei","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5zdei":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapCacheJs = require("./_MapCache.js");
var _mapCacheJsDefault = parcelHelpers.interopDefault(_mapCacheJs);
/** Error message constants. */ var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */ function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') throw new TypeError(FUNC_ERROR_TEXT);
    var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) return cache.get(key);
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
    };
    memoized.cache = new (memoize.Cache || _mapCacheJsDefault.default);
    return memoized;
}
// Expose `MapCache`.
memoize.Cache = _mapCacheJsDefault.default;
exports.default = memoize;

},{"./_MapCache.js":"kdqbj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kdqbj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapCacheClearJs = require("./_mapCacheClear.js");
var _mapCacheClearJsDefault = parcelHelpers.interopDefault(_mapCacheClearJs);
var _mapCacheDeleteJs = require("./_mapCacheDelete.js");
var _mapCacheDeleteJsDefault = parcelHelpers.interopDefault(_mapCacheDeleteJs);
var _mapCacheGetJs = require("./_mapCacheGet.js");
var _mapCacheGetJsDefault = parcelHelpers.interopDefault(_mapCacheGetJs);
var _mapCacheHasJs = require("./_mapCacheHas.js");
var _mapCacheHasJsDefault = parcelHelpers.interopDefault(_mapCacheHasJs);
var _mapCacheSetJs = require("./_mapCacheSet.js");
var _mapCacheSetJsDefault = parcelHelpers.interopDefault(_mapCacheSetJs);
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `MapCache`.
MapCache.prototype.clear = _mapCacheClearJsDefault.default;
MapCache.prototype['delete'] = _mapCacheDeleteJsDefault.default;
MapCache.prototype.get = _mapCacheGetJsDefault.default;
MapCache.prototype.has = _mapCacheHasJsDefault.default;
MapCache.prototype.set = _mapCacheSetJsDefault.default;
exports.default = MapCache;

},{"./_mapCacheClear.js":"6PhQB","./_mapCacheDelete.js":"eoP1L","./_mapCacheGet.js":"lbrg6","./_mapCacheHas.js":"lPQeP","./_mapCacheSet.js":"4UIYE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6PhQB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hashJs = require("./_Hash.js");
var _hashJsDefault = parcelHelpers.interopDefault(_hashJs);
var _listCacheJs = require("./_ListCache.js");
var _listCacheJsDefault = parcelHelpers.interopDefault(_listCacheJs);
var _mapJs = require("./_Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
        'hash': new _hashJsDefault.default,
        'map': new (_mapJsDefault.default || _listCacheJsDefault.default),
        'string': new _hashJsDefault.default
    };
}
exports.default = mapCacheClear;

},{"./_Hash.js":"1HkPM","./_ListCache.js":"cqhDQ","./_Map.js":"8spnB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1HkPM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hashClearJs = require("./_hashClear.js");
var _hashClearJsDefault = parcelHelpers.interopDefault(_hashClearJs);
var _hashDeleteJs = require("./_hashDelete.js");
var _hashDeleteJsDefault = parcelHelpers.interopDefault(_hashDeleteJs);
var _hashGetJs = require("./_hashGet.js");
var _hashGetJsDefault = parcelHelpers.interopDefault(_hashGetJs);
var _hashHasJs = require("./_hashHas.js");
var _hashHasJsDefault = parcelHelpers.interopDefault(_hashHasJs);
var _hashSetJs = require("./_hashSet.js");
var _hashSetJsDefault = parcelHelpers.interopDefault(_hashSetJs);
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `Hash`.
Hash.prototype.clear = _hashClearJsDefault.default;
Hash.prototype['delete'] = _hashDeleteJsDefault.default;
Hash.prototype.get = _hashGetJsDefault.default;
Hash.prototype.has = _hashHasJsDefault.default;
Hash.prototype.set = _hashSetJsDefault.default;
exports.default = Hash;

},{"./_hashClear.js":"5oLNs","./_hashDelete.js":"3Xo6B","./_hashGet.js":"j4Vuu","./_hashHas.js":"d5QIn","./_hashSet.js":"lQL69","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5oLNs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeCreateJs = require("./_nativeCreate.js");
var _nativeCreateJsDefault = parcelHelpers.interopDefault(_nativeCreateJs);
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = _nativeCreateJsDefault.default ? _nativeCreateJsDefault.default(null) : {
    };
    this.size = 0;
}
exports.default = hashClear;

},{"./_nativeCreate.js":"2XXd9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2XXd9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNativeJs = require("./_getNative.js");
var _getNativeJsDefault = parcelHelpers.interopDefault(_getNativeJs);
/* Built-in method references that are verified to be native. */ var nativeCreate = _getNativeJsDefault.default(Object, 'create');
exports.default = nativeCreate;

},{"./_getNative.js":"bQrQL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Xo6B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
}
exports.default = hashDelete;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j4Vuu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeCreateJs = require("./_nativeCreate.js");
var _nativeCreateJsDefault = parcelHelpers.interopDefault(_nativeCreateJs);
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (_nativeCreateJsDefault.default) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
exports.default = hashGet;

},{"./_nativeCreate.js":"2XXd9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d5QIn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeCreateJs = require("./_nativeCreate.js");
var _nativeCreateJsDefault = parcelHelpers.interopDefault(_nativeCreateJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return _nativeCreateJsDefault.default ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
exports.default = hashHas;

},{"./_nativeCreate.js":"2XXd9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lQL69":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeCreateJs = require("./_nativeCreate.js");
var _nativeCreateJsDefault = parcelHelpers.interopDefault(_nativeCreateJs);
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = _nativeCreateJsDefault.default && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
exports.default = hashSet;

},{"./_nativeCreate.js":"2XXd9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cqhDQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _listCacheClearJs = require("./_listCacheClear.js");
var _listCacheClearJsDefault = parcelHelpers.interopDefault(_listCacheClearJs);
var _listCacheDeleteJs = require("./_listCacheDelete.js");
var _listCacheDeleteJsDefault = parcelHelpers.interopDefault(_listCacheDeleteJs);
var _listCacheGetJs = require("./_listCacheGet.js");
var _listCacheGetJsDefault = parcelHelpers.interopDefault(_listCacheGetJs);
var _listCacheHasJs = require("./_listCacheHas.js");
var _listCacheHasJsDefault = parcelHelpers.interopDefault(_listCacheHasJs);
var _listCacheSetJs = require("./_listCacheSet.js");
var _listCacheSetJsDefault = parcelHelpers.interopDefault(_listCacheSetJs);
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `ListCache`.
ListCache.prototype.clear = _listCacheClearJsDefault.default;
ListCache.prototype['delete'] = _listCacheDeleteJsDefault.default;
ListCache.prototype.get = _listCacheGetJsDefault.default;
ListCache.prototype.has = _listCacheHasJsDefault.default;
ListCache.prototype.set = _listCacheSetJsDefault.default;
exports.default = ListCache;

},{"./_listCacheClear.js":"bSUq2","./_listCacheDelete.js":"3kM5j","./_listCacheGet.js":"9nv7v","./_listCacheHas.js":"4N5RL","./_listCacheSet.js":"bA8oX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bSUq2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
}
exports.default = listCacheClear;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3kM5j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assocIndexOfJs = require("./_assocIndexOf.js");
var _assocIndexOfJsDefault = parcelHelpers.interopDefault(_assocIndexOfJs);
/** Used for built-in method references. */ var arrayProto = Array.prototype;
/** Built-in value references. */ var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = _assocIndexOfJsDefault.default(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    --this.size;
    return true;
}
exports.default = listCacheDelete;

},{"./_assocIndexOf.js":"124Ga","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"124Ga":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eqJs = require("./eq.js");
var _eqJsDefault = parcelHelpers.interopDefault(_eqJs);
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (_eqJsDefault.default(array[length][0], key)) return length;
    }
    return -1;
}
exports.default = assocIndexOf;

},{"./eq.js":"7el3s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9nv7v":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assocIndexOfJs = require("./_assocIndexOf.js");
var _assocIndexOfJsDefault = parcelHelpers.interopDefault(_assocIndexOfJs);
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = _assocIndexOfJsDefault.default(data, key);
    return index < 0 ? undefined : data[index][1];
}
exports.default = listCacheGet;

},{"./_assocIndexOf.js":"124Ga","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4N5RL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assocIndexOfJs = require("./_assocIndexOf.js");
var _assocIndexOfJsDefault = parcelHelpers.interopDefault(_assocIndexOfJs);
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return _assocIndexOfJsDefault.default(this.__data__, key) > -1;
}
exports.default = listCacheHas;

},{"./_assocIndexOf.js":"124Ga","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bA8oX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assocIndexOfJs = require("./_assocIndexOf.js");
var _assocIndexOfJsDefault = parcelHelpers.interopDefault(_assocIndexOfJs);
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = _assocIndexOfJsDefault.default(data, key);
    if (index < 0) {
        ++this.size;
        data.push([
            key,
            value
        ]);
    } else data[index][1] = value;
    return this;
}
exports.default = listCacheSet;

},{"./_assocIndexOf.js":"124Ga","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8spnB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNativeJs = require("./_getNative.js");
var _getNativeJsDefault = parcelHelpers.interopDefault(_getNativeJs);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/* Built-in method references that are verified to be native. */ var Map = _getNativeJsDefault.default(_rootJsDefault.default, 'Map');
exports.default = Map;

},{"./_getNative.js":"bQrQL","./_root.js":"8yvCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eoP1L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getMapDataJs = require("./_getMapData.js");
var _getMapDataJsDefault = parcelHelpers.interopDefault(_getMapDataJs);
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    var result = _getMapDataJsDefault.default(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
}
exports.default = mapCacheDelete;

},{"./_getMapData.js":"3xzxe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3xzxe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isKeyableJs = require("./_isKeyable.js");
var _isKeyableJsDefault = parcelHelpers.interopDefault(_isKeyableJs);
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return _isKeyableJsDefault.default(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
exports.default = getMapData;

},{"./_isKeyable.js":"9O1jG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9O1jG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
exports.default = isKeyable;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lbrg6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getMapDataJs = require("./_getMapData.js");
var _getMapDataJsDefault = parcelHelpers.interopDefault(_getMapDataJs);
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return _getMapDataJsDefault.default(this, key).get(key);
}
exports.default = mapCacheGet;

},{"./_getMapData.js":"3xzxe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lPQeP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getMapDataJs = require("./_getMapData.js");
var _getMapDataJsDefault = parcelHelpers.interopDefault(_getMapDataJs);
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return _getMapDataJsDefault.default(this, key).has(key);
}
exports.default = mapCacheHas;

},{"./_getMapData.js":"3xzxe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4UIYE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getMapDataJs = require("./_getMapData.js");
var _getMapDataJsDefault = parcelHelpers.interopDefault(_getMapDataJs);
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    var data = _getMapDataJsDefault.default(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
}
exports.default = mapCacheSet;

},{"./_getMapData.js":"3xzxe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hF0LJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseToStringJs = require("./_baseToString.js");
var _baseToStringJsDefault = parcelHelpers.interopDefault(_baseToStringJs);
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */ function toString(value) {
    return value == null ? '' : _baseToStringJsDefault.default(value);
}
exports.default = toString;

},{"./_baseToString.js":"fQ5ds","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fQ5ds":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _symbolJs = require("./_Symbol.js");
var _symbolJsDefault = parcelHelpers.interopDefault(_symbolJs);
var _arrayMapJs = require("./_arrayMap.js");
var _arrayMapJsDefault = parcelHelpers.interopDefault(_arrayMapJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */ var symbolProto = _symbolJsDefault.default ? _symbolJsDefault.default.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */ function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') return value;
    if (_isArrayJsDefault.default(value)) // Recursively convert values (susceptible to call stack limits).
    return _arrayMapJsDefault.default(value, baseToString) + '';
    if (_isSymbolJsDefault.default(value)) return symbolToString ? symbolToString.call(value) : '';
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
exports.default = baseToString;

},{"./_Symbol.js":"jx216","./_arrayMap.js":"gDCVM","./isArray.js":"ETPQ1","./isSymbol.js":"gCyRJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gDCVM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */ function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while(++index < length)result[index] = iteratee(array[index], index, array);
    return result;
}
exports.default = arrayMap;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Zo68s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */ function toKey(value) {
    if (typeof value == 'string' || _isSymbolJsDefault.default(value)) return value;
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
exports.default = toKey;

},{"./isSymbol.js":"gCyRJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jfq4F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseHasInJs = require("./_baseHasIn.js");
var _baseHasInJsDefault = parcelHelpers.interopDefault(_baseHasInJs);
var _hasPathJs = require("./_hasPath.js");
var _hasPathJsDefault = parcelHelpers.interopDefault(_hasPathJs);
/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */ function hasIn(object, path) {
    return object != null && _hasPathJsDefault.default(object, path, _baseHasInJsDefault.default);
}
exports.default = hasIn;

},{"./_baseHasIn.js":"8Hqdk","./_hasPath.js":"lcHZs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Hqdk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */ function baseHasIn(object, key) {
    return object != null && key in Object(object);
}
exports.default = baseHasIn;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lcHZs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _castPathJs = require("./_castPath.js");
var _castPathJsDefault = parcelHelpers.interopDefault(_castPathJs);
var _isArgumentsJs = require("./isArguments.js");
var _isArgumentsJsDefault = parcelHelpers.interopDefault(_isArgumentsJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isIndexJs = require("./_isIndex.js");
var _isIndexJsDefault = parcelHelpers.interopDefault(_isIndexJs);
var _isLengthJs = require("./isLength.js");
var _isLengthJsDefault = parcelHelpers.interopDefault(_isLengthJs);
var _toKeyJs = require("./_toKey.js");
var _toKeyJsDefault = parcelHelpers.interopDefault(_toKeyJs);
/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */ function hasPath(object, path, hasFunc) {
    path = _castPathJsDefault.default(path, object);
    var index = -1, length = path.length, result = false;
    while(++index < length){
        var key = _toKeyJsDefault.default(path[index]);
        if (!(result = object != null && hasFunc(object, key))) break;
        object = object[key];
    }
    if (result || ++index != length) return result;
    length = object == null ? 0 : object.length;
    return !!length && _isLengthJsDefault.default(length) && _isIndexJsDefault.default(key, length) && (_isArrayJsDefault.default(object) || _isArgumentsJsDefault.default(object));
}
exports.default = hasPath;

},{"./_castPath.js":"g21zK","./isArguments.js":"9k91Y","./isArray.js":"ETPQ1","./_isIndex.js":"5DS1K","./isLength.js":"bItM0","./_toKey.js":"Zo68s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gArhC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _isObjectLikeJs = require("./isObjectLike.js");
var _isObjectLikeJsDefault = parcelHelpers.interopDefault(_isObjectLikeJs);
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */ function isArrayLikeObject(value) {
    return _isObjectLikeJsDefault.default(value) && _isArrayLikeJsDefault.default(value);
}
exports.default = isArrayLikeObject;

},{"./isArrayLike.js":"8SdiO","./isObjectLike.js":"iad76","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"llpEE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
var _stubFalseJs = require("./stubFalse.js");
var _stubFalseJsDefault = parcelHelpers.interopDefault(_stubFalseJs);
/** Detect free variable `exports`. */ var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */ var Buffer = moduleExports ? _rootJsDefault.default.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */ var isBuffer = nativeIsBuffer || _stubFalseJsDefault.default;
exports.default = isBuffer;

},{"./_root.js":"8yvCA","./stubFalse.js":"fF5mf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fF5mf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */ function stubFalse() {
    return false;
}
exports.default = stubFalse;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eNhTn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIsEqualJs = require("./_baseIsEqual.js");
var _baseIsEqualJsDefault = parcelHelpers.interopDefault(_baseIsEqualJs);
/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */ function isEqual(value, other) {
    return _baseIsEqualJsDefault.default(value, other);
}
exports.default = isEqual;

},{"./_baseIsEqual.js":"1zaYh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1zaYh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIsEqualDeepJs = require("./_baseIsEqualDeep.js");
var _baseIsEqualDeepJsDefault = parcelHelpers.interopDefault(_baseIsEqualDeepJs);
var _isObjectLikeJs = require("./isObjectLike.js");
var _isObjectLikeJsDefault = parcelHelpers.interopDefault(_isObjectLikeJs);
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */ function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) return true;
    if (value == null || other == null || !_isObjectLikeJsDefault.default(value) && !_isObjectLikeJsDefault.default(other)) return value !== value && other !== other;
    return _baseIsEqualDeepJsDefault.default(value, other, bitmask, customizer, baseIsEqual, stack);
}
exports.default = baseIsEqual;

},{"./_baseIsEqualDeep.js":"hBKuk","./isObjectLike.js":"iad76","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hBKuk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _stackJs = require("./_Stack.js");
var _stackJsDefault = parcelHelpers.interopDefault(_stackJs);
var _equalArraysJs = require("./_equalArrays.js");
var _equalArraysJsDefault = parcelHelpers.interopDefault(_equalArraysJs);
var _equalByTagJs = require("./_equalByTag.js");
var _equalByTagJsDefault = parcelHelpers.interopDefault(_equalByTagJs);
var _equalObjectsJs = require("./_equalObjects.js");
var _equalObjectsJsDefault = parcelHelpers.interopDefault(_equalObjectsJs);
var _getTagJs = require("./_getTag.js");
var _getTagJsDefault = parcelHelpers.interopDefault(_getTagJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isBufferJs = require("./isBuffer.js");
var _isBufferJsDefault = parcelHelpers.interopDefault(_isBufferJs);
var _isTypedArrayJs = require("./isTypedArray.js");
var _isTypedArrayJsDefault = parcelHelpers.interopDefault(_isTypedArrayJs);
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1;
/** `Object#toString` result references. */ var argsTag = '[object Arguments]', arrayTag = '[object Array]', objectTag = '[object Object]';
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = _isArrayJsDefault.default(object), othIsArr = _isArrayJsDefault.default(other), objTag = objIsArr ? arrayTag : _getTagJsDefault.default(object), othTag = othIsArr ? arrayTag : _getTagJsDefault.default(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && _isBufferJsDefault.default(object)) {
        if (!_isBufferJsDefault.default(other)) return false;
        objIsArr = true;
        objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
        stack || (stack = new _stackJsDefault.default);
        return objIsArr || _isTypedArrayJsDefault.default(object) ? _equalArraysJsDefault.default(object, other, bitmask, customizer, equalFunc, stack) : _equalByTagJsDefault.default(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
        if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new _stackJsDefault.default);
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
    }
    if (!isSameTag) return false;
    stack || (stack = new _stackJsDefault.default);
    return _equalObjectsJsDefault.default(object, other, bitmask, customizer, equalFunc, stack);
}
exports.default = baseIsEqualDeep;

},{"./_Stack.js":"dCpM5","./_equalArrays.js":"3xWWQ","./_equalByTag.js":"9KfIu","./_equalObjects.js":"7yAdV","./_getTag.js":"1kCom","./isArray.js":"ETPQ1","./isBuffer.js":"llpEE","./isTypedArray.js":"2LIMs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dCpM5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _listCacheJs = require("./_ListCache.js");
var _listCacheJsDefault = parcelHelpers.interopDefault(_listCacheJs);
var _stackClearJs = require("./_stackClear.js");
var _stackClearJsDefault = parcelHelpers.interopDefault(_stackClearJs);
var _stackDeleteJs = require("./_stackDelete.js");
var _stackDeleteJsDefault = parcelHelpers.interopDefault(_stackDeleteJs);
var _stackGetJs = require("./_stackGet.js");
var _stackGetJsDefault = parcelHelpers.interopDefault(_stackGetJs);
var _stackHasJs = require("./_stackHas.js");
var _stackHasJsDefault = parcelHelpers.interopDefault(_stackHasJs);
var _stackSetJs = require("./_stackSet.js");
var _stackSetJsDefault = parcelHelpers.interopDefault(_stackSetJs);
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Stack(entries) {
    var data = this.__data__ = new _listCacheJsDefault.default(entries);
    this.size = data.size;
}
// Add methods to `Stack`.
Stack.prototype.clear = _stackClearJsDefault.default;
Stack.prototype['delete'] = _stackDeleteJsDefault.default;
Stack.prototype.get = _stackGetJsDefault.default;
Stack.prototype.has = _stackHasJsDefault.default;
Stack.prototype.set = _stackSetJsDefault.default;
exports.default = Stack;

},{"./_ListCache.js":"cqhDQ","./_stackClear.js":"4BuA3","./_stackDelete.js":"2mGxC","./_stackGet.js":"c3cE4","./_stackHas.js":"23Sz6","./_stackSet.js":"jnSxK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4BuA3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _listCacheJs = require("./_ListCache.js");
var _listCacheJsDefault = parcelHelpers.interopDefault(_listCacheJs);
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */ function stackClear() {
    this.__data__ = new _listCacheJsDefault.default;
    this.size = 0;
}
exports.default = stackClear;

},{"./_ListCache.js":"cqhDQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2mGxC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function stackDelete(key) {
    var data = this.__data__, result = data['delete'](key);
    this.size = data.size;
    return result;
}
exports.default = stackDelete;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c3cE4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function stackGet(key) {
    return this.__data__.get(key);
}
exports.default = stackGet;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"23Sz6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function stackHas(key) {
    return this.__data__.has(key);
}
exports.default = stackHas;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jnSxK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _listCacheJs = require("./_ListCache.js");
var _listCacheJsDefault = parcelHelpers.interopDefault(_listCacheJs);
var _mapJs = require("./_Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _mapCacheJs = require("./_MapCache.js");
var _mapCacheJsDefault = parcelHelpers.interopDefault(_mapCacheJs);
/** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */ function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof _listCacheJsDefault.default) {
        var pairs = data.__data__;
        if (!_mapJsDefault.default || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            this.size = ++data.size;
            return this;
        }
        data = this.__data__ = new _mapCacheJsDefault.default(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
}
exports.default = stackSet;

},{"./_ListCache.js":"cqhDQ","./_Map.js":"8spnB","./_MapCache.js":"kdqbj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3xWWQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setCacheJs = require("./_SetCache.js");
var _setCacheJsDefault = parcelHelpers.interopDefault(_setCacheJs);
var _arraySomeJs = require("./_arraySome.js");
var _arraySomeJsDefault = parcelHelpers.interopDefault(_arraySomeJs);
var _cacheHasJs = require("./_cacheHas.js");
var _cacheHasJsDefault = parcelHelpers.interopDefault(_cacheHasJs);
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */ function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
    // Check that cyclic values are equal.
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) return arrStacked == other && othStacked == array;
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new _setCacheJsDefault.default : undefined;
    stack.set(array, other);
    stack.set(other, array);
    // Ignore non-index properties.
    while(++index < arrLength){
        var arrValue = array[index], othValue1 = other[index];
        if (customizer) var compared = isPartial ? customizer(othValue1, arrValue, index, other, array, stack) : customizer(arrValue, othValue1, index, array, other, stack);
        if (compared !== undefined) {
            if (compared) continue;
            result = false;
            break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
            if (!_arraySomeJsDefault.default(other, function(othValue, othIndex) {
                if (!_cacheHasJsDefault.default(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) return seen.push(othIndex);
            })) {
                result = false;
                break;
            }
        } else if (!(arrValue === othValue1 || equalFunc(arrValue, othValue1, bitmask, customizer, stack))) {
            result = false;
            break;
        }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
}
exports.default = equalArrays;

},{"./_SetCache.js":"6YwQx","./_arraySome.js":"9k95T","./_cacheHas.js":"jSrgN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6YwQx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapCacheJs = require("./_MapCache.js");
var _mapCacheJsDefault = parcelHelpers.interopDefault(_mapCacheJs);
var _setCacheAddJs = require("./_setCacheAdd.js");
var _setCacheAddJsDefault = parcelHelpers.interopDefault(_setCacheAddJs);
var _setCacheHasJs = require("./_setCacheHas.js");
var _setCacheHasJsDefault = parcelHelpers.interopDefault(_setCacheHasJs);
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */ function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new _mapCacheJsDefault.default;
    while(++index < length)this.add(values[index]);
}
// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = _setCacheAddJsDefault.default;
SetCache.prototype.has = _setCacheHasJsDefault.default;
exports.default = SetCache;

},{"./_MapCache.js":"kdqbj","./_setCacheAdd.js":"7m7Pn","./_setCacheHas.js":"BJklm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7m7Pn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */ function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
exports.default = setCacheAdd;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"BJklm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */ function setCacheHas(value) {
    return this.__data__.has(value);
}
exports.default = setCacheHas;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9k95T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */ function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while(++index < length){
        if (predicate(array[index], index, array)) return true;
    }
    return false;
}
exports.default = arraySome;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jSrgN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function cacheHas(cache, key) {
    return cache.has(key);
}
exports.default = cacheHas;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9KfIu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _symbolJs = require("./_Symbol.js");
var _symbolJsDefault = parcelHelpers.interopDefault(_symbolJs);
var _uint8ArrayJs = require("./_Uint8Array.js");
var _uint8ArrayJsDefault = parcelHelpers.interopDefault(_uint8ArrayJs);
var _eqJs = require("./eq.js");
var _eqJsDefault = parcelHelpers.interopDefault(_eqJs);
var _equalArraysJs = require("./_equalArrays.js");
var _equalArraysJsDefault = parcelHelpers.interopDefault(_equalArraysJs);
var _mapToArrayJs = require("./_mapToArray.js");
var _mapToArrayJsDefault = parcelHelpers.interopDefault(_mapToArrayJs);
var _setToArrayJs = require("./_setToArray.js");
var _setToArrayJsDefault = parcelHelpers.interopDefault(_setToArrayJs);
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
/** `Object#toString` result references. */ var boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', mapTag = '[object Map]', numberTag = '[object Number]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]';
/** Used to convert symbols to primitives and strings. */ var symbolProto = _symbolJsDefault.default ? _symbolJsDefault.default.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch(tag){
        case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;
            object = object.buffer;
            other = other.buffer;
        case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new _uint8ArrayJsDefault.default(object), new _uint8ArrayJsDefault.default(other))) return false;
            return true;
        case boolTag:
        case dateTag:
        case numberTag:
            // Coerce booleans to `1` or `0` and dates to milliseconds.
            // Invalid dates are coerced to `NaN`.
            return _eqJsDefault.default(+object, +other);
        case errorTag:
            return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
            // Coerce regexes to strings and treat strings, primitives and objects,
            // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
            // for more details.
            return object == other + '';
        case mapTag:
            var convert = _mapToArrayJsDefault.default;
        case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = _setToArrayJsDefault.default);
            if (object.size != other.size && !isPartial) return false;
            // Assume cyclic values are equal.
            var stacked = stack.get(object);
            if (stacked) return stacked == other;
            bitmask |= COMPARE_UNORDERED_FLAG;
            // Recursively compare objects (susceptible to call stack limits).
            stack.set(object, other);
            var result = _equalArraysJsDefault.default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack['delete'](object);
            return result;
        case symbolTag:
            if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
    }
    return false;
}
exports.default = equalByTag;

},{"./_Symbol.js":"jx216","./_Uint8Array.js":"5zVAV","./eq.js":"7el3s","./_equalArrays.js":"3xWWQ","./_mapToArray.js":"3RRCW","./_setToArray.js":"2ugef","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5zVAV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/** Built-in value references. */ var Uint8Array = _rootJsDefault.default.Uint8Array;
exports.default = Uint8Array;

},{"./_root.js":"8yvCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3RRCW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */ function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
exports.default = mapToArray;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2ugef":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */ function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
exports.default = setToArray;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7yAdV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getAllKeysJs = require("./_getAllKeys.js");
var _getAllKeysJsDefault = parcelHelpers.interopDefault(_getAllKeysJs);
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1;
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = _getAllKeysJsDefault.default(object), objLength = objProps.length, othProps = _getAllKeysJsDefault.default(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) return false;
    var index = objLength;
    while(index--){
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return false;
    }
    // Check that cyclic values are equal.
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) return objStacked == other && othStacked == object;
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while(++index < objLength){
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
        }
        skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) result = false;
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
}
exports.default = equalObjects;

},{"./_getAllKeys.js":"68ZDs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"68ZDs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseGetAllKeysJs = require("./_baseGetAllKeys.js");
var _baseGetAllKeysJsDefault = parcelHelpers.interopDefault(_baseGetAllKeysJs);
var _getSymbolsJs = require("./_getSymbols.js");
var _getSymbolsJsDefault = parcelHelpers.interopDefault(_getSymbolsJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */ function getAllKeys(object) {
    return _baseGetAllKeysJsDefault.default(object, _keysJsDefault.default, _getSymbolsJsDefault.default);
}
exports.default = getAllKeys;

},{"./_baseGetAllKeys.js":"jHmw2","./_getSymbols.js":"egqKq","./keys.js":"lbEZV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jHmw2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayPushJs = require("./_arrayPush.js");
var _arrayPushJsDefault = parcelHelpers.interopDefault(_arrayPushJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return _isArrayJsDefault.default(object) ? result : _arrayPushJsDefault.default(result, symbolsFunc(object));
}
exports.default = baseGetAllKeys;

},{"./_arrayPush.js":"4BTrx","./isArray.js":"ETPQ1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"egqKq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayFilterJs = require("./_arrayFilter.js");
var _arrayFilterJsDefault = parcelHelpers.interopDefault(_arrayFilterJs);
var _stubArrayJs = require("./stubArray.js");
var _stubArrayJsDefault = parcelHelpers.interopDefault(_stubArrayJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Built-in value references. */ var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbols = !nativeGetSymbols ? _stubArrayJsDefault.default : function(object) {
    if (object == null) return [];
    object = Object(object);
    return _arrayFilterJsDefault.default(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
    });
};
exports.default = getSymbols;

},{"./_arrayFilter.js":"iZqHX","./stubArray.js":"iwLLL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iZqHX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */ function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while(++index < length){
        var value = array[index];
        if (predicate(value, index, array)) result[resIndex++] = value;
    }
    return result;
}
exports.default = arrayFilter;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iwLLL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */ function stubArray() {
    return [];
}
exports.default = stubArray;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lbEZV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayLikeKeysJs = require("./_arrayLikeKeys.js");
var _arrayLikeKeysJsDefault = parcelHelpers.interopDefault(_arrayLikeKeysJs);
var _baseKeysJs = require("./_baseKeys.js");
var _baseKeysJsDefault = parcelHelpers.interopDefault(_baseKeysJs);
var _isArrayLikeJs = require("./isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */ function keys(object) {
    return _isArrayLikeJsDefault.default(object) ? _arrayLikeKeysJsDefault.default(object) : _baseKeysJsDefault.default(object);
}
exports.default = keys;

},{"./_arrayLikeKeys.js":"b4sHy","./_baseKeys.js":"7rx4g","./isArrayLike.js":"8SdiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b4sHy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseTimesJs = require("./_baseTimes.js");
var _baseTimesJsDefault = parcelHelpers.interopDefault(_baseTimesJs);
var _isArgumentsJs = require("./isArguments.js");
var _isArgumentsJsDefault = parcelHelpers.interopDefault(_isArgumentsJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isBufferJs = require("./isBuffer.js");
var _isBufferJsDefault = parcelHelpers.interopDefault(_isBufferJs);
var _isIndexJs = require("./_isIndex.js");
var _isIndexJsDefault = parcelHelpers.interopDefault(_isIndexJs);
var _isTypedArrayJs = require("./isTypedArray.js");
var _isTypedArrayJsDefault = parcelHelpers.interopDefault(_isTypedArrayJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    var isArr = _isArrayJsDefault.default(value), isArg = !isArr && _isArgumentsJsDefault.default(value), isBuff = !isArr && !isArg && _isBufferJsDefault.default(value), isType = !isArr && !isArg && !isBuff && _isTypedArrayJsDefault.default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? _baseTimesJsDefault.default(value.length, String) : [], length = result.length;
    for(var key in value)if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    _isIndexJsDefault.default(key, length)))) result.push(key);
    return result;
}
exports.default = arrayLikeKeys;

},{"./_baseTimes.js":"6yWeR","./isArguments.js":"9k91Y","./isArray.js":"ETPQ1","./isBuffer.js":"llpEE","./_isIndex.js":"5DS1K","./isTypedArray.js":"2LIMs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6yWeR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n)result[index] = iteratee(index);
    return result;
}
exports.default = baseTimes;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2LIMs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIsTypedArrayJs = require("./_baseIsTypedArray.js");
var _baseIsTypedArrayJsDefault = parcelHelpers.interopDefault(_baseIsTypedArrayJs);
var _baseUnaryJs = require("./_baseUnary.js");
var _baseUnaryJsDefault = parcelHelpers.interopDefault(_baseUnaryJs);
var _nodeUtilJs = require("./_nodeUtil.js");
var _nodeUtilJsDefault = parcelHelpers.interopDefault(_nodeUtilJs);
/* Node.js helper references. */ var nodeIsTypedArray = _nodeUtilJsDefault.default && _nodeUtilJsDefault.default.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */ var isTypedArray = nodeIsTypedArray ? _baseUnaryJsDefault.default(nodeIsTypedArray) : _baseIsTypedArrayJsDefault.default;
exports.default = isTypedArray;

},{"./_baseIsTypedArray.js":"jcEk3","./_baseUnary.js":"jBUGV","./_nodeUtil.js":"cxU0K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jcEk3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseGetTagJs = require("./_baseGetTag.js");
var _baseGetTagJsDefault = parcelHelpers.interopDefault(_baseGetTagJs);
var _isLengthJs = require("./isLength.js");
var _isLengthJsDefault = parcelHelpers.interopDefault(_isLengthJs);
var _isObjectLikeJs = require("./isObjectLike.js");
var _isObjectLikeJsDefault = parcelHelpers.interopDefault(_isObjectLikeJs);
/** `Object#toString` result references. */ var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */ var typedArrayTags = {
};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */ function baseIsTypedArray(value) {
    return _isObjectLikeJsDefault.default(value) && _isLengthJsDefault.default(value.length) && !!typedArrayTags[_baseGetTagJsDefault.default(value)];
}
exports.default = baseIsTypedArray;

},{"./_baseGetTag.js":"gVDfP","./isLength.js":"bItM0","./isObjectLike.js":"iad76","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jBUGV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */ function baseUnary(func) {
    return function(value) {
        return func(value);
    };
}
exports.default = baseUnary;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cxU0K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _freeGlobalJs = require("./_freeGlobal.js");
var _freeGlobalJsDefault = parcelHelpers.interopDefault(_freeGlobalJs);
/** Detect free variable `exports`. */ var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */ var freeProcess = moduleExports && _freeGlobalJsDefault.default.process;
/** Used to access faster Node.js helpers. */ var nodeUtil = function() {
    try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;
        if (types) return types;
        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {
    }
}();
exports.default = nodeUtil;

},{"./_freeGlobal.js":"98hMd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7rx4g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isPrototypeJs = require("./_isPrototype.js");
var _isPrototypeJsDefault = parcelHelpers.interopDefault(_isPrototypeJs);
var _nativeKeysJs = require("./_nativeKeys.js");
var _nativeKeysJsDefault = parcelHelpers.interopDefault(_nativeKeysJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeys(object) {
    if (!_isPrototypeJsDefault.default(object)) return _nativeKeysJsDefault.default(object);
    var result = [];
    for(var key in Object(object))if (hasOwnProperty.call(object, key) && key != 'constructor') result.push(key);
    return result;
}
exports.default = baseKeys;

},{"./_isPrototype.js":"jOAyW","./_nativeKeys.js":"4fIwW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jOAyW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
exports.default = isPrototype;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4fIwW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _overArgJs = require("./_overArg.js");
var _overArgJsDefault = parcelHelpers.interopDefault(_overArgJs);
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeKeys = _overArgJsDefault.default(Object.keys, Object);
exports.default = nativeKeys;

},{"./_overArg.js":"lqvyN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lqvyN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
exports.default = overArg;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1kCom":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _dataViewJs = require("./_DataView.js");
var _dataViewJsDefault = parcelHelpers.interopDefault(_dataViewJs);
var _mapJs = require("./_Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _promiseJs = require("./_Promise.js");
var _promiseJsDefault = parcelHelpers.interopDefault(_promiseJs);
var _setJs = require("./_Set.js");
var _setJsDefault = parcelHelpers.interopDefault(_setJs);
var _weakMapJs = require("./_WeakMap.js");
var _weakMapJsDefault = parcelHelpers.interopDefault(_weakMapJs);
var _baseGetTagJs = require("./_baseGetTag.js");
var _baseGetTagJsDefault = parcelHelpers.interopDefault(_baseGetTagJs);
var _toSourceJs = require("./_toSource.js");
var _toSourceJsDefault = parcelHelpers.interopDefault(_toSourceJs);
/** `Object#toString` result references. */ var mapTag = '[object Map]', objectTag = '[object Object]', promiseTag = '[object Promise]', setTag = '[object Set]', weakMapTag = '[object WeakMap]';
var dataViewTag = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = _toSourceJsDefault.default(_dataViewJsDefault.default), mapCtorString = _toSourceJsDefault.default(_mapJsDefault.default), promiseCtorString = _toSourceJsDefault.default(_promiseJsDefault.default), setCtorString = _toSourceJsDefault.default(_setJsDefault.default), weakMapCtorString = _toSourceJsDefault.default(_weakMapJsDefault.default);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ var getTag = _baseGetTagJsDefault.default;
// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if (_dataViewJsDefault.default && getTag(new _dataViewJsDefault.default(new ArrayBuffer(1))) != dataViewTag || _mapJsDefault.default && getTag(new _mapJsDefault.default) != mapTag || _promiseJsDefault.default && getTag(_promiseJsDefault.default.resolve()) != promiseTag || _setJsDefault.default && getTag(new _setJsDefault.default) != setTag || _weakMapJsDefault.default && getTag(new _weakMapJsDefault.default) != weakMapTag) getTag = function(value) {
    var result = _baseGetTagJsDefault.default(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? _toSourceJsDefault.default(Ctor) : '';
    if (ctorString) switch(ctorString){
        case dataViewCtorString:
            return dataViewTag;
        case mapCtorString:
            return mapTag;
        case promiseCtorString:
            return promiseTag;
        case setCtorString:
            return setTag;
        case weakMapCtorString:
            return weakMapTag;
    }
    return result;
};
exports.default = getTag;

},{"./_DataView.js":"4SeGN","./_Map.js":"8spnB","./_Promise.js":"lbYHf","./_Set.js":"jf3T7","./_WeakMap.js":"52eE0","./_baseGetTag.js":"gVDfP","./_toSource.js":"4wd66","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4SeGN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNativeJs = require("./_getNative.js");
var _getNativeJsDefault = parcelHelpers.interopDefault(_getNativeJs);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/* Built-in method references that are verified to be native. */ var DataView = _getNativeJsDefault.default(_rootJsDefault.default, 'DataView');
exports.default = DataView;

},{"./_getNative.js":"bQrQL","./_root.js":"8yvCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lbYHf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNativeJs = require("./_getNative.js");
var _getNativeJsDefault = parcelHelpers.interopDefault(_getNativeJs);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/* Built-in method references that are verified to be native. */ var Promise = _getNativeJsDefault.default(_rootJsDefault.default, 'Promise');
exports.default = Promise;

},{"./_getNative.js":"bQrQL","./_root.js":"8yvCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jf3T7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNativeJs = require("./_getNative.js");
var _getNativeJsDefault = parcelHelpers.interopDefault(_getNativeJs);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/* Built-in method references that are verified to be native. */ var Set = _getNativeJsDefault.default(_rootJsDefault.default, 'Set');
exports.default = Set;

},{"./_getNative.js":"bQrQL","./_root.js":"8yvCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kwvYw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _basePropertyJs = require("./_baseProperty.js");
var _basePropertyJsDefault = parcelHelpers.interopDefault(_basePropertyJs);
var _basePropertyDeepJs = require("./_basePropertyDeep.js");
var _basePropertyDeepJsDefault = parcelHelpers.interopDefault(_basePropertyDeepJs);
var _isKeyJs = require("./_isKey.js");
var _isKeyJsDefault = parcelHelpers.interopDefault(_isKeyJs);
var _toKeyJs = require("./_toKey.js");
var _toKeyJsDefault = parcelHelpers.interopDefault(_toKeyJs);
/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */ function property(path) {
    return _isKeyJsDefault.default(path) ? _basePropertyJsDefault.default(_toKeyJsDefault.default(path)) : _basePropertyDeepJsDefault.default(path);
}
exports.default = property;

},{"./_baseProperty.js":"gAjZk","./_basePropertyDeep.js":"1xKss","./_isKey.js":"h7SfK","./_toKey.js":"Zo68s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gAjZk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */ function baseProperty(key) {
    return function(object) {
        return object == null ? undefined : object[key];
    };
}
exports.default = baseProperty;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1xKss":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseGetJs = require("./_baseGet.js");
var _baseGetJsDefault = parcelHelpers.interopDefault(_baseGetJs);
/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */ function basePropertyDeep(path) {
    return function(object) {
        return _baseGetJsDefault.default(object, path);
    };
}
exports.default = basePropertyDeep;

},{"./_baseGet.js":"3IUaj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2xup9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createRangeJs = require("./_createRange.js");
var _createRangeJsDefault = parcelHelpers.interopDefault(_createRangeJs);
/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */ var range = _createRangeJsDefault.default();
exports.default = range;

},{"./_createRange.js":"h5MaG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h5MaG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseRangeJs = require("./_baseRange.js");
var _baseRangeJsDefault = parcelHelpers.interopDefault(_baseRangeJs);
var _isIterateeCallJs = require("./_isIterateeCall.js");
var _isIterateeCallJsDefault = parcelHelpers.interopDefault(_isIterateeCallJs);
var _toFiniteJs = require("./toFinite.js");
var _toFiniteJsDefault = parcelHelpers.interopDefault(_toFiniteJs);
/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */ function createRange(fromRight) {
    return function(start, end, step) {
        if (step && typeof step != 'number' && _isIterateeCallJsDefault.default(start, end, step)) end = step = undefined;
        // Ensure the sign of `-0` is preserved.
        start = _toFiniteJsDefault.default(start);
        if (end === undefined) {
            end = start;
            start = 0;
        } else end = _toFiniteJsDefault.default(end);
        step = step === undefined ? start < end ? 1 : -1 : _toFiniteJsDefault.default(step);
        return _baseRangeJsDefault.default(start, end, step, fromRight);
    };
}
exports.default = createRange;

},{"./_baseRange.js":"1twHx","./_isIterateeCall.js":"1jM1r","./toFinite.js":"FJR8i","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1twHx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeCeil = Math.ceil, nativeMax = Math.max;
/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */ function baseRange(start, end, step, fromRight) {
    var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
    while(length--){
        result[fromRight ? length : ++index] = start;
        start += step;
    }
    return result;
}
exports.default = baseRange;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b6mtE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arraySampleJs = require("./_arraySample.js");
var _arraySampleJsDefault = parcelHelpers.interopDefault(_arraySampleJs);
var _baseSampleJs = require("./_baseSample.js");
var _baseSampleJsDefault = parcelHelpers.interopDefault(_baseSampleJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
/**
 * Gets a random element from `collection`.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to sample.
 * @returns {*} Returns the random element.
 * @example
 *
 * _.sample([1, 2, 3, 4]);
 * // => 2
 */ function sample(collection) {
    var func = _isArrayJsDefault.default(collection) ? _arraySampleJsDefault.default : _baseSampleJsDefault.default;
    return func(collection);
}
exports.default = sample;

},{"./_arraySample.js":"fmRSg","./_baseSample.js":"cX3Ks","./isArray.js":"ETPQ1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fmRSg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseRandomJs = require("./_baseRandom.js");
var _baseRandomJsDefault = parcelHelpers.interopDefault(_baseRandomJs);
/**
 * A specialized version of `_.sample` for arrays.
 *
 * @private
 * @param {Array} array The array to sample.
 * @returns {*} Returns the random element.
 */ function arraySample(array) {
    var length = array.length;
    return length ? array[_baseRandomJsDefault.default(0, length - 1)] : undefined;
}
exports.default = arraySample;

},{"./_baseRandom.js":"kestZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kestZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeFloor = Math.floor, nativeRandom = Math.random;
/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */ function baseRandom(lower, upper) {
    return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
}
exports.default = baseRandom;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cX3Ks":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arraySampleJs = require("./_arraySample.js");
var _arraySampleJsDefault = parcelHelpers.interopDefault(_arraySampleJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
/**
 * The base implementation of `_.sample`.
 *
 * @private
 * @param {Array|Object} collection The collection to sample.
 * @returns {*} Returns the random element.
 */ function baseSample(collection) {
    return _arraySampleJsDefault.default(_valuesJsDefault.default(collection));
}
exports.default = baseSample;

},{"./_arraySample.js":"fmRSg","./values.js":"bjkOg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bjkOg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseValuesJs = require("./_baseValues.js");
var _baseValuesJsDefault = parcelHelpers.interopDefault(_baseValuesJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */ function values(object) {
    return object == null ? [] : _baseValuesJsDefault.default(object, _keysJsDefault.default(object));
}
exports.default = values;

},{"./_baseValues.js":"6sg61","./keys.js":"lbEZV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6sg61":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayMapJs = require("./_arrayMap.js");
var _arrayMapJsDefault = parcelHelpers.interopDefault(_arrayMapJs);
/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */ function baseValues(object, props) {
    return _arrayMapJsDefault.default(props, function(key) {
        return object[key];
    });
}
exports.default = baseValues;

},{"./_arrayMap.js":"gDCVM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"42BZ9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseFlattenJs = require("./_baseFlatten.js");
var _baseFlattenJsDefault = parcelHelpers.interopDefault(_baseFlattenJs);
var _baseOrderByJs = require("./_baseOrderBy.js");
var _baseOrderByJsDefault = parcelHelpers.interopDefault(_baseOrderByJs);
var _baseRestJs = require("./_baseRest.js");
var _baseRestJsDefault = parcelHelpers.interopDefault(_baseRestJs);
var _isIterateeCallJs = require("./_isIterateeCall.js");
var _isIterateeCallJsDefault = parcelHelpers.interopDefault(_isIterateeCallJs);
/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 30 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
 */ var sortBy = _baseRestJsDefault.default(function(collection, iteratees) {
    if (collection == null) return [];
    var length = iteratees.length;
    if (length > 1 && _isIterateeCallJsDefault.default(collection, iteratees[0], iteratees[1])) iteratees = [];
    else if (length > 2 && _isIterateeCallJsDefault.default(iteratees[0], iteratees[1], iteratees[2])) iteratees = [
        iteratees[0]
    ];
    return _baseOrderByJsDefault.default(collection, _baseFlattenJsDefault.default(iteratees, 1), []);
});
exports.default = sortBy;

},{"./_baseFlatten.js":"92emb","./_baseOrderBy.js":"eLjrn","./_baseRest.js":"1fKJX","./_isIterateeCall.js":"1jM1r","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eLjrn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayMapJs = require("./_arrayMap.js");
var _arrayMapJsDefault = parcelHelpers.interopDefault(_arrayMapJs);
var _baseGetJs = require("./_baseGet.js");
var _baseGetJsDefault = parcelHelpers.interopDefault(_baseGetJs);
var _baseIterateeJs = require("./_baseIteratee.js");
var _baseIterateeJsDefault = parcelHelpers.interopDefault(_baseIterateeJs);
var _baseMapJs = require("./_baseMap.js");
var _baseMapJsDefault = parcelHelpers.interopDefault(_baseMapJs);
var _baseSortByJs = require("./_baseSortBy.js");
var _baseSortByJsDefault = parcelHelpers.interopDefault(_baseSortByJs);
var _baseUnaryJs = require("./_baseUnary.js");
var _baseUnaryJsDefault = parcelHelpers.interopDefault(_baseUnaryJs);
var _compareMultipleJs = require("./_compareMultiple.js");
var _compareMultipleJsDefault = parcelHelpers.interopDefault(_compareMultipleJs);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */ function baseOrderBy(collection, iteratees, orders) {
    if (iteratees.length) iteratees = _arrayMapJsDefault.default(iteratees, function(iteratee) {
        if (_isArrayJsDefault.default(iteratee)) return function(value) {
            return _baseGetJsDefault.default(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        };
        return iteratee;
    });
    else iteratees = [
        _identityJsDefault.default
    ];
    var index = -1;
    iteratees = _arrayMapJsDefault.default(iteratees, _baseUnaryJsDefault.default(_baseIterateeJsDefault.default));
    var result = _baseMapJsDefault.default(collection, function(value, key, collection) {
        var criteria = _arrayMapJsDefault.default(iteratees, function(iteratee) {
            return iteratee(value);
        });
        return {
            'criteria': criteria,
            'index': ++index,
            'value': value
        };
    });
    return _baseSortByJsDefault.default(result, function(object, other) {
        return _compareMultipleJsDefault.default(object, other, orders);
    });
}
exports.default = baseOrderBy;

},{"./_arrayMap.js":"gDCVM","./_baseGet.js":"3IUaj","./_baseIteratee.js":"48kCP","./_baseMap.js":"eHrfS","./_baseSortBy.js":"h9y0s","./_baseUnary.js":"jBUGV","./_compareMultiple.js":"3O3PE","./identity.js":"1Y0KA","./isArray.js":"ETPQ1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"48kCP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseMatchesJs = require("./_baseMatches.js");
var _baseMatchesJsDefault = parcelHelpers.interopDefault(_baseMatchesJs);
var _baseMatchesPropertyJs = require("./_baseMatchesProperty.js");
var _baseMatchesPropertyJsDefault = parcelHelpers.interopDefault(_baseMatchesPropertyJs);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _propertyJs = require("./property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */ function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') return value;
    if (value == null) return _identityJsDefault.default;
    if (typeof value == 'object') return _isArrayJsDefault.default(value) ? _baseMatchesPropertyJsDefault.default(value[0], value[1]) : _baseMatchesJsDefault.default(value);
    return _propertyJsDefault.default(value);
}
exports.default = baseIteratee;

},{"./_baseMatches.js":"6vwVM","./_baseMatchesProperty.js":"4hv6L","./identity.js":"1Y0KA","./isArray.js":"ETPQ1","./property.js":"kwvYw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6vwVM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIsMatchJs = require("./_baseIsMatch.js");
var _baseIsMatchJsDefault = parcelHelpers.interopDefault(_baseIsMatchJs);
var _getMatchDataJs = require("./_getMatchData.js");
var _getMatchDataJsDefault = parcelHelpers.interopDefault(_getMatchDataJs);
var _matchesStrictComparableJs = require("./_matchesStrictComparable.js");
var _matchesStrictComparableJsDefault = parcelHelpers.interopDefault(_matchesStrictComparableJs);
/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */ function baseMatches(source) {
    var matchData = _getMatchDataJsDefault.default(source);
    if (matchData.length == 1 && matchData[0][2]) return _matchesStrictComparableJsDefault.default(matchData[0][0], matchData[0][1]);
    return function(object) {
        return object === source || _baseIsMatchJsDefault.default(object, source, matchData);
    };
}
exports.default = baseMatches;

},{"./_baseIsMatch.js":"519lF","./_getMatchData.js":"2HQJS","./_matchesStrictComparable.js":"19Pwe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"519lF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _stackJs = require("./_Stack.js");
var _stackJsDefault = parcelHelpers.interopDefault(_stackJs);
var _baseIsEqualJs = require("./_baseIsEqual.js");
var _baseIsEqualJsDefault = parcelHelpers.interopDefault(_baseIsEqualJs);
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */ function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length = index, noCustomizer = !customizer;
    if (object == null) return !length;
    object = Object(object);
    while(index--){
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return false;
    }
    while(++index < length){
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
            if (objValue === undefined && !(key in object)) return false;
        } else {
            var stack = new _stackJsDefault.default;
            if (customizer) var result = customizer(objValue, srcValue, key, object, source, stack);
            if (!(result === undefined ? _baseIsEqualJsDefault.default(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) return false;
        }
    }
    return true;
}
exports.default = baseIsMatch;

},{"./_Stack.js":"dCpM5","./_baseIsEqual.js":"1zaYh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2HQJS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isStrictComparableJs = require("./_isStrictComparable.js");
var _isStrictComparableJsDefault = parcelHelpers.interopDefault(_isStrictComparableJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */ function getMatchData(object) {
    var result = _keysJsDefault.default(object), length = result.length;
    while(length--){
        var key = result[length], value = object[key];
        result[length] = [
            key,
            value,
            _isStrictComparableJsDefault.default(value)
        ];
    }
    return result;
}
exports.default = getMatchData;

},{"./_isStrictComparable.js":"ksPGX","./keys.js":"lbEZV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ksPGX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */ function isStrictComparable(value) {
    return value === value && !_isObjectJsDefault.default(value);
}
exports.default = isStrictComparable;

},{"./isObject.js":"dHhyW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"19Pwe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */ function matchesStrictComparable(key, srcValue) {
    return function(object) {
        if (object == null) return false;
        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
}
exports.default = matchesStrictComparable;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4hv6L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIsEqualJs = require("./_baseIsEqual.js");
var _baseIsEqualJsDefault = parcelHelpers.interopDefault(_baseIsEqualJs);
var _getJs = require("./get.js");
var _getJsDefault = parcelHelpers.interopDefault(_getJs);
var _hasInJs = require("./hasIn.js");
var _hasInJsDefault = parcelHelpers.interopDefault(_hasInJs);
var _isKeyJs = require("./_isKey.js");
var _isKeyJsDefault = parcelHelpers.interopDefault(_isKeyJs);
var _isStrictComparableJs = require("./_isStrictComparable.js");
var _isStrictComparableJsDefault = parcelHelpers.interopDefault(_isStrictComparableJs);
var _matchesStrictComparableJs = require("./_matchesStrictComparable.js");
var _matchesStrictComparableJsDefault = parcelHelpers.interopDefault(_matchesStrictComparableJs);
var _toKeyJs = require("./_toKey.js");
var _toKeyJsDefault = parcelHelpers.interopDefault(_toKeyJs);
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */ function baseMatchesProperty(path, srcValue) {
    if (_isKeyJsDefault.default(path) && _isStrictComparableJsDefault.default(srcValue)) return _matchesStrictComparableJsDefault.default(_toKeyJsDefault.default(path), srcValue);
    return function(object) {
        var objValue = _getJsDefault.default(object, path);
        return objValue === undefined && objValue === srcValue ? _hasInJsDefault.default(object, path) : _baseIsEqualJsDefault.default(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
}
exports.default = baseMatchesProperty;

},{"./_baseIsEqual.js":"1zaYh","./get.js":"9ZP5X","./hasIn.js":"jfq4F","./_isKey.js":"h7SfK","./_isStrictComparable.js":"ksPGX","./_matchesStrictComparable.js":"19Pwe","./_toKey.js":"Zo68s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eHrfS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseEachJs = require("./_baseEach.js");
var _baseEachJsDefault = parcelHelpers.interopDefault(_baseEachJs);
var _isArrayLikeJs = require("./isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */ function baseMap(collection1, iteratee) {
    var index = -1, result = _isArrayLikeJsDefault.default(collection1) ? Array(collection1.length) : [];
    _baseEachJsDefault.default(collection1, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
    });
    return result;
}
exports.default = baseMap;

},{"./_baseEach.js":"cgTz5","./isArrayLike.js":"8SdiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cgTz5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseForOwnJs = require("./_baseForOwn.js");
var _baseForOwnJsDefault = parcelHelpers.interopDefault(_baseForOwnJs);
var _createBaseEachJs = require("./_createBaseEach.js");
var _createBaseEachJsDefault = parcelHelpers.interopDefault(_createBaseEachJs);
/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */ var baseEach = _createBaseEachJsDefault.default(_baseForOwnJsDefault.default);
exports.default = baseEach;

},{"./_baseForOwn.js":"bGCTn","./_createBaseEach.js":"5mXl9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bGCTn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseForJs = require("./_baseFor.js");
var _baseForJsDefault = parcelHelpers.interopDefault(_baseForJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */ function baseForOwn(object, iteratee) {
    return object && _baseForJsDefault.default(object, iteratee, _keysJsDefault.default);
}
exports.default = baseForOwn;

},{"./_baseFor.js":"1Zprl","./keys.js":"lbEZV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Zprl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createBaseForJs = require("./_createBaseFor.js");
var _createBaseForJsDefault = parcelHelpers.interopDefault(_createBaseForJs);
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */ var baseFor = _createBaseForJsDefault.default();
exports.default = baseFor;

},{"./_createBaseFor.js":"1W89a","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1W89a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */ function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while(length--){
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) break;
        }
        return object;
    };
}
exports.default = createBaseFor;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5mXl9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */ function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
        if (collection == null) return collection;
        if (!_isArrayLikeJsDefault.default(collection)) return eachFunc(collection, iteratee);
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while(fromRight ? index-- : ++index < length){
            if (iteratee(iterable[index], index, iterable) === false) break;
        }
        return collection;
    };
}
exports.default = createBaseEach;

},{"./isArrayLike.js":"8SdiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h9y0s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */ function baseSortBy(array, comparer) {
    var length = array.length;
    array.sort(comparer);
    while(length--)array[length] = array[length].value;
    return array;
}
exports.default = baseSortBy;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3O3PE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _compareAscendingJs = require("./_compareAscending.js");
var _compareAscendingJsDefault = parcelHelpers.interopDefault(_compareAscendingJs);
/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */ function compareMultiple(object, other, orders) {
    var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
    while(++index < length){
        var result = _compareAscendingJsDefault.default(objCriteria[index], othCriteria[index]);
        if (result) {
            if (index >= ordersLength) return result;
            var order = orders[index];
            return result * (order == 'desc' ? -1 : 1);
        }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
}
exports.default = compareMultiple;

},{"./_compareAscending.js":"3NsI7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3NsI7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */ function compareAscending(value, other) {
    if (value !== other) {
        var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = _isSymbolJsDefault.default(value);
        var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = _isSymbolJsDefault.default(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) return 1;
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1;
    }
    return 0;
}
exports.default = compareAscending;

},{"./isSymbol.js":"gCyRJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1fKJX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _overRestJs = require("./_overRest.js");
var _overRestJsDefault = parcelHelpers.interopDefault(_overRestJs);
var _setToStringJs = require("./_setToString.js");
var _setToStringJsDefault = parcelHelpers.interopDefault(_setToStringJs);
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */ function baseRest(func, start) {
    return _setToStringJsDefault.default(_overRestJsDefault.default(func, start, _identityJsDefault.default), func + '');
}
exports.default = baseRest;

},{"./identity.js":"1Y0KA","./_overRest.js":"d1Uaz","./_setToString.js":"3GXSg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"feLWk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseSumJs = require("./_baseSum.js");
var _baseSumJsDefault = parcelHelpers.interopDefault(_baseSumJs);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
/**
 * Computes the sum of the values in `array`.
 *
 * @static
 * @memberOf _
 * @since 3.4.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {number} Returns the sum.
 * @example
 *
 * _.sum([4, 2, 8, 6]);
 * // => 20
 */ function sum(array) {
    return array && array.length ? _baseSumJsDefault.default(array, _identityJsDefault.default) : 0;
}
exports.default = sum;

},{"./_baseSum.js":"fLeWk","./identity.js":"1Y0KA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fLeWk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.sum` and `_.sumBy` without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the sum.
 */ function baseSum(array, iteratee) {
    var result, index = -1, length = array.length;
    while(++index < length){
        var current = iteratee(array[index]);
        if (current !== undefined) result = result === undefined ? current : result + current;
    }
    return result;
}
exports.default = baseSum;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"57kq6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseUniqJs = require("./_baseUniq.js");
var _baseUniqJsDefault = parcelHelpers.interopDefault(_baseUniqJs);
/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */ function uniq(array) {
    return array && array.length ? _baseUniqJsDefault.default(array) : [];
}
exports.default = uniq;

},{"./_baseUniq.js":"g6Jw9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g6Jw9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setCacheJs = require("./_SetCache.js");
var _setCacheJsDefault = parcelHelpers.interopDefault(_setCacheJs);
var _arrayIncludesJs = require("./_arrayIncludes.js");
var _arrayIncludesJsDefault = parcelHelpers.interopDefault(_arrayIncludesJs);
var _arrayIncludesWithJs = require("./_arrayIncludesWith.js");
var _arrayIncludesWithJsDefault = parcelHelpers.interopDefault(_arrayIncludesWithJs);
var _cacheHasJs = require("./_cacheHas.js");
var _cacheHasJsDefault = parcelHelpers.interopDefault(_cacheHasJs);
var _createSetJs = require("./_createSet.js");
var _createSetJsDefault = parcelHelpers.interopDefault(_createSetJs);
var _setToArrayJs = require("./_setToArray.js");
var _setToArrayJsDefault = parcelHelpers.interopDefault(_setToArrayJs);
/** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;
/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */ function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = _arrayIncludesJsDefault.default, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
        isCommon = false;
        includes = _arrayIncludesWithJsDefault.default;
    } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : _createSetJsDefault.default(array);
        if (set) return _setToArrayJsDefault.default(set);
        isCommon = false;
        includes = _cacheHasJsDefault.default;
        seen = new _setCacheJsDefault.default;
    } else seen = iteratee ? [] : result;
    outer: while(++index < length){
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while(seenIndex--){
                if (seen[seenIndex] === computed) continue outer;
            }
            if (iteratee) seen.push(computed);
            result.push(value);
        } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) seen.push(computed);
            result.push(value);
        }
    }
    return result;
}
exports.default = baseUniq;

},{"./_SetCache.js":"6YwQx","./_arrayIncludes.js":"b8a5u","./_arrayIncludesWith.js":"bGuRD","./_cacheHas.js":"jSrgN","./_createSet.js":"6FD4V","./_setToArray.js":"2ugef","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b8a5u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIndexOfJs = require("./_baseIndexOf.js");
var _baseIndexOfJsDefault = parcelHelpers.interopDefault(_baseIndexOfJs);
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && _baseIndexOfJsDefault.default(array, value, 0) > -1;
}
exports.default = arrayIncludes;

},{"./_baseIndexOf.js":"5Q55M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Q55M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseFindIndexJs = require("./_baseFindIndex.js");
var _baseFindIndexJsDefault = parcelHelpers.interopDefault(_baseFindIndexJs);
var _baseIsNaNJs = require("./_baseIsNaN.js");
var _baseIsNaNJsDefault = parcelHelpers.interopDefault(_baseIsNaNJs);
var _strictIndexOfJs = require("./_strictIndexOf.js");
var _strictIndexOfJsDefault = parcelHelpers.interopDefault(_strictIndexOfJs);
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseIndexOf(array, value, fromIndex) {
    return value === value ? _strictIndexOfJsDefault.default(array, value, fromIndex) : _baseFindIndexJsDefault.default(array, _baseIsNaNJsDefault.default, fromIndex);
}
exports.default = baseIndexOf;

},{"./_baseFindIndex.js":"12Lgh","./_baseIsNaN.js":"3FBze","./_strictIndexOf.js":"dm4sG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"12Lgh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while(fromRight ? index-- : ++index < length){
        if (predicate(array[index], index, array)) return index;
    }
    return -1;
}
exports.default = baseFindIndex;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3FBze":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */ function baseIsNaN(value) {
    return value !== value;
}
exports.default = baseIsNaN;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dm4sG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while(++index < length){
        if (array[index] === value) return index;
    }
    return -1;
}
exports.default = strictIndexOf;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bGuRD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array == null ? 0 : array.length;
    while(++index < length){
        if (comparator(value, array[index])) return true;
    }
    return false;
}
exports.default = arrayIncludesWith;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6FD4V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setJs = require("./_Set.js");
var _setJsDefault = parcelHelpers.interopDefault(_setJs);
var _noopJs = require("./noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var _setToArrayJs = require("./_setToArray.js");
var _setToArrayJsDefault = parcelHelpers.interopDefault(_setToArrayJs);
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */ var createSet = !(_setJsDefault.default && 1 / _setToArrayJsDefault.default(new _setJsDefault.default([
    ,
    -0
]))[1] == INFINITY) ? _noopJsDefault.default : function(values) {
    return new _setJsDefault.default(values);
};
exports.default = createSet;

},{"./_Set.js":"jf3T7","./noop.js":"9q6VJ","./_setToArray.js":"2ugef","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eZnwu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIterateeJs = require("./_baseIteratee.js");
var _baseIterateeJsDefault = parcelHelpers.interopDefault(_baseIterateeJs);
var _baseUniqJs = require("./_baseUniq.js");
var _baseUniqJsDefault = parcelHelpers.interopDefault(_baseUniqJs);
/**
 * This method is like `_.uniq` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * uniqueness is computed. The order of result values is determined by the
 * order they occur in the array. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
 * // => [2.1, 1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */ function uniqBy(array, iteratee) {
    return array && array.length ? _baseUniqJsDefault.default(array, _baseIterateeJsDefault.default(iteratee, 2)) : [];
}
exports.default = uniqBy;

},{"./_baseIteratee.js":"48kCP","./_baseUniq.js":"g6Jw9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6UDxA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseUniqJs = require("./_baseUniq.js");
var _baseUniqJsDefault = parcelHelpers.interopDefault(_baseUniqJs);
/**
 * This method is like `_.uniq` except that it accepts `comparator` which
 * is invoked to compare elements of `array`. The order of result values is
 * determined by the order they occur in the array.The comparator is invoked
 * with two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.uniqWith(objects, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 */ function uniqWith(array, comparator) {
    comparator = typeof comparator == 'function' ? comparator : undefined;
    return array && array.length ? _baseUniqJsDefault.default(array, undefined, comparator) : [];
}
exports.default = uniqWith;

},{"./_baseUniq.js":"g6Jw9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j1DxS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayFilterJs = require("./_arrayFilter.js");
var _arrayFilterJsDefault = parcelHelpers.interopDefault(_arrayFilterJs);
var _arrayMapJs = require("./_arrayMap.js");
var _arrayMapJsDefault = parcelHelpers.interopDefault(_arrayMapJs);
var _basePropertyJs = require("./_baseProperty.js");
var _basePropertyJsDefault = parcelHelpers.interopDefault(_basePropertyJs);
var _baseTimesJs = require("./_baseTimes.js");
var _baseTimesJsDefault = parcelHelpers.interopDefault(_baseTimesJs);
var _isArrayLikeObjectJs = require("./isArrayLikeObject.js");
var _isArrayLikeObjectJsDefault = parcelHelpers.interopDefault(_isArrayLikeObjectJs);
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max;
/**
 * This method is like `_.zip` except that it accepts an array of grouped
 * elements and creates an array regrouping the elements to their pre-zip
 * configuration.
 *
 * @static
 * @memberOf _
 * @since 1.2.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @returns {Array} Returns the new array of regrouped elements.
 * @example
 *
 * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
 * // => [['a', 1, true], ['b', 2, false]]
 *
 * _.unzip(zipped);
 * // => [['a', 'b'], [1, 2], [true, false]]
 */ function unzip(array) {
    if (!(array && array.length)) return [];
    var length = 0;
    array = _arrayFilterJsDefault.default(array, function(group) {
        if (_isArrayLikeObjectJsDefault.default(group)) {
            length = nativeMax(group.length, length);
            return true;
        }
    });
    return _baseTimesJsDefault.default(length, function(index) {
        return _arrayMapJsDefault.default(array, _basePropertyJsDefault.default(index));
    });
}
exports.default = unzip;

},{"./_arrayFilter.js":"iZqHX","./_arrayMap.js":"gDCVM","./_baseProperty.js":"gAjZk","./_baseTimes.js":"6yWeR","./isArrayLikeObject.js":"gArhC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bc76B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _applyJs = require("./_apply.js");
var _applyJsDefault = parcelHelpers.interopDefault(_applyJs);
var _arrayMapJs = require("./_arrayMap.js");
var _arrayMapJsDefault = parcelHelpers.interopDefault(_arrayMapJs);
var _unzipJs = require("./unzip.js");
var _unzipJsDefault = parcelHelpers.interopDefault(_unzipJs);
/**
 * This method is like `_.unzip` except that it accepts `iteratee` to specify
 * how regrouped values should be combined. The iteratee is invoked with the
 * elements of each group: (...group).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @param {Function} [iteratee=_.identity] The function to combine
 *  regrouped values.
 * @returns {Array} Returns the new array of regrouped elements.
 * @example
 *
 * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
 * // => [[1, 10, 100], [2, 20, 200]]
 *
 * _.unzipWith(zipped, _.add);
 * // => [3, 30, 300]
 */ function unzipWith(array, iteratee) {
    if (!(array && array.length)) return [];
    var result = _unzipJsDefault.default(array);
    if (iteratee == null) return result;
    return _arrayMapJsDefault.default(result, function(group) {
        return _applyJsDefault.default(iteratee, undefined, group);
    });
}
exports.default = unzipWith;

},{"./_apply.js":"kqJ3H","./_arrayMap.js":"gDCVM","./unzip.js":"j1DxS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1agvX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseRestJs = require("./_baseRest.js");
var _baseRestJsDefault = parcelHelpers.interopDefault(_baseRestJs);
var _unzipWithJs = require("./unzipWith.js");
var _unzipWithJsDefault = parcelHelpers.interopDefault(_unzipWithJs);
/**
 * This method is like `_.zip` except that it accepts `iteratee` to specify
 * how grouped values should be combined. The iteratee is invoked with the
 * elements of each group: (...group).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Array
 * @param {...Array} [arrays] The arrays to process.
 * @param {Function} [iteratee=_.identity] The function to combine
 *  grouped values.
 * @returns {Array} Returns the new array of grouped elements.
 * @example
 *
 * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
 *   return a + b + c;
 * });
 * // => [111, 222]
 */ var zipWith = _baseRestJsDefault.default(function(arrays) {
    var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
    iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
    return _unzipWithJsDefault.default(arrays, iteratee);
});
exports.default = zipWith;

},{"./_baseRest.js":"1fKJX","./unzipWith.js":"bc76B","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3WkEt":[function(require,module,exports) {
'use strict';
module.exports = angleNormals;
function hypot(x, y, z) {
    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
}
function weight(s, r, a) {
    return Math.atan2(r, s - a);
}
function mulAdd(dest, s, x, y, z) {
    dest[0] += s * x;
    dest[1] += s * y;
    dest[2] += s * z;
}
function angleNormals(cells, positions) {
    var numVerts = positions.length;
    var numCells = cells.length;
    //Allocate normal array
    var normals = new Array(numVerts);
    for(var i = 0; i < numVerts; ++i)normals[i] = [
        0,
        0,
        0
    ];
    //Scan cells, and
    for(var i = 0; i < numCells; ++i){
        var cell = cells[i];
        var a = positions[cell[0]];
        var b = positions[cell[1]];
        var c = positions[cell[2]];
        var abx = a[0] - b[0];
        var aby = a[1] - b[1];
        var abz = a[2] - b[2];
        var ab = hypot(abx, aby, abz);
        var bcx = b[0] - c[0];
        var bcy = b[1] - c[1];
        var bcz = b[2] - c[2];
        var bc = hypot(bcx, bcy, bcz);
        var cax = c[0] - a[0];
        var cay = c[1] - a[1];
        var caz = c[2] - a[2];
        var ca = hypot(cax, cay, caz);
        if (Math.min(ab, bc, ca) < 0.000001) continue;
        var s = 0.5 * (ab + bc + ca);
        var r = Math.sqrt((s - ab) * (s - bc) * (s - ca) / s);
        var nx = aby * bcz - abz * bcy;
        var ny = abz * bcx - abx * bcz;
        var nz = abx * bcy - aby * bcx;
        var nl = hypot(nx, ny, nz);
        nx /= nl;
        ny /= nl;
        nz /= nl;
        mulAdd(normals[cell[0]], weight(s, r, bc), nx, ny, nz);
        mulAdd(normals[cell[1]], weight(s, r, ca), nx, ny, nz);
        mulAdd(normals[cell[2]], weight(s, r, ab), nx, ny, nz);
    }
    //Normalize all the normals
    for(var i = 0; i < numVerts; ++i){
        var n = normals[i];
        var l = Math.sqrt(Math.pow(n[0], 2) + Math.pow(n[1], 2) + Math.pow(n[2], 2));
        if (l < 0.00000001) {
            n[0] = 1;
            n[1] = 0;
            n[2] = 0;
            continue;
        }
        n[0] /= l;
        n[1] /= l;
        n[2] /= l;
    }
    return normals;
}

},{}],"9J7Dv":[function(require,module,exports) {
// Data Structure
exports.Edge = require("./mda/Core/Edge.js");
exports.HalfEdge = require("./mda/Core/HalfEdge.js");
exports.Vertex = require("./mda/Core/Vertex.js");
exports.Face = require("./mda/Core/Face.js");
exports.Mesh = require("./mda/Core/Mesh.js");
// Checks
exports.Integrity = require("./mda/Integrity/Integrity.js");
exports.MeshIntegrity = require("./mda/Integrity/MeshIntegrity.js");
exports.FaceIntegrity = require("./mda/Integrity/FaceIntegrity.js");
exports.EdgeIntegrity = require("./mda/Integrity/EdgeIntegrity.js");
exports.HalfEdgeIntegrity = require("./mda/Integrity/HalfEdgeIntegrity.js");
exports.VertexIntegrity = require("./mda/Integrity/VertexIntegrity.js");
// Queries
exports.HalfEdgePrev = require("./mda/Queries/HalfEdgePrev.js");
exports.EdgeVertices = require("./mda/Queries/EdgeVertices.js");
exports.FaceHalfEdges = require("./mda/Queries/FaceHalfEdges.js");
exports.FaceVertices = require("./mda/Queries/FaceVertices.js");
exports.VertexFaces = require("./mda/Queries/VertexFaces.js");
exports.VertexHalfEdges = require("./mda/Queries/VertexHalfEdges.js");
exports.VertexNeighbors = require("./mda/Queries/VertexNeighbors.js");
exports.MeshCentroid = require("./mda/Queries/MeshCentroid.js");
// Operators
exports.InsertVertexOperator = require("./mda/Operators/InsertVertex.js");
exports.InsertEdgeOperator = require("./mda/Operators/InsertEdge.js");
exports.DeleteEdgeOperator = require("./mda/Operators/DeleteEdge.js");
exports.LoopOperator = require("./mda/Operators/Loop.js");
exports.CatmullClarkOperator = require("./mda/Operators/CatmullClark.js");
exports.QuadSubdivideOperator = require("./mda/Operators/QuadSubdivide.js");
exports.TriangulateOperator = require("./mda/Operators/Triangulate.js");
exports.ExtrudeOperator = require('./mda/Operators/Extrude.js');
exports.PipeOperator = require('./mda/Operators/Pipe.js');
exports.DuplicateOperator = require('./mda/Operators/Duplicate.js');
exports.CombineOperator = require('./mda/Operators/Combine.js');
exports.ScaleOperator = require('./mda/Operators/Scale.js');
exports.MoveOperator = require('./mda/Operators/Move.js');
exports.InvertOperator = require('./mda/Operators/Invert.js');
exports.WireframeOperator = require('./mda/Operators/Wireframe.js');
exports.CreateFaceOperator = require('./mda/Operators/CreateFace.js');
// Generator
exports.ProfileGenerator = require("./mda/Generators/Profile.js");

},{"./mda/Core/Edge.js":"dOHcN","./mda/Core/HalfEdge.js":"72nec","./mda/Core/Vertex.js":"aMW4R","./mda/Core/Face.js":"fVwz7","./mda/Core/Mesh.js":"lGuYv","./mda/Integrity/Integrity.js":"ePOBu","./mda/Integrity/MeshIntegrity.js":"bU9N9","./mda/Integrity/FaceIntegrity.js":"aJGqU","./mda/Integrity/EdgeIntegrity.js":"bJZiZ","./mda/Integrity/HalfEdgeIntegrity.js":"hnjcF","./mda/Integrity/VertexIntegrity.js":"gBmpk","./mda/Queries/HalfEdgePrev.js":"lRsPN","./mda/Queries/EdgeVertices.js":"2K4CD","./mda/Queries/FaceHalfEdges.js":"eum8y","./mda/Queries/FaceVertices.js":"elyLX","./mda/Queries/VertexFaces.js":"gqIAR","./mda/Queries/VertexHalfEdges.js":"8DhJJ","./mda/Queries/VertexNeighbors.js":"f9YBN","./mda/Queries/MeshCentroid.js":"kKwVL","./mda/Operators/InsertVertex.js":"aoQ2o","./mda/Operators/InsertEdge.js":"e3H1k","./mda/Operators/DeleteEdge.js":"69uv4","./mda/Operators/Loop.js":"5MnuS","./mda/Operators/CatmullClark.js":"cnkNJ","./mda/Operators/QuadSubdivide.js":"dLOrr","./mda/Operators/Triangulate.js":"1FODs","./mda/Operators/Extrude.js":"bARYg","./mda/Operators/Pipe.js":"7E3Pw","./mda/Operators/Duplicate.js":"5Bekj","./mda/Operators/Combine.js":"1rKhw","./mda/Operators/Scale.js":"ggWoq","./mda/Operators/Move.js":"iT2PL","./mda/Operators/Invert.js":"dwfab","./mda/Operators/Wireframe.js":"fEWOP","./mda/Operators/CreateFace.js":"lxPIU","./mda/Generators/Profile.js":"7Nhm8"}],"dOHcN":[function(require,module,exports) {
function Edge() {
    this.halfEdge = undefined;
    this.index = -1;
}
Edge.prototype.setIndex = function(index) {
    this.index = index;
};
Edge.prototype.getIndex = function() {
    return this.index;
};
Edge.prototype.setHalfEdge = function(halfEdge) {
    this.halfEdge = halfEdge;
};
Edge.prototype.getHalfEdge = function() {
    return this.halfEdge;
};
module.exports = Edge;

},{}],"72nec":[function(require,module,exports) {
function HalfEdge() {
    this.nextHalfEdge = undefined; // points to the next halfedge around the current face (CCW)
    this.flipHalfEdge = undefined; // points to the other halfedge associated with this edge
    this.vertex = undefined; // points to the vertex at the "tail" of this halfedge
    this.edge = undefined; // points to the edge associated with this halfedge
    this.face = undefined; // points to the face containing this halfedge  
}
HalfEdge.prototype.setVertex = function(vertex) {
    this.vertex = vertex;
};
HalfEdge.prototype.getVertex = function() {
    return this.vertex;
};
HalfEdge.prototype.setFace = function(face) {
    this.face = face;
};
HalfEdge.prototype.getFace = function() {
    return this.face;
};
HalfEdge.prototype.setEdge = function(edge) {
    this.edge = edge;
};
HalfEdge.prototype.getEdge = function() {
    return this.edge;
};
HalfEdge.prototype.setNextHalfEdge = function(nextHalfEdge) {
    this.nextHalfEdge = nextHalfEdge;
};
HalfEdge.prototype.getNextHalfEdge = function() {
    return this.nextHalfEdge;
};
HalfEdge.prototype.setFlipHalfEdge = function(flipHalfEdge) {
    this.flipHalfEdge = flipHalfEdge;
};
HalfEdge.prototype.getFlipHalfEdge = function() {
    return this.flipHalfEdge;
};
HalfEdge.prototype.onBoundary = function() {
    if (this.getFlipHalfEdge()) return false;
    return true;
};
module.exports = HalfEdge;

},{}],"aMW4R":[function(require,module,exports) {
var vec3 = require('gl-matrix').vec3;
function Vertex() {
    this.halfEdge = undefined;
    this.index = -1;
}
Vertex.prototype.setIndex = function(index) {
    this.index = index;
};
Vertex.prototype.getIndex = function() {
    return this.index;
};
Vertex.prototype.setHalfEdge = function(halfEdge) {
    this.halfEdge = halfEdge;
};
Vertex.prototype.getHalfEdge = function() {
    return this.halfEdge;
};
module.exports = Vertex;

},{"gl-matrix":"3TXam"}],"3TXam":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "glMatrix", ()=>_commonJs
);
parcelHelpers.export(exports, "mat2", ()=>_mat2Js
);
parcelHelpers.export(exports, "mat2d", ()=>_mat2DJs
);
parcelHelpers.export(exports, "mat3", ()=>_mat3Js
);
parcelHelpers.export(exports, "mat4", ()=>_mat4Js
);
parcelHelpers.export(exports, "quat", ()=>_quatJs
);
parcelHelpers.export(exports, "quat2", ()=>_quat2Js
);
parcelHelpers.export(exports, "vec2", ()=>_vec2Js
);
parcelHelpers.export(exports, "vec3", ()=>_vec3Js
);
parcelHelpers.export(exports, "vec4", ()=>_vec4Js
);
var _commonJs = require("./gl-matrix/common.js");
var _mat2Js = require("./gl-matrix/mat2.js");
var _mat2DJs = require("./gl-matrix/mat2d.js");
var _mat3Js = require("./gl-matrix/mat3.js");
var _mat4Js = require("./gl-matrix/mat4.js");
var _quatJs = require("./gl-matrix/quat.js");
var _quat2Js = require("./gl-matrix/quat2.js");
var _vec2Js = require("./gl-matrix/vec2.js");
var _vec3Js = require("./gl-matrix/vec3.js");
var _vec4Js = require("./gl-matrix/vec4.js");

},{"./gl-matrix/common.js":"iRm9m","./gl-matrix/mat2.js":"i2DYt","./gl-matrix/mat2d.js":"8BNZN","./gl-matrix/mat3.js":"a3LaH","./gl-matrix/mat4.js":"jXHYx","./gl-matrix/quat.js":"8nyyw","./gl-matrix/quat2.js":"4kivg","./gl-matrix/vec2.js":"gQ8Wp","./gl-matrix/vec3.js":"kunHs","./gl-matrix/vec4.js":"1kX6y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iRm9m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EPSILON", ()=>EPSILON
);
parcelHelpers.export(exports, "ARRAY_TYPE", ()=>ARRAY_TYPE
);
parcelHelpers.export(exports, "RANDOM", ()=>RANDOM
);
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */ parcelHelpers.export(exports, "setMatrixArrayType", ()=>setMatrixArrayType
);
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */ parcelHelpers.export(exports, "toRadian", ()=>toRadian
);
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
function setMatrixArrayType(type) {
    ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
function toRadian(a) {
    return a * degree;
}
function equals(a, b) {
    return Math.abs(a - b) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i2DYt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 2x2 Matrix
 * @module mat2
 */ /**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "transpose", ()=>transpose
);
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "adjoint", ()=>adjoint
);
/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */ parcelHelpers.export(exports, "determinant", ()=>determinant
);
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "fromScaling", ()=>fromScaling
);
/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */ parcelHelpers.export(exports, "frob", ()=>frob
);
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */ parcelHelpers.export(exports, "LDU", ()=>LDU
);
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "multiplyScalar", ()=>multiplyScalar
);
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "multiplyScalarAndAdd", ()=>multiplyScalarAndAdd
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "sub", ()=>sub
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(4);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
    }
    out[0] = 1;
    out[3] = 1;
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
}
function fromValues(m00, m01, m10, m11) {
    var out = new _commonJs.ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
}
function set(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
}
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache
    // some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    return out;
}
function invert(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    // Calculate the determinant
    var det = a0 * a3 - a2 * a1;
    if (!det) return null;
    det = 1 / det;
    out[0] = a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] = a0 * det;
    return out;
}
function adjoint(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] = a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a0;
    return out;
}
function determinant(a) {
    return a[0] * a[3] - a[2] * a[1];
}
function multiply(out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
}
function rotate(out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
}
function scale(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
}
function fromRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}
function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}
function str(a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
}
function LDU(L, D, U, a) {
    L[2] = a[2] / a[0];
    U[0] = a[0];
    U[1] = a[1];
    U[3] = a[3] - L[2] * U[1];
    return [
        L,
        D,
        U
    ];
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
}
function multiplyScalarAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    return out;
}
var mul = multiply;
var sub = subtract;

},{"./common.js":"iRm9m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8BNZN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */ /**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */ parcelHelpers.export(exports, "determinant", ()=>determinant
);
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "fromScaling", ()=>fromScaling
);
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "fromTranslation", ()=>fromTranslation
);
/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */ parcelHelpers.export(exports, "frob", ()=>frob
);
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "multiplyScalar", ()=>multiplyScalar
);
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "multiplyScalarAndAdd", ()=>multiplyScalarAndAdd
);
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "sub", ()=>sub
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(6);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[4] = 0;
        out[5] = 0;
    }
    out[0] = 1;
    out[3] = 1;
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
}
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
}
function fromValues(a, b, c, d, tx, ty) {
    var out = new _commonJs.ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
}
function set(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
}
function invert(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3];
    var atx = a[4], aty = a[5];
    var det = aa * ad - ab * ac;
    if (!det) return null;
    det = 1 / det;
    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
}
function determinant(a) {
    return a[0] * a[3] - a[1] * a[2];
}
function multiply(out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
}
function rotate(out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
}
function scale(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
}
function translate(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
}
function fromRotation(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}
function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}
function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}
function str(a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}
function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
}
function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
}
function multiplyScalarAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    out[4] = a[4] + b[4] * scale1;
    out[5] = a[5] + b[5] * scale1;
    return out;
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _commonJs.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _commonJs.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5));
}
var mul = multiply;
var sub = subtract;

},{"./common.js":"iRm9m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a3LaH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 3x3 Matrix
 * @module mat3
 */ /**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "fromMat4", ()=>fromMat4
);
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "transpose", ()=>transpose
);
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "adjoint", ()=>adjoint
);
/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */ parcelHelpers.export(exports, "determinant", ()=>determinant
);
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "fromTranslation", ()=>fromTranslation
);
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "fromScaling", ()=>fromScaling
);
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/ parcelHelpers.export(exports, "fromMat2d", ()=>fromMat2d
);
/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/ parcelHelpers.export(exports, "fromQuat", ()=>fromQuat
);
/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/ parcelHelpers.export(exports, "normalFromMat4", ()=>normalFromMat4
);
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "projection", ()=>projection
);
/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */ parcelHelpers.export(exports, "frob", ()=>frob
);
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "multiplyScalar", ()=>multiplyScalar
);
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "multiplyScalarAndAdd", ()=>multiplyScalarAndAdd
);
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "sub", ()=>sub
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(9);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
}
function fromMat4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new _commonJs.ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
}
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
}
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    return out;
}
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    // Calculate the determinant
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) return null;
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
}
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
}
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
}
function translate(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
}
function rotate(out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
}
function scale(out, a, v) {
    var x = v[0], y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
}
function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}
function fromRotation(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}
function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}
function fromMat2d(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;
    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;
    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
}
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
}
function normalFromMat4(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    // Calculate the determinant
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) return null;
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
}
function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
}
function str(a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}
function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
}
function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
}
function multiplyScalarAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    out[4] = a[4] + b[4] * scale1;
    out[5] = a[5] + b[5] * scale1;
    out[6] = a[6] + b[6] * scale1;
    out[7] = a[7] + b[7] * scale1;
    out[8] = a[8] + b[8] * scale1;
    return out;
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _commonJs.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _commonJs.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _commonJs.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _commonJs.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _commonJs.EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul = multiply;
var sub = subtract;

},{"./common.js":"iRm9m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jXHYx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */ /**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "transpose", ()=>transpose
);
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "adjoint", ()=>adjoint
);
/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */ parcelHelpers.export(exports, "determinant", ()=>determinant
);
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromTranslation", ()=>fromTranslation
);
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromScaling", ()=>fromScaling
);
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromXRotation", ()=>fromXRotation
);
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromYRotation", ()=>fromYRotation
);
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromZRotation", ()=>fromZRotation
);
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromRotationTranslation", ()=>fromRotationTranslation
);
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */ parcelHelpers.export(exports, "fromQuat2", ()=>fromQuat2
);
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */ parcelHelpers.export(exports, "getTranslation", ()=>getTranslation
);
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */ parcelHelpers.export(exports, "getScaling", ()=>getScaling
);
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */ parcelHelpers.export(exports, "getRotation", ()=>getRotation
);
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromRotationTranslationScale", ()=>fromRotationTranslationScale
);
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromRotationTranslationScaleOrigin", ()=>fromRotationTranslationScaleOrigin
);
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromQuat", ()=>fromQuat
);
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "frustum", ()=>frustum
);
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "perspective", ()=>perspective
);
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "perspectiveFromFieldOfView", ()=>perspectiveFromFieldOfView
);
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "ortho", ()=>ortho
);
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "lookAt", ()=>lookAt
);
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "targetTo", ()=>targetTo
);
/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */ parcelHelpers.export(exports, "frob", ()=>frob
);
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "multiplyScalar", ()=>multiplyScalar
);
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "multiplyScalarAndAdd", ()=>multiplyScalarAndAdd
);
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "sub", ()=>sub
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(16);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new _commonJs.ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
}
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
}
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3];
        var a12 = a[6], a13 = a[7];
        var a23 = a[11];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    return out;
}
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    // Calculate the determinant
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) return null;
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
}
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
}
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    // Cache only the current line of the second matrix
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
}
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    var a00 = void 0, a01 = void 0, a02 = void 0, a03 = void 0;
    var a10 = void 0, a11 = void 0, a12 = void 0, a13 = void 0;
    var a20 = void 0, a21 = void 0, a22 = void 0, a23 = void 0;
    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0];
        a01 = a[1];
        a02 = a[2];
        a03 = a[3];
        a10 = a[4];
        a11 = a[5];
        a12 = a[6];
        a13 = a[7];
        a20 = a[8];
        a21 = a[9];
        a22 = a[10];
        a23 = a[11];
        out[0] = a00;
        out[1] = a01;
        out[2] = a02;
        out[3] = a03;
        out[4] = a10;
        out[5] = a11;
        out[6] = a12;
        out[7] = a13;
        out[8] = a20;
        out[9] = a21;
        out[10] = a22;
        out[11] = a23;
        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
}
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len = Math.sqrt(x * x + y * y + z * z);
    var s = void 0, c = void 0, t = void 0;
    var a00 = void 0, a01 = void 0, a02 = void 0, a03 = void 0;
    var a10 = void 0, a11 = void 0, a12 = void 0, a13 = void 0;
    var a20 = void 0, a21 = void 0, a22 = void 0, a23 = void 0;
    var b00 = void 0, b01 = void 0, b02 = void 0;
    var b10 = void 0, b11 = void 0, b12 = void 0;
    var b20 = void 0, b21 = void 0, b22 = void 0;
    if (len < _commonJs.EPSILON) return null;
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    // Construct the elements of the rotation matrix
    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c;
    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
        // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
}
function rotateX(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
}
function rotateY(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
}
function rotateZ(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged last row
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
}
function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromRotation(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len = Math.sqrt(x * x + y * y + z * z);
    var s = void 0, c = void 0, t = void 0;
    if (len < _commonJs.EPSILON) return null;
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromXRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    // Perform axis-specific matrix multiplication
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromYRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    // Perform axis-specific matrix multiplication
    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromZRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    // Perform axis-specific matrix multiplication
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function fromQuat2(out, a) {
    var translation = new _commonJs.ARRAY_TYPE(3);
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw;
    //Only scale if it makes sense
    if (magnitude > 0) {
        translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
        translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
        translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
        translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
        translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
        translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    fromRotationTranslation(out, a, translation);
    return out;
}
function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
}
function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    return out;
}
function getRotation(out, mat) {
    // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    var trace = mat[0] + mat[5] + mat[10];
    var S = 0;
    if (trace > 0) {
        S = Math.sqrt(trace + 1) * 2;
        out[3] = 0.25 * S;
        out[0] = (mat[6] - mat[9]) / S;
        out[1] = (mat[8] - mat[2]) / S;
        out[2] = (mat[1] - mat[4]) / S;
    } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
        S = Math.sqrt(1 + mat[0] - mat[5] - mat[10]) * 2;
        out[3] = (mat[6] - mat[9]) / S;
        out[0] = 0.25 * S;
        out[1] = (mat[1] + mat[4]) / S;
        out[2] = (mat[8] + mat[2]) / S;
    } else if (mat[5] > mat[10]) {
        S = Math.sqrt(1 + mat[5] - mat[0] - mat[10]) * 2;
        out[3] = (mat[8] - mat[2]) / S;
        out[0] = (mat[1] + mat[4]) / S;
        out[1] = 0.25 * S;
        out[2] = (mat[6] + mat[9]) / S;
    } else {
        S = Math.sqrt(1 + mat[10] - mat[0] - mat[5]) * 2;
        out[3] = (mat[1] - mat[4]) / S;
        out[0] = (mat[8] + mat[2]) / S;
        out[1] = (mat[6] + mat[9]) / S;
        out[2] = 0.25 * S;
    }
    return out;
}
function fromRotationTranslationScale(out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
}
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
}
function perspective(out, fovy, aspect, near, far) {
    var f = 1 / Math.tan(fovy / 2), nf = void 0;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
        nf = 1 / (near - far);
        out[10] = (far + near) * nf;
        out[14] = 2 * far * near * nf;
    } else {
        out[10] = -1;
        out[14] = -2 * near;
    }
    return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    var xScale = 2 / (leftTan + rightTan);
    var yScale = 2 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = yScale;
    out[6] = 0;
    out[7] = 0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near / (near - far);
    out[15] = 0;
    return out;
}
function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
}
function lookAt(out, eye, center, up) {
    var x0 = void 0, x1 = void 0, x2 = void 0, y0 = void 0, y1 = void 0, y2 = void 0, z0 = void 0, z1 = void 0, z2 = void 0, len = void 0;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];
    if (Math.abs(eyex - centerx) < _commonJs.EPSILON && Math.abs(eyey - centery) < _commonJs.EPSILON && Math.abs(eyez - centerz) < _commonJs.EPSILON) return identity(out);
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
}
function targetTo(out, eye, target, up) {
    var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
    var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
    var len = z0 * z0 + z1 * z1 + z2 * z2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        z0 *= len;
        z1 *= len;
        z2 *= len;
    }
    var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
}
function str(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}
function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
}
function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
}
function multiplyScalarAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    out[4] = a[4] + b[4] * scale1;
    out[5] = a[5] + b[5] * scale1;
    out[6] = a[6] + b[6] * scale1;
    out[7] = a[7] + b[7] * scale1;
    out[8] = a[8] + b[8] * scale1;
    out[9] = a[9] + b[9] * scale1;
    out[10] = a[10] + b[10] * scale1;
    out[11] = a[11] + b[11] * scale1;
    out[12] = a[12] + b[12] * scale1;
    out[13] = a[13] + b[13] * scale1;
    out[14] = a[14] + b[14] * scale1;
    out[15] = a[15] + b[15] * scale1;
    return out;
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
    var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
    var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
    var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _commonJs.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _commonJs.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _commonJs.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _commonJs.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _commonJs.EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _commonJs.EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _commonJs.EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _commonJs.EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _commonJs.EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _commonJs.EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _commonJs.EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _commonJs.EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul = multiply;
var sub = subtract;

},{"./common.js":"iRm9m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8nyyw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Quaternion
 * @module quat
 */ /**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/ parcelHelpers.export(exports, "setAxisAngle", ()=>setAxisAngle
);
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */ parcelHelpers.export(exports, "getAxisAngle", ()=>getAxisAngle
);
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */ parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */ parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */ parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */ parcelHelpers.export(exports, "calculateW", ()=>calculateW
);
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */ parcelHelpers.export(exports, "slerp", ()=>slerp
);
/**
 * Generates a random quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */ parcelHelpers.export(exports, "random", ()=>random
);
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */ parcelHelpers.export(exports, "conjugate", ()=>conjugate
);
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */ parcelHelpers.export(exports, "fromMat3", ()=>fromMat3
);
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */ parcelHelpers.export(exports, "fromEuler", ()=>fromEuler
);
/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */ parcelHelpers.export(exports, "str", ()=>str
);
parcelHelpers.export(exports, "clone", ()=>clone
);
parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
parcelHelpers.export(exports, "copy", ()=>copy
);
parcelHelpers.export(exports, "set", ()=>set
);
parcelHelpers.export(exports, "add", ()=>add
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "scale", ()=>scale
);
parcelHelpers.export(exports, "dot", ()=>dot
);
parcelHelpers.export(exports, "lerp", ()=>lerp
);
parcelHelpers.export(exports, "length", ()=>length
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
parcelHelpers.export(exports, "normalize", ()=>normalize
);
parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "rotationTo", ()=>rotationTo
);
parcelHelpers.export(exports, "sqlerp", ()=>sqlerp
);
parcelHelpers.export(exports, "setAxes", ()=>setAxes
);
var _commonJs = require("./common.js");
var _mat3Js = require("./mat3.js");
var _vec3Js = require("./vec3.js");
var _vec4Js = require("./vec4.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(4);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
    }
    out[3] = 1;
    return out;
}
function identity(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
}
function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
}
function getAxisAngle(out_axis, q) {
    var rad = Math.acos(q[3]) * 2;
    var s = Math.sin(rad / 2);
    if (s > _commonJs.EPSILON) {
        out_axis[0] = q[0] / s;
        out_axis[1] = q[1] / s;
        out_axis[2] = q[2] / s;
    } else {
        // If s is zero, return any axis (no rotation - axis does not matter)
        out_axis[0] = 1;
        out_axis[1] = 0;
        out_axis[2] = 0;
    }
    return rad;
}
function multiply(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
}
function rotateX(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
}
function rotateY(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var by = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
}
function rotateZ(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bz = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
}
function calculateW(out, a) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
    return out;
}
function slerp(out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    var omega = void 0, cosom = void 0, sinom = void 0, scale0 = void 0, scale1 = void 0;
    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if (cosom < 0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
    }
    // calculate coefficients
    if (1 - cosom > _commonJs.EPSILON) {
        // standard case (slerp)
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {
        // "from" and "to" quaternions are very close
        //  ... so we can do a linear interpolation
        scale0 = 1 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
}
function random(out) {
    // Implementation of http://planning.cs.uiuc.edu/node198.html
    // TODO: Calling random 3 times is probably not the fastest solution
    var u1 = _commonJs.RANDOM();
    var u2 = _commonJs.RANDOM();
    var u3 = _commonJs.RANDOM();
    var sqrt1MinusU1 = Math.sqrt(1 - u1);
    var sqrtU1 = Math.sqrt(u1);
    out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
    out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
    out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
    out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
    return out;
}
function invert(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var dot1 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
    var invDot = dot1 ? 1 / dot1 : 0;
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a2 * invDot;
    out[3] = a3 * invDot;
    return out;
}
function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
}
function fromMat3(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot = void 0;
    if (fTrace > 0) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1); // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot; // 1/(4w)
        out[0] = (m[5] - m[7]) * fRoot;
        out[1] = (m[6] - m[2]) * fRoot;
        out[2] = (m[1] - m[3]) * fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if (m[4] > m[0]) i = 1;
        if (m[8] > m[i * 3 + i]) i = 2;
        var j = (i + 1) % 3;
        var k = (i + 2) % 3;
        fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
        out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
        out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }
    return out;
}
function fromEuler(out, x, y, z) {
    var halfToRad = 0.5 * Math.PI / 180;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
}
function str(a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
var clone = _vec4Js.clone;
var fromValues = _vec4Js.fromValues;
var copy = _vec4Js.copy;
var set = _vec4Js.set;
var add = _vec4Js.add;
var mul = multiply;
var scale = _vec4Js.scale;
var dot = _vec4Js.dot;
var lerp = _vec4Js.lerp;
var length = _vec4Js.length;
var len = length;
var squaredLength = _vec4Js.squaredLength;
var sqrLen = squaredLength;
var normalize = _vec4Js.normalize;
var exactEquals = _vec4Js.exactEquals;
var equals = _vec4Js.equals;
var rotationTo = function() {
    var tmpvec3 = _vec3Js.create();
    var xUnitVec3 = _vec3Js.fromValues(1, 0, 0);
    var yUnitVec3 = _vec3Js.fromValues(0, 1, 0);
    return function(out, a, b) {
        var dot2 = _vec3Js.dot(a, b);
        if (dot2 < -0.999999) {
            _vec3Js.cross(tmpvec3, xUnitVec3, a);
            if (_vec3Js.len(tmpvec3) < 0.000001) _vec3Js.cross(tmpvec3, yUnitVec3, a);
            _vec3Js.normalize(tmpvec3, tmpvec3);
            setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot2 > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            _vec3Js.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot2;
            return normalize(out, out);
        }
    };
}();
var sqlerp = function() {
    var temp1 = create();
    var temp2 = create();
    return function(out, a, b, c, d, t) {
        slerp(temp1, a, d, t);
        slerp(temp2, b, c, t);
        slerp(out, temp1, temp2, 2 * t * (1 - t));
        return out;
    };
}();
var setAxes = function() {
    var matr = _mat3Js.create();
    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];
        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];
        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];
        return normalize(out, fromMat3(out, matr));
    };
}();

},{"./common.js":"iRm9m","./mat3.js":"a3LaH","./vec3.js":"kunHs","./vec4.js":"1kX6y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kunHs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 3 Dimensional Vector
 * @module vec3
 */ /**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */ parcelHelpers.export(exports, "length", ()=>length
);
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "divide", ()=>divide
);
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "ceil", ()=>ceil
);
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "floor", ()=>floor
);
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "min", ()=>min
);
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "max", ()=>max
);
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "round", ()=>round
);
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "scaleAndAdd", ()=>scaleAndAdd
);
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */ parcelHelpers.export(exports, "distance", ()=>distance
);
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance
);
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */ parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "negate", ()=>negate
);
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "inverse", ()=>inverse
);
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */ parcelHelpers.export(exports, "dot", ()=>dot
);
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "cross", ()=>cross
);
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "lerp", ()=>lerp
);
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "hermite", ()=>hermite
);
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "bezier", ()=>bezier
);
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "random", ()=>random
);
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "transformMat4", ()=>transformMat4
);
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "transformMat3", ()=>transformMat3
);
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "transformQuat", ()=>transformQuat
);
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */ parcelHelpers.export(exports, "angle", ()=>angle
);
/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "sub", ()=>sub
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "div", ()=>div
);
parcelHelpers.export(exports, "dist", ()=>dist
);
parcelHelpers.export(exports, "sqrDist", ()=>sqrDist
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
parcelHelpers.export(exports, "forEach", ()=>forEach
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(3);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
    }
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
}
function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.sqrt(x * x + y * y + z * z);
}
function fromValues(x, y, z) {
    var out = new _commonJs.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
}
function set(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
}
function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
}
function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
}
function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
}
function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
}
function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
}
function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
}
function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
}
function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
}
function scaleAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    return out;
}
function distance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.sqrt(x * x + y * y + z * z);
}
function squaredDistance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
}
function squaredLength(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
}
function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
}
function inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    return out;
}
function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len1 = x * x + y * y + z * z;
    if (len1 > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len1 = 1 / Math.sqrt(len1);
        out[0] = a[0] * len1;
        out[1] = a[1] * len1;
        out[2] = a[2] * len1;
    }
    return out;
}
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
}
function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
}
function hermite(out, a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
}
function bezier(out, a, b, c, d, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
}
function random(out, scale2) {
    scale2 = scale2 || 1;
    var r = _commonJs.RANDOM() * 2 * Math.PI;
    var z = _commonJs.RANDOM() * 2 - 1;
    var zScale = Math.sqrt(1 - z * z) * scale2;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale2;
    return out;
}
function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
}
function transformMat3(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
}
function transformQuat(out, a, q) {
    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x = a[0], y = a[1], z = a[2];
    // var qvec = [qx, qy, qz];
    // var uv = vec3.cross([], qvec, a);
    var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
    // var uuv = vec3.cross([], qvec, uv);
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    // vec3.scale(uv, uv, 2 * w);
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    // vec3.scale(uuv, uuv, 2);
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    // return vec3.add(out, a, vec3.add(out, uv, uuv));
    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
}
function rotateX(out, a, b, c) {
    var p = [], r = [];
    //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    //perform rotation
    r[0] = p[0];
    r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
    r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);
    //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function rotateY(out, a, b, c) {
    var p = [], r = [];
    //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    //perform rotation
    r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);
    //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function rotateZ(out, a, b, c) {
    var p = [], r = [];
    //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    //perform rotation
    r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
    r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
    r[2] = p[2];
    //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function angle(a, b) {
    var tempA = fromValues(a[0], a[1], a[2]);
    var tempB = fromValues(b[0], b[1], b[2]);
    normalize(tempA, tempA);
    normalize(tempB, tempB);
    var cosine = dot(tempA, tempB);
    if (cosine > 1) return 0;
    else if (cosine < -1) return Math.PI;
    else return Math.acos(cosine);
}
function str(a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
    var vec = create();
    return function(a, stride, offset, count, fn, arg) {
        var i = void 0, l = void 0;
        if (!stride) stride = 3;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
        }
        return a;
    };
}();

},{"./common.js":"iRm9m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1kX6y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 4 Dimensional Vector
 * @module vec4
 */ /**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "divide", ()=>divide
);
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "ceil", ()=>ceil
);
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "floor", ()=>floor
);
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "min", ()=>min
);
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "max", ()=>max
);
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "round", ()=>round
);
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "scaleAndAdd", ()=>scaleAndAdd
);
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */ parcelHelpers.export(exports, "distance", ()=>distance
);
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance
);
/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */ parcelHelpers.export(exports, "length", ()=>length
);
/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */ parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "negate", ()=>negate
);
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "inverse", ()=>inverse
);
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */ parcelHelpers.export(exports, "dot", ()=>dot
);
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "lerp", ()=>lerp
);
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "random", ()=>random
);
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "transformMat4", ()=>transformMat4
);
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "transformQuat", ()=>transformQuat
);
/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "sub", ()=>sub
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "div", ()=>div
);
parcelHelpers.export(exports, "dist", ()=>dist
);
parcelHelpers.export(exports, "sqrDist", ()=>sqrDist
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
parcelHelpers.export(exports, "forEach", ()=>forEach
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(4);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
    }
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function fromValues(x, y, z, w) {
    var out = new _commonJs.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function set(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
}
function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
}
function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
}
function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
}
function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
}
function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
}
function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
}
function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
}
function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
}
function scaleAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    return out;
}
function distance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return Math.sqrt(x * x + y * y + z * z + w * w);
}
function squaredDistance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return x * x + y * y + z * z + w * w;
}
function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return Math.sqrt(x * x + y * y + z * z + w * w);
}
function squaredLength(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return x * x + y * y + z * z + w * w;
}
function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
}
function inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    out[3] = 1 / a[3];
    return out;
}
function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len1 = x * x + y * y + z * z + w * w;
    if (len1 > 0) {
        len1 = 1 / Math.sqrt(len1);
        out[0] = x * len1;
        out[1] = y * len1;
        out[2] = z * len1;
        out[3] = w * len1;
    }
    return out;
}
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
}
function random(out, scale2) {
    scale2 = scale2 || 1;
    // Marsaglia, George. Choosing a Point from the Surface of a
    // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
    // http://projecteuclid.org/euclid.aoms/1177692644;
    var v1, v2, v3, v4;
    var s1, s2;
    do {
        v1 = _commonJs.RANDOM() * 2 - 1;
        v2 = _commonJs.RANDOM() * 2 - 1;
        s1 = v1 * v1 + v2 * v2;
    }while (s1 >= 1)
    do {
        v3 = _commonJs.RANDOM() * 2 - 1;
        v4 = _commonJs.RANDOM() * 2 - 1;
        s2 = v3 * v3 + v4 * v4;
    }while (s2 >= 1)
    var d = Math.sqrt((1 - s1) / s2);
    out[0] = scale2 * v1;
    out[1] = scale2 * v2;
    out[2] = scale2 * v3 * d;
    out[3] = scale2 * v4 * d;
    return out;
}
function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
}
function transformQuat(out, a, q) {
    var x = a[0], y = a[1], z = a[2];
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    // calculate quat * vec
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
}
function str(a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
    var vec = create();
    return function(a, stride, offset, count, fn, arg) {
        var i = void 0, l = void 0;
        if (!stride) stride = 4;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            vec[3] = a[i + 3];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
            a[i + 3] = vec[3];
        }
        return a;
    };
}();

},{"./common.js":"iRm9m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4kivg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */ /**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */ parcelHelpers.export(exports, "fromRotationTranslationValues", ()=>fromRotationTranslationValues
);
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q quaternion
 * @param {vec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */ parcelHelpers.export(exports, "fromRotationTranslation", ()=>fromRotationTranslation
);
/**
 * Creates a dual quat from a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {vec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */ parcelHelpers.export(exports, "fromTranslation", ()=>fromTranslation
);
/**
 * Creates a dual quat from a quaternion
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {mat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */ parcelHelpers.export(exports, "fromMat4", ()=>fromMat4
);
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "set", ()=>set
);
parcelHelpers.export(exports, "getReal", ()=>getReal
);
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} dual part
 */ parcelHelpers.export(exports, "getDual", ()=>getDual
);
parcelHelpers.export(exports, "setReal", ()=>setReal
);
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "setDual", ()=>setDual
);
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {quat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */ parcelHelpers.export(exports, "getTranslation", ()=>getTranslation
);
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to translate
 * @param {vec3} v vector to translate by
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {quat} q quaternion to rotate by
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateByQuatAppend", ()=>rotateByQuatAppend
);
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat} q quaternion to rotate by
 * @param {quat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateByQuatPrepend", ()=>rotateByQuatPrepend
);
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {vec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateAroundAxis", ()=>rotateAroundAxis
);
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
parcelHelpers.export(exports, "mul", ()=>mul
);
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
parcelHelpers.export(exports, "dot", ()=>dot
);
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "lerp", ()=>lerp
);
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "conjugate", ()=>conjugate
);
parcelHelpers.export(exports, "length", ()=>length
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {quat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat2} a the first dual quaternion.
 * @param {quat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {quat2} a the first dual quat.
 * @param {quat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
var _commonJs = require("./common.js");
var _quatJs = require("./quat.js");
var _mat4Js = require("./mat4.js");
function create() {
    var dq = new _commonJs.ARRAY_TYPE(8);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        dq[0] = 0;
        dq[1] = 0;
        dq[2] = 0;
        dq[4] = 0;
        dq[5] = 0;
        dq[6] = 0;
        dq[7] = 0;
    }
    dq[3] = 1;
    return dq;
}
function clone(a) {
    var dq = new _commonJs.ARRAY_TYPE(8);
    dq[0] = a[0];
    dq[1] = a[1];
    dq[2] = a[2];
    dq[3] = a[3];
    dq[4] = a[4];
    dq[5] = a[5];
    dq[6] = a[6];
    dq[7] = a[7];
    return dq;
}
function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
    var dq = new _commonJs.ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    dq[4] = x2;
    dq[5] = y2;
    dq[6] = z2;
    dq[7] = w2;
    return dq;
}
function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
    var dq = new _commonJs.ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    var ax = x2 * 0.5, ay = y2 * 0.5, az = z2 * 0.5;
    dq[4] = ax * w1 + ay * z1 - az * y1;
    dq[5] = ay * w1 + az * x1 - ax * z1;
    dq[6] = az * w1 + ax * y1 - ay * x1;
    dq[7] = -ax * x1 - ay * y1 - az * z1;
    return dq;
}
function fromRotationTranslation(out, q, t) {
    var ax = t[0] * 0.5, ay = t[1] * 0.5, az = t[2] * 0.5, bx = q[0], by = q[1], bz = q[2], bw = q[3];
    out[0] = bx;
    out[1] = by;
    out[2] = bz;
    out[3] = bw;
    out[4] = ax * bw + ay * bz - az * by;
    out[5] = ay * bw + az * bx - ax * bz;
    out[6] = az * bw + ax * by - ay * bx;
    out[7] = -ax * bx - ay * by - az * bz;
    return out;
}
function fromTranslation(out, t) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = t[0] * 0.5;
    out[5] = t[1] * 0.5;
    out[6] = t[2] * 0.5;
    out[7] = 0;
    return out;
}
function fromRotation(out, q) {
    out[0] = q[0];
    out[1] = q[1];
    out[2] = q[2];
    out[3] = q[3];
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
}
function fromMat4(out, a) {
    //TODO Optimize this
    var outer = _quatJs.create();
    _mat4Js.getRotation(outer, a);
    var t = new _commonJs.ARRAY_TYPE(3);
    _mat4Js.getTranslation(t, a);
    fromRotationTranslation(out, outer, t);
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    return out;
}
function identity(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
}
function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
    out[0] = x1;
    out[1] = y1;
    out[2] = z1;
    out[3] = w1;
    out[4] = x2;
    out[5] = y2;
    out[6] = z2;
    out[7] = w2;
    return out;
}
var getReal = _quatJs.copy;
function getDual(out, a) {
    out[0] = a[4];
    out[1] = a[5];
    out[2] = a[6];
    out[3] = a[7];
    return out;
}
var setReal = _quatJs.copy;
function setDual(out, q) {
    out[4] = q[0];
    out[5] = q[1];
    out[6] = q[2];
    out[7] = q[3];
    return out;
}
function getTranslation(out, a) {
    var ax = a[4], ay = a[5], az = a[6], aw = a[7], bx = -a[0], by = -a[1], bz = -a[2], bw = a[3];
    out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    return out;
}
function translate(out, a, v) {
    var ax1 = a[0], ay1 = a[1], az1 = a[2], aw1 = a[3], bx1 = v[0] * 0.5, by1 = v[1] * 0.5, bz1 = v[2] * 0.5, ax2 = a[4], ay2 = a[5], az2 = a[6], aw2 = a[7];
    out[0] = ax1;
    out[1] = ay1;
    out[2] = az1;
    out[3] = aw1;
    out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
    out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
    out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
    out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
    return out;
}
function rotateX(out, a, rad) {
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
    _quatJs.rotateX(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
}
function rotateY(out, a, rad) {
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
    _quatJs.rotateY(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
}
function rotateZ(out, a, rad) {
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
    _quatJs.rotateZ(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
}
function rotateByQuatAppend(out, a, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3], ax = a[0], ay = a[1], az = a[2], aw = a[3];
    out[0] = ax * qw + aw * qx + ay * qz - az * qy;
    out[1] = ay * qw + aw * qy + az * qx - ax * qz;
    out[2] = az * qw + aw * qz + ax * qy - ay * qx;
    out[3] = aw * qw - ax * qx - ay * qy - az * qz;
    ax = a[4];
    ay = a[5];
    az = a[6];
    aw = a[7];
    out[4] = ax * qw + aw * qx + ay * qz - az * qy;
    out[5] = ay * qw + aw * qy + az * qx - ax * qz;
    out[6] = az * qw + aw * qz + ax * qy - ay * qx;
    out[7] = aw * qw - ax * qx - ay * qy - az * qz;
    return out;
}
function rotateByQuatPrepend(out, q, a) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3], bx = a[0], by = a[1], bz = a[2], bw = a[3];
    out[0] = qx * bw + qw * bx + qy * bz - qz * by;
    out[1] = qy * bw + qw * by + qz * bx - qx * bz;
    out[2] = qz * bw + qw * bz + qx * by - qy * bx;
    out[3] = qw * bw - qx * bx - qy * by - qz * bz;
    bx = a[4];
    by = a[5];
    bz = a[6];
    bw = a[7];
    out[4] = qx * bw + qw * bx + qy * bz - qz * by;
    out[5] = qy * bw + qw * by + qz * bx - qx * bz;
    out[6] = qz * bw + qw * bz + qx * by - qy * bx;
    out[7] = qw * bw - qx * bx - qy * by - qz * bz;
    return out;
}
function rotateAroundAxis(out, a, axis, rad) {
    //Special case for rad = 0
    if (Math.abs(rad) < _commonJs.EPSILON) return copy(out, a);
    var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);
    rad = rad * 0.5;
    var s = Math.sin(rad);
    var bx = s * axis[0] / axisLength;
    var by = s * axis[1] / axisLength;
    var bz = s * axis[2] / axisLength;
    var bw = Math.cos(rad);
    var ax1 = a[0], ay1 = a[1], az1 = a[2], aw1 = a[3];
    out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    var ax = a[4], ay = a[5], az = a[6], aw = a[7];
    out[4] = ax * bw + aw * bx + ay * bz - az * by;
    out[5] = ay * bw + aw * by + az * bx - ax * bz;
    out[6] = az * bw + aw * bz + ax * by - ay * bx;
    out[7] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    return out;
}
function multiply(out, a, b) {
    var ax0 = a[0], ay0 = a[1], az0 = a[2], aw0 = a[3], bx1 = b[4], by1 = b[5], bz1 = b[6], bw1 = b[7], ax1 = a[4], ay1 = a[5], az1 = a[6], aw1 = a[7], bx0 = b[0], by0 = b[1], bz0 = b[2], bw0 = b[3];
    out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
    out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
    out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
    out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
    out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
    out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
    out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
    out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
    return out;
}
var mul = multiply;
function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    return out;
}
var dot = _quatJs.dot;
function lerp(out, a, b, t) {
    var mt = 1 - t;
    if (dot(a, b) < 0) t = -t;
    out[0] = a[0] * mt + b[0] * t;
    out[1] = a[1] * mt + b[1] * t;
    out[2] = a[2] * mt + b[2] * t;
    out[3] = a[3] * mt + b[3] * t;
    out[4] = a[4] * mt + b[4] * t;
    out[5] = a[5] * mt + b[5] * t;
    out[6] = a[6] * mt + b[6] * t;
    out[7] = a[7] * mt + b[7] * t;
    return out;
}
function invert(out, a) {
    var sqlen = squaredLength(a);
    out[0] = -a[0] / sqlen;
    out[1] = -a[1] / sqlen;
    out[2] = -a[2] / sqlen;
    out[3] = a[3] / sqlen;
    out[4] = -a[4] / sqlen;
    out[5] = -a[5] / sqlen;
    out[6] = -a[6] / sqlen;
    out[7] = a[7] / sqlen;
    return out;
}
function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    out[4] = -a[4];
    out[5] = -a[5];
    out[6] = -a[6];
    out[7] = a[7];
    return out;
}
var length = _quatJs.length;
var len = length;
var squaredLength = _quatJs.squaredLength;
var sqrLen = squaredLength;
function normalize(out, a) {
    var magnitude = squaredLength(a);
    if (magnitude > 0) {
        magnitude = Math.sqrt(magnitude);
        var a0 = a[0] / magnitude;
        var a1 = a[1] / magnitude;
        var a2 = a[2] / magnitude;
        var a3 = a[3] / magnitude;
        var b0 = a[4];
        var b1 = a[5];
        var b2 = a[6];
        var b3 = a[7];
        var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
        out[0] = a0;
        out[1] = a1;
        out[2] = a2;
        out[3] = a3;
        out[4] = (b0 - a0 * a_dot_b) / magnitude;
        out[5] = (b1 - a1 * a_dot_b) / magnitude;
        out[6] = (b2 - a2 * a_dot_b) / magnitude;
        out[7] = (b3 - a3 * a_dot_b) / magnitude;
    }
    return out;
}
function str(a) {
    return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _commonJs.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _commonJs.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _commonJs.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _commonJs.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7));
}

},{"./common.js":"iRm9m","./quat.js":"8nyyw","./mat4.js":"jXHYx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gQ8Wp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 2 Dimensional Vector
 * @module vec2
 */ /**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "divide", ()=>divide
);
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "ceil", ()=>ceil
);
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "floor", ()=>floor
);
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "min", ()=>min
);
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "max", ()=>max
);
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "round", ()=>round
);
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "scaleAndAdd", ()=>scaleAndAdd
);
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */ parcelHelpers.export(exports, "distance", ()=>distance
);
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance
);
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */ parcelHelpers.export(exports, "length", ()=>length
);
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */ parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "negate", ()=>negate
);
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "inverse", ()=>inverse
);
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */ parcelHelpers.export(exports, "dot", ()=>dot
);
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "cross", ()=>cross
);
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "lerp", ()=>lerp
);
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "random", ()=>random
);
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "transformMat2", ()=>transformMat2
);
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "transformMat2d", ()=>transformMat2d
);
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "transformMat3", ()=>transformMat3
);
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "transformMat4", ()=>transformMat4
);
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */ parcelHelpers.export(exports, "angle", ()=>angle
);
/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "sub", ()=>sub
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "div", ()=>div
);
parcelHelpers.export(exports, "dist", ()=>dist
);
parcelHelpers.export(exports, "sqrDist", ()=>sqrDist
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
parcelHelpers.export(exports, "forEach", ()=>forEach
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(2);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
    }
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
}
function fromValues(x, y) {
    var out = new _commonJs.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
}
function set(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
}
function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
}
function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
}
function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
}
function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
}
function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
}
function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
}
function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
}
function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
}
function scaleAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    return out;
}
function distance(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return Math.sqrt(x * x + y * y);
}
function squaredDistance(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return x * x + y * y;
}
function length(a) {
    var x = a[0], y = a[1];
    return Math.sqrt(x * x + y * y);
}
function squaredLength(a) {
    var x = a[0], y = a[1];
    return x * x + y * y;
}
function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
}
function inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    return out;
}
function normalize(out, a) {
    var x = a[0], y = a[1];
    var len1 = x * x + y * y;
    if (len1 > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len1 = 1 / Math.sqrt(len1);
        out[0] = a[0] * len1;
        out[1] = a[1] * len1;
    }
    return out;
}
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
}
function cross(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
}
function lerp(out, a, b, t) {
    var ax = a[0], ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
}
function random(out, scale2) {
    scale2 = scale2 || 1;
    var r = _commonJs.RANDOM() * 2 * Math.PI;
    out[0] = Math.cos(r) * scale2;
    out[1] = Math.sin(r) * scale2;
    return out;
}
function transformMat2(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
}
function transformMat2d(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
}
function transformMat3(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
}
function transformMat4(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
}
function rotate(out, a, b, c) {
    //Translate point to the origin
    var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(c), cosC = Math.cos(c);
    //perform rotation and translate to correct position
    out[0] = p0 * cosC - p1 * sinC + b[0];
    out[1] = p0 * sinC + p1 * cosC + b[1];
    return out;
}
function angle(a, b) {
    var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1];
    var len1 = x1 * x1 + y1 * y1;
    if (len1 > 0) //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
    var len2 = x2 * x2 + y2 * y2;
    if (len2 > 0) //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
    var cosine = (x1 * x2 + y1 * y2) * len1 * len2;
    if (cosine > 1) return 0;
    else if (cosine < -1) return Math.PI;
    else return Math.acos(cosine);
}
function str(a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len = length;
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var sqrLen = squaredLength;
var forEach = function() {
    var vec = create();
    return function(a, stride, offset, count, fn, arg) {
        var i = void 0, l = void 0;
        if (!stride) stride = 2;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
        }
        return a;
    };
}();

},{"./common.js":"iRm9m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fVwz7":[function(require,module,exports) {
function Face() {
    this.halfEdge = undefined; // points to one of the halfedges associated with this face
    this.index = -1;
}
Face.prototype.setIndex = function(index) {
    this.index = index;
};
Face.prototype.getIndex = function() {
    return this.index;
};
Face.prototype.setHalfEdge = function(halfEdge) {
    this.halfEdge = halfEdge;
};
Face.prototype.getHalfEdge = function() {
    return this.halfEdge;
};
module.exports = Face;

},{}],"lGuYv":[function(require,module,exports) {
var vec3 = require('gl-matrix').vec3;
var Vertex = require('./Vertex');
var Edge = require('./Edge');
var HalfEdge = require('./HalfEdge');
var Face = require('./Face');
function Mesh() {
    this.halfEdges = []; // Half - check;
    this.vertices = []; // Vert - check
    this.edges = []; // Edge - check
    this.faces = []; // Face - check
    this.boundaries = []; // Face - not done
    this.positions = []; // For Faster Rendering
    this.cells = []; // For Faster Rendering
    this.edgeMap = {
    } // ( 1 - 3 ) <==> ( 3 - 1 )
    ;
}
Mesh.prototype.getFaces = function() {
    return this.faces;
};
Mesh.prototype.getEdges = function() {
    return this.edges;
};
Mesh.prototype.getEdgeMap = function() {
    return this.edgeMap;
};
Mesh.prototype.getVertices = function() {
    return this.vertices;
};
Mesh.prototype.getHalfEdges = function() {
    return this.halfEdges;
};
Mesh.prototype.getEdgeKey = function(vertexIndex0, vertexIndex1) {
    return vertexIndex0 + '-' + vertexIndex1;
};
Mesh.prototype.getEdgeKeys = function(vertexIndex0, vertexIndex1) {
    return [
        this.getEdgeKey(vertexIndex0, vertexIndex1),
        this.getEdgeKey(vertexIndex1, vertexIndex0)
    ];
};
Mesh.prototype.containsEdge = function(vertexIndex0, vertexIndex1) {
    var edgeMap = this.edgeMap;
    var keys = this.getEdgeKeys(vertexIndex0, vertexIndex1);
    if (edgeMap[keys[0]] !== undefined && edgeMap[keys[1]] !== undefined) return true;
    return false;
};
Mesh.prototype.getEdge = function(vertexIndex0, vertexIndex1) {
    var edgeMap = this.edgeMap;
    var keys = this.getEdgeKeys(vertexIndex0, vertexIndex1);
    if (edgeMap[keys[0]] !== undefined && edgeMap[keys[1]] !== undefined) return edgeMap[keys[0]];
    return;
};
Mesh.prototype.setPositions = function(positions) {
    this.positions = positions;
    var len = positions.length;
    for(var i = 0; i < len; i++){
        var vertex = new Vertex();
        vertex.setIndex(i);
        this.vertices.push(vertex);
    }
};
Mesh.prototype.getPositions = function() {
    var results = [];
    var vertices = this.vertices;
    var positions = this.positions;
    var len = vertices.length;
    for(var i = 0; i < len; i++){
        var index = vertices[i].getIndex();
        results.push(positions[index]);
    }
    return results;
};
Mesh.prototype.setCells = function(cells) {
    this.cells = cells.slice();
    var len = cells.length;
    for(var i = 0; i < len; i++){
        var face = new Face();
        face.setIndex(i);
        this.faces.push(face);
    }
    this.buildEdgeMap();
};
Mesh.prototype.getCells = function() {
    var results = [];
    var faces = this.faces;
    var vertices = this.vertices;
    var len = faces.length;
    var halfEdge;
    for(var i = 0; i < len; i++){
        var face = faces[i];
        var halfEdgeStart = halfEdge = face.getHalfEdge();
        var cell = [];
        do {
            var vertex = halfEdge.getVertex();
            var index = vertex.getIndex();
            cell.push(index);
            halfEdge = halfEdge.getNextHalfEdge();
        }while (halfEdge != halfEdgeStart)
        results.push(cell);
    }
    return results;
};
Mesh.prototype.buildEdgeMap = function() {
    var cells = this.cells;
    var edges = this.edges;
    var edgeMap = this.edgeMap;
    var len = cells.length;
    for(var i = 0; i < len; i++){
        var cell = cells[i];
        var flen = cell.length;
        for(var j = 0; j < flen; j++){
            var i0 = cell[j];
            var i1 = cell[(j + 1) % flen];
            var key0 = i0 + '-' + i1;
            var key1 = i1 + '-' + i0;
            if (edgeMap[key0] === undefined && edgeMap[key1] === undefined) {
                var edge = new Edge();
                edge.setIndex(edges.length);
                edges.push(edge);
                edgeMap[key0] = edge;
                edgeMap[key1] = edge;
            }
        }
    }
};
Mesh.prototype.process = function() {
    var edgeMap = this.edgeMap;
    var edges = this.edges;
    var cells = this.cells;
    var vertices = this.vertices;
    var faces = this.faces;
    var halfEdges = this.halfEdges;
    var clen = cells.length;
    for(var faceIndex = 0; faceIndex < clen; faceIndex++){
        var cell = cells[faceIndex];
        var face = faces[faceIndex];
        var flen = cells[faceIndex].length;
        var prevHalfEdge = undefined;
        var firstHalfEdge = undefined;
        for(var vertexIndex = 0; vertexIndex < flen; vertexIndex++){
            var vertexIndexCurr = cell[vertexIndex];
            var vertexIndexNext = cell[(vertexIndex + 1) % flen];
            var edge = edgeMap[vertexIndexCurr + '-' + vertexIndexNext];
            var vertex = vertices[vertexIndexCurr];
            //Set Half Edge Properties
            var halfedge = new HalfEdge();
            halfedge.setVertex(vertex);
            halfedge.setFace(face);
            halfedge.setEdge(edge);
            if (edge.getHalfEdge()) {
                halfedge.setFlipHalfEdge(edge.getHalfEdge());
                edge.getHalfEdge().setFlipHalfEdge(halfedge);
            } else edge.setHalfEdge(halfedge);
            if (prevHalfEdge !== undefined) prevHalfEdge.setNextHalfEdge(halfedge);
            prevHalfEdge = halfedge;
            if (vertexIndex === 0) firstHalfEdge = halfedge;
            halfEdges.push(halfedge);
            //Set Vertex Properties
            vertex.setHalfEdge(halfedge);
        }
        //Set Face Properties
        face.setHalfEdge(firstHalfEdge);
        prevHalfEdge.setNextHalfEdge(firstHalfEdge);
    }
};
module.exports = Mesh;

},{"gl-matrix":"3TXam","./Vertex":"aMW4R","./Edge":"dOHcN","./HalfEdge":"72nec","./Face":"fVwz7"}],"ePOBu":[function(require,module,exports) {
var FaceIntegrity = require('./FaceIntegrity');
var EdgeIntegrity = require('./EdgeIntegrity');
var VertexIntegrity = require('./VertexIntegrity');
var HalfEdgeIntegrity = require('./HalfEdgeIntegrity');
var Integrity = {
};
Integrity.checkMesh = function(mesh) {
    var passed = true;
    if (!this.checkFaces(mesh.getFaces())) {
        console.log('faces are messed up');
        passed = false;
    }
    if (!this.checkEdges(mesh.getEdges())) {
        console.log('edges are messed up');
        passed = false;
    }
    if (!this.checkVertices(mesh.getVertices())) {
        console.log('vertices are messed up');
        passed = false;
    }
    if (!this.checkHalfEdges(mesh.getHalfEdges())) {
        console.log('half edges are messed up');
        passed = false;
    }
    console.log('mesh is valid!');
    return passed;
};
Integrity.checkEdges = function(edges) {
    var passed = true;
    var len = edges.length;
    for(var i = 0; i < len; i++){
        var edge = edges[i];
        passed = EdgeIntegrity(edge);
    }
    return passed;
};
Integrity.checkFaces = function(faces) {
    var passed = true;
    var len = faces.length;
    for(var i = 0; i < len; i++){
        var face = faces[i];
        passed = FaceIntegrity(face);
    }
    return passed;
};
Integrity.checkVertices = function(vertices) {
    var passed = true;
    var len = vertices.length;
    for(var i = 0; i < len; i++){
        var vertex = vertices[i];
        passed = VertexIntegrity(vertex);
    }
    return passed;
};
Integrity.checkHalfEdges = function(halfEdges) {
    var passed = true;
    var len = halfEdges.length;
    for(var i = 0; i < len; i++){
        var halfedge = halfEdges[i];
        passed = HalfEdgeIntegrity(halfedge);
    }
    return passed;
};
module.exports = Integrity;

},{"./FaceIntegrity":"aJGqU","./EdgeIntegrity":"bJZiZ","./VertexIntegrity":"gBmpk","./HalfEdgeIntegrity":"hnjcF"}],"aJGqU":[function(require,module,exports) {
module.exports = function(face) {
    var passed = true;
    if (face.getIndex() === -1) {
        console.log('face: ', face.getIndex(), ' does not have a proper index');
        passed = false;
    }
    if (face.getHalfEdge() === undefined) {
        console.log('face: ', face.getIndex(), ' does not have a half edge');
        passed = false;
    }
    return passed;
};

},{}],"bJZiZ":[function(require,module,exports) {
module.exports = function(edge) {
    var passed = true;
    if (edge.getIndex() === -1) {
        console.log('edge: ', edge.getIndex(), ' does not have a proper index');
        passed = false;
    }
    if (edge.getHalfEdge() === undefined) {
        console.log('edge: ', edge.getIndex(), ' does not have a half edge');
        passed = false;
    }
    return passed;
};

},{}],"gBmpk":[function(require,module,exports) {
module.exports = function(vertex) {
    var passed = true;
    if (vertex.getIndex() === -1) {
        console.log('vertex : ', vertex.getIndex(), ' does not have a proper index');
        passed = false;
    }
    if (vertex.getHalfEdge() === undefined) {
        console.log('vertex : ', vertex.getIndex(), ' does not have a half edge');
        passed = false;
    }
    return passed;
};

},{}],"hnjcF":[function(require,module,exports) {
var HalfEdgePrev = require('./../Queries/HalfEdgePrev');
module.exports = function(halfEdge) {
    var passed = true;
    var he = halfEdge;
    if (he.getNextHalfEdge() === undefined) {
        console.log('halfEdge: does not have a next half edge');
        passed = false;
    }
    if (he.getFlipHalfEdge() === undefined) {
        console.log('halfEdge: does not have a flip half edge');
        passed = false;
    }
    if (he.getVertex() === undefined) {
        console.log('halfEdge: does not have a valid vertex');
        passed = false;
    }
    if (he.getEdge() === undefined) {
        console.log('halfEdge: does not have an edge');
        passed = false;
    }
    if (he.getFace() === undefined) {
        console.log('halfEdge: does not have a face');
        passed = false;
    }
    return passed;
};

},{"./../Queries/HalfEdgePrev":"lRsPN"}],"lRsPN":[function(require,module,exports) {
module.exports = function(he) {
    var startHalfEdge = he;
    while(he.getNextHalfEdge() != startHalfEdge)he = he.getNextHalfEdge();
    return he;
};

},{}],"bU9N9":[function(require,module,exports) {
var Integrity = require('./Integrity');
module.exports = function(mesh) {
    var passed = true;
    console.log('checking faces');
    if (!Integrity.checkFaces(mesh.getFaces())) {
        console.log('faces are messed up');
        passed = false;
    }
    console.log('checking edges');
    if (!Integrity.checkEdges(mesh.getEdges())) {
        console.log('edges are messed up');
        passed = false;
    }
    console.log('checking vertices');
    if (!Integrity.checkVertices(mesh.getVertices())) {
        console.log('vertices are messed up');
        passed = false;
    }
    console.log('checking halfedges');
    if (!Integrity.checkHalfEdges(mesh.getHalfEdges())) {
        console.log('half edges are messed up');
        passed = false;
    }
    console.log('mesh is valid!');
    return passed;
};

},{"./Integrity":"ePOBu"}],"2K4CD":[function(require,module,exports) {
module.exports = function(edge) {
    var results = [];
    var he = edge.getHalfEdge();
    results.push(he.getVertex());
    he = he.getFlipHalfEdge();
    results.push(he.getVertex());
    return results;
};

},{}],"eum8y":[function(require,module,exports) {
module.exports = function(face) {
    var originalHalfEdge = he = face.getHalfEdge();
    var halfEdges = [];
    do {
        halfEdges.push(he);
        he = he.getNextHalfEdge();
    }while (he != originalHalfEdge)
    return halfEdges;
};

},{}],"elyLX":[function(require,module,exports) {
module.exports = function(face) {
    var originalHalfEdge = he = face.getHalfEdge();
    var vertices = [];
    do {
        vertices.push(he.getVertex());
        he = he.getNextHalfEdge();
    }while (he != originalHalfEdge)
    return vertices;
};

},{}],"gqIAR":[function(require,module,exports) {
module.exports = function(vertex) {
    var startHalfEdge = originalHalfEdge = he = vertex.getHalfEdge();
    var faces = [];
    do if (he.getNextHalfEdge() === startHalfEdge) {
        faces.push(he.getFace());
        he = he.getFlipHalfEdge();
        startHalfEdge = he;
    } else he = he.getNextHalfEdge();
    while (he != originalHalfEdge)
    return faces;
};

},{}],"8DhJJ":[function(require,module,exports) {
module.exports = function(vertex) {
    var startHalfEdge = originalHalfEdge = he = vertex.getHalfEdge();
    var halfEdges = [];
    do if (he.getNextHalfEdge() === startHalfEdge) {
        he = he.getFlipHalfEdge();
        startHalfEdge = he;
        halfEdges.push(he);
    } else he = he.getNextHalfEdge();
    while (he != originalHalfEdge)
    return halfEdges;
};

},{}],"f9YBN":[function(require,module,exports) {
module.exports = function(vertex) {
    var startHalfEdge = originalHalfEdge = he = vertex.getHalfEdge();
    var neighbors = [];
    do if (he.getNextHalfEdge() === startHalfEdge) {
        neighbors.push(he.getVertex());
        he = he.getFlipHalfEdge();
        startHalfEdge = he;
    } else he = he.getNextHalfEdge();
    while (he != originalHalfEdge)
    return neighbors;
};

},{}],"kKwVL":[function(require,module,exports) {
var vec3 = require('gl-matrix').vec3;
module.exports = function(mesh) {
    var center = vec3.create();
    var positions = mesh.positions;
    var plen = positions.length;
    for(var i = 0; i < plen; i++)vec3.add(center, center, positions[i]);
    vec3.scale(center, center, 1 / plen);
    return center;
};

},{"gl-matrix":"3TXam"}],"aoQ2o":[function(require,module,exports) {
var Face = require('./../Core/Face');
var Edge = require('./../Core/Edge');
var Vertex = require('./../Core/Vertex');
var HalfEdge = require('./../Core/HalfEdge');
var vec3 = require('gl-matrix').vec3;
module.exports = function(mesh, edgeIndex, position) {
    // when you create a new vertex
    // you create a new edge
    // you create two new half edges
    // you create a new vertex
    var edges = mesh.getEdges();
    var halfEdges = mesh.getHalfEdges();
    var edgeMap = mesh.getEdgeMap();
    var vertices = mesh.getVertices();
    var positions = mesh.positions; //hack fix this <-
    var originalEdge = edges[edgeIndex];
    var originalHalfEdge = originalEdge.getHalfEdge();
    var originalHalfEdgeFace = originalHalfEdge.getFace();
    var originalHalfEdgeNext = originalHalfEdge.getNextHalfEdge();
    var originalHalfEdgeFlip = originalHalfEdge.getFlipHalfEdge();
    var originalVertex = originalHalfEdge.getVertex();
    var originalVertexIndex = originalVertex.getIndex();
    var originalVertexPosition = positions[originalVertexIndex];
    var originalVertexNext = originalHalfEdgeNext.getVertex();
    var originalVertexNextIndex = originalVertexNext.getIndex();
    var originalVertexNextPosition = positions[originalVertexNextIndex];
    var newEdge = new Edge();
    var newVertex = new Vertex();
    var newHalfEdge = new HalfEdge();
    var newHalfEdgeFlip = new HalfEdge();
    //Set New Vertex Properties
    var newVertexIndex = positions.length;
    var newVertexPosition = vec3.create();
    if (position !== undefined) vec3.copy(newVertexPosition, position);
    else {
        vec3.add(newVertexPosition, originalVertexPosition, originalVertexNextPosition);
        vec3.scale(newVertexPosition, newVertexPosition, 0.5);
    }
    newVertex.setIndex(newVertexIndex);
    newVertex.setHalfEdge(newHalfEdge);
    positions.push(newVertexPosition);
    vertices.push(newVertex);
    //Set New Half Edge Properties
    newHalfEdge.setVertex(newVertex);
    newHalfEdge.setFace(originalHalfEdgeFace);
    newHalfEdge.setNextHalfEdge(originalHalfEdgeNext);
    newHalfEdge.setFlipHalfEdge(originalHalfEdgeFlip);
    newHalfEdge.setEdge(newEdge);
    // Set Original Half Edge Properties
    originalHalfEdge.setNextHalfEdge(newHalfEdge);
    originalHalfEdge.setFlipHalfEdge(newHalfEdgeFlip);
    //fix Edge map
    var originalEdgeKey0Old = originalVertexIndex + '-' + originalVertexNextIndex;
    var originalEdgeKey1Old = originalVertexNextIndex + '-' + originalVertexIndex;
    delete edgeMap[originalEdgeKey0Old]; //deletes edge key
    delete edgeMap[originalEdgeKey1Old]; //deletes edge key
    var originalEdgeKey0New = originalVertexIndex + '-' + newVertexIndex;
    var originalEdgeKey1New = newVertexIndex + '-' + originalVertexIndex;
    edgeMap[originalEdgeKey0New] = originalEdge;
    edgeMap[originalEdgeKey1New] = originalEdge;
    newEdge.setIndex(edges.length);
    edges.push(newEdge);
    newEdge.setHalfEdge(newHalfEdge);
    var newEdgeKey0 = newVertexIndex + '-' + originalVertexNextIndex;
    var newEdgeKey1 = originalVertexNextIndex + '-' + newVertexIndex;
    edgeMap[newEdgeKey0] = newEdge;
    edgeMap[newEdgeKey1] = newEdge;
    // Set original half edge flip properties
    var originalHalfEdgeFlipFace = originalHalfEdgeFlip.getFace();
    var originalHalfEdgeFlipNext = originalHalfEdgeFlip.getNextHalfEdge();
    originalHalfEdgeFlip.setNextHalfEdge(newHalfEdgeFlip);
    originalHalfEdgeFlip.setFlipHalfEdge(newHalfEdge);
    originalHalfEdgeFlip.setEdge(newEdge);
    newHalfEdgeFlip.setNextHalfEdge(originalHalfEdgeFlipNext);
    newHalfEdgeFlip.setFlipHalfEdge(originalHalfEdge);
    newHalfEdgeFlip.setVertex(newVertex);
    newHalfEdgeFlip.setEdge(originalEdge);
    newHalfEdgeFlip.setFace(originalHalfEdgeFlipFace);
    halfEdges.push(newHalfEdgeFlip);
    return newVertex;
};

},{"./../Core/Face":"fVwz7","./../Core/Edge":"dOHcN","./../Core/Vertex":"aMW4R","./../Core/HalfEdge":"72nec","gl-matrix":"3TXam"}],"e3H1k":[function(require,module,exports) {
var Face = require('./../Core/Face');
var Edge = require('./../Core/Edge');
var HalfEdge = require('./../Core/HalfEdge');
var HalfEdgePrev = require('./../Queries/HalfEdgePrev');
var VertexHalfEdges = require('./../Queries/VertexHalfEdges');
module.exports = function(mesh, startVertexIndex, endVertexIndex) {
    // console.log( 'faceIndex:', faceIndex );
    // console.log( 'startVertexIndex:', startVertexIndex );
    // console.log( 'endVertexIndex:', endVertexIndex );
    if (startVertexIndex === endVertexIndex) throw 'illegal edge inseration: ' + startVertexIndex + ' , ' + endVertexIndex;
    var edges = mesh.getEdges();
    var halfEdges = mesh.getHalfEdges();
    var edgeMap = mesh.getEdgeMap();
    var vertices = mesh.getVertices();
    var faces = mesh.getFaces();
    var edge = mesh.getEdge(startVertexIndex, endVertexIndex);
    if (edge) // console.log( 'mesh already contains edge: ', mesh.getEdgeKeys( startVertexIndex, endVertexIndex ) );
    return; //{ edge: edge, face: faces[ edge.getHalfEdge().getFace().getIndex() ] };
    var startVertex = vertices[startVertexIndex];
    var endVertex = vertices[endVertexIndex];
    var cfaces = commonFaces(startVertex, endVertex);
    var clen = cfaces.length;
    var halfEdgeA, halfEdgeB, halfEdgeC, halfEdgeD;
    for(var i = 0; i < clen; i++){
        var face = faces[cfaces[i]];
        var faceHalfEdge = face.getHalfEdge();
        var he = faceHalfEdge;
        do {
            var vertexIndex = he.getVertex().getIndex();
            // var vertexIndexNext = hef.getVertex().getIndex();
            if (vertexIndex === startVertexIndex) halfEdgeA = he;
            if (vertexIndex === endVertexIndex) halfEdgeC = he;
            he = he.getNextHalfEdge();
        }while (he != faceHalfEdge)
        if (halfEdgeC != undefined || halfEdgeA != undefined) break;
        halfEdgeC = undefined;
        halfEdgeA = undefined;
    }
    // console.log( halfEdgeC );
    // console.log( halfEdgeA );
    halfEdgeB = HalfEdgePrev(halfEdgeC);
    halfEdgeD = HalfEdgePrev(halfEdgeA);
    if (halfEdgeA === undefined || halfEdgeB === undefined || halfEdgeC === undefined || halfEdgeD === undefined) throw 'error finding neighboring half edges when inserting edge';
    // Set New Edge Properties
    var newEdge = new Edge();
    newEdge.setIndex(edges.length);
    var edgeKeys = mesh.getEdgeKeys(startVertexIndex, endVertexIndex);
    edgeMap[edgeKeys[0]] = newEdge;
    edgeMap[edgeKeys[1]] = newEdge;
    edges.push(newEdge);
    var newFace = new Face();
    newFace.setIndex(faces.length);
    faces.push(newFace);
    //create new half edges
    var newHalfEdgeAB = new HalfEdge();
    var newHalfEdgeCD = new HalfEdge();
    newHalfEdgeAB.setNextHalfEdge(halfEdgeA);
    newHalfEdgeAB.setFlipHalfEdge(newHalfEdgeCD);
    newHalfEdgeAB.setVertex(endVertex);
    newHalfEdgeAB.setEdge(newEdge);
    newHalfEdgeAB.setFace(face);
    halfEdges.push(newHalfEdgeAB);
    newHalfEdgeCD.setNextHalfEdge(halfEdgeC);
    newHalfEdgeCD.setFlipHalfEdge(newHalfEdgeAB);
    newHalfEdgeCD.setVertex(startVertex);
    newHalfEdgeCD.setEdge(newEdge);
    newHalfEdgeCD.setFace(newFace);
    halfEdges.push(newHalfEdgeCD);
    //set all other edge & halfedge & face properties so they are accurate
    newEdge.setHalfEdge(newHalfEdgeAB);
    face.setHalfEdge(newHalfEdgeAB);
    newFace.setHalfEdge(newHalfEdgeCD);
    halfEdgeD.setNextHalfEdge(newHalfEdgeCD);
    halfEdgeB.setNextHalfEdge(newHalfEdgeAB);
    setHalfEdgeLoopFace(newHalfEdgeCD, newFace);
    setHalfEdgeLoopFace(newHalfEdgeAB, face);
    return {
        edge: newEdge,
        face: newFace
    };
};
function commonFaces(vertex0, vertex1) {
    var results = {
    };
    var hes0 = VertexHalfEdges(vertex0);
    var hes0l = hes0.length;
    var hes1 = VertexHalfEdges(vertex1);
    var hes1l = hes1.length;
    for(var i = 0; i < hes0l; i++){
        var he0f = hes0[i].getFace();
        for(var j = 0; j < hes1l; j++){
            var he1f = hes1[j].getFace();
            if (he0f.getIndex() === he1f.getIndex()) results[he0f.getIndex()] = he1f;
        }
    }
    return Object.keys(results);
}
function setHalfEdgeLoopFace(he, face) {
    var starthe = he;
    do {
        he.setFace(face);
        he = he.getNextHalfEdge();
    }while (he != starthe)
}

},{"./../Core/Face":"fVwz7","./../Core/Edge":"dOHcN","./../Core/HalfEdge":"72nec","./../Queries/HalfEdgePrev":"lRsPN","./../Queries/VertexHalfEdges":"8DhJJ"}],"69uv4":[function(require,module,exports) {
var Face = require('./../Core/Face');
var Edge = require('./../Core/Edge');
var HalfEdge = require('./../Core/HalfEdge');
var HalfEdgePrev = require('./../Queries/HalfEdgePrev');
module.exports = function(mesh, edgeIndex) {
    var edges = mesh.getEdges();
    var edge = edges[edgeIndex];
    var edgeHalfEdge = edge.getHalfEdge();
    var edgeHalfEdgePrev = HalfEdgePrev(edgeHalfEdge);
    var edgeHalfEdgeNext = edgeHalfEdge.getNextHalfEdge();
    var edgeHalfEdgeVertex = edgeHalfEdge.getVertex();
    var edgeHalfEdgeFace = edgeHalfEdge.getFace();
    var edgeHalfEdgeFlip = edgeHalfEdge.getFlipHalfEdge();
    var edgeHalfEdgeFlipPrev = HalfEdgePrev(edgeHalfEdgeFlip);
    var edgeHalfEdgeFlipNext = edgeHalfEdgeFlip.getNextHalfEdge();
    var edgeHalfEdgeFlipVertex = edgeHalfEdgeFlip.getVertex();
    var edgeHalfEdgeFlipFace = edgeHalfEdgeFlip.getFace();
    // Set Face Half Edge
    edgeHalfEdgeFace.setHalfEdge(edgeHalfEdgeNext);
    //Set Half Edge Face Properties
    edgeHalfEdgePrev.setNextHalfEdge(edgeHalfEdgeFlipNext);
    edgeHalfEdgeVertex.setHalfEdge(edgeHalfEdgeFlipNext);
    // Set Half Edge Flip Face Properties
    edgeHalfEdgeFlipPrev.setNextHalfEdge(edgeHalfEdgeNext);
    edgeHalfEdgeFlipVertex.setHalfEdge(edgeHalfEdgeNext);
    // Remove Half Edge Flip Face
    var faces = mesh.getFaces();
    faces.splice(edgeHalfEdgeFlipFace.getIndex(), 1);
    var flen = faces.length;
    for(var i = 0; i < flen; i++)faces[i].setIndex(i);
    // Remove Edge from Edges Array
    edges.splice(edgeIndex, 1);
    var elen = edges.length;
    for(var i = 0; i < elen; i++)edges[i].setIndex(i);
    // Remove Edge from Edge Hash Map
    var keys = mesh.getEdgeKeys(edgeHalfEdgeVertex.getIndex(), edgeHalfEdgeFlipVertex.getIndex());
    var edgeMap = mesh.getEdgeMap();
    delete edgeMap[keys[0]];
    delete edgeMap[keys[1]];
};

},{"./../Core/Face":"fVwz7","./../Core/Edge":"dOHcN","./../Core/HalfEdge":"72nec","./../Queries/HalfEdgePrev":"lRsPN"}],"5MnuS":[function(require,module,exports) {
var vec3 = require('gl-matrix').vec3;
var FaceVertices = require('./../Queries/FaceVertices');
var VertexNeighbors = require('./../Queries/VertexNeighbors');
var InsertVertex = require('./InsertVertex');
var InsertEdge = require('./InsertEdge');
module.exports = function(mesh) {
    var positions = mesh.positions;
    var plen = positions.length;
    var newPositions = [];
    for(var i = 0; i < plen; i++)newPositions.push(vec3.create());
    var vertices = mesh.getVertices();
    var vlen = vertices.length;
    var beta;
    for(var i = 0; i < vlen; i++){
        var vertex = vertices[i];
        var vertexIndex = vertex.getIndex();
        var vertexPos = positions[vertexIndex];
        var newPos = newPositions[vertexIndex];
        var neighbors = VertexNeighbors(vertex);
        var nlen = neighbors.length;
        if (nlen === 3) beta = 0.1875;
        else if (nlen > 3) beta = (0.625 - Math.pow(0.375 + 0.25 * Math.cos(Math.PI * 2 / nlen), 2)) / nlen;
        vec3.scaleAndAdd(newPos, newPos, vertexPos, 1 - nlen * beta);
        for(var j = 0; j < nlen; j++){
            var neighborPos = positions[neighbors[j].getIndex()];
            vec3.scaleAndAdd(newPos, newPos, neighborPos, beta);
        }
    }
    var edges = mesh.getEdges();
    var len = edges.length;
    var newVerts = [];
    var vertexAdjacentFactor = 0.375;
    var vertexOppositeFactor = 0.125;
    var newPos = vec3.create();
    for(var i = 0; i < len; i++){
        vec3.set(newPos, 0, 0, 0);
        var edge = edges[i];
        var halfEdge = edge.getHalfEdge();
        var halfEdgeFlip = halfEdge.getFlipHalfEdge();
        var halfEdgeTop = halfEdge.getNextHalfEdge().getNextHalfEdge();
        var halfEdgeFlipTop = halfEdgeFlip.getNextHalfEdge().getNextHalfEdge();
        var halfEdgeVertex = halfEdge.getVertex();
        var halfEdgeFlipVertex = halfEdgeFlip.getVertex();
        var halfEdgeTopVertex = halfEdgeTop.getVertex();
        var halfEdgeFlipTopVertex = halfEdgeFlipTop.getVertex();
        var halfEdgeVertexPos = positions[halfEdgeVertex.getIndex()];
        var halfEdgeFlipVertexPos = positions[halfEdgeFlipVertex.getIndex()];
        var halfEdgeTopVertexPos = positions[halfEdgeTopVertex.getIndex()];
        var halfEdgeFlipTopVertexPos = positions[halfEdgeFlipTopVertex.getIndex()];
        vec3.scaleAndAdd(newPos, newPos, halfEdgeVertexPos, vertexAdjacentFactor);
        vec3.scaleAndAdd(newPos, newPos, halfEdgeFlipVertexPos, vertexAdjacentFactor);
        vec3.scaleAndAdd(newPos, newPos, halfEdgeTopVertexPos, vertexOppositeFactor);
        vec3.scaleAndAdd(newPos, newPos, halfEdgeFlipTopVertexPos, vertexOppositeFactor);
        newVerts.push(InsertVertex(mesh, edge.getIndex(), newPos));
    }
    var faces = mesh.getFaces();
    var flen = faces.length;
    var result;
    for(var i = 0; i < flen; i++){
        var face = faces[i];
        var vertices = FaceVertices(face);
        var vlen = vertices.length;
        var v1 = vertices[1];
        var v3 = vertices[3];
        var v5 = vertices[5];
        result = InsertEdge(mesh, v1.getIndex(), v3.getIndex());
        result = InsertEdge(mesh, v3.getIndex(), v5.getIndex());
        result = InsertEdge(mesh, v5.getIndex(), v1.getIndex());
    }
    for(var i = 0; i < plen; i++)vec3.copy(positions[i], newPositions[i]);
};

},{"gl-matrix":"3TXam","./../Queries/FaceVertices":"elyLX","./../Queries/VertexNeighbors":"f9YBN","./InsertVertex":"aoQ2o","./InsertEdge":"e3H1k"}],"cnkNJ":[function(require,module,exports) {
var VertexNeighbors = require('./../Queries/VertexNeighbors');
var FaceVertices = require('./../Queries/FaceVertices');
var FaceHalfEdges = require('./../Queries/FaceHalfEdges');
var VertexHalfEdges = require('./../Queries/VertexHalfEdges');
var InsertVertex = require('./InsertVertex');
var InsertEdge = require('./InsertEdge');
var vec3 = require('gl-matrix').vec3;
module.exports = function(mesh) {
    var newPositions = [];
    var positions = mesh.positions;
    var plen = positions.length;
    for(var i = 0; i < plen; i++)newPositions.push(vec3.clone(positions[i]));
    var tmp = vec3.create();
    var newPos = vec3.create();
    //calculate new original vertex positions
    var vertices = mesh.getVertices();
    var vlen = vertices.length;
    var kmap = {
    };
    for(var i = 0; i < 32; i++){
        var beta = 3 / (2 * i);
        var rho = 1 / (4 * i);
        kmap[i] = [
            1 - beta - rho,
            beta / i,
            rho / i
        ];
    }
    for(var i = 0; i < vlen; i++){
        var vertex = vertices[i];
        var vertexIndex = vertex.getIndex();
        var vertexPos = positions[vertexIndex];
        var neighbors = VertexHalfEdges(vertex);
        var nlen = neighbors.length;
        var kernel = kmap[nlen];
        vec3.copy(newPos, vertexPos);
        vec3.scale(newPos, newPos, kernel[0]);
        for(var j = 0; j < nlen; j++){
            var he = neighbors[j];
            var hen = he.getNextHalfEdge();
            var v0iPos = positions[hen.getVertex().getIndex()];
            vec3.scaleAndAdd(newPos, newPos, v0iPos, kernel[1]);
            var henn = hen.getNextHalfEdge();
            var v1iPos = positions[henn.getVertex().getIndex()];
            vec3.scaleAndAdd(newPos, newPos, v1iPos, kernel[2]);
        }
        vec3.copy(newPositions[vertexIndex], newPos);
    }
    //Calculate Face Verts
    var faceVerticesPosHash = {
    };
    var faces = mesh.getFaces();
    var flen = faces.length;
    for(var i = 0; i < flen; i++){
        var face = faces[i];
        var faceVertices = FaceVertices(face);
        var vlen = faceVertices.length;
        var faceVertexPos = vec3.create();
        faceVerticesPosHash[face.getIndex()] = faceVertexPos;
        for(var j = 0; j < vlen; j++){
            var vertex = faceVertices[j];
            var vertexIndex = vertex.getIndex();
            var vertexPos = positions[vertexIndex];
            vec3.scaleAndAdd(faceVertexPos, faceVertexPos, vertexPos, 0.25);
        }
    }
    //Calculate Edge Verts
    var edgeVerticesPosHash = {
    };
    var edges = mesh.getEdges();
    var elen = edges.length;
    for(var i = 0; i < elen; i++){
        var edge = edges[i];
        var edgeVertexPos = vec3.create();
        edgeVerticesPosHash[edge.getIndex()] = edgeVertexPos;
        var he = edge.getHalfEdge();
        var heVertex = he.getVertex();
        var heVertexPos = positions[heVertex.getIndex()];
        vec3.scaleAndAdd(edgeVertexPos, edgeVertexPos, heVertexPos, 0.375);
        var heVertexPos0 = positions[he.getNextHalfEdge().getNextHalfEdge().getVertex().getIndex()];
        var heVertexPos1 = positions[he.getNextHalfEdge().getNextHalfEdge().getNextHalfEdge().getVertex().getIndex()];
        vec3.scaleAndAdd(edgeVertexPos, edgeVertexPos, heVertexPos0, 0.0625);
        vec3.scaleAndAdd(edgeVertexPos, edgeVertexPos, heVertexPos1, 0.0625);
        var hef = he.getFlipHalfEdge();
        var hefVertex = hef.getVertex();
        var hefVertexPos = positions[hefVertex.getIndex()];
        vec3.scaleAndAdd(edgeVertexPos, edgeVertexPos, hefVertexPos, 0.375);
        var hefVertexPos0 = positions[hef.getNextHalfEdge().getNextHalfEdge().getVertex().getIndex()];
        var hefVertexPos1 = positions[hef.getNextHalfEdge().getNextHalfEdge().getNextHalfEdge().getVertex().getIndex()];
        vec3.scaleAndAdd(edgeVertexPos, edgeVertexPos, hefVertexPos0, 0.0625);
        vec3.scaleAndAdd(edgeVertexPos, edgeVertexPos, hefVertexPos1, 0.0625);
    }
    // console.log( edgeVerticesPosHash );
    // insert edges and set vertex positions
    for(var i = 0; i < elen; i++){
        var edge = edges[i];
        var edgeIndex = edge.getIndex();
        InsertVertex(mesh, edge.getIndex(), edgeVerticesPosHash[edgeIndex]);
    }
    var edgeVertices = {
    };
    for(var i = 0; i < flen; i++){
        var face = faces[i];
        edgeVertices[face.getIndex()] = [];
        var vertices = FaceVertices(face);
        var vlen = vertices.length;
        for(var j = 0; j < vlen; j++){
            var vertex = vertices[j];
            var neighbors = VertexNeighbors(vertex);
            if (neighbors.length == 2) edgeVertices[face.getIndex()].push(vertex);
        }
    }
    var keys = Object.keys(edgeVertices);
    for(var i = 0; i < keys.length; i++){
        var faceIndex = keys[i];
        var vertices = edgeVertices[faceIndex];
        var v0 = vertices[0];
        var v1 = vertices[1];
        var v2 = vertices[2];
        var v3 = vertices[3];
        var result = InsertEdge(mesh, v0.getIndex(), v2.getIndex());
        var cv = InsertVertex(mesh, result.edge.getIndex(), faceVerticesPosHash[faceIndex]);
        edgeVertices[faceIndex].push(cv);
        InsertEdge(mesh, v1.getIndex(), cv.getIndex());
        InsertEdge(mesh, v3.getIndex(), cv.getIndex());
    }
    for(var i = 0; i < plen; i++)vec3.copy(positions[i], newPositions[i]);
};

},{"./../Queries/VertexNeighbors":"f9YBN","./../Queries/FaceVertices":"elyLX","./../Queries/FaceHalfEdges":"eum8y","./../Queries/VertexHalfEdges":"8DhJJ","./InsertVertex":"aoQ2o","./InsertEdge":"e3H1k","gl-matrix":"3TXam"}],"dLOrr":[function(require,module,exports) {
var vec3 = require('gl-matrix').vec3;
var VertexNeighbors = require('./../Queries/VertexNeighbors');
var FaceVertices = require('./../Queries/FaceVertices');
var InsertVertex = require('./InsertVertex');
var InsertEdge = require('./InsertEdge');
module.exports = function(mesh) {
    var edges = mesh.getEdges();
    var elen = edges.length;
    var edgeVertices = {
    };
    for(var i = 0; i < elen; i++){
        var edge = edges[i];
        InsertVertex(mesh, edge.getIndex());
    }
    var faces = mesh.getFaces();
    var flen = faces.length;
    for(var i = 0; i < flen; i++){
        var face = faces[i];
        edgeVertices[face.getIndex()] = [];
        var vertices = FaceVertices(face);
        var vlen = vertices.length;
        for(var j = 0; j < vlen; j++){
            var vertex = vertices[j];
            var neighbors = VertexNeighbors(vertex);
            if (neighbors.length == 2) edgeVertices[face.getIndex()].push(vertex);
        }
    }
    var keys = Object.keys(edgeVertices);
    for(var i = 0; i < keys.length; i++){
        var faceIndex = keys[i];
        var vertices = edgeVertices[faceIndex];
        var v0 = vertices[0];
        var v1 = vertices[1];
        var v2 = vertices[2];
        var v3 = vertices[3];
        var result = InsertEdge(mesh, v0.getIndex(), v2.getIndex());
        var cv = InsertVertex(mesh, result.edge.getIndex());
        edgeVertices[faceIndex].push(cv);
        InsertEdge(mesh, v1.getIndex(), cv.getIndex());
        InsertEdge(mesh, v3.getIndex(), cv.getIndex());
    }
};

},{"gl-matrix":"3TXam","./../Queries/VertexNeighbors":"f9YBN","./../Queries/FaceVertices":"elyLX","./InsertVertex":"aoQ2o","./InsertEdge":"e3H1k"}],"1FODs":[function(require,module,exports) {
var FaceVertices = require('./../Queries/FaceVertices');
var calculateNormal = require('guf').calculateNormal;
var triangulatePolygon = require('cga').triangulatePolygon2;
var vec3 = require('gl-matrix').vec3;
var quat = require('gl-matrix').quat;
var InsertEdge = require('./InsertEdge');
module.exports = function(mesh) {
    // console.log( 'starting triangulation' );
    var positions = mesh.positions;
    var faces = mesh.getFaces();
    var flen = faces.length;
    var zAxis = vec3.fromValues(0, 0, 1);
    var res = {
    };
    for(var i = 0; i < flen; i++){
        var face = faces[i];
        var vertices = FaceVertices(face);
        var vlen = vertices.length;
        if (vlen === 3) continue;
        var v0 = positions[vertices[0].getIndex()];
        var v1 = positions[vertices[1].getIndex()];
        var v2 = positions[vertices[2].getIndex()];
        var normal = calculateNormal(v0, v1, v2);
        var faceOri = quat.create();
        quat.rotationTo(faceOri, normal, zAxis);
        var polygon = [];
        var indicies = [];
        for(var j = 0; j < vlen; j++){
            var vertex = vertices[j];
            var vertexIndex = vertex.getIndex();
            var vertexPos = vec3.clone(positions[vertexIndex]);
            vec3.transformQuat(vertexPos, vertexPos, faceOri);
            polygon.push([
                vertexPos[0],
                vertexPos[1]
            ]);
            indicies.push(vertexIndex);
        }
        var results = triangulatePolygon(polygon);
        var rlen = results.length;
        for(var k = 0; k < rlen; k++){
            var result = results[k];
            var i1 = indicies[result[1]];
            var i2 = indicies[result[2]];
            InsertEdge(mesh, i1, i2);
        }
    }
};

},{"./../Queries/FaceVertices":"elyLX","guf":"hlcpy","cga":"6OXri","gl-matrix":"3TXam","./InsertEdge":"e3H1k"}],"hlcpy":[function(require,module,exports) {
//ARRAYS
exports.normalizeArray = require('./guf/normalize-array');
//NORMALS
exports.faceNormals = require('./guf/face-normals');
exports.vertexNormals = require('./guf/vertex-normals');
//ONE NORMAL
exports.calculateNormal = require('./guf/calculate-normal');
//HELPFUL UTILS
exports.cross = require('./guf/cross');
exports.normalize = require('./guf/normalize');

},{"./guf/normalize-array":"hbYme","./guf/face-normals":"pRQIg","./guf/vertex-normals":"4Wsz2","./guf/calculate-normal":"2LifG","./guf/cross":"2QhQE","./guf/normalize":"dO7Tz"}],"hbYme":[function(require,module,exports) {
module.exports = function(a) {
    var result = [];
    var len = a.length;
    var slen = a[0].length;
    var addZ = slen < 3 ? true : false;
    for(var i = 0; i < len; i++){
        for(var j = 0; j < slen; j++)result.push(a[i][j]);
        if (addZ) result.push(0);
    }
    return result;
};

},{}],"pRQIg":[function(require,module,exports) {
var normalize = require('guf').normalizeArray;
var calculateNormal = require('./calculate-normal');
module.exports = function(verts, faces) {
    var positions = verts;
    var con = verts[0].constructor;
    if (con === Array || con == Float32Array) positions = normalize(verts);
    var cells = faces[0].constructor === Array ? normalize(faces) : faces;
    var normals = [];
    var i0, i1, i2;
    var a = [];
    var b = [];
    var c = [];
    var d = [];
    for(var i = 0; i < cells.length; i += 3){
        i0 = cells[i] * 3;
        i1 = cells[i + 1] * 3;
        i2 = cells[i + 2] * 3;
        a[0] = positions[i0];
        a[1] = positions[i0 + 1];
        a[2] = positions[i0 + 2];
        b[0] = positions[i1];
        b[1] = positions[i1 + 1];
        b[2] = positions[i1 + 2];
        c[0] = positions[i2];
        c[1] = positions[i2 + 1];
        c[2] = positions[i2 + 2];
        d = calculateNormal(a, b, c);
        normals[i] = d[0];
        normals[i + 1] = d[1];
        normals[i + 2] = d[2];
    }
    return normals;
};

},{"guf":"hlcpy","./calculate-normal":"2LifG"}],"2LifG":[function(require,module,exports) {
var cross = require('./cross');
var normalize = require('./normalize');
module.exports = function(a, b, c) {
    var r = [
        0,
        0,
        0
    ];
    cross(r, a, b, c);
    normalize(r, r);
    return r;
};

},{"./cross":"2QhQE","./normalize":"dO7Tz"}],"2QhQE":[function(require,module,exports) {
module.exports = function(out, a, b, c) {
    var abx = b[0] - a[0], aby = b[1] - a[1], abz = b[2] - a[2], acx = c[0] - a[0], acy = c[1] - a[1], acz = c[2] - a[2];
    out[0] = aby * acz - abz * acy;
    out[1] = abz * acx - abx * acz;
    out[2] = abx * acy - aby * acx;
    return out;
};

},{}],"dO7Tz":[function(require,module,exports) {
module.exports = function(out, v) {
    var length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
    out[0] = v[0] / length;
    out[1] = v[1] / length;
    out[2] = v[2] / length;
    return out;
};

},{}],"4Wsz2":[function(require,module,exports) {
var cross = require('./cross');
var normalize = require('./normalize');
var normalizeArray = require('./normalize-array');
module.exports = function(verts, faces) {
    var positions = verts[0].constructor === Array ? normalizeArray(verts) : verts;
    var cells = faces[0].constructor === Array ? normalizeArray(faces) : faces;
    //Create Vertex Face Map ( tells you which vert belong to what faces )
    var map = {
    };
    var plen = positions.length / 3;
    for(var i = 0; i < plen; i++)map[i] = [];
    //Fill in Map
    var clen = cells.length;
    var i0, i1, i2, index;
    for(var i = 0; i < clen; i += 3){
        index = i;
        i0 = index;
        i1 = index + 1;
        i2 = index + 2;
        map[cells[i0]].push(i);
        map[cells[i1]].push(i);
        map[cells[i2]].push(i);
    }
    //Calculate Vertex Normals
    var normals = [];
    var temp = [
        0,
        0,
        0
    ];
    var norm = [
        0,
        0,
        0
    ];
    var keys = Object.keys(map);
    var v0, v1, v2, a = [
        0,
        0,
        0
    ], b = [
        0,
        0,
        0
    ], c = [
        0,
        0,
        0
    ];
    for(var i = 0; i < keys.length; i++){
        var faces = map[keys[i]];
        for(var j = 0; j < faces.length; j++){
            var index = faces[j];
            v0 = cells[index];
            v1 = cells[index + 1];
            v2 = cells[index + 2];
            a[0] = positions[v0 * 3];
            a[1] = positions[v0 * 3 + 1];
            a[2] = positions[v0 * 3 + 2];
            b[0] = positions[v1 * 3];
            b[1] = positions[v1 * 3 + 1];
            b[2] = positions[v1 * 3 + 2];
            c[0] = positions[v2 * 3];
            c[1] = positions[v2 * 3 + 1];
            c[2] = positions[v2 * 3 + 2];
            cross(temp, a, b, c);
            norm[0] += temp[0];
            norm[1] += temp[1];
            norm[2] += temp[2];
        }
        normalize(norm, norm);
        normals.push(norm[0], norm[1], norm[2]);
        norm[0] = 0;
        norm[1] = 0;
        norm[2] = 0;
    }
    return normals;
};

},{"./cross":"2QhQE","./normalize":"dO7Tz","./normalize-array":"hbYme"}],"6OXri":[function(require,module,exports) {
//1D Functions
exports.greaterThanZero = require("./cga/greater-than-zero-1d.js");
exports.isEqual = require("./cga/is-equal-1d.js");
exports.isZero = require("./cga/is-zero-1d.js");
//2D Functions
exports.area2 = require("./cga/area2-2d.js");
exports.convexHull2 = require("./cga/convex-hull-2d.js");
exports.cross2 = require("./cga/cross-2d.js");
exports.expandPolygon2 = require("./cga/expand-polygon-2d.js");
exports.inCone2 = require("./cga/in-cone-2d.js");
exports.intersection2 = require("./cga/intersection-2d.js");
exports.intersects2 = require("./cga/intersects-2d.js");
exports.intersectsProper2 = require("./cga/intersects-proper-2d.js");
exports.isBetween2 = require("./cga/is-between-2d.js");
exports.isColinear2 = require("./cga/is-colinear-2d.js");
exports.isDiagonal2 = require("./cga/is-diagonal-2d.js");
exports.isDiagonalie2 = require("./cga/is-diagonalie-2d.js");
exports.isEqual2 = require("./cga/is-equal-2d.js");
exports.isLeft2 = require("./cga/is-left-2d.js");
exports.isLeftOn2 = require("./cga/is-left-on-2d.js");
exports.triangulatePolygon2 = require("./cga/triangulate-polygon-2d.js");
//3D Functions
exports.isColinear3 = require("./cga/is-colinear-3d.js");

},{"./cga/greater-than-zero-1d.js":"2i5lt","./cga/is-equal-1d.js":"3tsmP","./cga/is-zero-1d.js":"bzoFj","./cga/area2-2d.js":"jmO8T","./cga/convex-hull-2d.js":"bVbna","./cga/cross-2d.js":"66ave","./cga/expand-polygon-2d.js":"dPgq8","./cga/in-cone-2d.js":"3D3fk","./cga/intersection-2d.js":"hL4qm","./cga/intersects-2d.js":"JHiGh","./cga/intersects-proper-2d.js":"hFVyS","./cga/is-between-2d.js":"gs80s","./cga/is-colinear-2d.js":"avCJ3","./cga/is-diagonal-2d.js":"3uoBd","./cga/is-diagonalie-2d.js":"cykSS","./cga/is-equal-2d.js":"e4Ra3","./cga/is-left-2d.js":"kloc4","./cga/is-left-on-2d.js":"1Bcyb","./cga/triangulate-polygon-2d.js":"kAGmZ","./cga/is-colinear-3d.js":"fgQl4"}],"2i5lt":[function(require,module,exports) {
module.exports = function(a) {
    return a > 0.00001;
};

},{}],"3tsmP":[function(require,module,exports) {
var isZero = require('./is-zero-1d');
module.exports = function(a, b) {
    return a === b || isZero(a - b);
};

},{"./is-zero-1d":"bzoFj"}],"bzoFj":[function(require,module,exports) {
module.exports = function(a) {
    return a === 0 || Math.abs(a) < 0.000001;
};

},{}],"jmO8T":[function(require,module,exports) {
module.exports = function(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
};

},{}],"bVbna":[function(require,module,exports) {
var isEqual = require('./is-equal-1d');
var isLeft = require('./is-left-2d');
module.exports = function(polygon) {
    // find the lowest rightmost point
    var ri = -1;
    var rx = -1000000, ry = 10000000;
    var len = polygon.length;
    var x, y;
    for(var i = 0; i < len; i++){
        x = polygon[i][0];
        y = polygon[i][1];
        if (y < ry || y == ry && x > rx) {
            ri = i;
            rx = x;
            ry = y;
        }
    }
    // calculate the angles (relative to the positive x-axis) from bottom
    // right most point and every other point
    var angles = [];
    for(var i = 0; i < len; i++){
        x = polygon[i][0] - rx;
        y = polygon[i][1] - ry;
        angles[i] = {
            'key': i,
            'value': Math.atan2(y, x),
            'length': x * x + y * y
        };
    }
    // sort the angles, keep the indicies of the original points for referece
    angles.sort(function(a, b) {
        if (isEqual(a.value, b.value)) return 0;
        else if (a.value < b.value) return -1;
        return 1;
    });
    // remove points that have the same angle ( only remove the one closest to
    // the bottom right most point )
    var a1, b1;
    for(var i = 1; i < angles.length; i++){
        a1 = angles[i - 1];
        b1 = angles[i];
        if (isEqual(a1.value, b1.value)) {
            if (a1.length > b1.length) angles.splice(i, 1); //remove b ( 1 )
            else angles.splice(i - 1, 1); //remove a ( 0 )
            i--;
        }
    }
    // use graham's algorithm to find the convex hull ( checks
    // to see if the next point on the stack turns left or right
    // if it turns right, the remove it and test again till you turn left
    var i = 1;
    var limit = angles.length;
    var index;
    var stack = [
        angles[limit - 1].key,
        ri
    ];
    while(i < limit){
        index = angles[i].key;
        var s = stack.length - 1;
        var sl = s - 1;
        if (isLeft(polygon[stack[sl]], polygon[stack[s]], polygon[index])) {
            stack.push(index);
            i++;
        } else stack.pop();
    }
    return stack;
};

},{"./is-equal-1d":"3tsmP","./is-left-2d":"kloc4"}],"kloc4":[function(require,module,exports) {
var greaterThanZero = require('./greater-than-zero-1d');
var area2 = require('./area2-2d');
module.exports = function(a, b, c) {
    return greaterThanZero(area2(a, b, c));
};

},{"./greater-than-zero-1d":"2i5lt","./area2-2d":"jmO8T"}],"66ave":[function(require,module,exports) {
module.exports = function(a, b) {
    return a[0] * b[1] - b[0] * a[1];
};

},{}],"dPgq8":[function(require,module,exports) {
var vec2 = require('gl-matrix').vec2;
var vec3 = require('gl-matrix').vec3;
var intersection = require('./intersection-2d');
module.exports = function(polygon, amount) {
    amount = amount == undefined ? 0.5 : amount;
    var result = [];
    var len = polygon.length;
    var cpr = vec3.create();
    var zdir = vec3.fromValues(0, 0, 1);
    var cdir = vec3.create();
    var a = vec2.create();
    var b = vec2.create();
    var c = vec2.create();
    var d = vec2.create();
    var dir = vec2.create();
    var at, bt, ct, t;
    // Preform first a, b, calculation so we optimise loop
    at = polygon[len - 1];
    bt = polygon[0];
    vec2.copy(a, at);
    vec2.copy(b, bt);
    vec2.subtract(dir, b, a);
    vec3.set(cdir, dir[0], dir[1], 0);
    vec3.cross(cpr, cdir, zdir);
    vec3.normalize(cpr, cpr);
    vec3.scale(cpr, cpr, amount);
    vec2.copy(dir, cpr);
    vec2.add(a, a, dir);
    vec2.add(b, b, dir);
    for(var i = 0; i < len; i++){
        bt = polygon[i];
        ct = polygon[(i + 1) % len];
        vec2.copy(c, bt);
        vec2.copy(d, ct);
        vec2.subtract(dir, d, c);
        vec3.set(cdir, dir[0], dir[1], 0);
        vec3.cross(cpr, cdir, zdir);
        vec3.normalize(cpr, cpr);
        vec3.scale(cpr, cpr, amount);
        vec2.copy(dir, cpr);
        vec2.add(c, c, dir);
        vec2.add(d, d, dir);
        result.push(intersection(a, b, c, d));
        vec2.copy(a, c);
        vec2.copy(b, d);
    }
    return result;
};

},{"gl-matrix":"kzvF6","./intersection-2d":"hL4qm"}],"kzvF6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "glMatrix", ()=>_commonJs
);
parcelHelpers.export(exports, "mat2", ()=>_mat2Js
);
parcelHelpers.export(exports, "mat2d", ()=>_mat2DJs
);
parcelHelpers.export(exports, "mat3", ()=>_mat3Js
);
parcelHelpers.export(exports, "mat4", ()=>_mat4Js
);
parcelHelpers.export(exports, "quat", ()=>_quatJs
);
parcelHelpers.export(exports, "quat2", ()=>_quat2Js
);
parcelHelpers.export(exports, "vec2", ()=>_vec2Js
);
parcelHelpers.export(exports, "vec3", ()=>_vec3Js
);
parcelHelpers.export(exports, "vec4", ()=>_vec4Js
);
var _commonJs = require("./gl-matrix/common.js");
var _mat2Js = require("./gl-matrix/mat2.js");
var _mat2DJs = require("./gl-matrix/mat2d.js");
var _mat3Js = require("./gl-matrix/mat3.js");
var _mat4Js = require("./gl-matrix/mat4.js");
var _quatJs = require("./gl-matrix/quat.js");
var _quat2Js = require("./gl-matrix/quat2.js");
var _vec2Js = require("./gl-matrix/vec2.js");
var _vec3Js = require("./gl-matrix/vec3.js");
var _vec4Js = require("./gl-matrix/vec4.js");

},{"./gl-matrix/common.js":"fLrSS","./gl-matrix/mat2.js":"cAnzp","./gl-matrix/mat2d.js":"7P4Yo","./gl-matrix/mat3.js":"62qxW","./gl-matrix/mat4.js":"4qMJv","./gl-matrix/quat.js":"lPOiD","./gl-matrix/quat2.js":"aGpcr","./gl-matrix/vec2.js":"1PFsL","./gl-matrix/vec3.js":"baThR","./gl-matrix/vec4.js":"eMR41","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fLrSS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EPSILON", ()=>EPSILON
);
parcelHelpers.export(exports, "ARRAY_TYPE", ()=>ARRAY_TYPE
);
parcelHelpers.export(exports, "RANDOM", ()=>RANDOM
);
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */ parcelHelpers.export(exports, "setMatrixArrayType", ()=>setMatrixArrayType
);
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */ parcelHelpers.export(exports, "toRadian", ()=>toRadian
);
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
function setMatrixArrayType(type) {
    ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
function toRadian(a) {
    return a * degree;
}
function equals(a, b) {
    return Math.abs(a - b) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cAnzp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 2x2 Matrix
 * @module mat2
 */ /**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "transpose", ()=>transpose
);
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "adjoint", ()=>adjoint
);
/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */ parcelHelpers.export(exports, "determinant", ()=>determinant
);
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "fromScaling", ()=>fromScaling
);
/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */ parcelHelpers.export(exports, "frob", ()=>frob
);
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */ parcelHelpers.export(exports, "LDU", ()=>LDU
);
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "multiplyScalar", ()=>multiplyScalar
);
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "multiplyScalarAndAdd", ()=>multiplyScalarAndAdd
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "sub", ()=>sub
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(4);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
    }
    out[0] = 1;
    out[3] = 1;
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
}
function fromValues(m00, m01, m10, m11) {
    var out = new _commonJs.ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
}
function set(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
}
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache
    // some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    return out;
}
function invert(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    // Calculate the determinant
    var det = a0 * a3 - a2 * a1;
    if (!det) return null;
    det = 1 / det;
    out[0] = a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] = a0 * det;
    return out;
}
function adjoint(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] = a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a0;
    return out;
}
function determinant(a) {
    return a[0] * a[3] - a[2] * a[1];
}
function multiply(out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
}
function rotate(out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
}
function scale(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
}
function fromRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}
function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}
function str(a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
}
function LDU(L, D, U, a) {
    L[2] = a[2] / a[0];
    U[0] = a[0];
    U[1] = a[1];
    U[3] = a[3] - L[2] * U[1];
    return [
        L,
        D,
        U
    ];
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
}
function multiplyScalarAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    return out;
}
var mul = multiply;
var sub = subtract;

},{"./common.js":"fLrSS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7P4Yo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */ /**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */ parcelHelpers.export(exports, "determinant", ()=>determinant
);
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "fromScaling", ()=>fromScaling
);
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "fromTranslation", ()=>fromTranslation
);
/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */ parcelHelpers.export(exports, "frob", ()=>frob
);
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "multiplyScalar", ()=>multiplyScalar
);
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "multiplyScalarAndAdd", ()=>multiplyScalarAndAdd
);
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "sub", ()=>sub
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(6);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[4] = 0;
        out[5] = 0;
    }
    out[0] = 1;
    out[3] = 1;
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
}
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
}
function fromValues(a, b, c, d, tx, ty) {
    var out = new _commonJs.ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
}
function set(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
}
function invert(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3];
    var atx = a[4], aty = a[5];
    var det = aa * ad - ab * ac;
    if (!det) return null;
    det = 1 / det;
    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
}
function determinant(a) {
    return a[0] * a[3] - a[1] * a[2];
}
function multiply(out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
}
function rotate(out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
}
function scale(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
}
function translate(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
}
function fromRotation(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}
function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}
function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}
function str(a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}
function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
}
function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
}
function multiplyScalarAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    out[4] = a[4] + b[4] * scale1;
    out[5] = a[5] + b[5] * scale1;
    return out;
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _commonJs.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _commonJs.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5));
}
var mul = multiply;
var sub = subtract;

},{"./common.js":"fLrSS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"62qxW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 3x3 Matrix
 * @module mat3
 */ /**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "fromMat4", ()=>fromMat4
);
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "transpose", ()=>transpose
);
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "adjoint", ()=>adjoint
);
/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */ parcelHelpers.export(exports, "determinant", ()=>determinant
);
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "fromTranslation", ()=>fromTranslation
);
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "fromScaling", ()=>fromScaling
);
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/ parcelHelpers.export(exports, "fromMat2d", ()=>fromMat2d
);
/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/ parcelHelpers.export(exports, "fromQuat", ()=>fromQuat
);
/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/ parcelHelpers.export(exports, "normalFromMat4", ()=>normalFromMat4
);
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "projection", ()=>projection
);
/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */ parcelHelpers.export(exports, "frob", ()=>frob
);
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "multiplyScalar", ()=>multiplyScalar
);
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "multiplyScalarAndAdd", ()=>multiplyScalarAndAdd
);
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "sub", ()=>sub
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(9);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
}
function fromMat4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new _commonJs.ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
}
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
}
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    return out;
}
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    // Calculate the determinant
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) return null;
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
}
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
}
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
}
function translate(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
}
function rotate(out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
}
function scale(out, a, v) {
    var x = v[0], y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
}
function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}
function fromRotation(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}
function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}
function fromMat2d(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;
    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;
    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
}
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
}
function normalFromMat4(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    // Calculate the determinant
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) return null;
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
}
function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
}
function str(a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}
function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
}
function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
}
function multiplyScalarAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    out[4] = a[4] + b[4] * scale1;
    out[5] = a[5] + b[5] * scale1;
    out[6] = a[6] + b[6] * scale1;
    out[7] = a[7] + b[7] * scale1;
    out[8] = a[8] + b[8] * scale1;
    return out;
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _commonJs.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _commonJs.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _commonJs.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _commonJs.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _commonJs.EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul = multiply;
var sub = subtract;

},{"./common.js":"fLrSS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4qMJv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */ /**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "transpose", ()=>transpose
);
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "adjoint", ()=>adjoint
);
/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */ parcelHelpers.export(exports, "determinant", ()=>determinant
);
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromTranslation", ()=>fromTranslation
);
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromScaling", ()=>fromScaling
);
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromXRotation", ()=>fromXRotation
);
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromYRotation", ()=>fromYRotation
);
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromZRotation", ()=>fromZRotation
);
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromRotationTranslation", ()=>fromRotationTranslation
);
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */ parcelHelpers.export(exports, "fromQuat2", ()=>fromQuat2
);
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */ parcelHelpers.export(exports, "getTranslation", ()=>getTranslation
);
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */ parcelHelpers.export(exports, "getScaling", ()=>getScaling
);
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */ parcelHelpers.export(exports, "getRotation", ()=>getRotation
);
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromRotationTranslationScale", ()=>fromRotationTranslationScale
);
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromRotationTranslationScaleOrigin", ()=>fromRotationTranslationScaleOrigin
);
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromQuat", ()=>fromQuat
);
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "frustum", ()=>frustum
);
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "perspective", ()=>perspective
);
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "perspectiveFromFieldOfView", ()=>perspectiveFromFieldOfView
);
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "ortho", ()=>ortho
);
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "lookAt", ()=>lookAt
);
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "targetTo", ()=>targetTo
);
/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */ parcelHelpers.export(exports, "frob", ()=>frob
);
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "multiplyScalar", ()=>multiplyScalar
);
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "multiplyScalarAndAdd", ()=>multiplyScalarAndAdd
);
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "sub", ()=>sub
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(16);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new _commonJs.ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
}
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
}
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3];
        var a12 = a[6], a13 = a[7];
        var a23 = a[11];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    return out;
}
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    // Calculate the determinant
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) return null;
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
}
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
}
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    // Cache only the current line of the second matrix
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
}
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    var a00 = void 0, a01 = void 0, a02 = void 0, a03 = void 0;
    var a10 = void 0, a11 = void 0, a12 = void 0, a13 = void 0;
    var a20 = void 0, a21 = void 0, a22 = void 0, a23 = void 0;
    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0];
        a01 = a[1];
        a02 = a[2];
        a03 = a[3];
        a10 = a[4];
        a11 = a[5];
        a12 = a[6];
        a13 = a[7];
        a20 = a[8];
        a21 = a[9];
        a22 = a[10];
        a23 = a[11];
        out[0] = a00;
        out[1] = a01;
        out[2] = a02;
        out[3] = a03;
        out[4] = a10;
        out[5] = a11;
        out[6] = a12;
        out[7] = a13;
        out[8] = a20;
        out[9] = a21;
        out[10] = a22;
        out[11] = a23;
        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
}
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len = Math.sqrt(x * x + y * y + z * z);
    var s = void 0, c = void 0, t = void 0;
    var a00 = void 0, a01 = void 0, a02 = void 0, a03 = void 0;
    var a10 = void 0, a11 = void 0, a12 = void 0, a13 = void 0;
    var a20 = void 0, a21 = void 0, a22 = void 0, a23 = void 0;
    var b00 = void 0, b01 = void 0, b02 = void 0;
    var b10 = void 0, b11 = void 0, b12 = void 0;
    var b20 = void 0, b21 = void 0, b22 = void 0;
    if (len < _commonJs.EPSILON) return null;
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    // Construct the elements of the rotation matrix
    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c;
    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
        // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
}
function rotateX(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
}
function rotateY(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
}
function rotateZ(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged last row
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
}
function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromRotation(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len = Math.sqrt(x * x + y * y + z * z);
    var s = void 0, c = void 0, t = void 0;
    if (len < _commonJs.EPSILON) return null;
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromXRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    // Perform axis-specific matrix multiplication
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromYRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    // Perform axis-specific matrix multiplication
    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromZRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    // Perform axis-specific matrix multiplication
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function fromQuat2(out, a) {
    var translation = new _commonJs.ARRAY_TYPE(3);
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw;
    //Only scale if it makes sense
    if (magnitude > 0) {
        translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
        translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
        translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
        translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
        translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
        translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    fromRotationTranslation(out, a, translation);
    return out;
}
function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
}
function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    return out;
}
function getRotation(out, mat) {
    // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    var trace = mat[0] + mat[5] + mat[10];
    var S = 0;
    if (trace > 0) {
        S = Math.sqrt(trace + 1) * 2;
        out[3] = 0.25 * S;
        out[0] = (mat[6] - mat[9]) / S;
        out[1] = (mat[8] - mat[2]) / S;
        out[2] = (mat[1] - mat[4]) / S;
    } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
        S = Math.sqrt(1 + mat[0] - mat[5] - mat[10]) * 2;
        out[3] = (mat[6] - mat[9]) / S;
        out[0] = 0.25 * S;
        out[1] = (mat[1] + mat[4]) / S;
        out[2] = (mat[8] + mat[2]) / S;
    } else if (mat[5] > mat[10]) {
        S = Math.sqrt(1 + mat[5] - mat[0] - mat[10]) * 2;
        out[3] = (mat[8] - mat[2]) / S;
        out[0] = (mat[1] + mat[4]) / S;
        out[1] = 0.25 * S;
        out[2] = (mat[6] + mat[9]) / S;
    } else {
        S = Math.sqrt(1 + mat[10] - mat[0] - mat[5]) * 2;
        out[3] = (mat[1] - mat[4]) / S;
        out[0] = (mat[8] + mat[2]) / S;
        out[1] = (mat[6] + mat[9]) / S;
        out[2] = 0.25 * S;
    }
    return out;
}
function fromRotationTranslationScale(out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
}
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
}
function perspective(out, fovy, aspect, near, far) {
    var f = 1 / Math.tan(fovy / 2), nf = void 0;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
        nf = 1 / (near - far);
        out[10] = (far + near) * nf;
        out[14] = 2 * far * near * nf;
    } else {
        out[10] = -1;
        out[14] = -2 * near;
    }
    return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    var xScale = 2 / (leftTan + rightTan);
    var yScale = 2 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = yScale;
    out[6] = 0;
    out[7] = 0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near / (near - far);
    out[15] = 0;
    return out;
}
function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
}
function lookAt(out, eye, center, up) {
    var x0 = void 0, x1 = void 0, x2 = void 0, y0 = void 0, y1 = void 0, y2 = void 0, z0 = void 0, z1 = void 0, z2 = void 0, len = void 0;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];
    if (Math.abs(eyex - centerx) < _commonJs.EPSILON && Math.abs(eyey - centery) < _commonJs.EPSILON && Math.abs(eyez - centerz) < _commonJs.EPSILON) return identity(out);
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
}
function targetTo(out, eye, target, up) {
    var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
    var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
    var len = z0 * z0 + z1 * z1 + z2 * z2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        z0 *= len;
        z1 *= len;
        z2 *= len;
    }
    var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
}
function str(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}
function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
}
function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
}
function multiplyScalarAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    out[4] = a[4] + b[4] * scale1;
    out[5] = a[5] + b[5] * scale1;
    out[6] = a[6] + b[6] * scale1;
    out[7] = a[7] + b[7] * scale1;
    out[8] = a[8] + b[8] * scale1;
    out[9] = a[9] + b[9] * scale1;
    out[10] = a[10] + b[10] * scale1;
    out[11] = a[11] + b[11] * scale1;
    out[12] = a[12] + b[12] * scale1;
    out[13] = a[13] + b[13] * scale1;
    out[14] = a[14] + b[14] * scale1;
    out[15] = a[15] + b[15] * scale1;
    return out;
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
    var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
    var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
    var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _commonJs.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _commonJs.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _commonJs.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _commonJs.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _commonJs.EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _commonJs.EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _commonJs.EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _commonJs.EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _commonJs.EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _commonJs.EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _commonJs.EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _commonJs.EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul = multiply;
var sub = subtract;

},{"./common.js":"fLrSS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lPOiD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Quaternion
 * @module quat
 */ /**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/ parcelHelpers.export(exports, "setAxisAngle", ()=>setAxisAngle
);
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */ parcelHelpers.export(exports, "getAxisAngle", ()=>getAxisAngle
);
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */ parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */ parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */ parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */ parcelHelpers.export(exports, "calculateW", ()=>calculateW
);
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */ parcelHelpers.export(exports, "slerp", ()=>slerp
);
/**
 * Generates a random quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */ parcelHelpers.export(exports, "random", ()=>random
);
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */ parcelHelpers.export(exports, "conjugate", ()=>conjugate
);
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */ parcelHelpers.export(exports, "fromMat3", ()=>fromMat3
);
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */ parcelHelpers.export(exports, "fromEuler", ()=>fromEuler
);
/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */ parcelHelpers.export(exports, "str", ()=>str
);
parcelHelpers.export(exports, "clone", ()=>clone
);
parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
parcelHelpers.export(exports, "copy", ()=>copy
);
parcelHelpers.export(exports, "set", ()=>set
);
parcelHelpers.export(exports, "add", ()=>add
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "scale", ()=>scale
);
parcelHelpers.export(exports, "dot", ()=>dot
);
parcelHelpers.export(exports, "lerp", ()=>lerp
);
parcelHelpers.export(exports, "length", ()=>length
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
parcelHelpers.export(exports, "normalize", ()=>normalize
);
parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "rotationTo", ()=>rotationTo
);
parcelHelpers.export(exports, "sqlerp", ()=>sqlerp
);
parcelHelpers.export(exports, "setAxes", ()=>setAxes
);
var _commonJs = require("./common.js");
var _mat3Js = require("./mat3.js");
var _vec3Js = require("./vec3.js");
var _vec4Js = require("./vec4.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(4);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
    }
    out[3] = 1;
    return out;
}
function identity(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
}
function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
}
function getAxisAngle(out_axis, q) {
    var rad = Math.acos(q[3]) * 2;
    var s = Math.sin(rad / 2);
    if (s > _commonJs.EPSILON) {
        out_axis[0] = q[0] / s;
        out_axis[1] = q[1] / s;
        out_axis[2] = q[2] / s;
    } else {
        // If s is zero, return any axis (no rotation - axis does not matter)
        out_axis[0] = 1;
        out_axis[1] = 0;
        out_axis[2] = 0;
    }
    return rad;
}
function multiply(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
}
function rotateX(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
}
function rotateY(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var by = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
}
function rotateZ(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bz = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
}
function calculateW(out, a) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
    return out;
}
function slerp(out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    var omega = void 0, cosom = void 0, sinom = void 0, scale0 = void 0, scale1 = void 0;
    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if (cosom < 0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
    }
    // calculate coefficients
    if (1 - cosom > _commonJs.EPSILON) {
        // standard case (slerp)
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {
        // "from" and "to" quaternions are very close
        //  ... so we can do a linear interpolation
        scale0 = 1 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
}
function random(out) {
    // Implementation of http://planning.cs.uiuc.edu/node198.html
    // TODO: Calling random 3 times is probably not the fastest solution
    var u1 = _commonJs.RANDOM();
    var u2 = _commonJs.RANDOM();
    var u3 = _commonJs.RANDOM();
    var sqrt1MinusU1 = Math.sqrt(1 - u1);
    var sqrtU1 = Math.sqrt(u1);
    out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
    out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
    out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
    out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
    return out;
}
function invert(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var dot1 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
    var invDot = dot1 ? 1 / dot1 : 0;
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a2 * invDot;
    out[3] = a3 * invDot;
    return out;
}
function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
}
function fromMat3(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot = void 0;
    if (fTrace > 0) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1); // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot; // 1/(4w)
        out[0] = (m[5] - m[7]) * fRoot;
        out[1] = (m[6] - m[2]) * fRoot;
        out[2] = (m[1] - m[3]) * fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if (m[4] > m[0]) i = 1;
        if (m[8] > m[i * 3 + i]) i = 2;
        var j = (i + 1) % 3;
        var k = (i + 2) % 3;
        fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
        out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
        out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }
    return out;
}
function fromEuler(out, x, y, z) {
    var halfToRad = 0.5 * Math.PI / 180;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
}
function str(a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
var clone = _vec4Js.clone;
var fromValues = _vec4Js.fromValues;
var copy = _vec4Js.copy;
var set = _vec4Js.set;
var add = _vec4Js.add;
var mul = multiply;
var scale = _vec4Js.scale;
var dot = _vec4Js.dot;
var lerp = _vec4Js.lerp;
var length = _vec4Js.length;
var len = length;
var squaredLength = _vec4Js.squaredLength;
var sqrLen = squaredLength;
var normalize = _vec4Js.normalize;
var exactEquals = _vec4Js.exactEquals;
var equals = _vec4Js.equals;
var rotationTo = function() {
    var tmpvec3 = _vec3Js.create();
    var xUnitVec3 = _vec3Js.fromValues(1, 0, 0);
    var yUnitVec3 = _vec3Js.fromValues(0, 1, 0);
    return function(out, a, b) {
        var dot2 = _vec3Js.dot(a, b);
        if (dot2 < -0.999999) {
            _vec3Js.cross(tmpvec3, xUnitVec3, a);
            if (_vec3Js.len(tmpvec3) < 0.000001) _vec3Js.cross(tmpvec3, yUnitVec3, a);
            _vec3Js.normalize(tmpvec3, tmpvec3);
            setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot2 > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            _vec3Js.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot2;
            return normalize(out, out);
        }
    };
}();
var sqlerp = function() {
    var temp1 = create();
    var temp2 = create();
    return function(out, a, b, c, d, t) {
        slerp(temp1, a, d, t);
        slerp(temp2, b, c, t);
        slerp(out, temp1, temp2, 2 * t * (1 - t));
        return out;
    };
}();
var setAxes = function() {
    var matr = _mat3Js.create();
    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];
        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];
        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];
        return normalize(out, fromMat3(out, matr));
    };
}();

},{"./common.js":"fLrSS","./mat3.js":"62qxW","./vec3.js":"baThR","./vec4.js":"eMR41","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"baThR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 3 Dimensional Vector
 * @module vec3
 */ /**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */ parcelHelpers.export(exports, "length", ()=>length
);
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "divide", ()=>divide
);
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "ceil", ()=>ceil
);
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "floor", ()=>floor
);
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "min", ()=>min
);
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "max", ()=>max
);
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "round", ()=>round
);
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "scaleAndAdd", ()=>scaleAndAdd
);
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */ parcelHelpers.export(exports, "distance", ()=>distance
);
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance
);
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */ parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "negate", ()=>negate
);
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "inverse", ()=>inverse
);
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */ parcelHelpers.export(exports, "dot", ()=>dot
);
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "cross", ()=>cross
);
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "lerp", ()=>lerp
);
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "hermite", ()=>hermite
);
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "bezier", ()=>bezier
);
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "random", ()=>random
);
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "transformMat4", ()=>transformMat4
);
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "transformMat3", ()=>transformMat3
);
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "transformQuat", ()=>transformQuat
);
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */ parcelHelpers.export(exports, "angle", ()=>angle
);
/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "sub", ()=>sub
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "div", ()=>div
);
parcelHelpers.export(exports, "dist", ()=>dist
);
parcelHelpers.export(exports, "sqrDist", ()=>sqrDist
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
parcelHelpers.export(exports, "forEach", ()=>forEach
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(3);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
    }
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
}
function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.sqrt(x * x + y * y + z * z);
}
function fromValues(x, y, z) {
    var out = new _commonJs.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
}
function set(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
}
function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
}
function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
}
function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
}
function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
}
function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
}
function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
}
function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
}
function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
}
function scaleAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    return out;
}
function distance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.sqrt(x * x + y * y + z * z);
}
function squaredDistance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
}
function squaredLength(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
}
function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
}
function inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    return out;
}
function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len1 = x * x + y * y + z * z;
    if (len1 > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len1 = 1 / Math.sqrt(len1);
        out[0] = a[0] * len1;
        out[1] = a[1] * len1;
        out[2] = a[2] * len1;
    }
    return out;
}
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
}
function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
}
function hermite(out, a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
}
function bezier(out, a, b, c, d, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
}
function random(out, scale2) {
    scale2 = scale2 || 1;
    var r = _commonJs.RANDOM() * 2 * Math.PI;
    var z = _commonJs.RANDOM() * 2 - 1;
    var zScale = Math.sqrt(1 - z * z) * scale2;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale2;
    return out;
}
function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
}
function transformMat3(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
}
function transformQuat(out, a, q) {
    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x = a[0], y = a[1], z = a[2];
    // var qvec = [qx, qy, qz];
    // var uv = vec3.cross([], qvec, a);
    var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
    // var uuv = vec3.cross([], qvec, uv);
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    // vec3.scale(uv, uv, 2 * w);
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    // vec3.scale(uuv, uuv, 2);
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    // return vec3.add(out, a, vec3.add(out, uv, uuv));
    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
}
function rotateX(out, a, b, c) {
    var p = [], r = [];
    //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    //perform rotation
    r[0] = p[0];
    r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
    r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);
    //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function rotateY(out, a, b, c) {
    var p = [], r = [];
    //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    //perform rotation
    r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);
    //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function rotateZ(out, a, b, c) {
    var p = [], r = [];
    //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    //perform rotation
    r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
    r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
    r[2] = p[2];
    //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function angle(a, b) {
    var tempA = fromValues(a[0], a[1], a[2]);
    var tempB = fromValues(b[0], b[1], b[2]);
    normalize(tempA, tempA);
    normalize(tempB, tempB);
    var cosine = dot(tempA, tempB);
    if (cosine > 1) return 0;
    else if (cosine < -1) return Math.PI;
    else return Math.acos(cosine);
}
function str(a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
    var vec = create();
    return function(a, stride, offset, count, fn, arg) {
        var i = void 0, l = void 0;
        if (!stride) stride = 3;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
        }
        return a;
    };
}();

},{"./common.js":"fLrSS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eMR41":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 4 Dimensional Vector
 * @module vec4
 */ /**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "divide", ()=>divide
);
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "ceil", ()=>ceil
);
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "floor", ()=>floor
);
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "min", ()=>min
);
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "max", ()=>max
);
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "round", ()=>round
);
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "scaleAndAdd", ()=>scaleAndAdd
);
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */ parcelHelpers.export(exports, "distance", ()=>distance
);
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance
);
/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */ parcelHelpers.export(exports, "length", ()=>length
);
/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */ parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "negate", ()=>negate
);
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "inverse", ()=>inverse
);
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */ parcelHelpers.export(exports, "dot", ()=>dot
);
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "lerp", ()=>lerp
);
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "random", ()=>random
);
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "transformMat4", ()=>transformMat4
);
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "transformQuat", ()=>transformQuat
);
/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "sub", ()=>sub
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "div", ()=>div
);
parcelHelpers.export(exports, "dist", ()=>dist
);
parcelHelpers.export(exports, "sqrDist", ()=>sqrDist
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
parcelHelpers.export(exports, "forEach", ()=>forEach
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(4);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
    }
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function fromValues(x, y, z, w) {
    var out = new _commonJs.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function set(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
}
function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
}
function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
}
function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
}
function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
}
function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
}
function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
}
function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
}
function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
}
function scaleAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    return out;
}
function distance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return Math.sqrt(x * x + y * y + z * z + w * w);
}
function squaredDistance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return x * x + y * y + z * z + w * w;
}
function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return Math.sqrt(x * x + y * y + z * z + w * w);
}
function squaredLength(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return x * x + y * y + z * z + w * w;
}
function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
}
function inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    out[3] = 1 / a[3];
    return out;
}
function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len1 = x * x + y * y + z * z + w * w;
    if (len1 > 0) {
        len1 = 1 / Math.sqrt(len1);
        out[0] = x * len1;
        out[1] = y * len1;
        out[2] = z * len1;
        out[3] = w * len1;
    }
    return out;
}
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
}
function random(out, scale2) {
    scale2 = scale2 || 1;
    // Marsaglia, George. Choosing a Point from the Surface of a
    // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
    // http://projecteuclid.org/euclid.aoms/1177692644;
    var v1, v2, v3, v4;
    var s1, s2;
    do {
        v1 = _commonJs.RANDOM() * 2 - 1;
        v2 = _commonJs.RANDOM() * 2 - 1;
        s1 = v1 * v1 + v2 * v2;
    }while (s1 >= 1)
    do {
        v3 = _commonJs.RANDOM() * 2 - 1;
        v4 = _commonJs.RANDOM() * 2 - 1;
        s2 = v3 * v3 + v4 * v4;
    }while (s2 >= 1)
    var d = Math.sqrt((1 - s1) / s2);
    out[0] = scale2 * v1;
    out[1] = scale2 * v2;
    out[2] = scale2 * v3 * d;
    out[3] = scale2 * v4 * d;
    return out;
}
function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
}
function transformQuat(out, a, q) {
    var x = a[0], y = a[1], z = a[2];
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    // calculate quat * vec
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
}
function str(a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
    var vec = create();
    return function(a, stride, offset, count, fn, arg) {
        var i = void 0, l = void 0;
        if (!stride) stride = 4;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            vec[3] = a[i + 3];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
            a[i + 3] = vec[3];
        }
        return a;
    };
}();

},{"./common.js":"fLrSS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aGpcr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */ /**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */ parcelHelpers.export(exports, "fromRotationTranslationValues", ()=>fromRotationTranslationValues
);
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q quaternion
 * @param {vec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */ parcelHelpers.export(exports, "fromRotationTranslation", ()=>fromRotationTranslation
);
/**
 * Creates a dual quat from a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {vec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */ parcelHelpers.export(exports, "fromTranslation", ()=>fromTranslation
);
/**
 * Creates a dual quat from a quaternion
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {mat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */ parcelHelpers.export(exports, "fromMat4", ()=>fromMat4
);
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "set", ()=>set
);
parcelHelpers.export(exports, "getReal", ()=>getReal
);
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} dual part
 */ parcelHelpers.export(exports, "getDual", ()=>getDual
);
parcelHelpers.export(exports, "setReal", ()=>setReal
);
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "setDual", ()=>setDual
);
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {quat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */ parcelHelpers.export(exports, "getTranslation", ()=>getTranslation
);
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to translate
 * @param {vec3} v vector to translate by
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {quat} q quaternion to rotate by
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateByQuatAppend", ()=>rotateByQuatAppend
);
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat} q quaternion to rotate by
 * @param {quat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateByQuatPrepend", ()=>rotateByQuatPrepend
);
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {vec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateAroundAxis", ()=>rotateAroundAxis
);
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
parcelHelpers.export(exports, "mul", ()=>mul
);
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
parcelHelpers.export(exports, "dot", ()=>dot
);
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "lerp", ()=>lerp
);
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "conjugate", ()=>conjugate
);
parcelHelpers.export(exports, "length", ()=>length
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {quat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat2} a the first dual quaternion.
 * @param {quat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {quat2} a the first dual quat.
 * @param {quat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
var _commonJs = require("./common.js");
var _quatJs = require("./quat.js");
var _mat4Js = require("./mat4.js");
function create() {
    var dq = new _commonJs.ARRAY_TYPE(8);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        dq[0] = 0;
        dq[1] = 0;
        dq[2] = 0;
        dq[4] = 0;
        dq[5] = 0;
        dq[6] = 0;
        dq[7] = 0;
    }
    dq[3] = 1;
    return dq;
}
function clone(a) {
    var dq = new _commonJs.ARRAY_TYPE(8);
    dq[0] = a[0];
    dq[1] = a[1];
    dq[2] = a[2];
    dq[3] = a[3];
    dq[4] = a[4];
    dq[5] = a[5];
    dq[6] = a[6];
    dq[7] = a[7];
    return dq;
}
function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
    var dq = new _commonJs.ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    dq[4] = x2;
    dq[5] = y2;
    dq[6] = z2;
    dq[7] = w2;
    return dq;
}
function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
    var dq = new _commonJs.ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    var ax = x2 * 0.5, ay = y2 * 0.5, az = z2 * 0.5;
    dq[4] = ax * w1 + ay * z1 - az * y1;
    dq[5] = ay * w1 + az * x1 - ax * z1;
    dq[6] = az * w1 + ax * y1 - ay * x1;
    dq[7] = -ax * x1 - ay * y1 - az * z1;
    return dq;
}
function fromRotationTranslation(out, q, t) {
    var ax = t[0] * 0.5, ay = t[1] * 0.5, az = t[2] * 0.5, bx = q[0], by = q[1], bz = q[2], bw = q[3];
    out[0] = bx;
    out[1] = by;
    out[2] = bz;
    out[3] = bw;
    out[4] = ax * bw + ay * bz - az * by;
    out[5] = ay * bw + az * bx - ax * bz;
    out[6] = az * bw + ax * by - ay * bx;
    out[7] = -ax * bx - ay * by - az * bz;
    return out;
}
function fromTranslation(out, t) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = t[0] * 0.5;
    out[5] = t[1] * 0.5;
    out[6] = t[2] * 0.5;
    out[7] = 0;
    return out;
}
function fromRotation(out, q) {
    out[0] = q[0];
    out[1] = q[1];
    out[2] = q[2];
    out[3] = q[3];
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
}
function fromMat4(out, a) {
    //TODO Optimize this
    var outer = _quatJs.create();
    _mat4Js.getRotation(outer, a);
    var t = new _commonJs.ARRAY_TYPE(3);
    _mat4Js.getTranslation(t, a);
    fromRotationTranslation(out, outer, t);
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    return out;
}
function identity(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
}
function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
    out[0] = x1;
    out[1] = y1;
    out[2] = z1;
    out[3] = w1;
    out[4] = x2;
    out[5] = y2;
    out[6] = z2;
    out[7] = w2;
    return out;
}
var getReal = _quatJs.copy;
function getDual(out, a) {
    out[0] = a[4];
    out[1] = a[5];
    out[2] = a[6];
    out[3] = a[7];
    return out;
}
var setReal = _quatJs.copy;
function setDual(out, q) {
    out[4] = q[0];
    out[5] = q[1];
    out[6] = q[2];
    out[7] = q[3];
    return out;
}
function getTranslation(out, a) {
    var ax = a[4], ay = a[5], az = a[6], aw = a[7], bx = -a[0], by = -a[1], bz = -a[2], bw = a[3];
    out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    return out;
}
function translate(out, a, v) {
    var ax1 = a[0], ay1 = a[1], az1 = a[2], aw1 = a[3], bx1 = v[0] * 0.5, by1 = v[1] * 0.5, bz1 = v[2] * 0.5, ax2 = a[4], ay2 = a[5], az2 = a[6], aw2 = a[7];
    out[0] = ax1;
    out[1] = ay1;
    out[2] = az1;
    out[3] = aw1;
    out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
    out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
    out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
    out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
    return out;
}
function rotateX(out, a, rad) {
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
    _quatJs.rotateX(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
}
function rotateY(out, a, rad) {
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
    _quatJs.rotateY(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
}
function rotateZ(out, a, rad) {
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
    _quatJs.rotateZ(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
}
function rotateByQuatAppend(out, a, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3], ax = a[0], ay = a[1], az = a[2], aw = a[3];
    out[0] = ax * qw + aw * qx + ay * qz - az * qy;
    out[1] = ay * qw + aw * qy + az * qx - ax * qz;
    out[2] = az * qw + aw * qz + ax * qy - ay * qx;
    out[3] = aw * qw - ax * qx - ay * qy - az * qz;
    ax = a[4];
    ay = a[5];
    az = a[6];
    aw = a[7];
    out[4] = ax * qw + aw * qx + ay * qz - az * qy;
    out[5] = ay * qw + aw * qy + az * qx - ax * qz;
    out[6] = az * qw + aw * qz + ax * qy - ay * qx;
    out[7] = aw * qw - ax * qx - ay * qy - az * qz;
    return out;
}
function rotateByQuatPrepend(out, q, a) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3], bx = a[0], by = a[1], bz = a[2], bw = a[3];
    out[0] = qx * bw + qw * bx + qy * bz - qz * by;
    out[1] = qy * bw + qw * by + qz * bx - qx * bz;
    out[2] = qz * bw + qw * bz + qx * by - qy * bx;
    out[3] = qw * bw - qx * bx - qy * by - qz * bz;
    bx = a[4];
    by = a[5];
    bz = a[6];
    bw = a[7];
    out[4] = qx * bw + qw * bx + qy * bz - qz * by;
    out[5] = qy * bw + qw * by + qz * bx - qx * bz;
    out[6] = qz * bw + qw * bz + qx * by - qy * bx;
    out[7] = qw * bw - qx * bx - qy * by - qz * bz;
    return out;
}
function rotateAroundAxis(out, a, axis, rad) {
    //Special case for rad = 0
    if (Math.abs(rad) < _commonJs.EPSILON) return copy(out, a);
    var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);
    rad = rad * 0.5;
    var s = Math.sin(rad);
    var bx = s * axis[0] / axisLength;
    var by = s * axis[1] / axisLength;
    var bz = s * axis[2] / axisLength;
    var bw = Math.cos(rad);
    var ax1 = a[0], ay1 = a[1], az1 = a[2], aw1 = a[3];
    out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    var ax = a[4], ay = a[5], az = a[6], aw = a[7];
    out[4] = ax * bw + aw * bx + ay * bz - az * by;
    out[5] = ay * bw + aw * by + az * bx - ax * bz;
    out[6] = az * bw + aw * bz + ax * by - ay * bx;
    out[7] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    return out;
}
function multiply(out, a, b) {
    var ax0 = a[0], ay0 = a[1], az0 = a[2], aw0 = a[3], bx1 = b[4], by1 = b[5], bz1 = b[6], bw1 = b[7], ax1 = a[4], ay1 = a[5], az1 = a[6], aw1 = a[7], bx0 = b[0], by0 = b[1], bz0 = b[2], bw0 = b[3];
    out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
    out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
    out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
    out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
    out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
    out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
    out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
    out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
    return out;
}
var mul = multiply;
function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    return out;
}
var dot = _quatJs.dot;
function lerp(out, a, b, t) {
    var mt = 1 - t;
    if (dot(a, b) < 0) t = -t;
    out[0] = a[0] * mt + b[0] * t;
    out[1] = a[1] * mt + b[1] * t;
    out[2] = a[2] * mt + b[2] * t;
    out[3] = a[3] * mt + b[3] * t;
    out[4] = a[4] * mt + b[4] * t;
    out[5] = a[5] * mt + b[5] * t;
    out[6] = a[6] * mt + b[6] * t;
    out[7] = a[7] * mt + b[7] * t;
    return out;
}
function invert(out, a) {
    var sqlen = squaredLength(a);
    out[0] = -a[0] / sqlen;
    out[1] = -a[1] / sqlen;
    out[2] = -a[2] / sqlen;
    out[3] = a[3] / sqlen;
    out[4] = -a[4] / sqlen;
    out[5] = -a[5] / sqlen;
    out[6] = -a[6] / sqlen;
    out[7] = a[7] / sqlen;
    return out;
}
function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    out[4] = -a[4];
    out[5] = -a[5];
    out[6] = -a[6];
    out[7] = a[7];
    return out;
}
var length = _quatJs.length;
var len = length;
var squaredLength = _quatJs.squaredLength;
var sqrLen = squaredLength;
function normalize(out, a) {
    var magnitude = squaredLength(a);
    if (magnitude > 0) {
        magnitude = Math.sqrt(magnitude);
        var a0 = a[0] / magnitude;
        var a1 = a[1] / magnitude;
        var a2 = a[2] / magnitude;
        var a3 = a[3] / magnitude;
        var b0 = a[4];
        var b1 = a[5];
        var b2 = a[6];
        var b3 = a[7];
        var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
        out[0] = a0;
        out[1] = a1;
        out[2] = a2;
        out[3] = a3;
        out[4] = (b0 - a0 * a_dot_b) / magnitude;
        out[5] = (b1 - a1 * a_dot_b) / magnitude;
        out[6] = (b2 - a2 * a_dot_b) / magnitude;
        out[7] = (b3 - a3 * a_dot_b) / magnitude;
    }
    return out;
}
function str(a) {
    return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _commonJs.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _commonJs.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _commonJs.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _commonJs.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7));
}

},{"./common.js":"fLrSS","./quat.js":"lPOiD","./mat4.js":"4qMJv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1PFsL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 2 Dimensional Vector
 * @module vec2
 */ /**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "divide", ()=>divide
);
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "ceil", ()=>ceil
);
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "floor", ()=>floor
);
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "min", ()=>min
);
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "max", ()=>max
);
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "round", ()=>round
);
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "scaleAndAdd", ()=>scaleAndAdd
);
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */ parcelHelpers.export(exports, "distance", ()=>distance
);
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance
);
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */ parcelHelpers.export(exports, "length", ()=>length
);
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */ parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "negate", ()=>negate
);
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "inverse", ()=>inverse
);
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */ parcelHelpers.export(exports, "dot", ()=>dot
);
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "cross", ()=>cross
);
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "lerp", ()=>lerp
);
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "random", ()=>random
);
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "transformMat2", ()=>transformMat2
);
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "transformMat2d", ()=>transformMat2d
);
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "transformMat3", ()=>transformMat3
);
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "transformMat4", ()=>transformMat4
);
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */ parcelHelpers.export(exports, "angle", ()=>angle
);
/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "sub", ()=>sub
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "div", ()=>div
);
parcelHelpers.export(exports, "dist", ()=>dist
);
parcelHelpers.export(exports, "sqrDist", ()=>sqrDist
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
parcelHelpers.export(exports, "forEach", ()=>forEach
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(2);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
    }
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
}
function fromValues(x, y) {
    var out = new _commonJs.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
}
function set(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
}
function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
}
function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
}
function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
}
function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
}
function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
}
function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
}
function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
}
function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
}
function scaleAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    return out;
}
function distance(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return Math.sqrt(x * x + y * y);
}
function squaredDistance(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return x * x + y * y;
}
function length(a) {
    var x = a[0], y = a[1];
    return Math.sqrt(x * x + y * y);
}
function squaredLength(a) {
    var x = a[0], y = a[1];
    return x * x + y * y;
}
function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
}
function inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    return out;
}
function normalize(out, a) {
    var x = a[0], y = a[1];
    var len1 = x * x + y * y;
    if (len1 > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len1 = 1 / Math.sqrt(len1);
        out[0] = a[0] * len1;
        out[1] = a[1] * len1;
    }
    return out;
}
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
}
function cross(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
}
function lerp(out, a, b, t) {
    var ax = a[0], ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
}
function random(out, scale2) {
    scale2 = scale2 || 1;
    var r = _commonJs.RANDOM() * 2 * Math.PI;
    out[0] = Math.cos(r) * scale2;
    out[1] = Math.sin(r) * scale2;
    return out;
}
function transformMat2(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
}
function transformMat2d(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
}
function transformMat3(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
}
function transformMat4(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
}
function rotate(out, a, b, c) {
    //Translate point to the origin
    var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(c), cosC = Math.cos(c);
    //perform rotation and translate to correct position
    out[0] = p0 * cosC - p1 * sinC + b[0];
    out[1] = p0 * sinC + p1 * cosC + b[1];
    return out;
}
function angle(a, b) {
    var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1];
    var len1 = x1 * x1 + y1 * y1;
    if (len1 > 0) //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
    var len2 = x2 * x2 + y2 * y2;
    if (len2 > 0) //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
    var cosine = (x1 * x2 + y1 * y2) * len1 * len2;
    if (cosine > 1) return 0;
    else if (cosine < -1) return Math.PI;
    else return Math.acos(cosine);
}
function str(a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len = length;
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var sqrLen = squaredLength;
var forEach = function() {
    var vec = create();
    return function(a, stride, offset, count, fn, arg) {
        var i = void 0, l = void 0;
        if (!stride) stride = 2;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
        }
        return a;
    };
}();

},{"./common.js":"fLrSS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hL4qm":[function(require,module,exports) {
var vec2 = require('gl-matrix').vec2;
var cross = require('./cross-2d');
var isZero = require('./is-zero-1d');
module.exports = function(a, b, c, d) {
    var p = vec2.clone(a);
    var r = vec2.clone(b);
    vec2.subtract(r, r, p);
    var q = vec2.clone(c);
    var s = vec2.clone(d);
    vec2.subtract(s, s, q);
    var dqp = vec2.create();
    vec2.subtract(dqp, q, p);
    var t = -1;
    var rxs = cross(r, s);
    var qpxr = cross(dqp, r);
    var qpxs = cross(dqp, s);
    if (rxs != 0) t = qpxs / rxs;
    else if (isZero(qpxr) && isZero(rxs)) var t = vec2.dot(dqp, r) / vec2.dot(r, r);
    else if (!isZero(qpxr) && isZero(rxs)) throw 'lines are parallel and do no intersect';
    return vec2.fromValues(p[0] + t * r[0], p[1] + t * r[1]);
};

},{"gl-matrix":"kzvF6","./cross-2d":"66ave","./is-zero-1d":"bzoFj"}],"3D3fk":[function(require,module,exports) {
var isLeftOn = require('./is-left-on-2d');
var isLeft = require('./is-left-2d');
module.exports = function(a0, a, a1, b) {
    if (isLeftOn(a, a1, a0)) return isLeft(a, b, a0) && isLeft(b, a, a1);
    return !(isLeftOn(b, a, a0) && isLeftOn(a, b, a1));
};

},{"./is-left-on-2d":"1Bcyb","./is-left-2d":"kloc4"}],"1Bcyb":[function(require,module,exports) {
var area2 = require('./area2-2d');
var greaterThanZero = require('./greater-than-zero-1d');
var isZero = require('./is-zero-1d');
module.exports = function(a, b, c) {
    var res = area2(a, b, c);
    return greaterThanZero(res) || isZero(res);
};

},{"./area2-2d":"jmO8T","./greater-than-zero-1d":"2i5lt","./is-zero-1d":"bzoFj"}],"JHiGh":[function(require,module,exports) {
var intersectsProper = require('./intersects-proper-2d');
var isBetween = require('./is-between-2d');
module.exports = function(a, b, c, d) {
    if (intersectsProper(a, b, c, d)) return true;
    else if (isBetween(a, b, c) || isBetween(a, b, d) || isBetween(c, d, a) || isBetween(c, d, b)) return true;
    return false;
};

},{"./intersects-proper-2d":"hFVyS","./is-between-2d":"gs80s"}],"hFVyS":[function(require,module,exports) {
var isColinear = require('./is-colinear-2d');
var isLeft = require('./is-left-2d');
module.exports = function(a, b, c, d) {
    if (isColinear(a, b, c) || isColinear(a, b, d) || isColinear(c, d, a) || isColinear(c, d, b)) return false;
    if (isLeft(a, b, c) != isLeft(a, b, d) && isLeft(c, d, a) != isLeft(c, d, b)) return true;
    return false;
};

},{"./is-colinear-2d":"avCJ3","./is-left-2d":"kloc4"}],"avCJ3":[function(require,module,exports) {
var isZero = require('./is-zero-1d');
var area2 = require('./area2-2d');
module.exports = function(a, b, c) {
    return isZero(area2(a, b, c));
};

},{"./is-zero-1d":"bzoFj","./area2-2d":"jmO8T"}],"gs80s":[function(require,module,exports) {
var isColinear = require('./is-colinear-2d');
module.exports = function(a, b, c) {
    if (!isColinear(a, b, c)) return false;
    if (a[0] !== b[0]) return a[0] <= c[0] && c[0] <= b[0] || a[0] >= c[0] && c[0] >= b[0];
    else return a[1] <= c[1] && c[1] <= b[1] || a[1] >= c[1] && c[1] >= b[1];
    return false;
};

},{"./is-colinear-2d":"avCJ3"}],"3uoBd":[function(require,module,exports) {
var inCone = require('./in-cone-2d');
var isDiagonalie = require('./is-diagonalie-2d');
module.exports = function(i, j, polygon) {
    var len = polygon.length;
    var a0 = polygon[i - 1 < 0 ? len - 1 : i - 1];
    var a = polygon[i];
    var a1 = polygon[(i + 1) % len];
    var b0 = polygon[j - 1 < 0 ? len - 1 : j - 1];
    var b = polygon[j];
    var b1 = polygon[(j + 1) % len];
    if (inCone(a0, a, a1, b) && inCone(b0, b, b1, a) && isDiagonalie(a, b, polygon)) return true;
    return false;
};

},{"./in-cone-2d":"3D3fk","./is-diagonalie-2d":"cykSS"}],"cykSS":[function(require,module,exports) {
var isEqual = require('./is-equal-2d');
var intersectsProper = require('./intersects-proper-2d');
module.exports = function(a, b, polygon) {
    var c, c1, len = polygon.length;
    for(var i = 0; i < len; i++){
        c = polygon[i];
        c1 = polygon[(i + 1) % len];
        if (!isEqual(c, a) && !isEqual(c1, a) && !isEqual(c, b) && !isEqual(c1, b) && intersectsProper(a, b, c, c1)) return false;
    }
    return true;
};

},{"./is-equal-2d":"e4Ra3","./intersects-proper-2d":"hFVyS"}],"e4Ra3":[function(require,module,exports) {
var isZero = require('./is-zero-1d');
var isEqual = require('./is-equal-1d');
module.exports = function(a, b) {
    if (isEqual(a[0], b[0]) && isEqual(a[1], b[1])) return true;
    return false;
};

},{"./is-zero-1d":"bzoFj","./is-equal-1d":"3tsmP"}],"kAGmZ":[function(require,module,exports) {
var isDiagonal = require('./is-diagonal-2d');
module.exports = function(polygon) {
    var len = polygon.length;
    var ears = [];
    for(var i = 0; i < len; i++){
        var i0 = i - 1 < 0 ? len - 1 : i - 1;
        var i1 = (i + 1) % len;
        ears.push(isDiagonal(i0, i1, polygon));
    }
    var polys = polygon.slice(0);
    var v0, v1, v2 = 0, v3, v4, n = polys.length, end = 0;
    var lookups = [];
    var llen = 0;
    for(var i = 0; i < len; i++)lookups[i] = i;
    var cells = [];
    while(n > 3)do {
        llen = lookups.length;
        v2 = v2 % llen;
        if (ears[lookups[v2]]) {
            v4 = (v2 + 2) % llen;
            v3 = (v2 + 1) % llen;
            //v2//
            v1 = v2 - 1;
            v1 = v1 < 0 ? llen + v1 : v1;
            v0 = v1 - 1;
            v0 = v0 < 0 ? llen + v0 : v0;
            v0 = v0 % llen;
            v1 = v1 % llen;
            v2 = v2 % llen;
            v3 = v3 % llen;
            v4 = v4 % llen;
            ears[lookups[v1]] = isDiagonal(lookups[v0], lookups[v3], polys);
            ears[lookups[v3]] = isDiagonal(lookups[v1], lookups[v4], polys);
            cells.push([
                lookups[v2],
                lookups[v3],
                lookups[v1]
            ]);
            lookups.splice(v2, 1);
            end = v3;
            n--;
            break;
        }
        v2++;
    }while (v2 != end)
    cells.push([
        lookups[1],
        lookups[2],
        lookups[0]
    ]);
    return cells;
};

},{"./is-diagonal-2d":"3uoBd"}],"fgQl4":[function(require,module,exports) {
var isZero = require('./is-zero-1d');
module.exports = function(a, b, c) {
    var cax = c[0] - a[0];
    var cay = c[1] - a[1];
    var caz = c[2] - a[2];
    var bax = b[0] - a[0];
    var bay = b[1] - a[1];
    var baz = b[2] - a[2];
    return isZero(caz * bay - baz * cay) && isZero(baz * cax - bax * caz) && isZero(bax * cay - bay * cax);
};

},{"./is-zero-1d":"bzoFj"}],"bARYg":[function(require,module,exports) {
var Vertex = require('./../Core/Vertex');
var Edge = require('./../Core/Edge');
var HalfEdge = require('./../Core/HalfEdge');
var Face = require('./../Core/Face');
var FaceHalfEdges = require('./../Queries/FaceHalfEdges');
var MeshCentroid = require('./../Queries/MeshCentroid');
var calculateNormal = require('guf').calculateNormal;
var expandPolygon = require('cga').expandPolygon2;
var vec3 = require('gl-matrix').vec3;
var quat = require('gl-matrix').quat;
var zAxis = vec3.fromValues(0, 0, 1);
module.exports = function(mesh, faceIndex, distance, scale) {
    var meshVerts = mesh.getVertices();
    var meshHalfEdges = mesh.getHalfEdges();
    var meshEdges = mesh.getEdges();
    var meshEdgeMap = mesh.getEdgeMap();
    var meshFaces = mesh.getFaces();
    var meshPositions = mesh.positions;
    var originalFace = meshFaces[faceIndex];
    var faceHalfEdges = FaceHalfEdges(originalFace);
    var flen = faceHalfEdges.length;
    var originalVertices = [];
    for(var i = 0; i < flen; i++){
        var he = faceHalfEdges[i];
        var vertex = he.getVertex();
        var vertexIndex = vertex.getIndex();
        originalVertices.push(vertex);
    }
    var vlen = originalVertices.length;
    var v0 = meshPositions[originalVertices[0].getIndex()];
    var v1 = meshPositions[originalVertices[1].getIndex()];
    var v2 = meshPositions[originalVertices[2].getIndex()];
    var normal = calculateNormal(v0, v1, v2);
    var faceOri = quat.create();
    quat.rotationTo(faceOri, normal, zAxis);
    var newVertices = [];
    var polygon = [];
    var indicies = [];
    var zOffset = 0;
    for(var j = 0; j < vlen; j++){
        var vertex = originalVertices[j];
        var vertexIndex = vertex.getIndex();
        var vertexPos = vec3.clone(meshPositions[vertexIndex]);
        vec3.transformQuat(vertexPos, vertexPos, faceOri);
        zOffset = vertexPos[2];
        polygon.push([
            vertexPos[0],
            vertexPos[1]
        ]);
        indicies.push(vertexIndex);
        newVertices.push(new Vertex());
    }
    // console.log( zOffset );
    quat.rotationTo(faceOri, zAxis, normal);
    var results = expandPolygon(polygon, -(scale ? scale : 0.00001));
    var rlen = results.length;
    var newPositions = [];
    var newEdges = [];
    var newHalfEdges = [];
    zOffset += distance != undefined ? distance : 0;
    for(var i = 0; i < rlen; i++){
        var pos = results[i];
        var vpos = vec3.fromValues(pos[0], pos[1], zOffset);
        vec3.transformQuat(vpos, vpos, faceOri);
        // vec3.add( vpos, vpos, [0,0,zOffset]);
        newPositions.push(vpos);
        var vertex = newVertices[i];
        vertex.setIndex(meshPositions.length);
        meshPositions.push(vpos);
        meshVerts.push(vertex);
    }
    var lhe = undefined;
    var lhef = undefined;
    for(var i = 0; i < rlen; i++){
        var f = originalFace;
        var v = newVertices[i];
        var vn = newVertices[(i + 1) % rlen];
        var e = new Edge();
        var he = new HalfEdge();
        var hef = new HalfEdge();
        //he
        he.setFlipHalfEdge(hef);
        he.setEdge(e);
        he.setVertex(v);
        he.setFace(f);
        meshHalfEdges.push(he);
        //hef
        hef.setFlipHalfEdge(he);
        hef.setEdge(e);
        hef.setVertex(vn);
        meshHalfEdges.push(hef);
        //e
        e.setIndex(meshEdges.length);
        e.setHalfEdge(he);
        meshEdges.push(e);
        var keys = mesh.getEdgeKeys(v.getIndex(), vn.getIndex());
        meshEdgeMap[keys[0]] = e;
        meshEdgeMap[keys[1]] = e;
        //v
        v.setHalfEdge(he);
        newEdges.push(e);
        newHalfEdges.push(he);
        if (lhe) {
            lhe.setNextHalfEdge(he);
            hef.setNextHalfEdge(lhef);
        }
        lhe = he;
        lhef = hef;
    }
    var he = newHalfEdges[0];
    var hef = he.getFlipHalfEdge();
    lhe.setNextHalfEdge(he);
    hef.setNextHalfEdge(lhef);
    originalFace.setHalfEdge(he);
    var newFaces = [];
    var holeHalfEdges = [];
    var lf = undefined;
    var lhe = undefined;
    for(var i = 0; i < rlen; i++){
        var v = newVertices[i];
        var vo = originalVertices[i];
        var heo = v.getHalfEdge();
        var heof = heo.getFlipHalfEdge();
        var ofhe = faceHalfEdges[i];
        var li = i - 1;
        li = li < 0 ? rlen + li : li;
        var ofhep = faceHalfEdges[li];
        var f = new Face();
        var e = new Edge();
        var he = new HalfEdge();
        var hef = new HalfEdge();
        //he
        he.setFlipHalfEdge(hef);
        he.setNextHalfEdge(ofhe);
        he.setEdge(e);
        he.setVertex(v);
        he.setFace(f);
        //hef
        hef.setFlipHalfEdge(he);
        hef.setNextHalfEdge(heof.getNextHalfEdge());
        hef.setEdge(e);
        hef.setVertex(vo);
        hef.setFace(lf);
        //e
        e.setIndex(meshEdges.length);
        meshEdges.push(e);
        e.setHalfEdge(he);
        //f
        f.setIndex(meshFaces.length);
        f.setHalfEdge(he);
        meshFaces.push(f);
        newFaces.push(f);
        //vo
        vo.setHalfEdge(hef);
        //old connections
        heof.setNextHalfEdge(he);
        heof.setFace(f);
        ofhe.setFace(f);
        ofhep.setNextHalfEdge(hef);
        holeHalfEdges.push(he);
        lf = f;
    }
    var he = holeHalfEdges[0];
    var hef = he.getFlipHalfEdge();
    hef.setFace(newFaces[newFaces.length - 1]);
    // //didn't work for more than 1
    // for( var i = 0; i < rlen; i++ ) {
    //   var vn0 = newVertices[ i ];
    //   var vn1 = newVertices[ ( i + 1 ) % rlen ];
    //
    //   var vo0 = originalVertices[ i ];
    //   var vo1 = originalVertices[ ( i + 1 ) % rlen ];
    //
    //   meshFaces.push( createFace( mesh, [ vo0, vo1, vn1, vn0 ] ) );
    // }
    return originalFace;
};
function createFace(mesh, vertices, face) {
    var meshEdgeMap = mesh.getEdgeMap();
    var meshFaces = mesh.getFaces();
    var meshHalfEdges = mesh.getHalfEdges();
    var meshEdges = mesh.getEdges();
    if (!face) {
        face = new Face();
        face.setIndex(meshFaces.length);
    }
    var vlen = vertices.length;
    var lhe;
    var hes = [];
    for(var i = 0; i < vlen; i++){
        var v0 = vertices[i];
        var v1 = vertices[(i + 1) % vlen];
        var i0 = v0.getIndex();
        var i1 = v1.getIndex();
        var he = new HalfEdge();
        var edge = mesh.getEdge(i0, i1);
        if (edge) {
            var het = edge.getHalfEdge();
            var hetv = het.getVertex();
            if (hetv == v0) he = het;
            else {
                he.setFlipHalfEdge(het);
                het.setFlipHalfEdge(he);
            }
        } else {
            edge = new Edge();
            var keys = mesh.getEdgeKeys(i0, i1);
            edge.setIndex(meshEdges.length);
            meshEdges.push(edge);
            edge.setHalfEdge(he);
            meshEdgeMap[keys[0]] = edge;
            meshEdgeMap[keys[1]] = edge;
        }
        //he
        he.setEdge(edge);
        he.setFace(face);
        he.setVertex(v0);
        if (lhe) lhe.setNextHalfEdge(he);
        hes.push(he);
        lhe = he;
        meshHalfEdges.push(he);
    }
    face.setHalfEdge(lhe);
    lhe.setNextHalfEdge(hes[0]);
    return face;
}

},{"./../Core/Vertex":"aMW4R","./../Core/Edge":"dOHcN","./../Core/HalfEdge":"72nec","./../Core/Face":"fVwz7","./../Queries/FaceHalfEdges":"eum8y","./../Queries/MeshCentroid":"kKwVL","guf":"hlcpy","cga":"6OXri","gl-matrix":"3TXam"}],"7E3Pw":[function(require,module,exports) {
var Vertex = require('./../Core/Vertex');
var Edge = require('./../Core/Edge');
var HalfEdge = require('./../Core/HalfEdge');
var Face = require('./../Core/Face');
var FaceHalfEdges = require('./../Queries/FaceHalfEdges');
var FaceVertices = require('./../Queries/FaceVertices');
var HalfEdgePrev = require('./../Queries/HalfEdgePrev');
var createFace = require('./CreateFace');
module.exports = function(mesh, faceIndex0, faceIndex1, vertexOffset) {
    var meshFaces = mesh.getFaces();
    var f0 = meshFaces[faceIndex0];
    var f0HalfEdges = FaceHalfEdges(f0);
    var f0Vertices = FaceVertices(f0);
    var f0len = f0Vertices.length;
    var f1 = meshFaces[faceIndex1];
    var f1HalfEdges = FaceHalfEdges(f1);
    var f1Vertices = FaceVertices(f1);
    var f1len = f1Vertices.length;
    if (f0len != f1len) throw 'faces do not have the same number of vertices, can not create pipe';
    var faces = [
        f0,
        f1
    ];
    var offset = vertexOffset != undefined ? vertexOffset : 2;
    for(var i = 0; i < f0len; i++){
        var v0i0 = i - offset;
        v0i0 = v0i0 >= f0len ? v0i0 % f0len : v0i0;
        v0i0 = v0i0 < 0 ? f0len + v0i0 : v0i0;
        var v0i1 = (i + 1) % f0len - offset;
        v0i1 = v0i1 >= f0len ? v0i1 % f0len : v0i1;
        v0i1 = v0i1 < 0 ? f0len + v0i1 : v0i1;
        var v1i0 = (f0len - i) % f0len;
        var v1i1 = f0len - (i + 1);
        var oldFace = faces[i];
        var inputFace = oldFace ? true : false;
        var result = createFace(mesh, [
            f0Vertices[v0i0],
            f0Vertices[v0i1],
            f1Vertices[v1i1],
            f1Vertices[v1i0]
        ], oldFace);
        if (!inputFace) meshFaces.push(result);
    }
};

},{"./../Core/Vertex":"aMW4R","./../Core/Edge":"dOHcN","./../Core/HalfEdge":"72nec","./../Core/Face":"fVwz7","./../Queries/FaceHalfEdges":"eum8y","./../Queries/FaceVertices":"elyLX","./../Queries/HalfEdgePrev":"lRsPN","./CreateFace":"lxPIU"}],"lxPIU":[function(require,module,exports) {
var Edge = require('./../Core/Edge');
var HalfEdge = require('./../Core/HalfEdge');
var Face = require('./../Core/Face');
module.exports = function(mesh, vertices, face) {
    var meshEdgeMap = mesh.getEdgeMap();
    var meshFaces = mesh.getFaces();
    var meshHalfEdges = mesh.getHalfEdges();
    var meshEdges = mesh.getEdges();
    if (!face) {
        face = new Face();
        face.setIndex(meshFaces.length);
    }
    var vlen = vertices.length;
    var hel;
    var hes = [];
    for(var i = 0; i < vlen; i++){
        var v0 = vertices[i];
        var v1 = vertices[(i + 1) % vlen];
        var i0 = v0.getIndex();
        var i1 = v1.getIndex();
        var he = new HalfEdge();
        var edge = mesh.getEdge(i0, i1);
        if (edge) {
            var het = edge.getHalfEdge();
            var hetv = het.getVertex();
            if (hetv == v0) he = het;
            else {
                he.setFlipHalfEdge(het);
                het.setFlipHalfEdge(he);
            }
        } else {
            edge = new Edge();
            var keys = mesh.getEdgeKeys(i0, i1);
            edge.setIndex(meshEdges.length);
            meshEdges.push(edge);
            edge.setHalfEdge(he);
            meshEdgeMap[keys[0]] = edge;
            meshEdgeMap[keys[1]] = edge;
        }
        //he
        he.setEdge(edge);
        he.setFace(face);
        he.setVertex(v0);
        if (hel) hel.setNextHalfEdge(he);
        //v
        v0.setHalfEdge(he);
        hes.push(he);
        hel = he;
        meshHalfEdges.push(he);
    }
    face.setHalfEdge(hes[0]);
    hel.setNextHalfEdge(hes[0]);
    return face;
};

},{"./../Core/Edge":"dOHcN","./../Core/HalfEdge":"72nec","./../Core/Face":"fVwz7"}],"5Bekj":[function(require,module,exports) {
var Mesh = require('./../Core/Mesh');
var vec3 = require('gl-matrix').vec3;
module.exports = function(mesh) {
    var newMesh = new Mesh();
    var newPositions = [];
    var positions = mesh.getPositions();
    var plen = positions.length;
    for(var i = 0; i < plen; i++)newPositions.push(vec3.clone(positions[i]));
    newMesh.setPositions(newPositions);
    newMesh.setCells(mesh.getCells());
    newMesh.process();
    return newMesh;
};

},{"./../Core/Mesh":"lGuYv","gl-matrix":"3TXam"}],"1rKhw":[function(require,module,exports) {
var Mesh = require('./../Core/Mesh');
var Vertex = require('./../Core/Vertex');
var Edge = require('./../Core/Edge');
var HalfEdge = require('./../Core/HalfEdge');
var Face = require('./../Core/Face');
var FaceHalfEdges = require('./../Queries/FaceHalfEdges');
var vec3 = require('gl-matrix').vec3;
module.exports = function(mesh, other) {
    var meshPositions = mesh.positions;
    var mplen = meshPositions.length;
    var meshVerticies = mesh.getVertices();
    var mvlen = meshVerticies.length;
    var meshFaces = mesh.getFaces();
    var mflen = meshFaces.length;
    var meshEdges = mesh.getEdges();
    var melen = meshEdges.length;
    var meshEdgeMap = mesh.getEdgeMap();
    var otherPositions = other.positions;
    var oplen = otherPositions.length;
    var otherVertices = other.getVertices();
    var ovlen = otherVertices.length;
    var otherCells = other.getCells();
    var oclen = otherCells.length;
    for(var i = 0; i < oplen; i++){
        var v = new Vertex();
        v.setIndex(meshVerticies.length);
        meshVerticies.push(v);
        var p = vec3.clone(otherPositions[i]);
        meshPositions.push(p);
    }
    for(var i = 0; i < oclen; i++){
        var cell = otherCells[i];
        var clen = cell.length;
        var face = new Face();
        face.setIndex(meshFaces.length);
        meshFaces.push(face);
        var lhe = undefined;
        var hes = [];
        for(var j = 0; j < clen; j++){
            var i0 = mvlen + cell[j];
            var i1 = mvlen + cell[(j + 1) % clen];
            var vertex = meshVerticies[i0];
            var edge = mesh.getEdge(i0, i1);
            var hasEdge = edge ? true : false;
            var he = new HalfEdge();
            if (!hasEdge) {
                edge = new Edge();
                edge.setIndex(meshEdges.length);
                edge.setHalfEdge(he);
                meshEdges.push(edge);
                var keys = mesh.getEdgeKeys(i0, i1);
                meshEdgeMap[keys[0]] = edge;
                meshEdgeMap[keys[1]] = edge;
            } else {
                var hef = edge.getHalfEdge();
                hef.setFlipHalfEdge(he);
                he.setFlipHalfEdge(hef);
            }
            //he
            he.setFace(face);
            he.setEdge(edge);
            he.setVertex(vertex);
            if (lhe) lhe.setNextHalfEdge(he);
            hes.push(he);
            lhe = he;
            //vertex
            vertex.setHalfEdge(he);
        }
        face.setHalfEdge(lhe);
        lhe.setNextHalfEdge(hes[0]);
    }
};

},{"./../Core/Mesh":"lGuYv","./../Core/Vertex":"aMW4R","./../Core/Edge":"dOHcN","./../Core/HalfEdge":"72nec","./../Core/Face":"fVwz7","./../Queries/FaceHalfEdges":"eum8y","gl-matrix":"3TXam"}],"ggWoq":[function(require,module,exports) {
var MeshCentroid = require('./../Queries/MeshCentroid');
var vec3 = require('gl-matrix').vec3;
var tmp = vec3.create();
module.exports = function(mesh, scale) {
    if (scale.constructor != Array) scale = [
        scale,
        scale,
        scale
    ];
    vec3.set(tmp, 0, 0, 0);
    var centroid = MeshCentroid(mesh);
    var positions = mesh.positions;
    var plen = positions.length;
    for(var i = 0; i < plen; i++){
        var pos = positions[i];
        vec3.subtract(pos, pos, centroid);
        vec3.multiply(pos, pos, scale);
        vec3.add(pos, pos, centroid);
    }
};

},{"./../Queries/MeshCentroid":"kKwVL","gl-matrix":"3TXam"}],"iT2PL":[function(require,module,exports) {
var Mesh = require('./../Core/Mesh');
var vec3 = require('gl-matrix').vec3;
var tmp = vec3.create();
module.exports = function(mesh, displacement) {
    vec3.set(tmp, 0, 0, 0);
    var positions = mesh.positions;
    var plen = positions.length;
    for(var i = 0; i < plen; i++){
        var pos = positions[i];
        vec3.subtract(pos, pos, displacement);
    }
};

},{"./../Core/Mesh":"lGuYv","gl-matrix":"3TXam"}],"dwfab":[function(require,module,exports) {
var Mesh = require('./../Core/Mesh');
var FaceHalfEdges = require('./../Queries/FaceHalfEdges');
var FaceVertices = require('./../Queries/FaceVertices');
var vec3 = require('gl-matrix').vec3;
module.exports = function(mesh) {
    var faces = mesh.getFaces();
    var flen = faces.length;
    for(var i = 0; i < flen; i++){
        var hes = FaceHalfEdges(faces[i]);
        var vts = FaceVertices(faces[i]);
        var hlen = hes.length;
        for(var j = 0; j < hlen; j++){
            var i0 = j;
            var i1 = (j + 1) % hlen;
            var v0 = vts[i0];
            var v1 = vts[i1];
            var h0 = hes[i0];
            var h1 = hes[i1];
            h1.setNextHalfEdge(h0);
            h0.setVertex(v1);
            v1.setHalfEdge(h0);
        }
    }
};

},{"./../Core/Mesh":"lGuYv","./../Queries/FaceHalfEdges":"eum8y","./../Queries/FaceVertices":"elyLX","gl-matrix":"3TXam"}],"fEWOP":[function(require,module,exports) {
var Vertex = require('./../Core/Vertex');
var FaceHalfEdges = require('./../Queries/FaceHalfEdges');
var FaceVertices = require('./../Queries/FaceVertices');
var VertexHalfEdges = require('./../Queries/VertexHalfEdges');
var CreateFace = require('./CreateFace');
var Cross = require('guf').cross;
var CalculateNormal = require('guf').calculateNormal;
var ExpandPolygon = require('cga').expandPolygon2;
var vec3 = require('gl-matrix').vec3;
var quat = require('gl-matrix').quat;
var tmp = vec3.create();
var tmp2 = vec3.create();
var p0p1 = vec3.create();
var p2p1 = vec3.create();
var zAxis = vec3.fromValues(0, 0, 1);
module.exports = function(mesh, offset, depth) {
    var meshPositions = mesh.positions;
    var meshVertices = mesh.getVertices();
    var mvlen = meshVertices.length;
    var meshFaces = mesh.getFaces();
    var mflen = meshFaces.length;
    offset = offset != undefined ? offset : 1;
    depth = depth != undefined ? depth : offset;
    for(var i = 0; i < mvlen; i++){
        var vertex = meshVertices[i];
        var vertexPosition = meshPositions[vertex.getIndex()];
        var vertexHalfEdges = VertexHalfEdges(vertex);
        var hlen = vertexHalfEdges.length;
        vec3.set(tmp, 0, 0, 0);
        for(var j = 0; j < hlen; j++){
            var h0 = vertexHalfEdges[j];
            var h1 = vertexHalfEdges[(j + 1) % hlen];
            var h0n = h0.getNextHalfEdge();
            var h1n = h1.getNextHalfEdge();
            var v0 = h0n.getVertex();
            var v1 = h1n.getVertex();
            var p0 = meshPositions[v0.getIndex()];
            var p1 = meshPositions[v1.getIndex()];
            Cross(tmp2, p0, vertexPosition, p1);
            vec3.add(tmp, tmp, tmp2);
        }
        vec3.normalize(tmp, tmp);
        vec3.scale(tmp, tmp, depth);
        var newPosition = vec3.create();
        vec3.add(newPosition, vertexPosition, tmp);
        var vertex = new Vertex();
        vertex.setIndex(meshVertices.length);
        meshVertices.push(vertex);
        meshPositions.push(newPosition);
    }
    for(var k = 0; k < mflen; k++){
        var face = meshFaces[k];
        var faceVertices = FaceVertices(face);
        var vlen = faceVertices.length;
        var v0 = meshPositions[faceVertices[0].getIndex()];
        var v1 = meshPositions[faceVertices[1].getIndex()];
        var v2 = meshPositions[faceVertices[2].getIndex()];
        var normal = CalculateNormal(v0, v1, v2);
        var faceOri = quat.create();
        quat.rotationTo(faceOri, normal, zAxis);
        var newFaceVertices = [];
        var polygon = [];
        var zOffset = 0;
        for(var j = 0; j < vlen; j++){
            var vertex = faceVertices[j];
            var vertexIndex = vertex.getIndex();
            var vertexPos = vec3.clone(meshPositions[vertexIndex]);
            vec3.transformQuat(vertexPos, vertexPos, faceOri);
            zOffset = vertexPos[2];
            polygon.push([
                vertexPos[0],
                vertexPos[1]
            ]);
            newFaceVertices.push(new Vertex());
        }
        quat.rotationTo(faceOri, zAxis, normal);
        var results = ExpandPolygon(polygon, -offset);
        var rlen = results.length;
        for(var i = 0; i < rlen; i++){
            var pos = results[i];
            var vpos = vec3.fromValues(pos[0], pos[1], zOffset);
            vec3.transformQuat(vpos, vpos, faceOri);
            var vertex = newFaceVertices[i];
            vertex.setIndex(meshVertices.length);
            meshPositions.push(vpos);
            meshVertices.push(vertex);
        }
        var faces = [
            face
        ];
        for(var i = 0; i < vlen; i++){
            var i0 = i;
            var i1 = (i + 1) % vlen;
            var v0 = faceVertices[i0];
            var v1 = faceVertices[i1];
            var v0e = meshVertices[v0.getIndex() + mvlen];
            var v1e = meshVertices[v1.getIndex() + mvlen];
            var v2 = newFaceVertices[i1];
            var v3 = newFaceVertices[i0];
            var f = faces[i];
            var add = f == undefined ? true : false;
            var result;
            if (depth > 0) {
                result = CreateFace(mesh, [
                    v0,
                    v1,
                    v2,
                    v3
                ], f);
                meshFaces.push(CreateFace(mesh, [
                    v0e,
                    v3,
                    v2,
                    v1e
                ]));
            } else {
                result = CreateFace(mesh, [
                    v3,
                    v2,
                    v1,
                    v0
                ], f);
                meshFaces.push(CreateFace(mesh, [
                    v1e,
                    v2,
                    v3,
                    v0e
                ]));
            }
            if (add) meshFaces.push(result);
        }
    }
};

},{"./../Core/Vertex":"aMW4R","./../Queries/FaceHalfEdges":"eum8y","./../Queries/FaceVertices":"elyLX","./../Queries/VertexHalfEdges":"8DhJJ","./CreateFace":"lxPIU","guf":"hlcpy","cga":"6OXri","gl-matrix":"3TXam"}],"7Nhm8":[function(require,module,exports) {
var Mesh = require('./../Core/Mesh');
module.exports = function(profile) {
    if (profile.length < 0 || profile[0].length < 2) throw "profile must be a non-zero array of atleast 3 2D positions [ [ x0, y0 ], [ x1, y1 ], [ x2, y2 ] ]";
    var mesh = new Mesh();
    var positions = [];
    var frontFace = [];
    var backFace = [];
    var len = profile.length;
    for(var i = 0; i < len; i++){
        positions.push([
            profile[i][0],
            profile[i][1],
            0
        ]);
        frontFace.push(i);
        backFace.push(len - 1 - i);
    }
    var cells = [
        frontFace,
        backFace
    ];
    mesh = new Mesh();
    mesh.setPositions(positions);
    mesh.setCells(cells);
    mesh.process();
    return mesh;
};

},{"./../Core/Mesh":"lGuYv"}]},["idWrV"], "idWrV", "parcelRequireaf77")

//# sourceMappingURL=tessellation-worker.b5cf35a0.js.map
