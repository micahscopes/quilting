// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"M2YOe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _lodashEs = require("lodash-es");
var _picogl = require("picogl");
var _picoglDefault = parcelHelpers.interopDefault(_picogl);
var _loadTessellationAtlas = require("../src/load-tessellation-atlas");
var _picoUtil = require("./pico-util");
var _util = require("../src/util");
var _randomMesh = require("./random-mesh");
var _randomMeshDefault = parcelHelpers.interopDefault(_randomMesh);
var _paperSpinnerLiteJs = require("@polymer/paper-spinner/paper-spinner-lite.js");
// @ts-ignore
var _mda = require("mda");
var _mdaDefault = parcelHelpers.interopDefault(_mda);
var _core = require("@most/core");
var _scheduler = require("@most/scheduler");
// import positionInElement from "./position-in-element";
var _domEvent = require("@most/dom-event");
// @ts-ignore
var _rbushKnn = require("rbush-knn");
var _rbushKnnDefault = parcelHelpers.interopDefault(_rbushKnn);
// @ts-ignore
var _humanFormat = require("human-format");
var _humanFormatDefault = parcelHelpers.interopDefault(_humanFormat);
var _whileTabFocus = require("./whileTabFocus");
var _positionInElement = require("./position-in-element");
// import { decode, UnpackrStream, unpack} from "msgpackr";
// console.log(tessellations)
const closeVerts = 10;
const farVerts = closeVerts * 4;
const numVerts = 500;
const debugText = false;
const [low, mid, high] = [
    1,
    4,
    8
];
const lods = [];
const lodLevels = _lodashEs.uniq([
    ...lods,
    low,
    mid,
    high
]).map((x)=>2 ** x
);
const exampleLodLookup = (i)=>`[${2 ** i},${2 ** i},${2 ** i}]`
;
const lowLodKey = exampleLodLookup(low);
const midLodKey = exampleLodLookup(mid);
const highLodKey = exampleLodLookup(high);
// console.log("meshlet atlas", atlas);
// console.log(permutationIndices3);
const vs = _util.glsl`
    #version 300 es
    layout(location=0) in vec3 patchBary;
    layout(location=1) in ivec3 J;
    layout(location=2) in mat3x2 corners;

    out vec3 vColor; 
    out vec3 cornerColor;

    void main() {
        vec3 subpatchBary;
        ivec3 I = J.xyz;
        int i = gl_VertexID % 3;
        subpatchBary.x = float(i == 0 || i == 1);
        subpatchBary.y = float(i == 1 || i == 2);
        subpatchBary.z = float(i == 2 || i == 0);
        vColor = subpatchBary;
        cornerColor = vec3(patchBary[I[0]], patchBary[I[1]], patchBary[I[2]]) * 2.0;
        // cornerColor = patchBary*2.0;

        vec2 p = vec2(
          patchBary[I[0]]*corners[0][0] + patchBary[I[1]]*corners[1][0] + patchBary[I[2]]*corners[2][0],
          patchBary[I[0]]*corners[0][1] + patchBary[I[1]]*corners[1][1] + patchBary[I[2]]*corners[2][1]
        );
        // vColor = patchBary ? patchBary * 2.0;
        // vColor = patchBary;
        gl_Position = vec4(p.xy*4.0, 0.0, 1.0);
    }
`;
const fs = _util.glsl`
    #version 300 es
    precision highp float;

    in vec3 vColor;
    in vec3 cornerColor;

    out vec4 fragColor;
    void main() {
        // float threshold = 0.95;
        // bool c1 = cornerColor.x > threshold;
        // bool c2 = cornerColor.y > threshold;
        // bool c3 = cornerColor.z > threshold;
        // vec3 color = vec3(
        //   c1 ? 1.0 : !(c2 || c3) ? vColor.x : 0.0, //vColor.r,
        //   c2 ? 1.0 : !(c1 || c3) ? vColor.y : 0.0, //vColor.g,
        //   c3 ? 1.0 : !(c1 || c2) ? vColor.z : 0.0 //vColor.b
        // );
        // fragColor = vec4(color, 1.0);

        fragColor = vec4(vColor, 1.0);
    }
`;
document.addEventListener("DOMContentLoaded", async function() {
    const atlas = await _loadTessellationAtlas.loadTessellationAtlas(lodLevels);
    const canvas = document.createElement("canvas");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    document.body.appendChild(canvas);
    const canvas2d = document.createElement("canvas");
    canvas2d.style.pointerEvents = "none";
    canvas2d.width = window.innerWidth;
    canvas2d.height = window.innerHeight;
    document.body.appendChild(canvas2d);
    const ctx2D = canvas2d.getContext("2d");
    ctx2D.font = "8px Helvetica";
    const app = _picoglDefault.default.createApp(canvas).clearColor(0, 0, 0, 1);
    app.gl.enable(app.gl.CULL_FACE);
    app.gl.cullFace(app.gl.BACK);
    const timer = app.createTimer();
    window.utils.addTimerElement();
    window.onresize = function() {
        app.resize(window.innerWidth, window.innerHeight);
    };
    let positions = app.createVertexBuffer(_picoglDefault.default.UNSIGNED_SHORT, 3, new Uint16Array(_lodashEs.flatten(atlas.combinedMesh.positions)));
    const patchesPerMeshlet = numVerts / 1;
    const mesh = _randomMeshDefault.default(numVerts);
    mesh.mda.faces.forEach((face)=>face.fallbackLod = _lodashEs.sample([
            low,
            low
        ])
    );
    // window.M = mesh.mda;
    // window.mda = mda;
    const mouseInCanvas$ = _lodashEs.flow(_core.map(({ x , y  })=>[
            _rbushKnnDefault.default(mesh.rbush, x, y, closeVerts),
            _rbushKnnDefault.default(mesh.rbush, x, y, farVerts), 
        ]
    ), _core.map(([closer, further])=>[
            closer.flatMap(({ index  })=>{
                try {
                    return _mdaDefault.default.VertexFaces(mesh.mda.vertices[index]).map((face)=>face.index
                    );
                } catch (e) {
                    return [];
                }
            }),
            further.flatMap(({ index  })=>{
                try {
                    return _mdaDefault.default.VertexFaces(mesh.mda.vertices[index]).map((face)=>face.index
                    );
                } catch (e) {
                    return [];
                }
            }), 
        ]
    ))(_whileTabFocus.whileTabFocus(_positionInElement.positionInCanvas(_core.merge(_domEvent.mousemove(canvas), _core.map(({ touches  })=>touches[0]
    , _domEvent.touchmove(canvas))))));
    // (
    //   filter(
    //     () => !document.hidden,
    //     map(
    //       () => ({
    //         x: 0.5 * Math.sin(Date.now() / 4000),
    //         y: 0.5 * Math.cos(Date.now() / 4000),
    //       }),
    //       whileTabFocus(periodic(15))
    //     )
    //   )
    // );
    const scheduler = _scheduler.newDefaultScheduler();
    // runEffects(tap(console.log, mouseInCanvas$), scheduler);
    console.log(mesh);
    let corners = app.createMatrixBuffer(_picoglDefault.default.FLOAT_MAT3x2, new Float32Array(_lodashEs.flatten(_lodashEs.flatten(mesh.cellPositions).map(([x, y])=>[
            x,
            y
        ]
    ))));
    let permutations = app.createVertexBuffer(_picoglDefault.default.BYTE, 3, mesh.mda.faces.length * 3);
    // COMBINE VERTEX BUFFERS INTO VERTEX AR
    let triangleArray = app.createVertexArray().vertexAttributeBuffer(0, positions, {
        normalized: true
    }).instanceAttributeBuffer(1, permutations).instanceAttributeBuffer(2, corners);
    window.triangleArray = triangleArray;
    app.gl.disable(app.gl.CULL_FACE);
    const program = (await app.createPrograms([
        vs,
        fs
    ]))[0];
    // CREATE DRAW CALL FROM PROGRAM AND VERTEX ARRAY
    let drawCall = app.createDrawCall(program, triangleArray);
    let meshlets = mesh.mda.faces.map(()=>atlas.lookup[lowLodKey]
    );
    console.log("meshlets", meshlets);
    permutations.data(new Int8Array(_lodashEs.flatten(meshlets.flatMap((m)=>m.permutation
    ))));
    let ranges = [];
    _core.runEffects(_core.tap(async ([closerFaceIDs, furtherFaceIds])=>{
        // console.log("computing LODs", Math.round(Date.now() / 1000));
        // if (!document.hidden) {
        mesh.mda.faces.forEach((face)=>{
            if (closerFaceIDs.includes(face.index)) face.lod = high;
            else if (furtherFaceIds.includes(face.index)) face.lod = mid;
            else face.lod = low;
        });
        mesh.mda.faces.forEach((face)=>{
            const lodKey = JSON.stringify(_mdaDefault.default.FaceHalfEdges(face).map((he)=>// Math.max(face.lod || (face.fallbackLod || low), he.flipHalfEdge?.face.lod || (face.fallbackLod || low))
                Math.max(face.lod || face.fallbackLod || low, he.flipHalfEdge?.face.lod || he.flipHalfEdge?.face.fallbackLod || low)
            ).map((i)=>2 ** i
            ));
            face.lodKey = lodKey;
            face.meshlet = atlas.lookup[lodKey];
        });
        meshlets = mesh.mda.faces.map(({ meshlet  })=>meshlet
        );
        permutations.data(new Int8Array(_lodashEs.flatten(meshlets.flatMap((m)=>m.permutation
        ))));
        if (debugText) {
            ctx2D?.clearRect(-ctx2D.canvas.width / 2, -ctx2D.canvas.height / 2, ctx2D.canvas.width, ctx2D.canvas.height);
            mesh.mda.faces.forEach((face)=>{
                const faceMidpoint = _lodashEs.zipWith(..._mdaDefault.default.FaceVertices(face).map((v)=>mesh.mda.positions[v.index]
                ), (x, y, z)=>x + y + z
                ).map((x)=>x / 3
                ).slice(0, 2);
                ctx2D?.fillText(face.lod || face.fallbackLod, // `${[face.meshlet.lod || "0"]} :: ${face.meshlet.edgePermutation} :: ${face.meshlet.permutation}`,
                // face.lodKey,
                // `${face.meshlet.lod} @ ${face.meshlet.permutation}`,
                faceMidpoint[0] * ctx2D.canvas.width - 40, -faceMidpoint[1] * ctx2D.canvas.height);
            });
        }
        const triangles = `
      <p>
      triangles: 
        ${_humanFormatDefault.default(_lodashEs.sum(mesh.mda.faces.map(({ meshlet  })=>meshlet.count
        )) / 3)}
      </p><p>
      patches:
        ${mesh.mda.faces.length} 
      </p>
      `;
        // console.log(triangles)
        document.querySelector("#stats").innerHTML = triangles;
    // }
    }, _core.throttle(15, mouseInCanvas$)), scheduler);
    ctx2D?.translate(ctx2D.canvas.width / 2, ctx2D.canvas.height / 2);
    const draw = ()=>{
        // console.log("drawing", Math.round(Date.now() / 1000));
        if (timer.ready()) utils.updateTimerElement(timer.cpuTime, timer.gpuTime);
        timer.start();
        // DRAW
        app.clear();
        let nextRanges = [];
        for(let i = 0; i < meshlets.length; i++){
            const mNext = meshlets[i];
            const prev = nextRanges.at(-1);
            if (_lodashEs.isEqual(mNext.lod, prev?.at(-1))) prev[2] += 1;
            else nextRanges.push([
                mNext.baseIndex,
                mNext.count,
                1,
                i,
                mNext.lod
            ]);
        }
        ranges = nextRanges.map(([baseIndex, count, numInstances, baseInstance])=>[
                baseIndex,
                count,
                numInstances,
                baseInstance, 
            ]
        );
        // console.log('num ranges', ranges.length)
        drawCall.drawRanges(...ranges);
        drawCall.draw();
        timer.end();
        requestAnimationFrame(draw);
    };
    draw();
});

},{"lodash-es":"bXNwz","picogl":"idVgO","../src/load-tessellation-atlas":"4kohm","./pico-util":"5Adn4","../src/util":"7wzGb","./random-mesh":"ckB5R","@polymer/paper-spinner/paper-spinner-lite.js":"4dkwQ","mda":"9J7Dv","@most/core":"hGpP7","@most/scheduler":"jTyut","@most/dom-event":"k1B4s","rbush-knn":"d8fuf","human-format":"16D9h","./whileTabFocus":"fUigp","./position-in-element":"1cqHl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bXNwz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="es" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ parcelHelpers.export(exports, "add", ()=>_addJsDefault.default
);
parcelHelpers.export(exports, "after", ()=>_afterJsDefault.default
);
parcelHelpers.export(exports, "ary", ()=>_aryJsDefault.default
);
parcelHelpers.export(exports, "assign", ()=>_assignJsDefault.default
);
parcelHelpers.export(exports, "assignIn", ()=>_assignInJsDefault.default
);
parcelHelpers.export(exports, "assignInWith", ()=>_assignInWithJsDefault.default
);
parcelHelpers.export(exports, "assignWith", ()=>_assignWithJsDefault.default
);
parcelHelpers.export(exports, "at", ()=>_atJsDefault.default
);
parcelHelpers.export(exports, "attempt", ()=>_attemptJsDefault.default
);
parcelHelpers.export(exports, "before", ()=>_beforeJsDefault.default
);
parcelHelpers.export(exports, "bind", ()=>_bindJsDefault.default
);
parcelHelpers.export(exports, "bindAll", ()=>_bindAllJsDefault.default
);
parcelHelpers.export(exports, "bindKey", ()=>_bindKeyJsDefault.default
);
parcelHelpers.export(exports, "camelCase", ()=>_camelCaseJsDefault.default
);
parcelHelpers.export(exports, "capitalize", ()=>_capitalizeJsDefault.default
);
parcelHelpers.export(exports, "castArray", ()=>_castArrayJsDefault.default
);
parcelHelpers.export(exports, "ceil", ()=>_ceilJsDefault.default
);
parcelHelpers.export(exports, "chain", ()=>_chainJsDefault.default
);
parcelHelpers.export(exports, "chunk", ()=>_chunkJsDefault.default
);
parcelHelpers.export(exports, "clamp", ()=>_clampJsDefault.default
);
parcelHelpers.export(exports, "clone", ()=>_cloneJsDefault.default
);
parcelHelpers.export(exports, "cloneDeep", ()=>_cloneDeepJsDefault.default
);
parcelHelpers.export(exports, "cloneDeepWith", ()=>_cloneDeepWithJsDefault.default
);
parcelHelpers.export(exports, "cloneWith", ()=>_cloneWithJsDefault.default
);
parcelHelpers.export(exports, "commit", ()=>_commitJsDefault.default
);
parcelHelpers.export(exports, "compact", ()=>_compactJsDefault.default
);
parcelHelpers.export(exports, "concat", ()=>_concatJsDefault.default
);
parcelHelpers.export(exports, "cond", ()=>_condJsDefault.default
);
parcelHelpers.export(exports, "conforms", ()=>_conformsJsDefault.default
);
parcelHelpers.export(exports, "conformsTo", ()=>_conformsToJsDefault.default
);
parcelHelpers.export(exports, "constant", ()=>_constantJsDefault.default
);
parcelHelpers.export(exports, "countBy", ()=>_countByJsDefault.default
);
parcelHelpers.export(exports, "create", ()=>_createJsDefault.default
);
parcelHelpers.export(exports, "curry", ()=>_curryJsDefault.default
);
parcelHelpers.export(exports, "curryRight", ()=>_curryRightJsDefault.default
);
parcelHelpers.export(exports, "debounce", ()=>_debounceJsDefault.default
);
parcelHelpers.export(exports, "deburr", ()=>_deburrJsDefault.default
);
parcelHelpers.export(exports, "defaultTo", ()=>_defaultToJsDefault.default
);
parcelHelpers.export(exports, "defaults", ()=>_defaultsJsDefault.default
);
parcelHelpers.export(exports, "defaultsDeep", ()=>_defaultsDeepJsDefault.default
);
parcelHelpers.export(exports, "defer", ()=>_deferJsDefault.default
);
parcelHelpers.export(exports, "delay", ()=>_delayJsDefault.default
);
parcelHelpers.export(exports, "difference", ()=>_differenceJsDefault.default
);
parcelHelpers.export(exports, "differenceBy", ()=>_differenceByJsDefault.default
);
parcelHelpers.export(exports, "differenceWith", ()=>_differenceWithJsDefault.default
);
parcelHelpers.export(exports, "divide", ()=>_divideJsDefault.default
);
parcelHelpers.export(exports, "drop", ()=>_dropJsDefault.default
);
parcelHelpers.export(exports, "dropRight", ()=>_dropRightJsDefault.default
);
parcelHelpers.export(exports, "dropRightWhile", ()=>_dropRightWhileJsDefault.default
);
parcelHelpers.export(exports, "dropWhile", ()=>_dropWhileJsDefault.default
);
parcelHelpers.export(exports, "each", ()=>_eachJsDefault.default
);
parcelHelpers.export(exports, "eachRight", ()=>_eachRightJsDefault.default
);
parcelHelpers.export(exports, "endsWith", ()=>_endsWithJsDefault.default
);
parcelHelpers.export(exports, "entries", ()=>_entriesJsDefault.default
);
parcelHelpers.export(exports, "entriesIn", ()=>_entriesInJsDefault.default
);
parcelHelpers.export(exports, "eq", ()=>_eqJsDefault.default
);
parcelHelpers.export(exports, "escape", ()=>_escapeJsDefault.default
);
parcelHelpers.export(exports, "escapeRegExp", ()=>_escapeRegExpJsDefault.default
);
parcelHelpers.export(exports, "every", ()=>_everyJsDefault.default
);
parcelHelpers.export(exports, "extend", ()=>_extendJsDefault.default
);
parcelHelpers.export(exports, "extendWith", ()=>_extendWithJsDefault.default
);
parcelHelpers.export(exports, "fill", ()=>_fillJsDefault.default
);
parcelHelpers.export(exports, "filter", ()=>_filterJsDefault.default
);
parcelHelpers.export(exports, "find", ()=>_findJsDefault.default
);
parcelHelpers.export(exports, "findIndex", ()=>_findIndexJsDefault.default
);
parcelHelpers.export(exports, "findKey", ()=>_findKeyJsDefault.default
);
parcelHelpers.export(exports, "findLast", ()=>_findLastJsDefault.default
);
parcelHelpers.export(exports, "findLastIndex", ()=>_findLastIndexJsDefault.default
);
parcelHelpers.export(exports, "findLastKey", ()=>_findLastKeyJsDefault.default
);
parcelHelpers.export(exports, "first", ()=>_firstJsDefault.default
);
parcelHelpers.export(exports, "flatMap", ()=>_flatMapJsDefault.default
);
parcelHelpers.export(exports, "flatMapDeep", ()=>_flatMapDeepJsDefault.default
);
parcelHelpers.export(exports, "flatMapDepth", ()=>_flatMapDepthJsDefault.default
);
parcelHelpers.export(exports, "flatten", ()=>_flattenJsDefault.default
);
parcelHelpers.export(exports, "flattenDeep", ()=>_flattenDeepJsDefault.default
);
parcelHelpers.export(exports, "flattenDepth", ()=>_flattenDepthJsDefault.default
);
parcelHelpers.export(exports, "flip", ()=>_flipJsDefault.default
);
parcelHelpers.export(exports, "floor", ()=>_floorJsDefault.default
);
parcelHelpers.export(exports, "flow", ()=>_flowJsDefault.default
);
parcelHelpers.export(exports, "flowRight", ()=>_flowRightJsDefault.default
);
parcelHelpers.export(exports, "forEach", ()=>_forEachJsDefault.default
);
parcelHelpers.export(exports, "forEachRight", ()=>_forEachRightJsDefault.default
);
parcelHelpers.export(exports, "forIn", ()=>_forInJsDefault.default
);
parcelHelpers.export(exports, "forInRight", ()=>_forInRightJsDefault.default
);
parcelHelpers.export(exports, "forOwn", ()=>_forOwnJsDefault.default
);
parcelHelpers.export(exports, "forOwnRight", ()=>_forOwnRightJsDefault.default
);
parcelHelpers.export(exports, "fromPairs", ()=>_fromPairsJsDefault.default
);
parcelHelpers.export(exports, "functions", ()=>_functionsJsDefault.default
);
parcelHelpers.export(exports, "functionsIn", ()=>_functionsInJsDefault.default
);
parcelHelpers.export(exports, "get", ()=>_getJsDefault.default
);
parcelHelpers.export(exports, "groupBy", ()=>_groupByJsDefault.default
);
parcelHelpers.export(exports, "gt", ()=>_gtJsDefault.default
);
parcelHelpers.export(exports, "gte", ()=>_gteJsDefault.default
);
parcelHelpers.export(exports, "has", ()=>_hasJsDefault.default
);
parcelHelpers.export(exports, "hasIn", ()=>_hasInJsDefault.default
);
parcelHelpers.export(exports, "head", ()=>_headJsDefault.default
);
parcelHelpers.export(exports, "identity", ()=>_identityJsDefault.default
);
parcelHelpers.export(exports, "inRange", ()=>_inRangeJsDefault.default
);
parcelHelpers.export(exports, "includes", ()=>_includesJsDefault.default
);
parcelHelpers.export(exports, "indexOf", ()=>_indexOfJsDefault.default
);
parcelHelpers.export(exports, "initial", ()=>_initialJsDefault.default
);
parcelHelpers.export(exports, "intersection", ()=>_intersectionJsDefault.default
);
parcelHelpers.export(exports, "intersectionBy", ()=>_intersectionByJsDefault.default
);
parcelHelpers.export(exports, "intersectionWith", ()=>_intersectionWithJsDefault.default
);
parcelHelpers.export(exports, "invert", ()=>_invertJsDefault.default
);
parcelHelpers.export(exports, "invertBy", ()=>_invertByJsDefault.default
);
parcelHelpers.export(exports, "invoke", ()=>_invokeJsDefault.default
);
parcelHelpers.export(exports, "invokeMap", ()=>_invokeMapJsDefault.default
);
parcelHelpers.export(exports, "isArguments", ()=>_isArgumentsJsDefault.default
);
parcelHelpers.export(exports, "isArray", ()=>_isArrayJsDefault.default
);
parcelHelpers.export(exports, "isArrayBuffer", ()=>_isArrayBufferJsDefault.default
);
parcelHelpers.export(exports, "isArrayLike", ()=>_isArrayLikeJsDefault.default
);
parcelHelpers.export(exports, "isArrayLikeObject", ()=>_isArrayLikeObjectJsDefault.default
);
parcelHelpers.export(exports, "isBoolean", ()=>_isBooleanJsDefault.default
);
parcelHelpers.export(exports, "isBuffer", ()=>_isBufferJsDefault.default
);
parcelHelpers.export(exports, "isDate", ()=>_isDateJsDefault.default
);
parcelHelpers.export(exports, "isElement", ()=>_isElementJsDefault.default
);
parcelHelpers.export(exports, "isEmpty", ()=>_isEmptyJsDefault.default
);
parcelHelpers.export(exports, "isEqual", ()=>_isEqualJsDefault.default
);
parcelHelpers.export(exports, "isEqualWith", ()=>_isEqualWithJsDefault.default
);
parcelHelpers.export(exports, "isError", ()=>_isErrorJsDefault.default
);
parcelHelpers.export(exports, "isFinite", ()=>_isFiniteJsDefault.default
);
parcelHelpers.export(exports, "isFunction", ()=>_isFunctionJsDefault.default
);
parcelHelpers.export(exports, "isInteger", ()=>_isIntegerJsDefault.default
);
parcelHelpers.export(exports, "isLength", ()=>_isLengthJsDefault.default
);
parcelHelpers.export(exports, "isMap", ()=>_isMapJsDefault.default
);
parcelHelpers.export(exports, "isMatch", ()=>_isMatchJsDefault.default
);
parcelHelpers.export(exports, "isMatchWith", ()=>_isMatchWithJsDefault.default
);
parcelHelpers.export(exports, "isNaN", ()=>_isNaNJsDefault.default
);
parcelHelpers.export(exports, "isNative", ()=>_isNativeJsDefault.default
);
parcelHelpers.export(exports, "isNil", ()=>_isNilJsDefault.default
);
parcelHelpers.export(exports, "isNull", ()=>_isNullJsDefault.default
);
parcelHelpers.export(exports, "isNumber", ()=>_isNumberJsDefault.default
);
parcelHelpers.export(exports, "isObject", ()=>_isObjectJsDefault.default
);
parcelHelpers.export(exports, "isObjectLike", ()=>_isObjectLikeJsDefault.default
);
parcelHelpers.export(exports, "isPlainObject", ()=>_isPlainObjectJsDefault.default
);
parcelHelpers.export(exports, "isRegExp", ()=>_isRegExpJsDefault.default
);
parcelHelpers.export(exports, "isSafeInteger", ()=>_isSafeIntegerJsDefault.default
);
parcelHelpers.export(exports, "isSet", ()=>_isSetJsDefault.default
);
parcelHelpers.export(exports, "isString", ()=>_isStringJsDefault.default
);
parcelHelpers.export(exports, "isSymbol", ()=>_isSymbolJsDefault.default
);
parcelHelpers.export(exports, "isTypedArray", ()=>_isTypedArrayJsDefault.default
);
parcelHelpers.export(exports, "isUndefined", ()=>_isUndefinedJsDefault.default
);
parcelHelpers.export(exports, "isWeakMap", ()=>_isWeakMapJsDefault.default
);
parcelHelpers.export(exports, "isWeakSet", ()=>_isWeakSetJsDefault.default
);
parcelHelpers.export(exports, "iteratee", ()=>_iterateeJsDefault.default
);
parcelHelpers.export(exports, "join", ()=>_joinJsDefault.default
);
parcelHelpers.export(exports, "kebabCase", ()=>_kebabCaseJsDefault.default
);
parcelHelpers.export(exports, "keyBy", ()=>_keyByJsDefault.default
);
parcelHelpers.export(exports, "keys", ()=>_keysJsDefault.default
);
parcelHelpers.export(exports, "keysIn", ()=>_keysInJsDefault.default
);
parcelHelpers.export(exports, "last", ()=>_lastJsDefault.default
);
parcelHelpers.export(exports, "lastIndexOf", ()=>_lastIndexOfJsDefault.default
);
parcelHelpers.export(exports, "lodash", ()=>_wrapperLodashJsDefault.default
);
parcelHelpers.export(exports, "lowerCase", ()=>_lowerCaseJsDefault.default
);
parcelHelpers.export(exports, "lowerFirst", ()=>_lowerFirstJsDefault.default
);
parcelHelpers.export(exports, "lt", ()=>_ltJsDefault.default
);
parcelHelpers.export(exports, "lte", ()=>_lteJsDefault.default
);
parcelHelpers.export(exports, "map", ()=>_mapJsDefault.default
);
parcelHelpers.export(exports, "mapKeys", ()=>_mapKeysJsDefault.default
);
parcelHelpers.export(exports, "mapValues", ()=>_mapValuesJsDefault.default
);
parcelHelpers.export(exports, "matches", ()=>_matchesJsDefault.default
);
parcelHelpers.export(exports, "matchesProperty", ()=>_matchesPropertyJsDefault.default
);
parcelHelpers.export(exports, "max", ()=>_maxJsDefault.default
);
parcelHelpers.export(exports, "maxBy", ()=>_maxByJsDefault.default
);
parcelHelpers.export(exports, "mean", ()=>_meanJsDefault.default
);
parcelHelpers.export(exports, "meanBy", ()=>_meanByJsDefault.default
);
parcelHelpers.export(exports, "memoize", ()=>_memoizeJsDefault.default
);
parcelHelpers.export(exports, "merge", ()=>_mergeJsDefault.default
);
parcelHelpers.export(exports, "mergeWith", ()=>_mergeWithJsDefault.default
);
parcelHelpers.export(exports, "method", ()=>_methodJsDefault.default
);
parcelHelpers.export(exports, "methodOf", ()=>_methodOfJsDefault.default
);
parcelHelpers.export(exports, "min", ()=>_minJsDefault.default
);
parcelHelpers.export(exports, "minBy", ()=>_minByJsDefault.default
);
parcelHelpers.export(exports, "mixin", ()=>_mixinJsDefault.default
);
parcelHelpers.export(exports, "multiply", ()=>_multiplyJsDefault.default
);
parcelHelpers.export(exports, "negate", ()=>_negateJsDefault.default
);
parcelHelpers.export(exports, "next", ()=>_nextJsDefault.default
);
parcelHelpers.export(exports, "noop", ()=>_noopJsDefault.default
);
parcelHelpers.export(exports, "now", ()=>_nowJsDefault.default
);
parcelHelpers.export(exports, "nth", ()=>_nthJsDefault.default
);
parcelHelpers.export(exports, "nthArg", ()=>_nthArgJsDefault.default
);
parcelHelpers.export(exports, "omit", ()=>_omitJsDefault.default
);
parcelHelpers.export(exports, "omitBy", ()=>_omitByJsDefault.default
);
parcelHelpers.export(exports, "once", ()=>_onceJsDefault.default
);
parcelHelpers.export(exports, "orderBy", ()=>_orderByJsDefault.default
);
parcelHelpers.export(exports, "over", ()=>_overJsDefault.default
);
parcelHelpers.export(exports, "overArgs", ()=>_overArgsJsDefault.default
);
parcelHelpers.export(exports, "overEvery", ()=>_overEveryJsDefault.default
);
parcelHelpers.export(exports, "overSome", ()=>_overSomeJsDefault.default
);
parcelHelpers.export(exports, "pad", ()=>_padJsDefault.default
);
parcelHelpers.export(exports, "padEnd", ()=>_padEndJsDefault.default
);
parcelHelpers.export(exports, "padStart", ()=>_padStartJsDefault.default
);
parcelHelpers.export(exports, "parseInt", ()=>_parseIntJsDefault.default
);
parcelHelpers.export(exports, "partial", ()=>_partialJsDefault.default
);
parcelHelpers.export(exports, "partialRight", ()=>_partialRightJsDefault.default
);
parcelHelpers.export(exports, "partition", ()=>_partitionJsDefault.default
);
parcelHelpers.export(exports, "pick", ()=>_pickJsDefault.default
);
parcelHelpers.export(exports, "pickBy", ()=>_pickByJsDefault.default
);
parcelHelpers.export(exports, "plant", ()=>_plantJsDefault.default
);
parcelHelpers.export(exports, "property", ()=>_propertyJsDefault.default
);
parcelHelpers.export(exports, "propertyOf", ()=>_propertyOfJsDefault.default
);
parcelHelpers.export(exports, "pull", ()=>_pullJsDefault.default
);
parcelHelpers.export(exports, "pullAll", ()=>_pullAllJsDefault.default
);
parcelHelpers.export(exports, "pullAllBy", ()=>_pullAllByJsDefault.default
);
parcelHelpers.export(exports, "pullAllWith", ()=>_pullAllWithJsDefault.default
);
parcelHelpers.export(exports, "pullAt", ()=>_pullAtJsDefault.default
);
parcelHelpers.export(exports, "random", ()=>_randomJsDefault.default
);
parcelHelpers.export(exports, "range", ()=>_rangeJsDefault.default
);
parcelHelpers.export(exports, "rangeRight", ()=>_rangeRightJsDefault.default
);
parcelHelpers.export(exports, "rearg", ()=>_reargJsDefault.default
);
parcelHelpers.export(exports, "reduce", ()=>_reduceJsDefault.default
);
parcelHelpers.export(exports, "reduceRight", ()=>_reduceRightJsDefault.default
);
parcelHelpers.export(exports, "reject", ()=>_rejectJsDefault.default
);
parcelHelpers.export(exports, "remove", ()=>_removeJsDefault.default
);
parcelHelpers.export(exports, "repeat", ()=>_repeatJsDefault.default
);
parcelHelpers.export(exports, "replace", ()=>_replaceJsDefault.default
);
parcelHelpers.export(exports, "rest", ()=>_restJsDefault.default
);
parcelHelpers.export(exports, "result", ()=>_resultJsDefault.default
);
parcelHelpers.export(exports, "reverse", ()=>_reverseJsDefault.default
);
parcelHelpers.export(exports, "round", ()=>_roundJsDefault.default
);
parcelHelpers.export(exports, "sample", ()=>_sampleJsDefault.default
);
parcelHelpers.export(exports, "sampleSize", ()=>_sampleSizeJsDefault.default
);
parcelHelpers.export(exports, "set", ()=>_setJsDefault.default
);
parcelHelpers.export(exports, "setWith", ()=>_setWithJsDefault.default
);
parcelHelpers.export(exports, "shuffle", ()=>_shuffleJsDefault.default
);
parcelHelpers.export(exports, "size", ()=>_sizeJsDefault.default
);
parcelHelpers.export(exports, "slice", ()=>_sliceJsDefault.default
);
parcelHelpers.export(exports, "snakeCase", ()=>_snakeCaseJsDefault.default
);
parcelHelpers.export(exports, "some", ()=>_someJsDefault.default
);
parcelHelpers.export(exports, "sortBy", ()=>_sortByJsDefault.default
);
parcelHelpers.export(exports, "sortedIndex", ()=>_sortedIndexJsDefault.default
);
parcelHelpers.export(exports, "sortedIndexBy", ()=>_sortedIndexByJsDefault.default
);
parcelHelpers.export(exports, "sortedIndexOf", ()=>_sortedIndexOfJsDefault.default
);
parcelHelpers.export(exports, "sortedLastIndex", ()=>_sortedLastIndexJsDefault.default
);
parcelHelpers.export(exports, "sortedLastIndexBy", ()=>_sortedLastIndexByJsDefault.default
);
parcelHelpers.export(exports, "sortedLastIndexOf", ()=>_sortedLastIndexOfJsDefault.default
);
parcelHelpers.export(exports, "sortedUniq", ()=>_sortedUniqJsDefault.default
);
parcelHelpers.export(exports, "sortedUniqBy", ()=>_sortedUniqByJsDefault.default
);
parcelHelpers.export(exports, "split", ()=>_splitJsDefault.default
);
parcelHelpers.export(exports, "spread", ()=>_spreadJsDefault.default
);
parcelHelpers.export(exports, "startCase", ()=>_startCaseJsDefault.default
);
parcelHelpers.export(exports, "startsWith", ()=>_startsWithJsDefault.default
);
parcelHelpers.export(exports, "stubArray", ()=>_stubArrayJsDefault.default
);
parcelHelpers.export(exports, "stubFalse", ()=>_stubFalseJsDefault.default
);
parcelHelpers.export(exports, "stubObject", ()=>_stubObjectJsDefault.default
);
parcelHelpers.export(exports, "stubString", ()=>_stubStringJsDefault.default
);
parcelHelpers.export(exports, "stubTrue", ()=>_stubTrueJsDefault.default
);
parcelHelpers.export(exports, "subtract", ()=>_subtractJsDefault.default
);
parcelHelpers.export(exports, "sum", ()=>_sumJsDefault.default
);
parcelHelpers.export(exports, "sumBy", ()=>_sumByJsDefault.default
);
parcelHelpers.export(exports, "tail", ()=>_tailJsDefault.default
);
parcelHelpers.export(exports, "take", ()=>_takeJsDefault.default
);
parcelHelpers.export(exports, "takeRight", ()=>_takeRightJsDefault.default
);
parcelHelpers.export(exports, "takeRightWhile", ()=>_takeRightWhileJsDefault.default
);
parcelHelpers.export(exports, "takeWhile", ()=>_takeWhileJsDefault.default
);
parcelHelpers.export(exports, "tap", ()=>_tapJsDefault.default
);
parcelHelpers.export(exports, "template", ()=>_templateJsDefault.default
);
parcelHelpers.export(exports, "templateSettings", ()=>_templateSettingsJsDefault.default
);
parcelHelpers.export(exports, "throttle", ()=>_throttleJsDefault.default
);
parcelHelpers.export(exports, "thru", ()=>_thruJsDefault.default
);
parcelHelpers.export(exports, "times", ()=>_timesJsDefault.default
);
parcelHelpers.export(exports, "toArray", ()=>_toArrayJsDefault.default
);
parcelHelpers.export(exports, "toFinite", ()=>_toFiniteJsDefault.default
);
parcelHelpers.export(exports, "toInteger", ()=>_toIntegerJsDefault.default
);
parcelHelpers.export(exports, "toIterator", ()=>_toIteratorJsDefault.default
);
parcelHelpers.export(exports, "toJSON", ()=>_toJSONJsDefault.default
);
parcelHelpers.export(exports, "toLength", ()=>_toLengthJsDefault.default
);
parcelHelpers.export(exports, "toLower", ()=>_toLowerJsDefault.default
);
parcelHelpers.export(exports, "toNumber", ()=>_toNumberJsDefault.default
);
parcelHelpers.export(exports, "toPairs", ()=>_toPairsJsDefault.default
);
parcelHelpers.export(exports, "toPairsIn", ()=>_toPairsInJsDefault.default
);
parcelHelpers.export(exports, "toPath", ()=>_toPathJsDefault.default
);
parcelHelpers.export(exports, "toPlainObject", ()=>_toPlainObjectJsDefault.default
);
parcelHelpers.export(exports, "toSafeInteger", ()=>_toSafeIntegerJsDefault.default
);
parcelHelpers.export(exports, "toString", ()=>_toStringJsDefault.default
);
parcelHelpers.export(exports, "toUpper", ()=>_toUpperJsDefault.default
);
parcelHelpers.export(exports, "transform", ()=>_transformJsDefault.default
);
parcelHelpers.export(exports, "trim", ()=>_trimJsDefault.default
);
parcelHelpers.export(exports, "trimEnd", ()=>_trimEndJsDefault.default
);
parcelHelpers.export(exports, "trimStart", ()=>_trimStartJsDefault.default
);
parcelHelpers.export(exports, "truncate", ()=>_truncateJsDefault.default
);
parcelHelpers.export(exports, "unary", ()=>_unaryJsDefault.default
);
parcelHelpers.export(exports, "unescape", ()=>_unescapeJsDefault.default
);
parcelHelpers.export(exports, "union", ()=>_unionJsDefault.default
);
parcelHelpers.export(exports, "unionBy", ()=>_unionByJsDefault.default
);
parcelHelpers.export(exports, "unionWith", ()=>_unionWithJsDefault.default
);
parcelHelpers.export(exports, "uniq", ()=>_uniqJsDefault.default
);
parcelHelpers.export(exports, "uniqBy", ()=>_uniqByJsDefault.default
);
parcelHelpers.export(exports, "uniqWith", ()=>_uniqWithJsDefault.default
);
parcelHelpers.export(exports, "uniqueId", ()=>_uniqueIdJsDefault.default
);
parcelHelpers.export(exports, "unset", ()=>_unsetJsDefault.default
);
parcelHelpers.export(exports, "unzip", ()=>_unzipJsDefault.default
);
parcelHelpers.export(exports, "unzipWith", ()=>_unzipWithJsDefault.default
);
parcelHelpers.export(exports, "update", ()=>_updateJsDefault.default
);
parcelHelpers.export(exports, "updateWith", ()=>_updateWithJsDefault.default
);
parcelHelpers.export(exports, "upperCase", ()=>_upperCaseJsDefault.default
);
parcelHelpers.export(exports, "upperFirst", ()=>_upperFirstJsDefault.default
);
parcelHelpers.export(exports, "value", ()=>_valueJsDefault.default
);
parcelHelpers.export(exports, "valueOf", ()=>_valueOfJsDefault.default
);
parcelHelpers.export(exports, "values", ()=>_valuesJsDefault.default
);
parcelHelpers.export(exports, "valuesIn", ()=>_valuesInJsDefault.default
);
parcelHelpers.export(exports, "without", ()=>_withoutJsDefault.default
);
parcelHelpers.export(exports, "words", ()=>_wordsJsDefault.default
);
parcelHelpers.export(exports, "wrap", ()=>_wrapJsDefault.default
);
parcelHelpers.export(exports, "wrapperAt", ()=>_wrapperAtJsDefault.default
);
parcelHelpers.export(exports, "wrapperChain", ()=>_wrapperChainJsDefault.default
);
parcelHelpers.export(exports, "wrapperCommit", ()=>_commitJsDefault.default
);
parcelHelpers.export(exports, "wrapperLodash", ()=>_wrapperLodashJsDefault.default
);
parcelHelpers.export(exports, "wrapperNext", ()=>_nextJsDefault.default
);
parcelHelpers.export(exports, "wrapperPlant", ()=>_plantJsDefault.default
);
parcelHelpers.export(exports, "wrapperReverse", ()=>_wrapperReverseJsDefault.default
);
parcelHelpers.export(exports, "wrapperToIterator", ()=>_toIteratorJsDefault.default
);
parcelHelpers.export(exports, "wrapperValue", ()=>_wrapperValueJsDefault.default
);
parcelHelpers.export(exports, "xor", ()=>_xorJsDefault.default
);
parcelHelpers.export(exports, "xorBy", ()=>_xorByJsDefault.default
);
parcelHelpers.export(exports, "xorWith", ()=>_xorWithJsDefault.default
);
parcelHelpers.export(exports, "zip", ()=>_zipJsDefault.default
);
parcelHelpers.export(exports, "zipObject", ()=>_zipObjectJsDefault.default
);
parcelHelpers.export(exports, "zipObjectDeep", ()=>_zipObjectDeepJsDefault.default
);
parcelHelpers.export(exports, "zipWith", ()=>_zipWithJsDefault.default
);
parcelHelpers.export(exports, "default", ()=>_lodashDefaultJsDefault.default
);
var _addJs = require("./add.js");
var _addJsDefault = parcelHelpers.interopDefault(_addJs);
var _afterJs = require("./after.js");
var _afterJsDefault = parcelHelpers.interopDefault(_afterJs);
var _aryJs = require("./ary.js");
var _aryJsDefault = parcelHelpers.interopDefault(_aryJs);
var _assignJs = require("./assign.js");
var _assignJsDefault = parcelHelpers.interopDefault(_assignJs);
var _assignInJs = require("./assignIn.js");
var _assignInJsDefault = parcelHelpers.interopDefault(_assignInJs);
var _assignInWithJs = require("./assignInWith.js");
var _assignInWithJsDefault = parcelHelpers.interopDefault(_assignInWithJs);
var _assignWithJs = require("./assignWith.js");
var _assignWithJsDefault = parcelHelpers.interopDefault(_assignWithJs);
var _atJs = require("./at.js");
var _atJsDefault = parcelHelpers.interopDefault(_atJs);
var _attemptJs = require("./attempt.js");
var _attemptJsDefault = parcelHelpers.interopDefault(_attemptJs);
var _beforeJs = require("./before.js");
var _beforeJsDefault = parcelHelpers.interopDefault(_beforeJs);
var _bindJs = require("./bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var _bindAllJs = require("./bindAll.js");
var _bindAllJsDefault = parcelHelpers.interopDefault(_bindAllJs);
var _bindKeyJs = require("./bindKey.js");
var _bindKeyJsDefault = parcelHelpers.interopDefault(_bindKeyJs);
var _camelCaseJs = require("./camelCase.js");
var _camelCaseJsDefault = parcelHelpers.interopDefault(_camelCaseJs);
var _capitalizeJs = require("./capitalize.js");
var _capitalizeJsDefault = parcelHelpers.interopDefault(_capitalizeJs);
var _castArrayJs = require("./castArray.js");
var _castArrayJsDefault = parcelHelpers.interopDefault(_castArrayJs);
var _ceilJs = require("./ceil.js");
var _ceilJsDefault = parcelHelpers.interopDefault(_ceilJs);
var _chainJs = require("./chain.js");
var _chainJsDefault = parcelHelpers.interopDefault(_chainJs);
var _chunkJs = require("./chunk.js");
var _chunkJsDefault = parcelHelpers.interopDefault(_chunkJs);
var _clampJs = require("./clamp.js");
var _clampJsDefault = parcelHelpers.interopDefault(_clampJs);
var _cloneJs = require("./clone.js");
var _cloneJsDefault = parcelHelpers.interopDefault(_cloneJs);
var _cloneDeepJs = require("./cloneDeep.js");
var _cloneDeepJsDefault = parcelHelpers.interopDefault(_cloneDeepJs);
var _cloneDeepWithJs = require("./cloneDeepWith.js");
var _cloneDeepWithJsDefault = parcelHelpers.interopDefault(_cloneDeepWithJs);
var _cloneWithJs = require("./cloneWith.js");
var _cloneWithJsDefault = parcelHelpers.interopDefault(_cloneWithJs);
var _commitJs = require("./commit.js");
var _commitJsDefault = parcelHelpers.interopDefault(_commitJs);
var _compactJs = require("./compact.js");
var _compactJsDefault = parcelHelpers.interopDefault(_compactJs);
var _concatJs = require("./concat.js");
var _concatJsDefault = parcelHelpers.interopDefault(_concatJs);
var _condJs = require("./cond.js");
var _condJsDefault = parcelHelpers.interopDefault(_condJs);
var _conformsJs = require("./conforms.js");
var _conformsJsDefault = parcelHelpers.interopDefault(_conformsJs);
var _conformsToJs = require("./conformsTo.js");
var _conformsToJsDefault = parcelHelpers.interopDefault(_conformsToJs);
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _countByJs = require("./countBy.js");
var _countByJsDefault = parcelHelpers.interopDefault(_countByJs);
var _createJs = require("./create.js");
var _createJsDefault = parcelHelpers.interopDefault(_createJs);
var _curryJs = require("./curry.js");
var _curryJsDefault = parcelHelpers.interopDefault(_curryJs);
var _curryRightJs = require("./curryRight.js");
var _curryRightJsDefault = parcelHelpers.interopDefault(_curryRightJs);
var _debounceJs = require("./debounce.js");
var _debounceJsDefault = parcelHelpers.interopDefault(_debounceJs);
var _deburrJs = require("./deburr.js");
var _deburrJsDefault = parcelHelpers.interopDefault(_deburrJs);
var _defaultToJs = require("./defaultTo.js");
var _defaultToJsDefault = parcelHelpers.interopDefault(_defaultToJs);
var _defaultsJs = require("./defaults.js");
var _defaultsJsDefault = parcelHelpers.interopDefault(_defaultsJs);
var _defaultsDeepJs = require("./defaultsDeep.js");
var _defaultsDeepJsDefault = parcelHelpers.interopDefault(_defaultsDeepJs);
var _deferJs = require("./defer.js");
var _deferJsDefault = parcelHelpers.interopDefault(_deferJs);
var _delayJs = require("./delay.js");
var _delayJsDefault = parcelHelpers.interopDefault(_delayJs);
var _differenceJs = require("./difference.js");
var _differenceJsDefault = parcelHelpers.interopDefault(_differenceJs);
var _differenceByJs = require("./differenceBy.js");
var _differenceByJsDefault = parcelHelpers.interopDefault(_differenceByJs);
var _differenceWithJs = require("./differenceWith.js");
var _differenceWithJsDefault = parcelHelpers.interopDefault(_differenceWithJs);
var _divideJs = require("./divide.js");
var _divideJsDefault = parcelHelpers.interopDefault(_divideJs);
var _dropJs = require("./drop.js");
var _dropJsDefault = parcelHelpers.interopDefault(_dropJs);
var _dropRightJs = require("./dropRight.js");
var _dropRightJsDefault = parcelHelpers.interopDefault(_dropRightJs);
var _dropRightWhileJs = require("./dropRightWhile.js");
var _dropRightWhileJsDefault = parcelHelpers.interopDefault(_dropRightWhileJs);
var _dropWhileJs = require("./dropWhile.js");
var _dropWhileJsDefault = parcelHelpers.interopDefault(_dropWhileJs);
var _eachJs = require("./each.js");
var _eachJsDefault = parcelHelpers.interopDefault(_eachJs);
var _eachRightJs = require("./eachRight.js");
var _eachRightJsDefault = parcelHelpers.interopDefault(_eachRightJs);
var _endsWithJs = require("./endsWith.js");
var _endsWithJsDefault = parcelHelpers.interopDefault(_endsWithJs);
var _entriesJs = require("./entries.js");
var _entriesJsDefault = parcelHelpers.interopDefault(_entriesJs);
var _entriesInJs = require("./entriesIn.js");
var _entriesInJsDefault = parcelHelpers.interopDefault(_entriesInJs);
var _eqJs = require("./eq.js");
var _eqJsDefault = parcelHelpers.interopDefault(_eqJs);
var _escapeJs = require("./escape.js");
var _escapeJsDefault = parcelHelpers.interopDefault(_escapeJs);
var _escapeRegExpJs = require("./escapeRegExp.js");
var _escapeRegExpJsDefault = parcelHelpers.interopDefault(_escapeRegExpJs);
var _everyJs = require("./every.js");
var _everyJsDefault = parcelHelpers.interopDefault(_everyJs);
var _extendJs = require("./extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _extendWithJs = require("./extendWith.js");
var _extendWithJsDefault = parcelHelpers.interopDefault(_extendWithJs);
var _fillJs = require("./fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _filterJs = require("./filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
var _findJs = require("./find.js");
var _findJsDefault = parcelHelpers.interopDefault(_findJs);
var _findIndexJs = require("./findIndex.js");
var _findIndexJsDefault = parcelHelpers.interopDefault(_findIndexJs);
var _findKeyJs = require("./findKey.js");
var _findKeyJsDefault = parcelHelpers.interopDefault(_findKeyJs);
var _findLastJs = require("./findLast.js");
var _findLastJsDefault = parcelHelpers.interopDefault(_findLastJs);
var _findLastIndexJs = require("./findLastIndex.js");
var _findLastIndexJsDefault = parcelHelpers.interopDefault(_findLastIndexJs);
var _findLastKeyJs = require("./findLastKey.js");
var _findLastKeyJsDefault = parcelHelpers.interopDefault(_findLastKeyJs);
var _firstJs = require("./first.js");
var _firstJsDefault = parcelHelpers.interopDefault(_firstJs);
var _flatMapJs = require("./flatMap.js");
var _flatMapJsDefault = parcelHelpers.interopDefault(_flatMapJs);
var _flatMapDeepJs = require("./flatMapDeep.js");
var _flatMapDeepJsDefault = parcelHelpers.interopDefault(_flatMapDeepJs);
var _flatMapDepthJs = require("./flatMapDepth.js");
var _flatMapDepthJsDefault = parcelHelpers.interopDefault(_flatMapDepthJs);
var _flattenJs = require("./flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
var _flattenDeepJs = require("./flattenDeep.js");
var _flattenDeepJsDefault = parcelHelpers.interopDefault(_flattenDeepJs);
var _flattenDepthJs = require("./flattenDepth.js");
var _flattenDepthJsDefault = parcelHelpers.interopDefault(_flattenDepthJs);
var _flipJs = require("./flip.js");
var _flipJsDefault = parcelHelpers.interopDefault(_flipJs);
var _floorJs = require("./floor.js");
var _floorJsDefault = parcelHelpers.interopDefault(_floorJs);
var _flowJs = require("./flow.js");
var _flowJsDefault = parcelHelpers.interopDefault(_flowJs);
var _flowRightJs = require("./flowRight.js");
var _flowRightJsDefault = parcelHelpers.interopDefault(_flowRightJs);
var _forEachJs = require("./forEach.js");
var _forEachJsDefault = parcelHelpers.interopDefault(_forEachJs);
var _forEachRightJs = require("./forEachRight.js");
var _forEachRightJsDefault = parcelHelpers.interopDefault(_forEachRightJs);
var _forInJs = require("./forIn.js");
var _forInJsDefault = parcelHelpers.interopDefault(_forInJs);
var _forInRightJs = require("./forInRight.js");
var _forInRightJsDefault = parcelHelpers.interopDefault(_forInRightJs);
var _forOwnJs = require("./forOwn.js");
var _forOwnJsDefault = parcelHelpers.interopDefault(_forOwnJs);
var _forOwnRightJs = require("./forOwnRight.js");
var _forOwnRightJsDefault = parcelHelpers.interopDefault(_forOwnRightJs);
var _fromPairsJs = require("./fromPairs.js");
var _fromPairsJsDefault = parcelHelpers.interopDefault(_fromPairsJs);
var _functionsJs = require("./functions.js");
var _functionsJsDefault = parcelHelpers.interopDefault(_functionsJs);
var _functionsInJs = require("./functionsIn.js");
var _functionsInJsDefault = parcelHelpers.interopDefault(_functionsInJs);
var _getJs = require("./get.js");
var _getJsDefault = parcelHelpers.interopDefault(_getJs);
var _groupByJs = require("./groupBy.js");
var _groupByJsDefault = parcelHelpers.interopDefault(_groupByJs);
var _gtJs = require("./gt.js");
var _gtJsDefault = parcelHelpers.interopDefault(_gtJs);
var _gteJs = require("./gte.js");
var _gteJsDefault = parcelHelpers.interopDefault(_gteJs);
var _hasJs = require("./has.js");
var _hasJsDefault = parcelHelpers.interopDefault(_hasJs);
var _hasInJs = require("./hasIn.js");
var _hasInJsDefault = parcelHelpers.interopDefault(_hasInJs);
var _headJs = require("./head.js");
var _headJsDefault = parcelHelpers.interopDefault(_headJs);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _inRangeJs = require("./inRange.js");
var _inRangeJsDefault = parcelHelpers.interopDefault(_inRangeJs);
var _includesJs = require("./includes.js");
var _includesJsDefault = parcelHelpers.interopDefault(_includesJs);
var _indexOfJs = require("./indexOf.js");
var _indexOfJsDefault = parcelHelpers.interopDefault(_indexOfJs);
var _initialJs = require("./initial.js");
var _initialJsDefault = parcelHelpers.interopDefault(_initialJs);
var _intersectionJs = require("./intersection.js");
var _intersectionJsDefault = parcelHelpers.interopDefault(_intersectionJs);
var _intersectionByJs = require("./intersectionBy.js");
var _intersectionByJsDefault = parcelHelpers.interopDefault(_intersectionByJs);
var _intersectionWithJs = require("./intersectionWith.js");
var _intersectionWithJsDefault = parcelHelpers.interopDefault(_intersectionWithJs);
var _invertJs = require("./invert.js");
var _invertJsDefault = parcelHelpers.interopDefault(_invertJs);
var _invertByJs = require("./invertBy.js");
var _invertByJsDefault = parcelHelpers.interopDefault(_invertByJs);
var _invokeJs = require("./invoke.js");
var _invokeJsDefault = parcelHelpers.interopDefault(_invokeJs);
var _invokeMapJs = require("./invokeMap.js");
var _invokeMapJsDefault = parcelHelpers.interopDefault(_invokeMapJs);
var _isArgumentsJs = require("./isArguments.js");
var _isArgumentsJsDefault = parcelHelpers.interopDefault(_isArgumentsJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isArrayBufferJs = require("./isArrayBuffer.js");
var _isArrayBufferJsDefault = parcelHelpers.interopDefault(_isArrayBufferJs);
var _isArrayLikeJs = require("./isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _isArrayLikeObjectJs = require("./isArrayLikeObject.js");
var _isArrayLikeObjectJsDefault = parcelHelpers.interopDefault(_isArrayLikeObjectJs);
var _isBooleanJs = require("./isBoolean.js");
var _isBooleanJsDefault = parcelHelpers.interopDefault(_isBooleanJs);
var _isBufferJs = require("./isBuffer.js");
var _isBufferJsDefault = parcelHelpers.interopDefault(_isBufferJs);
var _isDateJs = require("./isDate.js");
var _isDateJsDefault = parcelHelpers.interopDefault(_isDateJs);
var _isElementJs = require("./isElement.js");
var _isElementJsDefault = parcelHelpers.interopDefault(_isElementJs);
var _isEmptyJs = require("./isEmpty.js");
var _isEmptyJsDefault = parcelHelpers.interopDefault(_isEmptyJs);
var _isEqualJs = require("./isEqual.js");
var _isEqualJsDefault = parcelHelpers.interopDefault(_isEqualJs);
var _isEqualWithJs = require("./isEqualWith.js");
var _isEqualWithJsDefault = parcelHelpers.interopDefault(_isEqualWithJs);
var _isErrorJs = require("./isError.js");
var _isErrorJsDefault = parcelHelpers.interopDefault(_isErrorJs);
var _isFiniteJs = require("./isFinite.js");
var _isFiniteJsDefault = parcelHelpers.interopDefault(_isFiniteJs);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _isIntegerJs = require("./isInteger.js");
var _isIntegerJsDefault = parcelHelpers.interopDefault(_isIntegerJs);
var _isLengthJs = require("./isLength.js");
var _isLengthJsDefault = parcelHelpers.interopDefault(_isLengthJs);
var _isMapJs = require("./isMap.js");
var _isMapJsDefault = parcelHelpers.interopDefault(_isMapJs);
var _isMatchJs = require("./isMatch.js");
var _isMatchJsDefault = parcelHelpers.interopDefault(_isMatchJs);
var _isMatchWithJs = require("./isMatchWith.js");
var _isMatchWithJsDefault = parcelHelpers.interopDefault(_isMatchWithJs);
var _isNaNJs = require("./isNaN.js");
var _isNaNJsDefault = parcelHelpers.interopDefault(_isNaNJs);
var _isNativeJs = require("./isNative.js");
var _isNativeJsDefault = parcelHelpers.interopDefault(_isNativeJs);
var _isNilJs = require("./isNil.js");
var _isNilJsDefault = parcelHelpers.interopDefault(_isNilJs);
var _isNullJs = require("./isNull.js");
var _isNullJsDefault = parcelHelpers.interopDefault(_isNullJs);
var _isNumberJs = require("./isNumber.js");
var _isNumberJsDefault = parcelHelpers.interopDefault(_isNumberJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _isObjectLikeJs = require("./isObjectLike.js");
var _isObjectLikeJsDefault = parcelHelpers.interopDefault(_isObjectLikeJs);
var _isPlainObjectJs = require("./isPlainObject.js");
var _isPlainObjectJsDefault = parcelHelpers.interopDefault(_isPlainObjectJs);
var _isRegExpJs = require("./isRegExp.js");
var _isRegExpJsDefault = parcelHelpers.interopDefault(_isRegExpJs);
var _isSafeIntegerJs = require("./isSafeInteger.js");
var _isSafeIntegerJsDefault = parcelHelpers.interopDefault(_isSafeIntegerJs);
var _isSetJs = require("./isSet.js");
var _isSetJsDefault = parcelHelpers.interopDefault(_isSetJs);
var _isStringJs = require("./isString.js");
var _isStringJsDefault = parcelHelpers.interopDefault(_isStringJs);
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
var _isTypedArrayJs = require("./isTypedArray.js");
var _isTypedArrayJsDefault = parcelHelpers.interopDefault(_isTypedArrayJs);
var _isUndefinedJs = require("./isUndefined.js");
var _isUndefinedJsDefault = parcelHelpers.interopDefault(_isUndefinedJs);
var _isWeakMapJs = require("./isWeakMap.js");
var _isWeakMapJsDefault = parcelHelpers.interopDefault(_isWeakMapJs);
var _isWeakSetJs = require("./isWeakSet.js");
var _isWeakSetJsDefault = parcelHelpers.interopDefault(_isWeakSetJs);
var _iterateeJs = require("./iteratee.js");
var _iterateeJsDefault = parcelHelpers.interopDefault(_iterateeJs);
var _joinJs = require("./join.js");
var _joinJsDefault = parcelHelpers.interopDefault(_joinJs);
var _kebabCaseJs = require("./kebabCase.js");
var _kebabCaseJsDefault = parcelHelpers.interopDefault(_kebabCaseJs);
var _keyByJs = require("./keyBy.js");
var _keyByJsDefault = parcelHelpers.interopDefault(_keyByJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
var _keysInJs = require("./keysIn.js");
var _keysInJsDefault = parcelHelpers.interopDefault(_keysInJs);
var _lastJs = require("./last.js");
var _lastJsDefault = parcelHelpers.interopDefault(_lastJs);
var _lastIndexOfJs = require("./lastIndexOf.js");
var _lastIndexOfJsDefault = parcelHelpers.interopDefault(_lastIndexOfJs);
var _wrapperLodashJs = require("./wrapperLodash.js");
var _wrapperLodashJsDefault = parcelHelpers.interopDefault(_wrapperLodashJs);
var _lowerCaseJs = require("./lowerCase.js");
var _lowerCaseJsDefault = parcelHelpers.interopDefault(_lowerCaseJs);
var _lowerFirstJs = require("./lowerFirst.js");
var _lowerFirstJsDefault = parcelHelpers.interopDefault(_lowerFirstJs);
var _ltJs = require("./lt.js");
var _ltJsDefault = parcelHelpers.interopDefault(_ltJs);
var _lteJs = require("./lte.js");
var _lteJsDefault = parcelHelpers.interopDefault(_lteJs);
var _mapJs = require("./map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _mapKeysJs = require("./mapKeys.js");
var _mapKeysJsDefault = parcelHelpers.interopDefault(_mapKeysJs);
var _mapValuesJs = require("./mapValues.js");
var _mapValuesJsDefault = parcelHelpers.interopDefault(_mapValuesJs);
var _matchesJs = require("./matches.js");
var _matchesJsDefault = parcelHelpers.interopDefault(_matchesJs);
var _matchesPropertyJs = require("./matchesProperty.js");
var _matchesPropertyJsDefault = parcelHelpers.interopDefault(_matchesPropertyJs);
var _maxJs = require("./max.js");
var _maxJsDefault = parcelHelpers.interopDefault(_maxJs);
var _maxByJs = require("./maxBy.js");
var _maxByJsDefault = parcelHelpers.interopDefault(_maxByJs);
var _meanJs = require("./mean.js");
var _meanJsDefault = parcelHelpers.interopDefault(_meanJs);
var _meanByJs = require("./meanBy.js");
var _meanByJsDefault = parcelHelpers.interopDefault(_meanByJs);
var _memoizeJs = require("./memoize.js");
var _memoizeJsDefault = parcelHelpers.interopDefault(_memoizeJs);
var _mergeJs = require("./merge.js");
var _mergeJsDefault = parcelHelpers.interopDefault(_mergeJs);
var _mergeWithJs = require("./mergeWith.js");
var _mergeWithJsDefault = parcelHelpers.interopDefault(_mergeWithJs);
var _methodJs = require("./method.js");
var _methodJsDefault = parcelHelpers.interopDefault(_methodJs);
var _methodOfJs = require("./methodOf.js");
var _methodOfJsDefault = parcelHelpers.interopDefault(_methodOfJs);
var _minJs = require("./min.js");
var _minJsDefault = parcelHelpers.interopDefault(_minJs);
var _minByJs = require("./minBy.js");
var _minByJsDefault = parcelHelpers.interopDefault(_minByJs);
var _mixinJs = require("./mixin.js");
var _mixinJsDefault = parcelHelpers.interopDefault(_mixinJs);
var _multiplyJs = require("./multiply.js");
var _multiplyJsDefault = parcelHelpers.interopDefault(_multiplyJs);
var _negateJs = require("./negate.js");
var _negateJsDefault = parcelHelpers.interopDefault(_negateJs);
var _nextJs = require("./next.js");
var _nextJsDefault = parcelHelpers.interopDefault(_nextJs);
var _noopJs = require("./noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var _nowJs = require("./now.js");
var _nowJsDefault = parcelHelpers.interopDefault(_nowJs);
var _nthJs = require("./nth.js");
var _nthJsDefault = parcelHelpers.interopDefault(_nthJs);
var _nthArgJs = require("./nthArg.js");
var _nthArgJsDefault = parcelHelpers.interopDefault(_nthArgJs);
var _omitJs = require("./omit.js");
var _omitJsDefault = parcelHelpers.interopDefault(_omitJs);
var _omitByJs = require("./omitBy.js");
var _omitByJsDefault = parcelHelpers.interopDefault(_omitByJs);
var _onceJs = require("./once.js");
var _onceJsDefault = parcelHelpers.interopDefault(_onceJs);
var _orderByJs = require("./orderBy.js");
var _orderByJsDefault = parcelHelpers.interopDefault(_orderByJs);
var _overJs = require("./over.js");
var _overJsDefault = parcelHelpers.interopDefault(_overJs);
var _overArgsJs = require("./overArgs.js");
var _overArgsJsDefault = parcelHelpers.interopDefault(_overArgsJs);
var _overEveryJs = require("./overEvery.js");
var _overEveryJsDefault = parcelHelpers.interopDefault(_overEveryJs);
var _overSomeJs = require("./overSome.js");
var _overSomeJsDefault = parcelHelpers.interopDefault(_overSomeJs);
var _padJs = require("./pad.js");
var _padJsDefault = parcelHelpers.interopDefault(_padJs);
var _padEndJs = require("./padEnd.js");
var _padEndJsDefault = parcelHelpers.interopDefault(_padEndJs);
var _padStartJs = require("./padStart.js");
var _padStartJsDefault = parcelHelpers.interopDefault(_padStartJs);
var _parseIntJs = require("./parseInt.js");
var _parseIntJsDefault = parcelHelpers.interopDefault(_parseIntJs);
var _partialJs = require("./partial.js");
var _partialJsDefault = parcelHelpers.interopDefault(_partialJs);
var _partialRightJs = require("./partialRight.js");
var _partialRightJsDefault = parcelHelpers.interopDefault(_partialRightJs);
var _partitionJs = require("./partition.js");
var _partitionJsDefault = parcelHelpers.interopDefault(_partitionJs);
var _pickJs = require("./pick.js");
var _pickJsDefault = parcelHelpers.interopDefault(_pickJs);
var _pickByJs = require("./pickBy.js");
var _pickByJsDefault = parcelHelpers.interopDefault(_pickByJs);
var _plantJs = require("./plant.js");
var _plantJsDefault = parcelHelpers.interopDefault(_plantJs);
var _propertyJs = require("./property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _propertyOfJs = require("./propertyOf.js");
var _propertyOfJsDefault = parcelHelpers.interopDefault(_propertyOfJs);
var _pullJs = require("./pull.js");
var _pullJsDefault = parcelHelpers.interopDefault(_pullJs);
var _pullAllJs = require("./pullAll.js");
var _pullAllJsDefault = parcelHelpers.interopDefault(_pullAllJs);
var _pullAllByJs = require("./pullAllBy.js");
var _pullAllByJsDefault = parcelHelpers.interopDefault(_pullAllByJs);
var _pullAllWithJs = require("./pullAllWith.js");
var _pullAllWithJsDefault = parcelHelpers.interopDefault(_pullAllWithJs);
var _pullAtJs = require("./pullAt.js");
var _pullAtJsDefault = parcelHelpers.interopDefault(_pullAtJs);
var _randomJs = require("./random.js");
var _randomJsDefault = parcelHelpers.interopDefault(_randomJs);
var _rangeJs = require("./range.js");
var _rangeJsDefault = parcelHelpers.interopDefault(_rangeJs);
var _rangeRightJs = require("./rangeRight.js");
var _rangeRightJsDefault = parcelHelpers.interopDefault(_rangeRightJs);
var _reargJs = require("./rearg.js");
var _reargJsDefault = parcelHelpers.interopDefault(_reargJs);
var _reduceJs = require("./reduce.js");
var _reduceJsDefault = parcelHelpers.interopDefault(_reduceJs);
var _reduceRightJs = require("./reduceRight.js");
var _reduceRightJsDefault = parcelHelpers.interopDefault(_reduceRightJs);
var _rejectJs = require("./reject.js");
var _rejectJsDefault = parcelHelpers.interopDefault(_rejectJs);
var _removeJs = require("./remove.js");
var _removeJsDefault = parcelHelpers.interopDefault(_removeJs);
var _repeatJs = require("./repeat.js");
var _repeatJsDefault = parcelHelpers.interopDefault(_repeatJs);
var _replaceJs = require("./replace.js");
var _replaceJsDefault = parcelHelpers.interopDefault(_replaceJs);
var _restJs = require("./rest.js");
var _restJsDefault = parcelHelpers.interopDefault(_restJs);
var _resultJs = require("./result.js");
var _resultJsDefault = parcelHelpers.interopDefault(_resultJs);
var _reverseJs = require("./reverse.js");
var _reverseJsDefault = parcelHelpers.interopDefault(_reverseJs);
var _roundJs = require("./round.js");
var _roundJsDefault = parcelHelpers.interopDefault(_roundJs);
var _sampleJs = require("./sample.js");
var _sampleJsDefault = parcelHelpers.interopDefault(_sampleJs);
var _sampleSizeJs = require("./sampleSize.js");
var _sampleSizeJsDefault = parcelHelpers.interopDefault(_sampleSizeJs);
var _setJs = require("./set.js");
var _setJsDefault = parcelHelpers.interopDefault(_setJs);
var _setWithJs = require("./setWith.js");
var _setWithJsDefault = parcelHelpers.interopDefault(_setWithJs);
var _shuffleJs = require("./shuffle.js");
var _shuffleJsDefault = parcelHelpers.interopDefault(_shuffleJs);
var _sizeJs = require("./size.js");
var _sizeJsDefault = parcelHelpers.interopDefault(_sizeJs);
var _sliceJs = require("./slice.js");
var _sliceJsDefault = parcelHelpers.interopDefault(_sliceJs);
var _snakeCaseJs = require("./snakeCase.js");
var _snakeCaseJsDefault = parcelHelpers.interopDefault(_snakeCaseJs);
var _someJs = require("./some.js");
var _someJsDefault = parcelHelpers.interopDefault(_someJs);
var _sortByJs = require("./sortBy.js");
var _sortByJsDefault = parcelHelpers.interopDefault(_sortByJs);
var _sortedIndexJs = require("./sortedIndex.js");
var _sortedIndexJsDefault = parcelHelpers.interopDefault(_sortedIndexJs);
var _sortedIndexByJs = require("./sortedIndexBy.js");
var _sortedIndexByJsDefault = parcelHelpers.interopDefault(_sortedIndexByJs);
var _sortedIndexOfJs = require("./sortedIndexOf.js");
var _sortedIndexOfJsDefault = parcelHelpers.interopDefault(_sortedIndexOfJs);
var _sortedLastIndexJs = require("./sortedLastIndex.js");
var _sortedLastIndexJsDefault = parcelHelpers.interopDefault(_sortedLastIndexJs);
var _sortedLastIndexByJs = require("./sortedLastIndexBy.js");
var _sortedLastIndexByJsDefault = parcelHelpers.interopDefault(_sortedLastIndexByJs);
var _sortedLastIndexOfJs = require("./sortedLastIndexOf.js");
var _sortedLastIndexOfJsDefault = parcelHelpers.interopDefault(_sortedLastIndexOfJs);
var _sortedUniqJs = require("./sortedUniq.js");
var _sortedUniqJsDefault = parcelHelpers.interopDefault(_sortedUniqJs);
var _sortedUniqByJs = require("./sortedUniqBy.js");
var _sortedUniqByJsDefault = parcelHelpers.interopDefault(_sortedUniqByJs);
var _splitJs = require("./split.js");
var _splitJsDefault = parcelHelpers.interopDefault(_splitJs);
var _spreadJs = require("./spread.js");
var _spreadJsDefault = parcelHelpers.interopDefault(_spreadJs);
var _startCaseJs = require("./startCase.js");
var _startCaseJsDefault = parcelHelpers.interopDefault(_startCaseJs);
var _startsWithJs = require("./startsWith.js");
var _startsWithJsDefault = parcelHelpers.interopDefault(_startsWithJs);
var _stubArrayJs = require("./stubArray.js");
var _stubArrayJsDefault = parcelHelpers.interopDefault(_stubArrayJs);
var _stubFalseJs = require("./stubFalse.js");
var _stubFalseJsDefault = parcelHelpers.interopDefault(_stubFalseJs);
var _stubObjectJs = require("./stubObject.js");
var _stubObjectJsDefault = parcelHelpers.interopDefault(_stubObjectJs);
var _stubStringJs = require("./stubString.js");
var _stubStringJsDefault = parcelHelpers.interopDefault(_stubStringJs);
var _stubTrueJs = require("./stubTrue.js");
var _stubTrueJsDefault = parcelHelpers.interopDefault(_stubTrueJs);
var _subtractJs = require("./subtract.js");
var _subtractJsDefault = parcelHelpers.interopDefault(_subtractJs);
var _sumJs = require("./sum.js");
var _sumJsDefault = parcelHelpers.interopDefault(_sumJs);
var _sumByJs = require("./sumBy.js");
var _sumByJsDefault = parcelHelpers.interopDefault(_sumByJs);
var _tailJs = require("./tail.js");
var _tailJsDefault = parcelHelpers.interopDefault(_tailJs);
var _takeJs = require("./take.js");
var _takeJsDefault = parcelHelpers.interopDefault(_takeJs);
var _takeRightJs = require("./takeRight.js");
var _takeRightJsDefault = parcelHelpers.interopDefault(_takeRightJs);
var _takeRightWhileJs = require("./takeRightWhile.js");
var _takeRightWhileJsDefault = parcelHelpers.interopDefault(_takeRightWhileJs);
var _takeWhileJs = require("./takeWhile.js");
var _takeWhileJsDefault = parcelHelpers.interopDefault(_takeWhileJs);
var _tapJs = require("./tap.js");
var _tapJsDefault = parcelHelpers.interopDefault(_tapJs);
var _templateJs = require("./template.js");
var _templateJsDefault = parcelHelpers.interopDefault(_templateJs);
var _templateSettingsJs = require("./templateSettings.js");
var _templateSettingsJsDefault = parcelHelpers.interopDefault(_templateSettingsJs);
var _throttleJs = require("./throttle.js");
var _throttleJsDefault = parcelHelpers.interopDefault(_throttleJs);
var _thruJs = require("./thru.js");
var _thruJsDefault = parcelHelpers.interopDefault(_thruJs);
var _timesJs = require("./times.js");
var _timesJsDefault = parcelHelpers.interopDefault(_timesJs);
var _toArrayJs = require("./toArray.js");
var _toArrayJsDefault = parcelHelpers.interopDefault(_toArrayJs);
var _toFiniteJs = require("./toFinite.js");
var _toFiniteJsDefault = parcelHelpers.interopDefault(_toFiniteJs);
var _toIntegerJs = require("./toInteger.js");
var _toIntegerJsDefault = parcelHelpers.interopDefault(_toIntegerJs);
var _toIteratorJs = require("./toIterator.js");
var _toIteratorJsDefault = parcelHelpers.interopDefault(_toIteratorJs);
var _toJSONJs = require("./toJSON.js");
var _toJSONJsDefault = parcelHelpers.interopDefault(_toJSONJs);
var _toLengthJs = require("./toLength.js");
var _toLengthJsDefault = parcelHelpers.interopDefault(_toLengthJs);
var _toLowerJs = require("./toLower.js");
var _toLowerJsDefault = parcelHelpers.interopDefault(_toLowerJs);
var _toNumberJs = require("./toNumber.js");
var _toNumberJsDefault = parcelHelpers.interopDefault(_toNumberJs);
var _toPairsJs = require("./toPairs.js");
var _toPairsJsDefault = parcelHelpers.interopDefault(_toPairsJs);
var _toPairsInJs = require("./toPairsIn.js");
var _toPairsInJsDefault = parcelHelpers.interopDefault(_toPairsInJs);
var _toPathJs = require("./toPath.js");
var _toPathJsDefault = parcelHelpers.interopDefault(_toPathJs);
var _toPlainObjectJs = require("./toPlainObject.js");
var _toPlainObjectJsDefault = parcelHelpers.interopDefault(_toPlainObjectJs);
var _toSafeIntegerJs = require("./toSafeInteger.js");
var _toSafeIntegerJsDefault = parcelHelpers.interopDefault(_toSafeIntegerJs);
var _toStringJs = require("./toString.js");
var _toStringJsDefault = parcelHelpers.interopDefault(_toStringJs);
var _toUpperJs = require("./toUpper.js");
var _toUpperJsDefault = parcelHelpers.interopDefault(_toUpperJs);
var _transformJs = require("./transform.js");
var _transformJsDefault = parcelHelpers.interopDefault(_transformJs);
var _trimJs = require("./trim.js");
var _trimJsDefault = parcelHelpers.interopDefault(_trimJs);
var _trimEndJs = require("./trimEnd.js");
var _trimEndJsDefault = parcelHelpers.interopDefault(_trimEndJs);
var _trimStartJs = require("./trimStart.js");
var _trimStartJsDefault = parcelHelpers.interopDefault(_trimStartJs);
var _truncateJs = require("./truncate.js");
var _truncateJsDefault = parcelHelpers.interopDefault(_truncateJs);
var _unaryJs = require("./unary.js");
var _unaryJsDefault = parcelHelpers.interopDefault(_unaryJs);
var _unescapeJs = require("./unescape.js");
var _unescapeJsDefault = parcelHelpers.interopDefault(_unescapeJs);
var _unionJs = require("./union.js");
var _unionJsDefault = parcelHelpers.interopDefault(_unionJs);
var _unionByJs = require("./unionBy.js");
var _unionByJsDefault = parcelHelpers.interopDefault(_unionByJs);
var _unionWithJs = require("./unionWith.js");
var _unionWithJsDefault = parcelHelpers.interopDefault(_unionWithJs);
var _uniqJs = require("./uniq.js");
var _uniqJsDefault = parcelHelpers.interopDefault(_uniqJs);
var _uniqByJs = require("./uniqBy.js");
var _uniqByJsDefault = parcelHelpers.interopDefault(_uniqByJs);
var _uniqWithJs = require("./uniqWith.js");
var _uniqWithJsDefault = parcelHelpers.interopDefault(_uniqWithJs);
var _uniqueIdJs = require("./uniqueId.js");
var _uniqueIdJsDefault = parcelHelpers.interopDefault(_uniqueIdJs);
var _unsetJs = require("./unset.js");
var _unsetJsDefault = parcelHelpers.interopDefault(_unsetJs);
var _unzipJs = require("./unzip.js");
var _unzipJsDefault = parcelHelpers.interopDefault(_unzipJs);
var _unzipWithJs = require("./unzipWith.js");
var _unzipWithJsDefault = parcelHelpers.interopDefault(_unzipWithJs);
var _updateJs = require("./update.js");
var _updateJsDefault = parcelHelpers.interopDefault(_updateJs);
var _updateWithJs = require("./updateWith.js");
var _updateWithJsDefault = parcelHelpers.interopDefault(_updateWithJs);
var _upperCaseJs = require("./upperCase.js");
var _upperCaseJsDefault = parcelHelpers.interopDefault(_upperCaseJs);
var _upperFirstJs = require("./upperFirst.js");
var _upperFirstJsDefault = parcelHelpers.interopDefault(_upperFirstJs);
var _valueJs = require("./value.js");
var _valueJsDefault = parcelHelpers.interopDefault(_valueJs);
var _valueOfJs = require("./valueOf.js");
var _valueOfJsDefault = parcelHelpers.interopDefault(_valueOfJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _valuesInJs = require("./valuesIn.js");
var _valuesInJsDefault = parcelHelpers.interopDefault(_valuesInJs);
var _withoutJs = require("./without.js");
var _withoutJsDefault = parcelHelpers.interopDefault(_withoutJs);
var _wordsJs = require("./words.js");
var _wordsJsDefault = parcelHelpers.interopDefault(_wordsJs);
var _wrapJs = require("./wrap.js");
var _wrapJsDefault = parcelHelpers.interopDefault(_wrapJs);
var _wrapperAtJs = require("./wrapperAt.js");
var _wrapperAtJsDefault = parcelHelpers.interopDefault(_wrapperAtJs);
var _wrapperChainJs = require("./wrapperChain.js");
var _wrapperChainJsDefault = parcelHelpers.interopDefault(_wrapperChainJs);
var _wrapperReverseJs = require("./wrapperReverse.js");
var _wrapperReverseJsDefault = parcelHelpers.interopDefault(_wrapperReverseJs);
var _wrapperValueJs = require("./wrapperValue.js");
var _wrapperValueJsDefault = parcelHelpers.interopDefault(_wrapperValueJs);
var _xorJs = require("./xor.js");
var _xorJsDefault = parcelHelpers.interopDefault(_xorJs);
var _xorByJs = require("./xorBy.js");
var _xorByJsDefault = parcelHelpers.interopDefault(_xorByJs);
var _xorWithJs = require("./xorWith.js");
var _xorWithJsDefault = parcelHelpers.interopDefault(_xorWithJs);
var _zipJs = require("./zip.js");
var _zipJsDefault = parcelHelpers.interopDefault(_zipJs);
var _zipObjectJs = require("./zipObject.js");
var _zipObjectJsDefault = parcelHelpers.interopDefault(_zipObjectJs);
var _zipObjectDeepJs = require("./zipObjectDeep.js");
var _zipObjectDeepJsDefault = parcelHelpers.interopDefault(_zipObjectDeepJs);
var _zipWithJs = require("./zipWith.js");
var _zipWithJsDefault = parcelHelpers.interopDefault(_zipWithJs);
var _lodashDefaultJs = require("./lodash.default.js");
var _lodashDefaultJsDefault = parcelHelpers.interopDefault(_lodashDefaultJs);

},{"./add.js":false,"./after.js":false,"./ary.js":false,"./assign.js":false,"./assignIn.js":false,"./assignInWith.js":false,"./assignWith.js":false,"./at.js":false,"./attempt.js":false,"./before.js":false,"./bind.js":false,"./bindAll.js":false,"./bindKey.js":false,"./camelCase.js":false,"./capitalize.js":false,"./castArray.js":false,"./ceil.js":false,"./chain.js":false,"./chunk.js":"fPV8N","./clamp.js":false,"./clone.js":false,"./cloneDeep.js":false,"./cloneDeepWith.js":false,"./cloneWith.js":false,"./commit.js":false,"./compact.js":false,"./concat.js":false,"./cond.js":false,"./conforms.js":false,"./conformsTo.js":false,"./constant.js":"a5s7V","./countBy.js":false,"./create.js":false,"./curry.js":false,"./curryRight.js":false,"./debounce.js":false,"./deburr.js":false,"./defaultTo.js":false,"./defaults.js":false,"./defaultsDeep.js":false,"./defer.js":false,"./delay.js":false,"./difference.js":false,"./differenceBy.js":false,"./differenceWith.js":false,"./divide.js":false,"./drop.js":false,"./dropRight.js":false,"./dropRightWhile.js":false,"./dropWhile.js":false,"./each.js":false,"./eachRight.js":false,"./endsWith.js":false,"./entries.js":false,"./entriesIn.js":false,"./eq.js":"7el3s","./escape.js":false,"./escapeRegExp.js":false,"./every.js":false,"./extend.js":false,"./extendWith.js":false,"./fill.js":false,"./filter.js":false,"./find.js":false,"./findIndex.js":false,"./findKey.js":false,"./findLast.js":false,"./findLastIndex.js":false,"./findLastKey.js":false,"./first.js":false,"./flatMap.js":false,"./flatMapDeep.js":false,"./flatMapDepth.js":false,"./flatten.js":"7cRZC","./flattenDeep.js":false,"./flattenDepth.js":false,"./flip.js":false,"./floor.js":false,"./flow.js":"leTwE","./flowRight.js":false,"./forEach.js":false,"./forEachRight.js":false,"./forIn.js":false,"./forInRight.js":false,"./forOwn.js":false,"./forOwnRight.js":false,"./fromPairs.js":"2o9tn","./functions.js":false,"./functionsIn.js":false,"./get.js":"9ZP5X","./groupBy.js":false,"./gt.js":false,"./gte.js":false,"./has.js":false,"./hasIn.js":"jfq4F","./head.js":false,"./identity.js":"1Y0KA","./inRange.js":false,"./includes.js":false,"./indexOf.js":false,"./initial.js":false,"./intersection.js":false,"./intersectionBy.js":false,"./intersectionWith.js":false,"./invert.js":false,"./invertBy.js":false,"./invoke.js":false,"./invokeMap.js":false,"./isArguments.js":"9k91Y","./isArray.js":"ETPQ1","./isArrayBuffer.js":false,"./isArrayLike.js":"8SdiO","./isArrayLikeObject.js":"gArhC","./isBoolean.js":false,"./isBuffer.js":"llpEE","./isDate.js":false,"./isElement.js":false,"./isEmpty.js":false,"./isEqual.js":"eNhTn","./isEqualWith.js":false,"./isError.js":false,"./isFinite.js":false,"./isFunction.js":"e5kis","./isInteger.js":false,"./isLength.js":"bItM0","./isMap.js":false,"./isMatch.js":false,"./isMatchWith.js":false,"./isNaN.js":false,"./isNative.js":false,"./isNil.js":false,"./isNull.js":false,"./isNumber.js":false,"./isObject.js":"dHhyW","./isObjectLike.js":"iad76","./isPlainObject.js":false,"./isRegExp.js":false,"./isSafeInteger.js":false,"./isSet.js":false,"./isString.js":false,"./isSymbol.js":"gCyRJ","./isTypedArray.js":"2LIMs","./isUndefined.js":false,"./isWeakMap.js":false,"./isWeakSet.js":false,"./iteratee.js":false,"./join.js":false,"./kebabCase.js":false,"./keyBy.js":false,"./keys.js":"lbEZV","./keysIn.js":false,"./last.js":false,"./lastIndexOf.js":false,"./wrapperLodash.js":"2iNJx","./lowerCase.js":false,"./lowerFirst.js":false,"./lt.js":false,"./lte.js":false,"./map.js":false,"./mapKeys.js":false,"./mapValues.js":false,"./matches.js":false,"./matchesProperty.js":false,"./max.js":false,"./maxBy.js":false,"./mean.js":false,"./meanBy.js":false,"./memoize.js":"5zdei","./merge.js":false,"./mergeWith.js":false,"./method.js":false,"./methodOf.js":false,"./min.js":false,"./minBy.js":false,"./mixin.js":false,"./multiply.js":false,"./negate.js":false,"./next.js":false,"./noop.js":"9q6VJ","./now.js":false,"./nth.js":false,"./nthArg.js":false,"./omit.js":false,"./omitBy.js":false,"./once.js":false,"./orderBy.js":false,"./over.js":false,"./overArgs.js":false,"./overEvery.js":false,"./overSome.js":false,"./pad.js":false,"./padEnd.js":false,"./padStart.js":false,"./parseInt.js":false,"./partial.js":false,"./partialRight.js":false,"./partition.js":false,"./pick.js":false,"./pickBy.js":false,"./plant.js":false,"./property.js":"kwvYw","./propertyOf.js":false,"./pull.js":false,"./pullAll.js":false,"./pullAllBy.js":false,"./pullAllWith.js":false,"./pullAt.js":false,"./random.js":false,"./range.js":"2xup9","./rangeRight.js":false,"./rearg.js":false,"./reduce.js":false,"./reduceRight.js":false,"./reject.js":false,"./remove.js":false,"./repeat.js":false,"./replace.js":false,"./rest.js":false,"./result.js":false,"./reverse.js":false,"./round.js":false,"./sample.js":"b6mtE","./sampleSize.js":false,"./set.js":false,"./setWith.js":false,"./shuffle.js":false,"./size.js":false,"./slice.js":false,"./snakeCase.js":false,"./some.js":false,"./sortBy.js":"42BZ9","./sortedIndex.js":false,"./sortedIndexBy.js":false,"./sortedIndexOf.js":false,"./sortedLastIndex.js":false,"./sortedLastIndexBy.js":false,"./sortedLastIndexOf.js":false,"./sortedUniq.js":false,"./sortedUniqBy.js":false,"./split.js":false,"./spread.js":false,"./startCase.js":false,"./startsWith.js":false,"./stubArray.js":"iwLLL","./stubFalse.js":"fF5mf","./stubObject.js":false,"./stubString.js":false,"./stubTrue.js":false,"./subtract.js":false,"./sum.js":"feLWk","./sumBy.js":false,"./tail.js":false,"./take.js":false,"./takeRight.js":false,"./takeRightWhile.js":false,"./takeWhile.js":false,"./tap.js":false,"./template.js":false,"./templateSettings.js":false,"./throttle.js":false,"./thru.js":false,"./times.js":false,"./toArray.js":false,"./toFinite.js":"FJR8i","./toInteger.js":"1tdUD","./toIterator.js":false,"./toJSON.js":false,"./toLength.js":false,"./toLower.js":false,"./toNumber.js":"4CrK2","./toPairs.js":false,"./toPairsIn.js":false,"./toPath.js":false,"./toPlainObject.js":false,"./toSafeInteger.js":false,"./toString.js":"hF0LJ","./toUpper.js":false,"./transform.js":false,"./trim.js":false,"./trimEnd.js":false,"./trimStart.js":false,"./truncate.js":false,"./unary.js":false,"./unescape.js":false,"./union.js":false,"./unionBy.js":false,"./unionWith.js":false,"./uniq.js":"57kq6","./uniqBy.js":"eZnwu","./uniqWith.js":"6UDxA","./uniqueId.js":false,"./unset.js":false,"./unzip.js":"j1DxS","./unzipWith.js":"bc76B","./update.js":false,"./updateWith.js":false,"./upperCase.js":false,"./upperFirst.js":false,"./value.js":false,"./valueOf.js":false,"./values.js":"bjkOg","./valuesIn.js":false,"./without.js":false,"./words.js":false,"./wrap.js":false,"./wrapperAt.js":false,"./wrapperChain.js":false,"./wrapperReverse.js":false,"./wrapperValue.js":false,"./xor.js":false,"./xorBy.js":false,"./xorWith.js":false,"./zip.js":false,"./zipObject.js":false,"./zipObjectDeep.js":false,"./zipWith.js":"1agvX","./lodash.default.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fPV8N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseSliceJs = require("./_baseSlice.js");
var _baseSliceJsDefault = parcelHelpers.interopDefault(_baseSliceJs);
var _isIterateeCallJs = require("./_isIterateeCall.js");
var _isIterateeCallJsDefault = parcelHelpers.interopDefault(_isIterateeCallJs);
var _toIntegerJs = require("./toInteger.js");
var _toIntegerJsDefault = parcelHelpers.interopDefault(_toIntegerJs);
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeCeil = Math.ceil, nativeMax = Math.max;
/**
 * Creates an array of elements split into groups the length of `size`.
 * If `array` can't be split evenly, the final chunk will be the remaining
 * elements.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to process.
 * @param {number} [size=1] The length of each chunk
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the new array of chunks.
 * @example
 *
 * _.chunk(['a', 'b', 'c', 'd'], 2);
 * // => [['a', 'b'], ['c', 'd']]
 *
 * _.chunk(['a', 'b', 'c', 'd'], 3);
 * // => [['a', 'b', 'c'], ['d']]
 */ function chunk(array, size, guard) {
    if (guard ? _isIterateeCallJsDefault.default(array, size, guard) : size === undefined) size = 1;
    else size = nativeMax(_toIntegerJsDefault.default(size), 0);
    var length = array == null ? 0 : array.length;
    if (!length || size < 1) return [];
    var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
    while(index < length)result[resIndex++] = _baseSliceJsDefault.default(array, index, index += size);
    return result;
}
exports.default = chunk;

},{"./_baseSlice.js":"aUyi1","./_isIterateeCall.js":"1jM1r","./toInteger.js":"1tdUD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aUyi1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */ function baseSlice(array, start, end) {
    var index = -1, length = array.length;
    if (start < 0) start = -start > length ? 0 : length + start;
    end = end > length ? length : end;
    if (end < 0) end += length;
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while(++index < length)result[index] = array[index + start];
    return result;
}
exports.default = baseSlice;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"1jM1r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eqJs = require("./eq.js");
var _eqJsDefault = parcelHelpers.interopDefault(_eqJs);
var _isArrayLikeJs = require("./isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _isIndexJs = require("./_isIndex.js");
var _isIndexJsDefault = parcelHelpers.interopDefault(_isIndexJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */ function isIterateeCall(value, index, object) {
    if (!_isObjectJsDefault.default(object)) return false;
    var type = typeof index;
    if (type == 'number' ? _isArrayLikeJsDefault.default(object) && _isIndexJsDefault.default(index, object.length) : type == 'string' && index in object) return _eqJsDefault.default(object[index], value);
    return false;
}
exports.default = isIterateeCall;

},{"./eq.js":"7el3s","./isArrayLike.js":"8SdiO","./_isIndex.js":"5DS1K","./isObject.js":"dHhyW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7el3s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
exports.default = eq;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8SdiO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _isLengthJs = require("./isLength.js");
var _isLengthJsDefault = parcelHelpers.interopDefault(_isLengthJs);
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && _isLengthJsDefault.default(value.length) && !_isFunctionJsDefault.default(value);
}
exports.default = isArrayLike;

},{"./isFunction.js":"e5kis","./isLength.js":"bItM0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e5kis":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseGetTagJs = require("./_baseGetTag.js");
var _baseGetTagJsDefault = parcelHelpers.interopDefault(_baseGetTagJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
/** `Object#toString` result references. */ var asyncTag = '[object AsyncFunction]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    if (!_isObjectJsDefault.default(value)) return false;
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = _baseGetTagJsDefault.default(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
exports.default = isFunction;

},{"./_baseGetTag.js":"gVDfP","./isObject.js":"dHhyW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gVDfP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _symbolJs = require("./_Symbol.js");
var _symbolJsDefault = parcelHelpers.interopDefault(_symbolJs);
var _getRawTagJs = require("./_getRawTag.js");
var _getRawTagJsDefault = parcelHelpers.interopDefault(_getRawTagJs);
var _objectToStringJs = require("./_objectToString.js");
var _objectToStringJsDefault = parcelHelpers.interopDefault(_objectToStringJs);
/** `Object#toString` result references. */ var nullTag = '[object Null]', undefinedTag = '[object Undefined]';
/** Built-in value references. */ var symToStringTag = _symbolJsDefault.default ? _symbolJsDefault.default.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    if (value == null) return value === undefined ? undefinedTag : nullTag;
    return symToStringTag && symToStringTag in Object(value) ? _getRawTagJsDefault.default(value) : _objectToStringJsDefault.default(value);
}
exports.default = baseGetTag;

},{"./_Symbol.js":"jx216","./_getRawTag.js":"ijXom","./_objectToString.js":"fTkTn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jx216":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/** Built-in value references. */ var Symbol = _rootJsDefault.default.Symbol;
exports.default = Symbol;

},{"./_root.js":"8yvCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8yvCA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _freeGlobalJs = require("./_freeGlobal.js");
var _freeGlobalJsDefault = parcelHelpers.interopDefault(_freeGlobalJs);
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = _freeGlobalJsDefault.default || freeSelf || Function('return this')();
exports.default = root;

},{"./_freeGlobal.js":"98hMd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"98hMd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var global = arguments[3];
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
exports.default = freeGlobal;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ijXom":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _symbolJs = require("./_Symbol.js");
var _symbolJsDefault = parcelHelpers.interopDefault(_symbolJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/** Built-in value references. */ var symToStringTag = _symbolJsDefault.default ? _symbolJsDefault.default.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */ function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
        value[symToStringTag] = undefined;
        var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) value[symToStringTag] = tag;
        else delete value[symToStringTag];
    }
    return result;
}
exports.default = getRawTag;

},{"./_Symbol.js":"jx216","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fTkTn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */ function objectToString(value) {
    return nativeObjectToString.call(value);
}
exports.default = objectToString;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dHhyW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
}
exports.default = isObject;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bItM0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
exports.default = isLength;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5DS1K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
exports.default = isIndex;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1tdUD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _toFiniteJs = require("./toFinite.js");
var _toFiniteJsDefault = parcelHelpers.interopDefault(_toFiniteJs);
/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */ function toInteger(value) {
    var result = _toFiniteJsDefault.default(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
}
exports.default = toInteger;

},{"./toFinite.js":"FJR8i","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"FJR8i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _toNumberJs = require("./toNumber.js");
var _toNumberJsDefault = parcelHelpers.interopDefault(_toNumberJs);
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0, MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */ function toFinite(value) {
    if (!value) return value === 0 ? value : 0;
    value = _toNumberJsDefault.default(value);
    if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
}
exports.default = toFinite;

},{"./toNumber.js":"4CrK2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4CrK2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseTrimJs = require("./_baseTrim.js");
var _baseTrimJsDefault = parcelHelpers.interopDefault(_baseTrimJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
/** Used as references for various `Number` constants. */ var NAN = 0 / 0;
/** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */ function toNumber(value) {
    if (typeof value == 'number') return value;
    if (_isSymbolJsDefault.default(value)) return NAN;
    if (_isObjectJsDefault.default(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = _isObjectJsDefault.default(other) ? other + '' : other;
    }
    if (typeof value != 'string') return value === 0 ? value : +value;
    value = _baseTrimJsDefault.default(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
exports.default = toNumber;

},{"./_baseTrim.js":"4X9xl","./isObject.js":"dHhyW","./isSymbol.js":"gCyRJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4X9xl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _trimmedEndIndexJs = require("./_trimmedEndIndex.js");
var _trimmedEndIndexJsDefault = parcelHelpers.interopDefault(_trimmedEndIndexJs);
/** Used to match leading whitespace. */ var reTrimStart = /^\s+/;
/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */ function baseTrim(string) {
    return string ? string.slice(0, _trimmedEndIndexJsDefault.default(string) + 1).replace(reTrimStart, '') : string;
}
exports.default = baseTrim;

},{"./_trimmedEndIndex.js":"lXShQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lXShQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used to match a single whitespace character. */ var reWhitespace = /\s/;
/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */ function trimmedEndIndex(string) {
    var index = string.length;
    while(index-- && reWhitespace.test(string.charAt(index)));
    return index;
}
exports.default = trimmedEndIndex;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gCyRJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseGetTagJs = require("./_baseGetTag.js");
var _baseGetTagJsDefault = parcelHelpers.interopDefault(_baseGetTagJs);
var _isObjectLikeJs = require("./isObjectLike.js");
var _isObjectLikeJsDefault = parcelHelpers.interopDefault(_isObjectLikeJs);
/** `Object#toString` result references. */ var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == 'symbol' || _isObjectLikeJsDefault.default(value) && _baseGetTagJsDefault.default(value) == symbolTag;
}
exports.default = isSymbol;

},{"./_baseGetTag.js":"gVDfP","./isObjectLike.js":"iad76","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iad76":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return value != null && typeof value == 'object';
}
exports.default = isObjectLike;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a5s7V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */ function constant(value) {
    return function() {
        return value;
    };
}
exports.default = constant;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7cRZC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseFlattenJs = require("./_baseFlatten.js");
var _baseFlattenJsDefault = parcelHelpers.interopDefault(_baseFlattenJs);
/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */ function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? _baseFlattenJsDefault.default(array, 1) : [];
}
exports.default = flatten;

},{"./_baseFlatten.js":"92emb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"92emb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayPushJs = require("./_arrayPush.js");
var _arrayPushJsDefault = parcelHelpers.interopDefault(_arrayPushJs);
var _isFlattenableJs = require("./_isFlattenable.js");
var _isFlattenableJsDefault = parcelHelpers.interopDefault(_isFlattenableJs);
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */ function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = _isFlattenableJsDefault.default);
    result || (result = []);
    while(++index < length){
        var value = array[index];
        if (depth > 0 && predicate(value)) {
            if (depth > 1) // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
            else _arrayPushJsDefault.default(result, value);
        } else if (!isStrict) result[result.length] = value;
    }
    return result;
}
exports.default = baseFlatten;

},{"./_arrayPush.js":"4BTrx","./_isFlattenable.js":"69qoZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4BTrx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length)array[offset + index] = values[index];
    return array;
}
exports.default = arrayPush;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"69qoZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _symbolJs = require("./_Symbol.js");
var _symbolJsDefault = parcelHelpers.interopDefault(_symbolJs);
var _isArgumentsJs = require("./isArguments.js");
var _isArgumentsJsDefault = parcelHelpers.interopDefault(_isArgumentsJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
/** Built-in value references. */ var spreadableSymbol = _symbolJsDefault.default ? _symbolJsDefault.default.isConcatSpreadable : undefined;
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */ function isFlattenable(value) {
    return _isArrayJsDefault.default(value) || _isArgumentsJsDefault.default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
exports.default = isFlattenable;

},{"./_Symbol.js":"jx216","./isArguments.js":"9k91Y","./isArray.js":"ETPQ1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9k91Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIsArgumentsJs = require("./_baseIsArguments.js");
var _baseIsArgumentsJsDefault = parcelHelpers.interopDefault(_baseIsArgumentsJs);
var _isObjectLikeJs = require("./isObjectLike.js");
var _isObjectLikeJsDefault = parcelHelpers.interopDefault(_isObjectLikeJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */ var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ var isArguments = _baseIsArgumentsJsDefault.default(function() {
    return arguments;
}()) ? _baseIsArgumentsJsDefault.default : function(value) {
    return _isObjectLikeJsDefault.default(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
exports.default = isArguments;

},{"./_baseIsArguments.js":"bnUuB","./isObjectLike.js":"iad76","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bnUuB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseGetTagJs = require("./_baseGetTag.js");
var _baseGetTagJsDefault = parcelHelpers.interopDefault(_baseGetTagJs);
var _isObjectLikeJs = require("./isObjectLike.js");
var _isObjectLikeJsDefault = parcelHelpers.interopDefault(_isObjectLikeJs);
/** `Object#toString` result references. */ var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */ function baseIsArguments(value) {
    return _isObjectLikeJsDefault.default(value) && _baseGetTagJsDefault.default(value) == argsTag;
}
exports.default = baseIsArguments;

},{"./_baseGetTag.js":"gVDfP","./isObjectLike.js":"iad76","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ETPQ1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
exports.default = isArray;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"leTwE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createFlowJs = require("./_createFlow.js");
var _createFlowJsDefault = parcelHelpers.interopDefault(_createFlowJs);
/**
 * Creates a function that returns the result of invoking the given functions
 * with the `this` binding of the created function, where each successive
 * invocation is supplied the return value of the previous.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {...(Function|Function[])} [funcs] The functions to invoke.
 * @returns {Function} Returns the new composite function.
 * @see _.flowRight
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var addSquare = _.flow([_.add, square]);
 * addSquare(1, 2);
 * // => 9
 */ var flow = _createFlowJsDefault.default();
exports.default = flow;

},{"./_createFlow.js":"l2aJ2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l2aJ2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashWrapperJs = require("./_LodashWrapper.js");
var _lodashWrapperJsDefault = parcelHelpers.interopDefault(_lodashWrapperJs);
var _flatRestJs = require("./_flatRest.js");
var _flatRestJsDefault = parcelHelpers.interopDefault(_flatRestJs);
var _getDataJs = require("./_getData.js");
var _getDataJsDefault = parcelHelpers.interopDefault(_getDataJs);
var _getFuncNameJs = require("./_getFuncName.js");
var _getFuncNameJsDefault = parcelHelpers.interopDefault(_getFuncNameJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isLaziableJs = require("./_isLaziable.js");
var _isLaziableJsDefault = parcelHelpers.interopDefault(_isLaziableJs);
/** Error message constants. */ var FUNC_ERROR_TEXT = 'Expected a function';
/** Used to compose bitmasks for function metadata. */ var WRAP_CURRY_FLAG = 8, WRAP_PARTIAL_FLAG = 32, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256;
/**
 * Creates a `_.flow` or `_.flowRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new flow function.
 */ function createFlow(fromRight) {
    return _flatRestJsDefault.default(function(funcs) {
        var length = funcs.length, index1 = length, prereq = _lodashWrapperJsDefault.default.prototype.thru;
        if (fromRight) funcs.reverse();
        while(index1--){
            var func = funcs[index1];
            if (typeof func != 'function') throw new TypeError(FUNC_ERROR_TEXT);
            if (prereq && !wrapper && _getFuncNameJsDefault.default(func) == 'wrapper') var wrapper = new _lodashWrapperJsDefault.default([], true);
        }
        index1 = wrapper ? index1 : length;
        while(++index1 < length){
            func = funcs[index1];
            var funcName = _getFuncNameJsDefault.default(func), data = funcName == 'wrapper' ? _getDataJsDefault.default(func) : undefined;
            if (data && _isLaziableJsDefault.default(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) wrapper = wrapper[_getFuncNameJsDefault.default(data[0])].apply(wrapper, data[3]);
            else wrapper = func.length == 1 && _isLaziableJsDefault.default(func) ? wrapper[funcName]() : wrapper.thru(func);
        }
        return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && _isArrayJsDefault.default(value)) return wrapper.plant(value).value();
            var index = 0, result = length ? funcs[index].apply(this, args) : value;
            while(++index < length)result = funcs[index].call(this, result);
            return result;
        };
    });
}
exports.default = createFlow;

},{"./_LodashWrapper.js":"iTw7d","./_flatRest.js":"iF6bf","./_getData.js":"7fRqS","./_getFuncName.js":"7lA3N","./isArray.js":"ETPQ1","./_isLaziable.js":"4XpWq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iTw7d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseCreateJs = require("./_baseCreate.js");
var _baseCreateJsDefault = parcelHelpers.interopDefault(_baseCreateJs);
var _baseLodashJs = require("./_baseLodash.js");
var _baseLodashJsDefault = parcelHelpers.interopDefault(_baseLodashJs);
/**
 * The base constructor for creating `lodash` wrapper objects.
 *
 * @private
 * @param {*} value The value to wrap.
 * @param {boolean} [chainAll] Enable explicit method chain sequences.
 */ function LodashWrapper(value, chainAll) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__chain__ = !!chainAll;
    this.__index__ = 0;
    this.__values__ = undefined;
}
LodashWrapper.prototype = _baseCreateJsDefault.default(_baseLodashJsDefault.default.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;
exports.default = LodashWrapper;

},{"./_baseCreate.js":"aq4aU","./_baseLodash.js":"dU7Kx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aq4aU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
/** Built-in value references. */ var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */ var baseCreate = function() {
    function object() {
    }
    return function(proto) {
        if (!_isObjectJsDefault.default(proto)) return {
        };
        if (objectCreate) return objectCreate(proto);
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
    };
}();
exports.default = baseCreate;

},{"./isObject.js":"dHhyW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dU7Kx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The function whose prototype chain sequence wrappers inherit from.
 *
 * @private
 */ function baseLodash() {
// No operation performed.
}
exports.default = baseLodash;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iF6bf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _flattenJs = require("./flatten.js");
var _flattenJsDefault = parcelHelpers.interopDefault(_flattenJs);
var _overRestJs = require("./_overRest.js");
var _overRestJsDefault = parcelHelpers.interopDefault(_overRestJs);
var _setToStringJs = require("./_setToString.js");
var _setToStringJsDefault = parcelHelpers.interopDefault(_setToStringJs);
/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */ function flatRest(func) {
    return _setToStringJsDefault.default(_overRestJsDefault.default(func, undefined, _flattenJsDefault.default), func + '');
}
exports.default = flatRest;

},{"./flatten.js":"7cRZC","./_overRest.js":"d1Uaz","./_setToString.js":"3GXSg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d1Uaz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _applyJs = require("./_apply.js");
var _applyJsDefault = parcelHelpers.interopDefault(_applyJs);
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */ function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while(++index < length)array[index] = args[start + index];
        index = -1;
        var otherArgs = Array(start + 1);
        while(++index < start)otherArgs[index] = args[index];
        otherArgs[start] = transform(array);
        return _applyJsDefault.default(func, this, otherArgs);
    };
}
exports.default = overRest;

},{"./_apply.js":"kqJ3H","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kqJ3H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */ function apply(func, thisArg, args) {
    switch(args.length){
        case 0:
            return func.call(thisArg);
        case 1:
            return func.call(thisArg, args[0]);
        case 2:
            return func.call(thisArg, args[0], args[1]);
        case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
exports.default = apply;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3GXSg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseSetToStringJs = require("./_baseSetToString.js");
var _baseSetToStringJsDefault = parcelHelpers.interopDefault(_baseSetToStringJs);
var _shortOutJs = require("./_shortOut.js");
var _shortOutJsDefault = parcelHelpers.interopDefault(_shortOutJs);
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */ var setToString = _shortOutJsDefault.default(_baseSetToStringJsDefault.default);
exports.default = setToString;

},{"./_baseSetToString.js":"lc4dY","./_shortOut.js":"dmiNi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lc4dY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _constantJs = require("./constant.js");
var _constantJsDefault = parcelHelpers.interopDefault(_constantJs);
var _definePropertyJs = require("./_defineProperty.js");
var _definePropertyJsDefault = parcelHelpers.interopDefault(_definePropertyJs);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */ var baseSetToString = !_definePropertyJsDefault.default ? _identityJsDefault.default : function(func, string) {
    return _definePropertyJsDefault.default(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': _constantJsDefault.default(string),
        'writable': true
    });
};
exports.default = baseSetToString;

},{"./constant.js":"a5s7V","./_defineProperty.js":"8u8dH","./identity.js":"1Y0KA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8u8dH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNativeJs = require("./_getNative.js");
var _getNativeJsDefault = parcelHelpers.interopDefault(_getNativeJs);
var defineProperty = function() {
    try {
        var func = _getNativeJsDefault.default(Object, 'defineProperty');
        func({
        }, '', {
        });
        return func;
    } catch (e) {
    }
}();
exports.default = defineProperty;

},{"./_getNative.js":"bQrQL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bQrQL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIsNativeJs = require("./_baseIsNative.js");
var _baseIsNativeJsDefault = parcelHelpers.interopDefault(_baseIsNativeJs);
var _getValueJs = require("./_getValue.js");
var _getValueJsDefault = parcelHelpers.interopDefault(_getValueJs);
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = _getValueJsDefault.default(object, key);
    return _baseIsNativeJsDefault.default(value) ? value : undefined;
}
exports.default = getNative;

},{"./_baseIsNative.js":"eZuBv","./_getValue.js":"dHb8j","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eZuBv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _isMaskedJs = require("./_isMasked.js");
var _isMaskedJsDefault = parcelHelpers.interopDefault(_isMaskedJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _toSourceJs = require("./_toSource.js");
var _toSourceJsDefault = parcelHelpers.interopDefault(_toSourceJs);
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */ var funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!_isObjectJsDefault.default(value) || _isMaskedJsDefault.default(value)) return false;
    var pattern = _isFunctionJsDefault.default(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSourceJsDefault.default(value));
}
exports.default = baseIsNative;

},{"./isFunction.js":"e5kis","./_isMasked.js":"8rXmg","./isObject.js":"dHhyW","./_toSource.js":"4wd66","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8rXmg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coreJsDataJs = require("./_coreJsData.js");
var _coreJsDataJsDefault = parcelHelpers.interopDefault(_coreJsDataJs);
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(_coreJsDataJsDefault.default && _coreJsDataJsDefault.default.keys && _coreJsDataJsDefault.default.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
exports.default = isMasked;

},{"./_coreJsData.js":"jb15d","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jb15d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/** Used to detect overreaching core-js shims. */ var coreJsData = _rootJsDefault.default['__core-js_shared__'];
exports.default = coreJsData;

},{"./_root.js":"8yvCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4wd66":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used for built-in method references. */ var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {
        }
        try {
            return func + '';
        } catch (e1) {
        }
    }
    return '';
}
exports.default = toSource;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dHb8j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
exports.default = getValue;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Y0KA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */ function identity(value) {
    return value;
}
exports.default = identity;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dmiNi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used to detect hot functions by number of calls within a span of milliseconds. */ var HOT_COUNT = 800, HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */ function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
            if (++count >= HOT_COUNT) return arguments[0];
        } else count = 0;
        return func.apply(undefined, arguments);
    };
}
exports.default = shortOut;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7fRqS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _metaMapJs = require("./_metaMap.js");
var _metaMapJsDefault = parcelHelpers.interopDefault(_metaMapJs);
var _noopJs = require("./noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
/**
 * Gets metadata for `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {*} Returns the metadata for `func`.
 */ var getData = !_metaMapJsDefault.default ? _noopJsDefault.default : function(func) {
    return _metaMapJsDefault.default.get(func);
};
exports.default = getData;

},{"./_metaMap.js":"2XktW","./noop.js":"9q6VJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2XktW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _weakMapJs = require("./_WeakMap.js");
var _weakMapJsDefault = parcelHelpers.interopDefault(_weakMapJs);
/** Used to store function metadata. */ var metaMap = _weakMapJsDefault.default && new _weakMapJsDefault.default;
exports.default = metaMap;

},{"./_WeakMap.js":"52eE0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"52eE0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNativeJs = require("./_getNative.js");
var _getNativeJsDefault = parcelHelpers.interopDefault(_getNativeJs);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/* Built-in method references that are verified to be native. */ var WeakMap = _getNativeJsDefault.default(_rootJsDefault.default, 'WeakMap');
exports.default = WeakMap;

},{"./_getNative.js":"bQrQL","./_root.js":"8yvCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9q6VJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */ function noop() {
// No operation performed.
}
exports.default = noop;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7lA3N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _realNamesJs = require("./_realNames.js");
var _realNamesJsDefault = parcelHelpers.interopDefault(_realNamesJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the name of `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {string} Returns the function name.
 */ function getFuncName(func) {
    var result = func.name + '', array = _realNamesJsDefault.default[result], length = hasOwnProperty.call(_realNamesJsDefault.default, result) ? array.length : 0;
    while(length--){
        var data = array[length], otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) return data.name;
    }
    return result;
}
exports.default = getFuncName;

},{"./_realNames.js":"gQChE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gQChE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used to lookup unminified function names. */ var realNames = {
};
exports.default = realNames;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4XpWq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lazyWrapperJs = require("./_LazyWrapper.js");
var _lazyWrapperJsDefault = parcelHelpers.interopDefault(_lazyWrapperJs);
var _getDataJs = require("./_getData.js");
var _getDataJsDefault = parcelHelpers.interopDefault(_getDataJs);
var _getFuncNameJs = require("./_getFuncName.js");
var _getFuncNameJsDefault = parcelHelpers.interopDefault(_getFuncNameJs);
var _wrapperLodashJs = require("./wrapperLodash.js");
var _wrapperLodashJsDefault = parcelHelpers.interopDefault(_wrapperLodashJs);
/**
 * Checks if `func` has a lazy counterpart.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
 *  else `false`.
 */ function isLaziable(func) {
    var funcName = _getFuncNameJsDefault.default(func), other = _wrapperLodashJsDefault.default[funcName];
    if (typeof other != 'function' || !(funcName in _lazyWrapperJsDefault.default.prototype)) return false;
    if (func === other) return true;
    var data = _getDataJsDefault.default(other);
    return !!data && func === data[0];
}
exports.default = isLaziable;

},{"./_LazyWrapper.js":"k5itv","./_getData.js":"7fRqS","./_getFuncName.js":"7lA3N","./wrapperLodash.js":"2iNJx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k5itv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseCreateJs = require("./_baseCreate.js");
var _baseCreateJsDefault = parcelHelpers.interopDefault(_baseCreateJs);
var _baseLodashJs = require("./_baseLodash.js");
var _baseLodashJsDefault = parcelHelpers.interopDefault(_baseLodashJs);
/** Used as references for the maximum length and index of an array. */ var MAX_ARRAY_LENGTH = 4294967295;
/**
 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
 *
 * @private
 * @constructor
 * @param {*} value The value to wrap.
 */ function LazyWrapper(value) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__dir__ = 1;
    this.__filtered__ = false;
    this.__iteratees__ = [];
    this.__takeCount__ = MAX_ARRAY_LENGTH;
    this.__views__ = [];
}
// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype = _baseCreateJsDefault.default(_baseLodashJsDefault.default.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;
exports.default = LazyWrapper;

},{"./_baseCreate.js":"aq4aU","./_baseLodash.js":"dU7Kx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2iNJx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lazyWrapperJs = require("./_LazyWrapper.js");
var _lazyWrapperJsDefault = parcelHelpers.interopDefault(_lazyWrapperJs);
var _lodashWrapperJs = require("./_LodashWrapper.js");
var _lodashWrapperJsDefault = parcelHelpers.interopDefault(_lodashWrapperJs);
var _baseLodashJs = require("./_baseLodash.js");
var _baseLodashJsDefault = parcelHelpers.interopDefault(_baseLodashJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isObjectLikeJs = require("./isObjectLike.js");
var _isObjectLikeJsDefault = parcelHelpers.interopDefault(_isObjectLikeJs);
var _wrapperCloneJs = require("./_wrapperClone.js");
var _wrapperCloneJsDefault = parcelHelpers.interopDefault(_wrapperCloneJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates a `lodash` object which wraps `value` to enable implicit method
 * chain sequences. Methods that operate on and return arrays, collections,
 * and functions can be chained together. Methods that retrieve a single value
 * or may return a primitive value will automatically end the chain sequence
 * and return the unwrapped value. Otherwise, the value must be unwrapped
 * with `_#value`.
 *
 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
 * enabled using `_.chain`.
 *
 * The execution of chained methods is lazy, that is, it's deferred until
 * `_#value` is implicitly or explicitly called.
 *
 * Lazy evaluation allows several methods to support shortcut fusion.
 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
 * the creation of intermediate arrays and can greatly reduce the number of
 * iteratee executions. Sections of a chain sequence qualify for shortcut
 * fusion if the section is applied to an array and iteratees accept only
 * one argument. The heuristic for whether a section qualifies for shortcut
 * fusion is subject to change.
 *
 * Chaining is supported in custom builds as long as the `_#value` method is
 * directly or indirectly included in the build.
 *
 * In addition to lodash methods, wrappers have `Array` and `String` methods.
 *
 * The wrapper `Array` methods are:
 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
 *
 * The wrapper `String` methods are:
 * `replace` and `split`
 *
 * The wrapper methods that support shortcut fusion are:
 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
 *
 * The chainable wrapper methods are:
 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
 * `zipObject`, `zipObjectDeep`, and `zipWith`
 *
 * The wrapper methods that are **not** chainable by default are:
 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
 * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
 * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
 * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
 * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
 * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
 * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
 * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
 * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
 * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
 * `upperFirst`, `value`, and `words`
 *
 * @name _
 * @constructor
 * @category Seq
 * @param {*} value The value to wrap in a `lodash` instance.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var wrapped = _([1, 2, 3]);
 *
 * // Returns an unwrapped value.
 * wrapped.reduce(_.add);
 * // => 6
 *
 * // Returns a wrapped value.
 * var squares = wrapped.map(square);
 *
 * _.isArray(squares);
 * // => false
 *
 * _.isArray(squares.value());
 * // => true
 */ function lodash(value) {
    if (_isObjectLikeJsDefault.default(value) && !_isArrayJsDefault.default(value) && !(value instanceof _lazyWrapperJsDefault.default)) {
        if (value instanceof _lodashWrapperJsDefault.default) return value;
        if (hasOwnProperty.call(value, '__wrapped__')) return _wrapperCloneJsDefault.default(value);
    }
    return new _lodashWrapperJsDefault.default(value);
}
// Ensure wrappers are instances of `baseLodash`.
lodash.prototype = _baseLodashJsDefault.default.prototype;
lodash.prototype.constructor = lodash;
exports.default = lodash;

},{"./_LazyWrapper.js":"k5itv","./_LodashWrapper.js":"iTw7d","./_baseLodash.js":"dU7Kx","./isArray.js":"ETPQ1","./isObjectLike.js":"iad76","./_wrapperClone.js":"2BZzZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2BZzZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lazyWrapperJs = require("./_LazyWrapper.js");
var _lazyWrapperJsDefault = parcelHelpers.interopDefault(_lazyWrapperJs);
var _lodashWrapperJs = require("./_LodashWrapper.js");
var _lodashWrapperJsDefault = parcelHelpers.interopDefault(_lodashWrapperJs);
var _copyArrayJs = require("./_copyArray.js");
var _copyArrayJsDefault = parcelHelpers.interopDefault(_copyArrayJs);
/**
 * Creates a clone of `wrapper`.
 *
 * @private
 * @param {Object} wrapper The wrapper to clone.
 * @returns {Object} Returns the cloned wrapper.
 */ function wrapperClone(wrapper) {
    if (wrapper instanceof _lazyWrapperJsDefault.default) return wrapper.clone();
    var result = new _lodashWrapperJsDefault.default(wrapper.__wrapped__, wrapper.__chain__);
    result.__actions__ = _copyArrayJsDefault.default(wrapper.__actions__);
    result.__index__ = wrapper.__index__;
    result.__values__ = wrapper.__values__;
    return result;
}
exports.default = wrapperClone;

},{"./_LazyWrapper.js":"k5itv","./_LodashWrapper.js":"iTw7d","./_copyArray.js":"9islt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9islt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */ function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while(++index < length)array[index] = source[index];
    return array;
}
exports.default = copyArray;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2o9tn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The inverse of `_.toPairs`; this method returns an object composed
 * from key-value `pairs`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} pairs The key-value pairs.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.fromPairs([['a', 1], ['b', 2]]);
 * // => { 'a': 1, 'b': 2 }
 */ function fromPairs(pairs) {
    var index = -1, length = pairs == null ? 0 : pairs.length, result = {
    };
    while(++index < length){
        var pair = pairs[index];
        result[pair[0]] = pair[1];
    }
    return result;
}
exports.default = fromPairs;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9ZP5X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseGetJs = require("./_baseGet.js");
var _baseGetJsDefault = parcelHelpers.interopDefault(_baseGetJs);
/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */ function get(object, path, defaultValue) {
    var result = object == null ? undefined : _baseGetJsDefault.default(object, path);
    return result === undefined ? defaultValue : result;
}
exports.default = get;

},{"./_baseGet.js":"3IUaj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3IUaj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _castPathJs = require("./_castPath.js");
var _castPathJsDefault = parcelHelpers.interopDefault(_castPathJs);
var _toKeyJs = require("./_toKey.js");
var _toKeyJsDefault = parcelHelpers.interopDefault(_toKeyJs);
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */ function baseGet(object, path) {
    path = _castPathJsDefault.default(path, object);
    var index = 0, length = path.length;
    while(object != null && index < length)object = object[_toKeyJsDefault.default(path[index++])];
    return index && index == length ? object : undefined;
}
exports.default = baseGet;

},{"./_castPath.js":"g21zK","./_toKey.js":"Zo68s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g21zK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isKeyJs = require("./_isKey.js");
var _isKeyJsDefault = parcelHelpers.interopDefault(_isKeyJs);
var _stringToPathJs = require("./_stringToPath.js");
var _stringToPathJsDefault = parcelHelpers.interopDefault(_stringToPathJs);
var _toStringJs = require("./toString.js");
var _toStringJsDefault = parcelHelpers.interopDefault(_toStringJs);
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */ function castPath(value, object) {
    if (_isArrayJsDefault.default(value)) return value;
    return _isKeyJsDefault.default(value, object) ? [
        value
    ] : _stringToPathJsDefault.default(_toStringJsDefault.default(value));
}
exports.default = castPath;

},{"./isArray.js":"ETPQ1","./_isKey.js":"h7SfK","./_stringToPath.js":"cgxmj","./toString.js":"hF0LJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h7SfK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
/** Used to match property names within property paths. */ var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */ function isKey(value, object) {
    if (_isArrayJsDefault.default(value)) return false;
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || _isSymbolJsDefault.default(value)) return true;
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
exports.default = isKey;

},{"./isArray.js":"ETPQ1","./isSymbol.js":"gCyRJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cgxmj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _memoizeCappedJs = require("./_memoizeCapped.js");
var _memoizeCappedJsDefault = parcelHelpers.interopDefault(_memoizeCappedJs);
/** Used to match property names within property paths. */ var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */ var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */ var stringToPath = _memoizeCappedJsDefault.default(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */ ) result.push('');
    string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
});
exports.default = stringToPath;

},{"./_memoizeCapped.js":"2kD71","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2kD71":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _memoizeJs = require("./memoize.js");
var _memoizeJsDefault = parcelHelpers.interopDefault(_memoizeJs);
/** Used as the maximum memoize cache size. */ var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */ function memoizeCapped(func) {
    var result = _memoizeJsDefault.default(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) cache.clear();
        return key;
    });
    var cache = result.cache;
    return result;
}
exports.default = memoizeCapped;

},{"./memoize.js":"5zdei","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5zdei":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapCacheJs = require("./_MapCache.js");
var _mapCacheJsDefault = parcelHelpers.interopDefault(_mapCacheJs);
/** Error message constants. */ var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */ function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') throw new TypeError(FUNC_ERROR_TEXT);
    var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) return cache.get(key);
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
    };
    memoized.cache = new (memoize.Cache || _mapCacheJsDefault.default);
    return memoized;
}
// Expose `MapCache`.
memoize.Cache = _mapCacheJsDefault.default;
exports.default = memoize;

},{"./_MapCache.js":"kdqbj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kdqbj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapCacheClearJs = require("./_mapCacheClear.js");
var _mapCacheClearJsDefault = parcelHelpers.interopDefault(_mapCacheClearJs);
var _mapCacheDeleteJs = require("./_mapCacheDelete.js");
var _mapCacheDeleteJsDefault = parcelHelpers.interopDefault(_mapCacheDeleteJs);
var _mapCacheGetJs = require("./_mapCacheGet.js");
var _mapCacheGetJsDefault = parcelHelpers.interopDefault(_mapCacheGetJs);
var _mapCacheHasJs = require("./_mapCacheHas.js");
var _mapCacheHasJsDefault = parcelHelpers.interopDefault(_mapCacheHasJs);
var _mapCacheSetJs = require("./_mapCacheSet.js");
var _mapCacheSetJsDefault = parcelHelpers.interopDefault(_mapCacheSetJs);
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `MapCache`.
MapCache.prototype.clear = _mapCacheClearJsDefault.default;
MapCache.prototype['delete'] = _mapCacheDeleteJsDefault.default;
MapCache.prototype.get = _mapCacheGetJsDefault.default;
MapCache.prototype.has = _mapCacheHasJsDefault.default;
MapCache.prototype.set = _mapCacheSetJsDefault.default;
exports.default = MapCache;

},{"./_mapCacheClear.js":"6PhQB","./_mapCacheDelete.js":"eoP1L","./_mapCacheGet.js":"lbrg6","./_mapCacheHas.js":"lPQeP","./_mapCacheSet.js":"4UIYE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6PhQB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hashJs = require("./_Hash.js");
var _hashJsDefault = parcelHelpers.interopDefault(_hashJs);
var _listCacheJs = require("./_ListCache.js");
var _listCacheJsDefault = parcelHelpers.interopDefault(_listCacheJs);
var _mapJs = require("./_Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
        'hash': new _hashJsDefault.default,
        'map': new (_mapJsDefault.default || _listCacheJsDefault.default),
        'string': new _hashJsDefault.default
    };
}
exports.default = mapCacheClear;

},{"./_Hash.js":"1HkPM","./_ListCache.js":"cqhDQ","./_Map.js":"8spnB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1HkPM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hashClearJs = require("./_hashClear.js");
var _hashClearJsDefault = parcelHelpers.interopDefault(_hashClearJs);
var _hashDeleteJs = require("./_hashDelete.js");
var _hashDeleteJsDefault = parcelHelpers.interopDefault(_hashDeleteJs);
var _hashGetJs = require("./_hashGet.js");
var _hashGetJsDefault = parcelHelpers.interopDefault(_hashGetJs);
var _hashHasJs = require("./_hashHas.js");
var _hashHasJsDefault = parcelHelpers.interopDefault(_hashHasJs);
var _hashSetJs = require("./_hashSet.js");
var _hashSetJsDefault = parcelHelpers.interopDefault(_hashSetJs);
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `Hash`.
Hash.prototype.clear = _hashClearJsDefault.default;
Hash.prototype['delete'] = _hashDeleteJsDefault.default;
Hash.prototype.get = _hashGetJsDefault.default;
Hash.prototype.has = _hashHasJsDefault.default;
Hash.prototype.set = _hashSetJsDefault.default;
exports.default = Hash;

},{"./_hashClear.js":"5oLNs","./_hashDelete.js":"3Xo6B","./_hashGet.js":"j4Vuu","./_hashHas.js":"d5QIn","./_hashSet.js":"lQL69","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5oLNs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeCreateJs = require("./_nativeCreate.js");
var _nativeCreateJsDefault = parcelHelpers.interopDefault(_nativeCreateJs);
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = _nativeCreateJsDefault.default ? _nativeCreateJsDefault.default(null) : {
    };
    this.size = 0;
}
exports.default = hashClear;

},{"./_nativeCreate.js":"2XXd9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2XXd9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNativeJs = require("./_getNative.js");
var _getNativeJsDefault = parcelHelpers.interopDefault(_getNativeJs);
/* Built-in method references that are verified to be native. */ var nativeCreate = _getNativeJsDefault.default(Object, 'create');
exports.default = nativeCreate;

},{"./_getNative.js":"bQrQL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Xo6B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
}
exports.default = hashDelete;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j4Vuu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeCreateJs = require("./_nativeCreate.js");
var _nativeCreateJsDefault = parcelHelpers.interopDefault(_nativeCreateJs);
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (_nativeCreateJsDefault.default) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
exports.default = hashGet;

},{"./_nativeCreate.js":"2XXd9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d5QIn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeCreateJs = require("./_nativeCreate.js");
var _nativeCreateJsDefault = parcelHelpers.interopDefault(_nativeCreateJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return _nativeCreateJsDefault.default ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
exports.default = hashHas;

},{"./_nativeCreate.js":"2XXd9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lQL69":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeCreateJs = require("./_nativeCreate.js");
var _nativeCreateJsDefault = parcelHelpers.interopDefault(_nativeCreateJs);
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = _nativeCreateJsDefault.default && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
exports.default = hashSet;

},{"./_nativeCreate.js":"2XXd9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cqhDQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _listCacheClearJs = require("./_listCacheClear.js");
var _listCacheClearJsDefault = parcelHelpers.interopDefault(_listCacheClearJs);
var _listCacheDeleteJs = require("./_listCacheDelete.js");
var _listCacheDeleteJsDefault = parcelHelpers.interopDefault(_listCacheDeleteJs);
var _listCacheGetJs = require("./_listCacheGet.js");
var _listCacheGetJsDefault = parcelHelpers.interopDefault(_listCacheGetJs);
var _listCacheHasJs = require("./_listCacheHas.js");
var _listCacheHasJsDefault = parcelHelpers.interopDefault(_listCacheHasJs);
var _listCacheSetJs = require("./_listCacheSet.js");
var _listCacheSetJsDefault = parcelHelpers.interopDefault(_listCacheSetJs);
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `ListCache`.
ListCache.prototype.clear = _listCacheClearJsDefault.default;
ListCache.prototype['delete'] = _listCacheDeleteJsDefault.default;
ListCache.prototype.get = _listCacheGetJsDefault.default;
ListCache.prototype.has = _listCacheHasJsDefault.default;
ListCache.prototype.set = _listCacheSetJsDefault.default;
exports.default = ListCache;

},{"./_listCacheClear.js":"bSUq2","./_listCacheDelete.js":"3kM5j","./_listCacheGet.js":"9nv7v","./_listCacheHas.js":"4N5RL","./_listCacheSet.js":"bA8oX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bSUq2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
}
exports.default = listCacheClear;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3kM5j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assocIndexOfJs = require("./_assocIndexOf.js");
var _assocIndexOfJsDefault = parcelHelpers.interopDefault(_assocIndexOfJs);
/** Used for built-in method references. */ var arrayProto = Array.prototype;
/** Built-in value references. */ var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = _assocIndexOfJsDefault.default(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    --this.size;
    return true;
}
exports.default = listCacheDelete;

},{"./_assocIndexOf.js":"124Ga","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"124Ga":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eqJs = require("./eq.js");
var _eqJsDefault = parcelHelpers.interopDefault(_eqJs);
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (_eqJsDefault.default(array[length][0], key)) return length;
    }
    return -1;
}
exports.default = assocIndexOf;

},{"./eq.js":"7el3s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9nv7v":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assocIndexOfJs = require("./_assocIndexOf.js");
var _assocIndexOfJsDefault = parcelHelpers.interopDefault(_assocIndexOfJs);
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = _assocIndexOfJsDefault.default(data, key);
    return index < 0 ? undefined : data[index][1];
}
exports.default = listCacheGet;

},{"./_assocIndexOf.js":"124Ga","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4N5RL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assocIndexOfJs = require("./_assocIndexOf.js");
var _assocIndexOfJsDefault = parcelHelpers.interopDefault(_assocIndexOfJs);
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return _assocIndexOfJsDefault.default(this.__data__, key) > -1;
}
exports.default = listCacheHas;

},{"./_assocIndexOf.js":"124Ga","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bA8oX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assocIndexOfJs = require("./_assocIndexOf.js");
var _assocIndexOfJsDefault = parcelHelpers.interopDefault(_assocIndexOfJs);
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = _assocIndexOfJsDefault.default(data, key);
    if (index < 0) {
        ++this.size;
        data.push([
            key,
            value
        ]);
    } else data[index][1] = value;
    return this;
}
exports.default = listCacheSet;

},{"./_assocIndexOf.js":"124Ga","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8spnB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNativeJs = require("./_getNative.js");
var _getNativeJsDefault = parcelHelpers.interopDefault(_getNativeJs);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/* Built-in method references that are verified to be native. */ var Map = _getNativeJsDefault.default(_rootJsDefault.default, 'Map');
exports.default = Map;

},{"./_getNative.js":"bQrQL","./_root.js":"8yvCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eoP1L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getMapDataJs = require("./_getMapData.js");
var _getMapDataJsDefault = parcelHelpers.interopDefault(_getMapDataJs);
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    var result = _getMapDataJsDefault.default(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
}
exports.default = mapCacheDelete;

},{"./_getMapData.js":"3xzxe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3xzxe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isKeyableJs = require("./_isKeyable.js");
var _isKeyableJsDefault = parcelHelpers.interopDefault(_isKeyableJs);
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return _isKeyableJsDefault.default(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
exports.default = getMapData;

},{"./_isKeyable.js":"9O1jG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9O1jG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
exports.default = isKeyable;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lbrg6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getMapDataJs = require("./_getMapData.js");
var _getMapDataJsDefault = parcelHelpers.interopDefault(_getMapDataJs);
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return _getMapDataJsDefault.default(this, key).get(key);
}
exports.default = mapCacheGet;

},{"./_getMapData.js":"3xzxe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lPQeP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getMapDataJs = require("./_getMapData.js");
var _getMapDataJsDefault = parcelHelpers.interopDefault(_getMapDataJs);
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return _getMapDataJsDefault.default(this, key).has(key);
}
exports.default = mapCacheHas;

},{"./_getMapData.js":"3xzxe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4UIYE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getMapDataJs = require("./_getMapData.js");
var _getMapDataJsDefault = parcelHelpers.interopDefault(_getMapDataJs);
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    var data = _getMapDataJsDefault.default(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
}
exports.default = mapCacheSet;

},{"./_getMapData.js":"3xzxe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hF0LJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseToStringJs = require("./_baseToString.js");
var _baseToStringJsDefault = parcelHelpers.interopDefault(_baseToStringJs);
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */ function toString(value) {
    return value == null ? '' : _baseToStringJsDefault.default(value);
}
exports.default = toString;

},{"./_baseToString.js":"fQ5ds","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fQ5ds":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _symbolJs = require("./_Symbol.js");
var _symbolJsDefault = parcelHelpers.interopDefault(_symbolJs);
var _arrayMapJs = require("./_arrayMap.js");
var _arrayMapJsDefault = parcelHelpers.interopDefault(_arrayMapJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */ var symbolProto = _symbolJsDefault.default ? _symbolJsDefault.default.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */ function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') return value;
    if (_isArrayJsDefault.default(value)) // Recursively convert values (susceptible to call stack limits).
    return _arrayMapJsDefault.default(value, baseToString) + '';
    if (_isSymbolJsDefault.default(value)) return symbolToString ? symbolToString.call(value) : '';
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
exports.default = baseToString;

},{"./_Symbol.js":"jx216","./_arrayMap.js":"gDCVM","./isArray.js":"ETPQ1","./isSymbol.js":"gCyRJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gDCVM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */ function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while(++index < length)result[index] = iteratee(array[index], index, array);
    return result;
}
exports.default = arrayMap;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Zo68s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */ function toKey(value) {
    if (typeof value == 'string' || _isSymbolJsDefault.default(value)) return value;
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
exports.default = toKey;

},{"./isSymbol.js":"gCyRJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jfq4F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseHasInJs = require("./_baseHasIn.js");
var _baseHasInJsDefault = parcelHelpers.interopDefault(_baseHasInJs);
var _hasPathJs = require("./_hasPath.js");
var _hasPathJsDefault = parcelHelpers.interopDefault(_hasPathJs);
/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */ function hasIn(object, path) {
    return object != null && _hasPathJsDefault.default(object, path, _baseHasInJsDefault.default);
}
exports.default = hasIn;

},{"./_baseHasIn.js":"8Hqdk","./_hasPath.js":"lcHZs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Hqdk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */ function baseHasIn(object, key) {
    return object != null && key in Object(object);
}
exports.default = baseHasIn;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lcHZs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _castPathJs = require("./_castPath.js");
var _castPathJsDefault = parcelHelpers.interopDefault(_castPathJs);
var _isArgumentsJs = require("./isArguments.js");
var _isArgumentsJsDefault = parcelHelpers.interopDefault(_isArgumentsJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isIndexJs = require("./_isIndex.js");
var _isIndexJsDefault = parcelHelpers.interopDefault(_isIndexJs);
var _isLengthJs = require("./isLength.js");
var _isLengthJsDefault = parcelHelpers.interopDefault(_isLengthJs);
var _toKeyJs = require("./_toKey.js");
var _toKeyJsDefault = parcelHelpers.interopDefault(_toKeyJs);
/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */ function hasPath(object, path, hasFunc) {
    path = _castPathJsDefault.default(path, object);
    var index = -1, length = path.length, result = false;
    while(++index < length){
        var key = _toKeyJsDefault.default(path[index]);
        if (!(result = object != null && hasFunc(object, key))) break;
        object = object[key];
    }
    if (result || ++index != length) return result;
    length = object == null ? 0 : object.length;
    return !!length && _isLengthJsDefault.default(length) && _isIndexJsDefault.default(key, length) && (_isArrayJsDefault.default(object) || _isArgumentsJsDefault.default(object));
}
exports.default = hasPath;

},{"./_castPath.js":"g21zK","./isArguments.js":"9k91Y","./isArray.js":"ETPQ1","./_isIndex.js":"5DS1K","./isLength.js":"bItM0","./_toKey.js":"Zo68s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gArhC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
var _isObjectLikeJs = require("./isObjectLike.js");
var _isObjectLikeJsDefault = parcelHelpers.interopDefault(_isObjectLikeJs);
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */ function isArrayLikeObject(value) {
    return _isObjectLikeJsDefault.default(value) && _isArrayLikeJsDefault.default(value);
}
exports.default = isArrayLikeObject;

},{"./isArrayLike.js":"8SdiO","./isObjectLike.js":"iad76","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"llpEE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
var _stubFalseJs = require("./stubFalse.js");
var _stubFalseJsDefault = parcelHelpers.interopDefault(_stubFalseJs);
/** Detect free variable `exports`. */ var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */ var Buffer = moduleExports ? _rootJsDefault.default.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */ var isBuffer = nativeIsBuffer || _stubFalseJsDefault.default;
exports.default = isBuffer;

},{"./_root.js":"8yvCA","./stubFalse.js":"fF5mf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fF5mf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */ function stubFalse() {
    return false;
}
exports.default = stubFalse;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eNhTn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIsEqualJs = require("./_baseIsEqual.js");
var _baseIsEqualJsDefault = parcelHelpers.interopDefault(_baseIsEqualJs);
/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */ function isEqual(value, other) {
    return _baseIsEqualJsDefault.default(value, other);
}
exports.default = isEqual;

},{"./_baseIsEqual.js":"1zaYh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1zaYh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIsEqualDeepJs = require("./_baseIsEqualDeep.js");
var _baseIsEqualDeepJsDefault = parcelHelpers.interopDefault(_baseIsEqualDeepJs);
var _isObjectLikeJs = require("./isObjectLike.js");
var _isObjectLikeJsDefault = parcelHelpers.interopDefault(_isObjectLikeJs);
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */ function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) return true;
    if (value == null || other == null || !_isObjectLikeJsDefault.default(value) && !_isObjectLikeJsDefault.default(other)) return value !== value && other !== other;
    return _baseIsEqualDeepJsDefault.default(value, other, bitmask, customizer, baseIsEqual, stack);
}
exports.default = baseIsEqual;

},{"./_baseIsEqualDeep.js":"hBKuk","./isObjectLike.js":"iad76","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hBKuk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _stackJs = require("./_Stack.js");
var _stackJsDefault = parcelHelpers.interopDefault(_stackJs);
var _equalArraysJs = require("./_equalArrays.js");
var _equalArraysJsDefault = parcelHelpers.interopDefault(_equalArraysJs);
var _equalByTagJs = require("./_equalByTag.js");
var _equalByTagJsDefault = parcelHelpers.interopDefault(_equalByTagJs);
var _equalObjectsJs = require("./_equalObjects.js");
var _equalObjectsJsDefault = parcelHelpers.interopDefault(_equalObjectsJs);
var _getTagJs = require("./_getTag.js");
var _getTagJsDefault = parcelHelpers.interopDefault(_getTagJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isBufferJs = require("./isBuffer.js");
var _isBufferJsDefault = parcelHelpers.interopDefault(_isBufferJs);
var _isTypedArrayJs = require("./isTypedArray.js");
var _isTypedArrayJsDefault = parcelHelpers.interopDefault(_isTypedArrayJs);
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1;
/** `Object#toString` result references. */ var argsTag = '[object Arguments]', arrayTag = '[object Array]', objectTag = '[object Object]';
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = _isArrayJsDefault.default(object), othIsArr = _isArrayJsDefault.default(other), objTag = objIsArr ? arrayTag : _getTagJsDefault.default(object), othTag = othIsArr ? arrayTag : _getTagJsDefault.default(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && _isBufferJsDefault.default(object)) {
        if (!_isBufferJsDefault.default(other)) return false;
        objIsArr = true;
        objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
        stack || (stack = new _stackJsDefault.default);
        return objIsArr || _isTypedArrayJsDefault.default(object) ? _equalArraysJsDefault.default(object, other, bitmask, customizer, equalFunc, stack) : _equalByTagJsDefault.default(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
        if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new _stackJsDefault.default);
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
    }
    if (!isSameTag) return false;
    stack || (stack = new _stackJsDefault.default);
    return _equalObjectsJsDefault.default(object, other, bitmask, customizer, equalFunc, stack);
}
exports.default = baseIsEqualDeep;

},{"./_Stack.js":"dCpM5","./_equalArrays.js":"3xWWQ","./_equalByTag.js":"9KfIu","./_equalObjects.js":"7yAdV","./_getTag.js":"1kCom","./isArray.js":"ETPQ1","./isBuffer.js":"llpEE","./isTypedArray.js":"2LIMs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dCpM5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _listCacheJs = require("./_ListCache.js");
var _listCacheJsDefault = parcelHelpers.interopDefault(_listCacheJs);
var _stackClearJs = require("./_stackClear.js");
var _stackClearJsDefault = parcelHelpers.interopDefault(_stackClearJs);
var _stackDeleteJs = require("./_stackDelete.js");
var _stackDeleteJsDefault = parcelHelpers.interopDefault(_stackDeleteJs);
var _stackGetJs = require("./_stackGet.js");
var _stackGetJsDefault = parcelHelpers.interopDefault(_stackGetJs);
var _stackHasJs = require("./_stackHas.js");
var _stackHasJsDefault = parcelHelpers.interopDefault(_stackHasJs);
var _stackSetJs = require("./_stackSet.js");
var _stackSetJsDefault = parcelHelpers.interopDefault(_stackSetJs);
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Stack(entries) {
    var data = this.__data__ = new _listCacheJsDefault.default(entries);
    this.size = data.size;
}
// Add methods to `Stack`.
Stack.prototype.clear = _stackClearJsDefault.default;
Stack.prototype['delete'] = _stackDeleteJsDefault.default;
Stack.prototype.get = _stackGetJsDefault.default;
Stack.prototype.has = _stackHasJsDefault.default;
Stack.prototype.set = _stackSetJsDefault.default;
exports.default = Stack;

},{"./_ListCache.js":"cqhDQ","./_stackClear.js":"4BuA3","./_stackDelete.js":"2mGxC","./_stackGet.js":"c3cE4","./_stackHas.js":"23Sz6","./_stackSet.js":"jnSxK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4BuA3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _listCacheJs = require("./_ListCache.js");
var _listCacheJsDefault = parcelHelpers.interopDefault(_listCacheJs);
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */ function stackClear() {
    this.__data__ = new _listCacheJsDefault.default;
    this.size = 0;
}
exports.default = stackClear;

},{"./_ListCache.js":"cqhDQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2mGxC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function stackDelete(key) {
    var data = this.__data__, result = data['delete'](key);
    this.size = data.size;
    return result;
}
exports.default = stackDelete;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c3cE4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function stackGet(key) {
    return this.__data__.get(key);
}
exports.default = stackGet;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"23Sz6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function stackHas(key) {
    return this.__data__.has(key);
}
exports.default = stackHas;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jnSxK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _listCacheJs = require("./_ListCache.js");
var _listCacheJsDefault = parcelHelpers.interopDefault(_listCacheJs);
var _mapJs = require("./_Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _mapCacheJs = require("./_MapCache.js");
var _mapCacheJsDefault = parcelHelpers.interopDefault(_mapCacheJs);
/** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */ function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof _listCacheJsDefault.default) {
        var pairs = data.__data__;
        if (!_mapJsDefault.default || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            this.size = ++data.size;
            return this;
        }
        data = this.__data__ = new _mapCacheJsDefault.default(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
}
exports.default = stackSet;

},{"./_ListCache.js":"cqhDQ","./_Map.js":"8spnB","./_MapCache.js":"kdqbj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3xWWQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setCacheJs = require("./_SetCache.js");
var _setCacheJsDefault = parcelHelpers.interopDefault(_setCacheJs);
var _arraySomeJs = require("./_arraySome.js");
var _arraySomeJsDefault = parcelHelpers.interopDefault(_arraySomeJs);
var _cacheHasJs = require("./_cacheHas.js");
var _cacheHasJsDefault = parcelHelpers.interopDefault(_cacheHasJs);
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */ function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
    // Check that cyclic values are equal.
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) return arrStacked == other && othStacked == array;
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new _setCacheJsDefault.default : undefined;
    stack.set(array, other);
    stack.set(other, array);
    // Ignore non-index properties.
    while(++index < arrLength){
        var arrValue = array[index], othValue1 = other[index];
        if (customizer) var compared = isPartial ? customizer(othValue1, arrValue, index, other, array, stack) : customizer(arrValue, othValue1, index, array, other, stack);
        if (compared !== undefined) {
            if (compared) continue;
            result = false;
            break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
            if (!_arraySomeJsDefault.default(other, function(othValue, othIndex) {
                if (!_cacheHasJsDefault.default(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) return seen.push(othIndex);
            })) {
                result = false;
                break;
            }
        } else if (!(arrValue === othValue1 || equalFunc(arrValue, othValue1, bitmask, customizer, stack))) {
            result = false;
            break;
        }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
}
exports.default = equalArrays;

},{"./_SetCache.js":"6YwQx","./_arraySome.js":"9k95T","./_cacheHas.js":"jSrgN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6YwQx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapCacheJs = require("./_MapCache.js");
var _mapCacheJsDefault = parcelHelpers.interopDefault(_mapCacheJs);
var _setCacheAddJs = require("./_setCacheAdd.js");
var _setCacheAddJsDefault = parcelHelpers.interopDefault(_setCacheAddJs);
var _setCacheHasJs = require("./_setCacheHas.js");
var _setCacheHasJsDefault = parcelHelpers.interopDefault(_setCacheHasJs);
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */ function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new _mapCacheJsDefault.default;
    while(++index < length)this.add(values[index]);
}
// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = _setCacheAddJsDefault.default;
SetCache.prototype.has = _setCacheHasJsDefault.default;
exports.default = SetCache;

},{"./_MapCache.js":"kdqbj","./_setCacheAdd.js":"7m7Pn","./_setCacheHas.js":"BJklm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7m7Pn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */ function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
exports.default = setCacheAdd;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"BJklm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */ function setCacheHas(value) {
    return this.__data__.has(value);
}
exports.default = setCacheHas;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9k95T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */ function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while(++index < length){
        if (predicate(array[index], index, array)) return true;
    }
    return false;
}
exports.default = arraySome;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jSrgN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function cacheHas(cache, key) {
    return cache.has(key);
}
exports.default = cacheHas;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9KfIu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _symbolJs = require("./_Symbol.js");
var _symbolJsDefault = parcelHelpers.interopDefault(_symbolJs);
var _uint8ArrayJs = require("./_Uint8Array.js");
var _uint8ArrayJsDefault = parcelHelpers.interopDefault(_uint8ArrayJs);
var _eqJs = require("./eq.js");
var _eqJsDefault = parcelHelpers.interopDefault(_eqJs);
var _equalArraysJs = require("./_equalArrays.js");
var _equalArraysJsDefault = parcelHelpers.interopDefault(_equalArraysJs);
var _mapToArrayJs = require("./_mapToArray.js");
var _mapToArrayJsDefault = parcelHelpers.interopDefault(_mapToArrayJs);
var _setToArrayJs = require("./_setToArray.js");
var _setToArrayJsDefault = parcelHelpers.interopDefault(_setToArrayJs);
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
/** `Object#toString` result references. */ var boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', mapTag = '[object Map]', numberTag = '[object Number]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]';
/** Used to convert symbols to primitives and strings. */ var symbolProto = _symbolJsDefault.default ? _symbolJsDefault.default.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch(tag){
        case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;
            object = object.buffer;
            other = other.buffer;
        case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new _uint8ArrayJsDefault.default(object), new _uint8ArrayJsDefault.default(other))) return false;
            return true;
        case boolTag:
        case dateTag:
        case numberTag:
            // Coerce booleans to `1` or `0` and dates to milliseconds.
            // Invalid dates are coerced to `NaN`.
            return _eqJsDefault.default(+object, +other);
        case errorTag:
            return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
            // Coerce regexes to strings and treat strings, primitives and objects,
            // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
            // for more details.
            return object == other + '';
        case mapTag:
            var convert = _mapToArrayJsDefault.default;
        case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = _setToArrayJsDefault.default);
            if (object.size != other.size && !isPartial) return false;
            // Assume cyclic values are equal.
            var stacked = stack.get(object);
            if (stacked) return stacked == other;
            bitmask |= COMPARE_UNORDERED_FLAG;
            // Recursively compare objects (susceptible to call stack limits).
            stack.set(object, other);
            var result = _equalArraysJsDefault.default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack['delete'](object);
            return result;
        case symbolTag:
            if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
    }
    return false;
}
exports.default = equalByTag;

},{"./_Symbol.js":"jx216","./_Uint8Array.js":"5zVAV","./eq.js":"7el3s","./_equalArrays.js":"3xWWQ","./_mapToArray.js":"3RRCW","./_setToArray.js":"2ugef","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5zVAV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/** Built-in value references. */ var Uint8Array = _rootJsDefault.default.Uint8Array;
exports.default = Uint8Array;

},{"./_root.js":"8yvCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3RRCW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */ function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
exports.default = mapToArray;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2ugef":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */ function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
exports.default = setToArray;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7yAdV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getAllKeysJs = require("./_getAllKeys.js");
var _getAllKeysJsDefault = parcelHelpers.interopDefault(_getAllKeysJs);
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1;
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = _getAllKeysJsDefault.default(object), objLength = objProps.length, othProps = _getAllKeysJsDefault.default(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) return false;
    var index = objLength;
    while(index--){
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return false;
    }
    // Check that cyclic values are equal.
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) return objStacked == other && othStacked == object;
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while(++index < objLength){
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
        }
        skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) result = false;
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
}
exports.default = equalObjects;

},{"./_getAllKeys.js":"68ZDs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"68ZDs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseGetAllKeysJs = require("./_baseGetAllKeys.js");
var _baseGetAllKeysJsDefault = parcelHelpers.interopDefault(_baseGetAllKeysJs);
var _getSymbolsJs = require("./_getSymbols.js");
var _getSymbolsJsDefault = parcelHelpers.interopDefault(_getSymbolsJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */ function getAllKeys(object) {
    return _baseGetAllKeysJsDefault.default(object, _keysJsDefault.default, _getSymbolsJsDefault.default);
}
exports.default = getAllKeys;

},{"./_baseGetAllKeys.js":"jHmw2","./_getSymbols.js":"egqKq","./keys.js":"lbEZV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jHmw2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayPushJs = require("./_arrayPush.js");
var _arrayPushJsDefault = parcelHelpers.interopDefault(_arrayPushJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return _isArrayJsDefault.default(object) ? result : _arrayPushJsDefault.default(result, symbolsFunc(object));
}
exports.default = baseGetAllKeys;

},{"./_arrayPush.js":"4BTrx","./isArray.js":"ETPQ1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"egqKq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayFilterJs = require("./_arrayFilter.js");
var _arrayFilterJsDefault = parcelHelpers.interopDefault(_arrayFilterJs);
var _stubArrayJs = require("./stubArray.js");
var _stubArrayJsDefault = parcelHelpers.interopDefault(_stubArrayJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Built-in value references. */ var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbols = !nativeGetSymbols ? _stubArrayJsDefault.default : function(object) {
    if (object == null) return [];
    object = Object(object);
    return _arrayFilterJsDefault.default(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
    });
};
exports.default = getSymbols;

},{"./_arrayFilter.js":"iZqHX","./stubArray.js":"iwLLL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iZqHX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */ function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while(++index < length){
        var value = array[index];
        if (predicate(value, index, array)) result[resIndex++] = value;
    }
    return result;
}
exports.default = arrayFilter;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iwLLL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */ function stubArray() {
    return [];
}
exports.default = stubArray;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lbEZV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayLikeKeysJs = require("./_arrayLikeKeys.js");
var _arrayLikeKeysJsDefault = parcelHelpers.interopDefault(_arrayLikeKeysJs);
var _baseKeysJs = require("./_baseKeys.js");
var _baseKeysJsDefault = parcelHelpers.interopDefault(_baseKeysJs);
var _isArrayLikeJs = require("./isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */ function keys(object) {
    return _isArrayLikeJsDefault.default(object) ? _arrayLikeKeysJsDefault.default(object) : _baseKeysJsDefault.default(object);
}
exports.default = keys;

},{"./_arrayLikeKeys.js":"b4sHy","./_baseKeys.js":"7rx4g","./isArrayLike.js":"8SdiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b4sHy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseTimesJs = require("./_baseTimes.js");
var _baseTimesJsDefault = parcelHelpers.interopDefault(_baseTimesJs);
var _isArgumentsJs = require("./isArguments.js");
var _isArgumentsJsDefault = parcelHelpers.interopDefault(_isArgumentsJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _isBufferJs = require("./isBuffer.js");
var _isBufferJsDefault = parcelHelpers.interopDefault(_isBufferJs);
var _isIndexJs = require("./_isIndex.js");
var _isIndexJsDefault = parcelHelpers.interopDefault(_isIndexJs);
var _isTypedArrayJs = require("./isTypedArray.js");
var _isTypedArrayJsDefault = parcelHelpers.interopDefault(_isTypedArrayJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    var isArr = _isArrayJsDefault.default(value), isArg = !isArr && _isArgumentsJsDefault.default(value), isBuff = !isArr && !isArg && _isBufferJsDefault.default(value), isType = !isArr && !isArg && !isBuff && _isTypedArrayJsDefault.default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? _baseTimesJsDefault.default(value.length, String) : [], length = result.length;
    for(var key in value)if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    _isIndexJsDefault.default(key, length)))) result.push(key);
    return result;
}
exports.default = arrayLikeKeys;

},{"./_baseTimes.js":"6yWeR","./isArguments.js":"9k91Y","./isArray.js":"ETPQ1","./isBuffer.js":"llpEE","./_isIndex.js":"5DS1K","./isTypedArray.js":"2LIMs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6yWeR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n)result[index] = iteratee(index);
    return result;
}
exports.default = baseTimes;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2LIMs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIsTypedArrayJs = require("./_baseIsTypedArray.js");
var _baseIsTypedArrayJsDefault = parcelHelpers.interopDefault(_baseIsTypedArrayJs);
var _baseUnaryJs = require("./_baseUnary.js");
var _baseUnaryJsDefault = parcelHelpers.interopDefault(_baseUnaryJs);
var _nodeUtilJs = require("./_nodeUtil.js");
var _nodeUtilJsDefault = parcelHelpers.interopDefault(_nodeUtilJs);
/* Node.js helper references. */ var nodeIsTypedArray = _nodeUtilJsDefault.default && _nodeUtilJsDefault.default.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */ var isTypedArray = nodeIsTypedArray ? _baseUnaryJsDefault.default(nodeIsTypedArray) : _baseIsTypedArrayJsDefault.default;
exports.default = isTypedArray;

},{"./_baseIsTypedArray.js":"jcEk3","./_baseUnary.js":"jBUGV","./_nodeUtil.js":"cxU0K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jcEk3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseGetTagJs = require("./_baseGetTag.js");
var _baseGetTagJsDefault = parcelHelpers.interopDefault(_baseGetTagJs);
var _isLengthJs = require("./isLength.js");
var _isLengthJsDefault = parcelHelpers.interopDefault(_isLengthJs);
var _isObjectLikeJs = require("./isObjectLike.js");
var _isObjectLikeJsDefault = parcelHelpers.interopDefault(_isObjectLikeJs);
/** `Object#toString` result references. */ var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */ var typedArrayTags = {
};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */ function baseIsTypedArray(value) {
    return _isObjectLikeJsDefault.default(value) && _isLengthJsDefault.default(value.length) && !!typedArrayTags[_baseGetTagJsDefault.default(value)];
}
exports.default = baseIsTypedArray;

},{"./_baseGetTag.js":"gVDfP","./isLength.js":"bItM0","./isObjectLike.js":"iad76","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jBUGV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */ function baseUnary(func) {
    return function(value) {
        return func(value);
    };
}
exports.default = baseUnary;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cxU0K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _freeGlobalJs = require("./_freeGlobal.js");
var _freeGlobalJsDefault = parcelHelpers.interopDefault(_freeGlobalJs);
/** Detect free variable `exports`. */ var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */ var freeProcess = moduleExports && _freeGlobalJsDefault.default.process;
/** Used to access faster Node.js helpers. */ var nodeUtil = function() {
    try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;
        if (types) return types;
        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {
    }
}();
exports.default = nodeUtil;

},{"./_freeGlobal.js":"98hMd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7rx4g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isPrototypeJs = require("./_isPrototype.js");
var _isPrototypeJsDefault = parcelHelpers.interopDefault(_isPrototypeJs);
var _nativeKeysJs = require("./_nativeKeys.js");
var _nativeKeysJsDefault = parcelHelpers.interopDefault(_nativeKeysJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeys(object) {
    if (!_isPrototypeJsDefault.default(object)) return _nativeKeysJsDefault.default(object);
    var result = [];
    for(var key in Object(object))if (hasOwnProperty.call(object, key) && key != 'constructor') result.push(key);
    return result;
}
exports.default = baseKeys;

},{"./_isPrototype.js":"jOAyW","./_nativeKeys.js":"4fIwW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jOAyW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
exports.default = isPrototype;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4fIwW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _overArgJs = require("./_overArg.js");
var _overArgJsDefault = parcelHelpers.interopDefault(_overArgJs);
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeKeys = _overArgJsDefault.default(Object.keys, Object);
exports.default = nativeKeys;

},{"./_overArg.js":"lqvyN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lqvyN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
exports.default = overArg;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1kCom":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _dataViewJs = require("./_DataView.js");
var _dataViewJsDefault = parcelHelpers.interopDefault(_dataViewJs);
var _mapJs = require("./_Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _promiseJs = require("./_Promise.js");
var _promiseJsDefault = parcelHelpers.interopDefault(_promiseJs);
var _setJs = require("./_Set.js");
var _setJsDefault = parcelHelpers.interopDefault(_setJs);
var _weakMapJs = require("./_WeakMap.js");
var _weakMapJsDefault = parcelHelpers.interopDefault(_weakMapJs);
var _baseGetTagJs = require("./_baseGetTag.js");
var _baseGetTagJsDefault = parcelHelpers.interopDefault(_baseGetTagJs);
var _toSourceJs = require("./_toSource.js");
var _toSourceJsDefault = parcelHelpers.interopDefault(_toSourceJs);
/** `Object#toString` result references. */ var mapTag = '[object Map]', objectTag = '[object Object]', promiseTag = '[object Promise]', setTag = '[object Set]', weakMapTag = '[object WeakMap]';
var dataViewTag = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = _toSourceJsDefault.default(_dataViewJsDefault.default), mapCtorString = _toSourceJsDefault.default(_mapJsDefault.default), promiseCtorString = _toSourceJsDefault.default(_promiseJsDefault.default), setCtorString = _toSourceJsDefault.default(_setJsDefault.default), weakMapCtorString = _toSourceJsDefault.default(_weakMapJsDefault.default);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ var getTag = _baseGetTagJsDefault.default;
// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if (_dataViewJsDefault.default && getTag(new _dataViewJsDefault.default(new ArrayBuffer(1))) != dataViewTag || _mapJsDefault.default && getTag(new _mapJsDefault.default) != mapTag || _promiseJsDefault.default && getTag(_promiseJsDefault.default.resolve()) != promiseTag || _setJsDefault.default && getTag(new _setJsDefault.default) != setTag || _weakMapJsDefault.default && getTag(new _weakMapJsDefault.default) != weakMapTag) getTag = function(value) {
    var result = _baseGetTagJsDefault.default(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? _toSourceJsDefault.default(Ctor) : '';
    if (ctorString) switch(ctorString){
        case dataViewCtorString:
            return dataViewTag;
        case mapCtorString:
            return mapTag;
        case promiseCtorString:
            return promiseTag;
        case setCtorString:
            return setTag;
        case weakMapCtorString:
            return weakMapTag;
    }
    return result;
};
exports.default = getTag;

},{"./_DataView.js":"4SeGN","./_Map.js":"8spnB","./_Promise.js":"lbYHf","./_Set.js":"jf3T7","./_WeakMap.js":"52eE0","./_baseGetTag.js":"gVDfP","./_toSource.js":"4wd66","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4SeGN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNativeJs = require("./_getNative.js");
var _getNativeJsDefault = parcelHelpers.interopDefault(_getNativeJs);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/* Built-in method references that are verified to be native. */ var DataView = _getNativeJsDefault.default(_rootJsDefault.default, 'DataView');
exports.default = DataView;

},{"./_getNative.js":"bQrQL","./_root.js":"8yvCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lbYHf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNativeJs = require("./_getNative.js");
var _getNativeJsDefault = parcelHelpers.interopDefault(_getNativeJs);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/* Built-in method references that are verified to be native. */ var Promise = _getNativeJsDefault.default(_rootJsDefault.default, 'Promise');
exports.default = Promise;

},{"./_getNative.js":"bQrQL","./_root.js":"8yvCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jf3T7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNativeJs = require("./_getNative.js");
var _getNativeJsDefault = parcelHelpers.interopDefault(_getNativeJs);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/* Built-in method references that are verified to be native. */ var Set = _getNativeJsDefault.default(_rootJsDefault.default, 'Set');
exports.default = Set;

},{"./_getNative.js":"bQrQL","./_root.js":"8yvCA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kwvYw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _basePropertyJs = require("./_baseProperty.js");
var _basePropertyJsDefault = parcelHelpers.interopDefault(_basePropertyJs);
var _basePropertyDeepJs = require("./_basePropertyDeep.js");
var _basePropertyDeepJsDefault = parcelHelpers.interopDefault(_basePropertyDeepJs);
var _isKeyJs = require("./_isKey.js");
var _isKeyJsDefault = parcelHelpers.interopDefault(_isKeyJs);
var _toKeyJs = require("./_toKey.js");
var _toKeyJsDefault = parcelHelpers.interopDefault(_toKeyJs);
/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */ function property(path) {
    return _isKeyJsDefault.default(path) ? _basePropertyJsDefault.default(_toKeyJsDefault.default(path)) : _basePropertyDeepJsDefault.default(path);
}
exports.default = property;

},{"./_baseProperty.js":"gAjZk","./_basePropertyDeep.js":"1xKss","./_isKey.js":"h7SfK","./_toKey.js":"Zo68s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gAjZk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */ function baseProperty(key) {
    return function(object) {
        return object == null ? undefined : object[key];
    };
}
exports.default = baseProperty;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1xKss":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseGetJs = require("./_baseGet.js");
var _baseGetJsDefault = parcelHelpers.interopDefault(_baseGetJs);
/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */ function basePropertyDeep(path) {
    return function(object) {
        return _baseGetJsDefault.default(object, path);
    };
}
exports.default = basePropertyDeep;

},{"./_baseGet.js":"3IUaj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2xup9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createRangeJs = require("./_createRange.js");
var _createRangeJsDefault = parcelHelpers.interopDefault(_createRangeJs);
/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */ var range = _createRangeJsDefault.default();
exports.default = range;

},{"./_createRange.js":"h5MaG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h5MaG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseRangeJs = require("./_baseRange.js");
var _baseRangeJsDefault = parcelHelpers.interopDefault(_baseRangeJs);
var _isIterateeCallJs = require("./_isIterateeCall.js");
var _isIterateeCallJsDefault = parcelHelpers.interopDefault(_isIterateeCallJs);
var _toFiniteJs = require("./toFinite.js");
var _toFiniteJsDefault = parcelHelpers.interopDefault(_toFiniteJs);
/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */ function createRange(fromRight) {
    return function(start, end, step) {
        if (step && typeof step != 'number' && _isIterateeCallJsDefault.default(start, end, step)) end = step = undefined;
        // Ensure the sign of `-0` is preserved.
        start = _toFiniteJsDefault.default(start);
        if (end === undefined) {
            end = start;
            start = 0;
        } else end = _toFiniteJsDefault.default(end);
        step = step === undefined ? start < end ? 1 : -1 : _toFiniteJsDefault.default(step);
        return _baseRangeJsDefault.default(start, end, step, fromRight);
    };
}
exports.default = createRange;

},{"./_baseRange.js":"1twHx","./_isIterateeCall.js":"1jM1r","./toFinite.js":"FJR8i","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1twHx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeCeil = Math.ceil, nativeMax = Math.max;
/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */ function baseRange(start, end, step, fromRight) {
    var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
    while(length--){
        result[fromRight ? length : ++index] = start;
        start += step;
    }
    return result;
}
exports.default = baseRange;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b6mtE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arraySampleJs = require("./_arraySample.js");
var _arraySampleJsDefault = parcelHelpers.interopDefault(_arraySampleJs);
var _baseSampleJs = require("./_baseSample.js");
var _baseSampleJsDefault = parcelHelpers.interopDefault(_baseSampleJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
/**
 * Gets a random element from `collection`.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to sample.
 * @returns {*} Returns the random element.
 * @example
 *
 * _.sample([1, 2, 3, 4]);
 * // => 2
 */ function sample(collection) {
    var func = _isArrayJsDefault.default(collection) ? _arraySampleJsDefault.default : _baseSampleJsDefault.default;
    return func(collection);
}
exports.default = sample;

},{"./_arraySample.js":"fmRSg","./_baseSample.js":"cX3Ks","./isArray.js":"ETPQ1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fmRSg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseRandomJs = require("./_baseRandom.js");
var _baseRandomJsDefault = parcelHelpers.interopDefault(_baseRandomJs);
/**
 * A specialized version of `_.sample` for arrays.
 *
 * @private
 * @param {Array} array The array to sample.
 * @returns {*} Returns the random element.
 */ function arraySample(array) {
    var length = array.length;
    return length ? array[_baseRandomJsDefault.default(0, length - 1)] : undefined;
}
exports.default = arraySample;

},{"./_baseRandom.js":"kestZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kestZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeFloor = Math.floor, nativeRandom = Math.random;
/**
 * The base implementation of `_.random` without support for returning
 * floating-point numbers.
 *
 * @private
 * @param {number} lower The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the random number.
 */ function baseRandom(lower, upper) {
    return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
}
exports.default = baseRandom;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cX3Ks":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arraySampleJs = require("./_arraySample.js");
var _arraySampleJsDefault = parcelHelpers.interopDefault(_arraySampleJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
/**
 * The base implementation of `_.sample`.
 *
 * @private
 * @param {Array|Object} collection The collection to sample.
 * @returns {*} Returns the random element.
 */ function baseSample(collection) {
    return _arraySampleJsDefault.default(_valuesJsDefault.default(collection));
}
exports.default = baseSample;

},{"./_arraySample.js":"fmRSg","./values.js":"bjkOg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bjkOg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseValuesJs = require("./_baseValues.js");
var _baseValuesJsDefault = parcelHelpers.interopDefault(_baseValuesJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */ function values(object) {
    return object == null ? [] : _baseValuesJsDefault.default(object, _keysJsDefault.default(object));
}
exports.default = values;

},{"./_baseValues.js":"6sg61","./keys.js":"lbEZV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6sg61":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayMapJs = require("./_arrayMap.js");
var _arrayMapJsDefault = parcelHelpers.interopDefault(_arrayMapJs);
/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */ function baseValues(object, props) {
    return _arrayMapJsDefault.default(props, function(key) {
        return object[key];
    });
}
exports.default = baseValues;

},{"./_arrayMap.js":"gDCVM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"42BZ9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseFlattenJs = require("./_baseFlatten.js");
var _baseFlattenJsDefault = parcelHelpers.interopDefault(_baseFlattenJs);
var _baseOrderByJs = require("./_baseOrderBy.js");
var _baseOrderByJsDefault = parcelHelpers.interopDefault(_baseOrderByJs);
var _baseRestJs = require("./_baseRest.js");
var _baseRestJsDefault = parcelHelpers.interopDefault(_baseRestJs);
var _isIterateeCallJs = require("./_isIterateeCall.js");
var _isIterateeCallJsDefault = parcelHelpers.interopDefault(_isIterateeCallJs);
/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 30 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
 */ var sortBy = _baseRestJsDefault.default(function(collection, iteratees) {
    if (collection == null) return [];
    var length = iteratees.length;
    if (length > 1 && _isIterateeCallJsDefault.default(collection, iteratees[0], iteratees[1])) iteratees = [];
    else if (length > 2 && _isIterateeCallJsDefault.default(iteratees[0], iteratees[1], iteratees[2])) iteratees = [
        iteratees[0]
    ];
    return _baseOrderByJsDefault.default(collection, _baseFlattenJsDefault.default(iteratees, 1), []);
});
exports.default = sortBy;

},{"./_baseFlatten.js":"92emb","./_baseOrderBy.js":"eLjrn","./_baseRest.js":"1fKJX","./_isIterateeCall.js":"1jM1r","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eLjrn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayMapJs = require("./_arrayMap.js");
var _arrayMapJsDefault = parcelHelpers.interopDefault(_arrayMapJs);
var _baseGetJs = require("./_baseGet.js");
var _baseGetJsDefault = parcelHelpers.interopDefault(_baseGetJs);
var _baseIterateeJs = require("./_baseIteratee.js");
var _baseIterateeJsDefault = parcelHelpers.interopDefault(_baseIterateeJs);
var _baseMapJs = require("./_baseMap.js");
var _baseMapJsDefault = parcelHelpers.interopDefault(_baseMapJs);
var _baseSortByJs = require("./_baseSortBy.js");
var _baseSortByJsDefault = parcelHelpers.interopDefault(_baseSortByJs);
var _baseUnaryJs = require("./_baseUnary.js");
var _baseUnaryJsDefault = parcelHelpers.interopDefault(_baseUnaryJs);
var _compareMultipleJs = require("./_compareMultiple.js");
var _compareMultipleJsDefault = parcelHelpers.interopDefault(_compareMultipleJs);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */ function baseOrderBy(collection, iteratees, orders) {
    if (iteratees.length) iteratees = _arrayMapJsDefault.default(iteratees, function(iteratee) {
        if (_isArrayJsDefault.default(iteratee)) return function(value) {
            return _baseGetJsDefault.default(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        };
        return iteratee;
    });
    else iteratees = [
        _identityJsDefault.default
    ];
    var index = -1;
    iteratees = _arrayMapJsDefault.default(iteratees, _baseUnaryJsDefault.default(_baseIterateeJsDefault.default));
    var result = _baseMapJsDefault.default(collection, function(value, key, collection) {
        var criteria = _arrayMapJsDefault.default(iteratees, function(iteratee) {
            return iteratee(value);
        });
        return {
            'criteria': criteria,
            'index': ++index,
            'value': value
        };
    });
    return _baseSortByJsDefault.default(result, function(object, other) {
        return _compareMultipleJsDefault.default(object, other, orders);
    });
}
exports.default = baseOrderBy;

},{"./_arrayMap.js":"gDCVM","./_baseGet.js":"3IUaj","./_baseIteratee.js":"48kCP","./_baseMap.js":"eHrfS","./_baseSortBy.js":"h9y0s","./_baseUnary.js":"jBUGV","./_compareMultiple.js":"3O3PE","./identity.js":"1Y0KA","./isArray.js":"ETPQ1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"48kCP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseMatchesJs = require("./_baseMatches.js");
var _baseMatchesJsDefault = parcelHelpers.interopDefault(_baseMatchesJs);
var _baseMatchesPropertyJs = require("./_baseMatchesProperty.js");
var _baseMatchesPropertyJsDefault = parcelHelpers.interopDefault(_baseMatchesPropertyJs);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _isArrayJs = require("./isArray.js");
var _isArrayJsDefault = parcelHelpers.interopDefault(_isArrayJs);
var _propertyJs = require("./property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */ function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') return value;
    if (value == null) return _identityJsDefault.default;
    if (typeof value == 'object') return _isArrayJsDefault.default(value) ? _baseMatchesPropertyJsDefault.default(value[0], value[1]) : _baseMatchesJsDefault.default(value);
    return _propertyJsDefault.default(value);
}
exports.default = baseIteratee;

},{"./_baseMatches.js":"6vwVM","./_baseMatchesProperty.js":"4hv6L","./identity.js":"1Y0KA","./isArray.js":"ETPQ1","./property.js":"kwvYw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6vwVM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIsMatchJs = require("./_baseIsMatch.js");
var _baseIsMatchJsDefault = parcelHelpers.interopDefault(_baseIsMatchJs);
var _getMatchDataJs = require("./_getMatchData.js");
var _getMatchDataJsDefault = parcelHelpers.interopDefault(_getMatchDataJs);
var _matchesStrictComparableJs = require("./_matchesStrictComparable.js");
var _matchesStrictComparableJsDefault = parcelHelpers.interopDefault(_matchesStrictComparableJs);
/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */ function baseMatches(source) {
    var matchData = _getMatchDataJsDefault.default(source);
    if (matchData.length == 1 && matchData[0][2]) return _matchesStrictComparableJsDefault.default(matchData[0][0], matchData[0][1]);
    return function(object) {
        return object === source || _baseIsMatchJsDefault.default(object, source, matchData);
    };
}
exports.default = baseMatches;

},{"./_baseIsMatch.js":"519lF","./_getMatchData.js":"2HQJS","./_matchesStrictComparable.js":"19Pwe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"519lF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _stackJs = require("./_Stack.js");
var _stackJsDefault = parcelHelpers.interopDefault(_stackJs);
var _baseIsEqualJs = require("./_baseIsEqual.js");
var _baseIsEqualJsDefault = parcelHelpers.interopDefault(_baseIsEqualJs);
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */ function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length = index, noCustomizer = !customizer;
    if (object == null) return !length;
    object = Object(object);
    while(index--){
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return false;
    }
    while(++index < length){
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
            if (objValue === undefined && !(key in object)) return false;
        } else {
            var stack = new _stackJsDefault.default;
            if (customizer) var result = customizer(objValue, srcValue, key, object, source, stack);
            if (!(result === undefined ? _baseIsEqualJsDefault.default(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) return false;
        }
    }
    return true;
}
exports.default = baseIsMatch;

},{"./_Stack.js":"dCpM5","./_baseIsEqual.js":"1zaYh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2HQJS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isStrictComparableJs = require("./_isStrictComparable.js");
var _isStrictComparableJsDefault = parcelHelpers.interopDefault(_isStrictComparableJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */ function getMatchData(object) {
    var result = _keysJsDefault.default(object), length = result.length;
    while(length--){
        var key = result[length], value = object[key];
        result[length] = [
            key,
            value,
            _isStrictComparableJsDefault.default(value)
        ];
    }
    return result;
}
exports.default = getMatchData;

},{"./_isStrictComparable.js":"ksPGX","./keys.js":"lbEZV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ksPGX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */ function isStrictComparable(value) {
    return value === value && !_isObjectJsDefault.default(value);
}
exports.default = isStrictComparable;

},{"./isObject.js":"dHhyW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"19Pwe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */ function matchesStrictComparable(key, srcValue) {
    return function(object) {
        if (object == null) return false;
        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
}
exports.default = matchesStrictComparable;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4hv6L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIsEqualJs = require("./_baseIsEqual.js");
var _baseIsEqualJsDefault = parcelHelpers.interopDefault(_baseIsEqualJs);
var _getJs = require("./get.js");
var _getJsDefault = parcelHelpers.interopDefault(_getJs);
var _hasInJs = require("./hasIn.js");
var _hasInJsDefault = parcelHelpers.interopDefault(_hasInJs);
var _isKeyJs = require("./_isKey.js");
var _isKeyJsDefault = parcelHelpers.interopDefault(_isKeyJs);
var _isStrictComparableJs = require("./_isStrictComparable.js");
var _isStrictComparableJsDefault = parcelHelpers.interopDefault(_isStrictComparableJs);
var _matchesStrictComparableJs = require("./_matchesStrictComparable.js");
var _matchesStrictComparableJsDefault = parcelHelpers.interopDefault(_matchesStrictComparableJs);
var _toKeyJs = require("./_toKey.js");
var _toKeyJsDefault = parcelHelpers.interopDefault(_toKeyJs);
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */ function baseMatchesProperty(path, srcValue) {
    if (_isKeyJsDefault.default(path) && _isStrictComparableJsDefault.default(srcValue)) return _matchesStrictComparableJsDefault.default(_toKeyJsDefault.default(path), srcValue);
    return function(object) {
        var objValue = _getJsDefault.default(object, path);
        return objValue === undefined && objValue === srcValue ? _hasInJsDefault.default(object, path) : _baseIsEqualJsDefault.default(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
}
exports.default = baseMatchesProperty;

},{"./_baseIsEqual.js":"1zaYh","./get.js":"9ZP5X","./hasIn.js":"jfq4F","./_isKey.js":"h7SfK","./_isStrictComparable.js":"ksPGX","./_matchesStrictComparable.js":"19Pwe","./_toKey.js":"Zo68s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eHrfS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseEachJs = require("./_baseEach.js");
var _baseEachJsDefault = parcelHelpers.interopDefault(_baseEachJs);
var _isArrayLikeJs = require("./isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */ function baseMap(collection1, iteratee) {
    var index = -1, result = _isArrayLikeJsDefault.default(collection1) ? Array(collection1.length) : [];
    _baseEachJsDefault.default(collection1, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
    });
    return result;
}
exports.default = baseMap;

},{"./_baseEach.js":"cgTz5","./isArrayLike.js":"8SdiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cgTz5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseForOwnJs = require("./_baseForOwn.js");
var _baseForOwnJsDefault = parcelHelpers.interopDefault(_baseForOwnJs);
var _createBaseEachJs = require("./_createBaseEach.js");
var _createBaseEachJsDefault = parcelHelpers.interopDefault(_createBaseEachJs);
/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */ var baseEach = _createBaseEachJsDefault.default(_baseForOwnJsDefault.default);
exports.default = baseEach;

},{"./_baseForOwn.js":"bGCTn","./_createBaseEach.js":"5mXl9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bGCTn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseForJs = require("./_baseFor.js");
var _baseForJsDefault = parcelHelpers.interopDefault(_baseForJs);
var _keysJs = require("./keys.js");
var _keysJsDefault = parcelHelpers.interopDefault(_keysJs);
/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */ function baseForOwn(object, iteratee) {
    return object && _baseForJsDefault.default(object, iteratee, _keysJsDefault.default);
}
exports.default = baseForOwn;

},{"./_baseFor.js":"1Zprl","./keys.js":"lbEZV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Zprl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _createBaseForJs = require("./_createBaseFor.js");
var _createBaseForJsDefault = parcelHelpers.interopDefault(_createBaseForJs);
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */ var baseFor = _createBaseForJsDefault.default();
exports.default = baseFor;

},{"./_createBaseFor.js":"1W89a","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1W89a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */ function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while(length--){
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) break;
        }
        return object;
    };
}
exports.default = createBaseFor;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5mXl9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isArrayLikeJs = require("./isArrayLike.js");
var _isArrayLikeJsDefault = parcelHelpers.interopDefault(_isArrayLikeJs);
/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */ function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
        if (collection == null) return collection;
        if (!_isArrayLikeJsDefault.default(collection)) return eachFunc(collection, iteratee);
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while(fromRight ? index-- : ++index < length){
            if (iteratee(iterable[index], index, iterable) === false) break;
        }
        return collection;
    };
}
exports.default = createBaseEach;

},{"./isArrayLike.js":"8SdiO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h9y0s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */ function baseSortBy(array, comparer) {
    var length = array.length;
    array.sort(comparer);
    while(length--)array[length] = array[length].value;
    return array;
}
exports.default = baseSortBy;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3O3PE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _compareAscendingJs = require("./_compareAscending.js");
var _compareAscendingJsDefault = parcelHelpers.interopDefault(_compareAscendingJs);
/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */ function compareMultiple(object, other, orders) {
    var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
    while(++index < length){
        var result = _compareAscendingJsDefault.default(objCriteria[index], othCriteria[index]);
        if (result) {
            if (index >= ordersLength) return result;
            var order = orders[index];
            return result * (order == 'desc' ? -1 : 1);
        }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
}
exports.default = compareMultiple;

},{"./_compareAscending.js":"3NsI7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3NsI7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isSymbolJs = require("./isSymbol.js");
var _isSymbolJsDefault = parcelHelpers.interopDefault(_isSymbolJs);
/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */ function compareAscending(value, other) {
    if (value !== other) {
        var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = _isSymbolJsDefault.default(value);
        var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = _isSymbolJsDefault.default(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) return 1;
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1;
    }
    return 0;
}
exports.default = compareAscending;

},{"./isSymbol.js":"gCyRJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1fKJX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
var _overRestJs = require("./_overRest.js");
var _overRestJsDefault = parcelHelpers.interopDefault(_overRestJs);
var _setToStringJs = require("./_setToString.js");
var _setToStringJsDefault = parcelHelpers.interopDefault(_setToStringJs);
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */ function baseRest(func, start) {
    return _setToStringJsDefault.default(_overRestJsDefault.default(func, start, _identityJsDefault.default), func + '');
}
exports.default = baseRest;

},{"./identity.js":"1Y0KA","./_overRest.js":"d1Uaz","./_setToString.js":"3GXSg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"feLWk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseSumJs = require("./_baseSum.js");
var _baseSumJsDefault = parcelHelpers.interopDefault(_baseSumJs);
var _identityJs = require("./identity.js");
var _identityJsDefault = parcelHelpers.interopDefault(_identityJs);
/**
 * Computes the sum of the values in `array`.
 *
 * @static
 * @memberOf _
 * @since 3.4.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {number} Returns the sum.
 * @example
 *
 * _.sum([4, 2, 8, 6]);
 * // => 20
 */ function sum(array) {
    return array && array.length ? _baseSumJsDefault.default(array, _identityJsDefault.default) : 0;
}
exports.default = sum;

},{"./_baseSum.js":"fLeWk","./identity.js":"1Y0KA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fLeWk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.sum` and `_.sumBy` without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the sum.
 */ function baseSum(array, iteratee) {
    var result, index = -1, length = array.length;
    while(++index < length){
        var current = iteratee(array[index]);
        if (current !== undefined) result = result === undefined ? current : result + current;
    }
    return result;
}
exports.default = baseSum;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"57kq6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseUniqJs = require("./_baseUniq.js");
var _baseUniqJsDefault = parcelHelpers.interopDefault(_baseUniqJs);
/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */ function uniq(array) {
    return array && array.length ? _baseUniqJsDefault.default(array) : [];
}
exports.default = uniq;

},{"./_baseUniq.js":"g6Jw9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g6Jw9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setCacheJs = require("./_SetCache.js");
var _setCacheJsDefault = parcelHelpers.interopDefault(_setCacheJs);
var _arrayIncludesJs = require("./_arrayIncludes.js");
var _arrayIncludesJsDefault = parcelHelpers.interopDefault(_arrayIncludesJs);
var _arrayIncludesWithJs = require("./_arrayIncludesWith.js");
var _arrayIncludesWithJsDefault = parcelHelpers.interopDefault(_arrayIncludesWithJs);
var _cacheHasJs = require("./_cacheHas.js");
var _cacheHasJsDefault = parcelHelpers.interopDefault(_cacheHasJs);
var _createSetJs = require("./_createSet.js");
var _createSetJsDefault = parcelHelpers.interopDefault(_createSetJs);
var _setToArrayJs = require("./_setToArray.js");
var _setToArrayJsDefault = parcelHelpers.interopDefault(_setToArrayJs);
/** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;
/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */ function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = _arrayIncludesJsDefault.default, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
        isCommon = false;
        includes = _arrayIncludesWithJsDefault.default;
    } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : _createSetJsDefault.default(array);
        if (set) return _setToArrayJsDefault.default(set);
        isCommon = false;
        includes = _cacheHasJsDefault.default;
        seen = new _setCacheJsDefault.default;
    } else seen = iteratee ? [] : result;
    outer: while(++index < length){
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while(seenIndex--){
                if (seen[seenIndex] === computed) continue outer;
            }
            if (iteratee) seen.push(computed);
            result.push(value);
        } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) seen.push(computed);
            result.push(value);
        }
    }
    return result;
}
exports.default = baseUniq;

},{"./_SetCache.js":"6YwQx","./_arrayIncludes.js":"b8a5u","./_arrayIncludesWith.js":"bGuRD","./_cacheHas.js":"jSrgN","./_createSet.js":"6FD4V","./_setToArray.js":"2ugef","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b8a5u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIndexOfJs = require("./_baseIndexOf.js");
var _baseIndexOfJsDefault = parcelHelpers.interopDefault(_baseIndexOfJs);
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && _baseIndexOfJsDefault.default(array, value, 0) > -1;
}
exports.default = arrayIncludes;

},{"./_baseIndexOf.js":"5Q55M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Q55M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseFindIndexJs = require("./_baseFindIndex.js");
var _baseFindIndexJsDefault = parcelHelpers.interopDefault(_baseFindIndexJs);
var _baseIsNaNJs = require("./_baseIsNaN.js");
var _baseIsNaNJsDefault = parcelHelpers.interopDefault(_baseIsNaNJs);
var _strictIndexOfJs = require("./_strictIndexOf.js");
var _strictIndexOfJsDefault = parcelHelpers.interopDefault(_strictIndexOfJs);
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseIndexOf(array, value, fromIndex) {
    return value === value ? _strictIndexOfJsDefault.default(array, value, fromIndex) : _baseFindIndexJsDefault.default(array, _baseIsNaNJsDefault.default, fromIndex);
}
exports.default = baseIndexOf;

},{"./_baseFindIndex.js":"12Lgh","./_baseIsNaN.js":"3FBze","./_strictIndexOf.js":"dm4sG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"12Lgh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while(fromRight ? index-- : ++index < length){
        if (predicate(array[index], index, array)) return index;
    }
    return -1;
}
exports.default = baseFindIndex;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3FBze":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */ function baseIsNaN(value) {
    return value !== value;
}
exports.default = baseIsNaN;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dm4sG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while(++index < length){
        if (array[index] === value) return index;
    }
    return -1;
}
exports.default = strictIndexOf;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bGuRD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array == null ? 0 : array.length;
    while(++index < length){
        if (comparator(value, array[index])) return true;
    }
    return false;
}
exports.default = arrayIncludesWith;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6FD4V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setJs = require("./_Set.js");
var _setJsDefault = parcelHelpers.interopDefault(_setJs);
var _noopJs = require("./noop.js");
var _noopJsDefault = parcelHelpers.interopDefault(_noopJs);
var _setToArrayJs = require("./_setToArray.js");
var _setToArrayJsDefault = parcelHelpers.interopDefault(_setToArrayJs);
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */ var createSet = !(_setJsDefault.default && 1 / _setToArrayJsDefault.default(new _setJsDefault.default([
    ,
    -0
]))[1] == INFINITY) ? _noopJsDefault.default : function(values) {
    return new _setJsDefault.default(values);
};
exports.default = createSet;

},{"./_Set.js":"jf3T7","./noop.js":"9q6VJ","./_setToArray.js":"2ugef","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eZnwu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIterateeJs = require("./_baseIteratee.js");
var _baseIterateeJsDefault = parcelHelpers.interopDefault(_baseIterateeJs);
var _baseUniqJs = require("./_baseUniq.js");
var _baseUniqJsDefault = parcelHelpers.interopDefault(_baseUniqJs);
/**
 * This method is like `_.uniq` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * uniqueness is computed. The order of result values is determined by the
 * order they occur in the array. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
 * // => [2.1, 1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */ function uniqBy(array, iteratee) {
    return array && array.length ? _baseUniqJsDefault.default(array, _baseIterateeJsDefault.default(iteratee, 2)) : [];
}
exports.default = uniqBy;

},{"./_baseIteratee.js":"48kCP","./_baseUniq.js":"g6Jw9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6UDxA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseUniqJs = require("./_baseUniq.js");
var _baseUniqJsDefault = parcelHelpers.interopDefault(_baseUniqJs);
/**
 * This method is like `_.uniq` except that it accepts `comparator` which
 * is invoked to compare elements of `array`. The order of result values is
 * determined by the order they occur in the array.The comparator is invoked
 * with two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.uniqWith(objects, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 */ function uniqWith(array, comparator) {
    comparator = typeof comparator == 'function' ? comparator : undefined;
    return array && array.length ? _baseUniqJsDefault.default(array, undefined, comparator) : [];
}
exports.default = uniqWith;

},{"./_baseUniq.js":"g6Jw9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j1DxS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayFilterJs = require("./_arrayFilter.js");
var _arrayFilterJsDefault = parcelHelpers.interopDefault(_arrayFilterJs);
var _arrayMapJs = require("./_arrayMap.js");
var _arrayMapJsDefault = parcelHelpers.interopDefault(_arrayMapJs);
var _basePropertyJs = require("./_baseProperty.js");
var _basePropertyJsDefault = parcelHelpers.interopDefault(_basePropertyJs);
var _baseTimesJs = require("./_baseTimes.js");
var _baseTimesJsDefault = parcelHelpers.interopDefault(_baseTimesJs);
var _isArrayLikeObjectJs = require("./isArrayLikeObject.js");
var _isArrayLikeObjectJsDefault = parcelHelpers.interopDefault(_isArrayLikeObjectJs);
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max;
/**
 * This method is like `_.zip` except that it accepts an array of grouped
 * elements and creates an array regrouping the elements to their pre-zip
 * configuration.
 *
 * @static
 * @memberOf _
 * @since 1.2.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @returns {Array} Returns the new array of regrouped elements.
 * @example
 *
 * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
 * // => [['a', 1, true], ['b', 2, false]]
 *
 * _.unzip(zipped);
 * // => [['a', 'b'], [1, 2], [true, false]]
 */ function unzip(array) {
    if (!(array && array.length)) return [];
    var length = 0;
    array = _arrayFilterJsDefault.default(array, function(group) {
        if (_isArrayLikeObjectJsDefault.default(group)) {
            length = nativeMax(group.length, length);
            return true;
        }
    });
    return _baseTimesJsDefault.default(length, function(index) {
        return _arrayMapJsDefault.default(array, _basePropertyJsDefault.default(index));
    });
}
exports.default = unzip;

},{"./_arrayFilter.js":"iZqHX","./_arrayMap.js":"gDCVM","./_baseProperty.js":"gAjZk","./_baseTimes.js":"6yWeR","./isArrayLikeObject.js":"gArhC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bc76B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _applyJs = require("./_apply.js");
var _applyJsDefault = parcelHelpers.interopDefault(_applyJs);
var _arrayMapJs = require("./_arrayMap.js");
var _arrayMapJsDefault = parcelHelpers.interopDefault(_arrayMapJs);
var _unzipJs = require("./unzip.js");
var _unzipJsDefault = parcelHelpers.interopDefault(_unzipJs);
/**
 * This method is like `_.unzip` except that it accepts `iteratee` to specify
 * how regrouped values should be combined. The iteratee is invoked with the
 * elements of each group: (...group).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @param {Function} [iteratee=_.identity] The function to combine
 *  regrouped values.
 * @returns {Array} Returns the new array of regrouped elements.
 * @example
 *
 * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
 * // => [[1, 10, 100], [2, 20, 200]]
 *
 * _.unzipWith(zipped, _.add);
 * // => [3, 30, 300]
 */ function unzipWith(array, iteratee) {
    if (!(array && array.length)) return [];
    var result = _unzipJsDefault.default(array);
    if (iteratee == null) return result;
    return _arrayMapJsDefault.default(result, function(group) {
        return _applyJsDefault.default(iteratee, undefined, group);
    });
}
exports.default = unzipWith;

},{"./_apply.js":"kqJ3H","./_arrayMap.js":"gDCVM","./unzip.js":"j1DxS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1agvX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseRestJs = require("./_baseRest.js");
var _baseRestJsDefault = parcelHelpers.interopDefault(_baseRestJs);
var _unzipWithJs = require("./unzipWith.js");
var _unzipWithJsDefault = parcelHelpers.interopDefault(_unzipWithJs);
/**
 * This method is like `_.zip` except that it accepts `iteratee` to specify
 * how grouped values should be combined. The iteratee is invoked with the
 * elements of each group: (...group).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Array
 * @param {...Array} [arrays] The arrays to process.
 * @param {Function} [iteratee=_.identity] The function to combine
 *  grouped values.
 * @returns {Array} Returns the new array of grouped elements.
 * @example
 *
 * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
 *   return a + b + c;
 * });
 * // => [111, 222]
 */ var zipWith = _baseRestJsDefault.default(function(arrays) {
    var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
    iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
    return _unzipWithJsDefault.default(arrays, iteratee);
});
exports.default = zipWith;

},{"./_baseRest.js":"1fKJX","./unzipWith.js":"bc76B","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"idVgO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PicoGL", ()=>PicoGL
);
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////
var _constantsJs = require("./constants.js");
var _appJs = require("./app.js");
let webglInfoInitialized = false;
const PicoGL = Object.assign({
    /**
        The version of PicoGL

        @type {string}
        @name PicoGL.version
        @private
     */ version: "0.17.9",
    WEBGL_INFO: /**
        WebGL information about the current system

        @type {Object.<string, *>}
        @name PicoGL.WEBGL_INFO
        @private
     */ _constantsJs.WEBGL_INFO,
    /**
        Create a PicoGL app. The app is the primary entry point to PicoGL. It stores
        the canvas, the WebGL context and all WebGL state.

        @function PicoGL.createApp
        @param {HTMLElement} canvas The canvas on which to create the WebGL context.
        @param {Object} [contextAttributes] Context attributes to pass when calling getContext().
        @return {App} New App object.
    */ createApp (gl, contextAttributes) {
        // Support providing a canvas and getting a WebGL 2 context
        if (gl.tagName === "CANVAS") gl = gl.getContext("webgl2", contextAttributes);
        if (!webglInfoInitialized) {
            _constantsJs.WEBGL_INFO.MAX_TEXTURE_UNITS = gl.getParameter(_constantsJs.GL.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            _constantsJs.WEBGL_INFO.MAX_UNIFORM_BUFFERS = gl.getParameter(_constantsJs.GL.MAX_UNIFORM_BUFFER_BINDINGS);
            _constantsJs.WEBGL_INFO.MAX_UNIFORMS = Math.min(gl.getParameter(_constantsJs.GL.MAX_VERTEX_UNIFORM_VECTORS), gl.getParameter(_constantsJs.GL.MAX_FRAGMENT_UNIFORM_VECTORS));
            _constantsJs.WEBGL_INFO.SAMPLES = gl.getParameter(_constantsJs.GL.SAMPLES);
            _constantsJs.WEBGL_INFO.VENDOR = "(Unknown)";
            _constantsJs.WEBGL_INFO.RENDERER = "(Unknown)";
            // Extensions
            _constantsJs.WEBGL_INFO.FLOAT_RENDER_TARGETS = Boolean(gl.getExtension("EXT_color_buffer_float"));
            _constantsJs.WEBGL_INFO.LINEAR_FLOAT_TEXTURES = Boolean(gl.getExtension("OES_texture_float_linear"));
            _constantsJs.WEBGL_INFO.S3TC_TEXTURES = Boolean(gl.getExtension("WEBGL_compressed_texture_s3tc"));
            _constantsJs.WEBGL_INFO.S3TC_SRGB_TEXTURES = Boolean(gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"));
            _constantsJs.WEBGL_INFO.ETC_TEXTURES = Boolean(gl.getExtension("WEBGL_compressed_texture_etc"));
            _constantsJs.WEBGL_INFO.ASTC_TEXTURES = Boolean(gl.getExtension("WEBGL_compressed_texture_astc"));
            _constantsJs.WEBGL_INFO.PVRTC_TEXTURES = Boolean(gl.getExtension("WEBGL_compressed_texture_pvrtc"));
            _constantsJs.WEBGL_INFO.LOSE_CONTEXT = Boolean(gl.getExtension("WEBGL_lose_context"));
            _constantsJs.WEBGL_INFO.DEBUG_SHADERS = Boolean(gl.getExtension("WEBGL_debug_shaders"));
            _constantsJs.WEBGL_INFO.GPU_TIMER = Boolean(gl.getExtension("EXT_disjoint_timer_query_webgl2") || gl.getExtension("EXT_disjoint_timer_query"));
            _constantsJs.WEBGL_INFO.TEXTURE_ANISOTROPY = Boolean(gl.getExtension("EXT_texture_filter_anisotropic"));
            _constantsJs.WEBGL_INFO.MAX_TEXTURE_ANISOTROPY = _constantsJs.WEBGL_INFO.TEXTURE_ANISOTROPY ? gl.getParameter(_constantsJs.GL.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
            _constantsJs.WEBGL_INFO.DEBUG_RENDERER_INFO = Boolean(gl.getExtension("WEBGL_debug_renderer_info"));
            if (_constantsJs.WEBGL_INFO.DEBUG_RENDERER_INFO) {
                _constantsJs.WEBGL_INFO.VENDOR = gl.getParameter(_constantsJs.GL.UNMASKED_VENDOR_WEBGL);
                _constantsJs.WEBGL_INFO.RENDERER = gl.getParameter(_constantsJs.GL.UNMASKED_RENDERER_WEBGL);
            }
            // Draft extensions
            _constantsJs.WEBGL_INFO.PARALLEL_SHADER_COMPILE = Boolean(gl.getExtension("KHR_parallel_shader_compile"));
            _constantsJs.WEBGL_INFO.MULTI_DRAW_INSTANCED = Boolean(gl.getExtension("WEBGL_multi_draw_instanced"));
            _constantsJs.WEBGL_INFO.DRAW_INSTANCED_BASE_VERTEX_BASE_INSTANCE = Boolean(gl.getExtension("WEBGL_draw_instanced_base_vertex_base_instance"));
            _constantsJs.WEBGL_INFO.MULTI_DRAW_INSTANCED_BASE_VERTEX_BASE_INSTANCE = Boolean(gl.getExtension("WEBGL_multi_draw_instanced_base_vertex_base_instance"));
            webglInfoInitialized = true;
        }
        return new _appJs.App(gl);
    }
}, _constantsJs.GL);
exports.default = PicoGL;

},{"./constants.js":"jCl2R","./app.js":"gBzmW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jCl2R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GL", ()=>GL
);
parcelHelpers.export(exports, "TYPE_SIZE", ()=>TYPE_SIZE
);
parcelHelpers.export(exports, "TEXTURE_FORMATS", ()=>TEXTURE_FORMATS
);
parcelHelpers.export(exports, "COMPRESSED_TEXTURE_TYPES", ()=>COMPRESSED_TEXTURE_TYPES
);
parcelHelpers.export(exports, "WEBGL_INFO", ()=>WEBGL_INFO
);
parcelHelpers.export(exports, "DUMMY_UNIT_ARRAY", ()=>DUMMY_UNIT_ARRAY
);
parcelHelpers.export(exports, "DUMMY_OBJECT", ()=>DUMMY_OBJECT
);
parcelHelpers.export(exports, "TEXTURE_FORMAT_DEFAULTS", ()=>TEXTURE_FORMAT_DEFAULTS
);
const GL = {
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_BUFFER_BIT
        @private
     */ DEPTH_BUFFER_BIT: 256,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BUFFER_BIT
        @private
     */ STENCIL_BUFFER_BIT: 1024,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_BUFFER_BIT
        @private
     */ COLOR_BUFFER_BIT: 16384,
    /**
        @type {GLenum}
        @name PicoGL.POINTS
        @private
     */ POINTS: 0,
    /**
        @type {GLenum}
        @name PicoGL.LINES
        @private
     */ LINES: 1,
    /**
        @type {GLenum}
        @name PicoGL.LINE_LOOP
        @private
     */ LINE_LOOP: 2,
    /**
        @type {GLenum}
        @name PicoGL.LINE_STRIP
        @private
     */ LINE_STRIP: 3,
    /**
        @type {GLenum}
        @name PicoGL.TRIANGLES
        @private
     */ TRIANGLES: 4,
    /**
        @type {GLenum}
        @name PicoGL.TRIANGLE_STRIP
        @private
     */ TRIANGLE_STRIP: 5,
    /**
        @type {GLenum}
        @name PicoGL.TRIANGLE_FAN
        @private
     */ TRIANGLE_FAN: 6,
    /**
        @type {GLenum}
        @name PicoGL.ZERO
        @private
     */ ZERO: 0,
    /**
        @type {GLenum}
        @name PicoGL.ONE
        @private
     */ ONE: 1,
    /**
        @type {GLenum}
        @name PicoGL.SRC_COLOR
        @private
     */ SRC_COLOR: 768,
    /**
        @type {GLenum}
        @name PicoGL.ONE_MINUS_SRC_COLOR
        @private
     */ ONE_MINUS_SRC_COLOR: 769,
    /**
        @type {GLenum}
        @name PicoGL.SRC_ALPHA
        @private
     */ SRC_ALPHA: 770,
    /**
        @type {GLenum}
        @name PicoGL.ONE_MINUS_SRC_ALPHA
        @private
     */ ONE_MINUS_SRC_ALPHA: 771,
    /**
        @type {GLenum}
        @name PicoGL.DST_ALPHA
        @private
     */ DST_ALPHA: 772,
    /**
        @type {GLenum}
        @name PicoGL.ONE_MINUS_DST_ALPHA
        @private
     */ ONE_MINUS_DST_ALPHA: 773,
    /**
        @type {GLenum}
        @name PicoGL.DST_COLOR
        @private
     */ DST_COLOR: 774,
    /**
        @type {GLenum}
        @name PicoGL.ONE_MINUS_DST_COLOR
        @private
     */ ONE_MINUS_DST_COLOR: 775,
    /**
        @type {GLenum}
        @name PicoGL.SRC_ALPHA_SATURATE
        @private
     */ SRC_ALPHA_SATURATE: 776,
    /**
        @type {GLenum}
        @name PicoGL.FUNC_ADD
        @private
     */ FUNC_ADD: 32774,
    /**
        @type {GLenum}
        @name PicoGL.BLEND_EQUATION
        @private
     */ BLEND_EQUATION: 32777,
    /**
        @type {GLenum}
        @name PicoGL.BLEND_EQUATION_RGB
        @private
     */ BLEND_EQUATION_RGB: 32777,
    /**
        @type {GLenum}
        @name PicoGL.BLEND_EQUATION_ALPHA
        @private
     */ BLEND_EQUATION_ALPHA: 34877,
    /**
        @type {GLenum}
        @name PicoGL.FUNC_SUBTRACT
        @private
     */ FUNC_SUBTRACT: 32778,
    /**
        @type {GLenum}
        @name PicoGL.FUNC_REVERSE_SUBTRACT
        @private
     */ FUNC_REVERSE_SUBTRACT: 32779,
    /**
        @type {GLenum}
        @name PicoGL.BLEND_DST_RGB
        @private
     */ BLEND_DST_RGB: 32968,
    /**
        @type {GLenum}
        @name PicoGL.BLEND_SRC_RGB
        @private
     */ BLEND_SRC_RGB: 32969,
    /**
        @type {GLenum}
        @name PicoGL.BLEND_DST_ALPHA
        @private
     */ BLEND_DST_ALPHA: 32970,
    /**
        @type {GLenum}
        @name PicoGL.BLEND_SRC_ALPHA
        @private
     */ BLEND_SRC_ALPHA: 32971,
    /**
        @type {GLenum}
        @name PicoGL.CONSTANT_COLOR
        @private
     */ CONSTANT_COLOR: 32769,
    /**
        @type {GLenum}
        @name PicoGL.ONE_MINUS_CONSTANT_COLOR
        @private
     */ ONE_MINUS_CONSTANT_COLOR: 32770,
    /**
        @type {GLenum}
        @name PicoGL.CONSTANT_ALPHA
        @private
     */ CONSTANT_ALPHA: 32771,
    /**
        @type {GLenum}
        @name PicoGL.ONE_MINUS_CONSTANT_ALPHA
        @private
     */ ONE_MINUS_CONSTANT_ALPHA: 32772,
    /**
        @type {GLenum}
        @name PicoGL.BLEND_COLOR
        @private
     */ BLEND_COLOR: 32773,
    /**
        @type {GLenum}
        @name PicoGL.ARRAY_BUFFER
        @private
     */ ARRAY_BUFFER: 34962,
    /**
        @type {GLenum}
        @name PicoGL.ELEMENT_ARRAY_BUFFER
        @private
     */ ELEMENT_ARRAY_BUFFER: 34963,
    /**
        @type {GLenum}
        @name PicoGL.ARRAY_BUFFER_BINDING
        @private
     */ ARRAY_BUFFER_BINDING: 34964,
    /**
        @type {GLenum}
        @name PicoGL.ELEMENT_ARRAY_BUFFER_BINDING
        @private
     */ ELEMENT_ARRAY_BUFFER_BINDING: 34965,
    /**
        @type {GLenum}
        @name PicoGL.STREAM_DRAW
        @private
     */ STREAM_DRAW: 35040,
    /**
        @type {GLenum}
        @name PicoGL.STATIC_DRAW
        @private
     */ STATIC_DRAW: 35044,
    /**
        @type {GLenum}
        @name PicoGL.DYNAMIC_DRAW
        @private
     */ DYNAMIC_DRAW: 35048,
    /**
        @type {GLenum}
        @name PicoGL.BUFFER_SIZE
        @private
     */ BUFFER_SIZE: 34660,
    /**
        @type {GLenum}
        @name PicoGL.BUFFER_USAGE
        @private
     */ BUFFER_USAGE: 34661,
    /**
        @type {GLenum}
        @name PicoGL.CURRENT_VERTEX_ATTRIB
        @private
     */ CURRENT_VERTEX_ATTRIB: 34342,
    /**
        @type {GLenum}
        @name PicoGL.FRONT
        @private
     */ FRONT: 1028,
    /**
        @type {GLenum}
        @name PicoGL.BACK
        @private
     */ BACK: 1029,
    /**
        @type {GLenum}
        @name PicoGL.FRONT_AND_BACK
        @private
     */ FRONT_AND_BACK: 1032,
    /**
        @type {GLenum}
        @name PicoGL.CULL_FACE
        @private
     */ CULL_FACE: 2884,
    /**
        @type {GLenum}
        @name PicoGL.BLEND
        @private
     */ BLEND: 3042,
    /**
        @type {GLenum}
        @name PicoGL.DITHER
        @private
     */ DITHER: 3024,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_TEST
        @private
     */ STENCIL_TEST: 2960,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_TEST
        @private
     */ DEPTH_TEST: 2929,
    /**
        @type {GLenum}
        @name PicoGL.SCISSOR_TEST
        @private
     */ SCISSOR_TEST: 3089,
    /**
        @type {GLenum}
        @name PicoGL.POLYGON_OFFSET_FILL
        @private
     */ POLYGON_OFFSET_FILL: 32823,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLE_ALPHA_TO_COVERAGE
        @private
     */ SAMPLE_ALPHA_TO_COVERAGE: 32926,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLE_COVERAGE
        @private
     */ SAMPLE_COVERAGE: 32928,
    /**
        @type {GLenum}
        @name PicoGL.NO_ERROR
        @private
     */ NO_ERROR: 0,
    /**
        @type {GLenum}
        @name PicoGL.INVALID_ENUM
        @private
     */ INVALID_ENUM: 1280,
    /**
        @type {GLenum}
        @name PicoGL.INVALID_VALUE
        @private
     */ INVALID_VALUE: 1281,
    /**
        @type {GLenum}
        @name PicoGL.INVALID_OPERATION
        @private
     */ INVALID_OPERATION: 1282,
    /**
        @type {GLenum}
        @name PicoGL.OUT_OF_MEMORY
        @private
     */ OUT_OF_MEMORY: 1285,
    /**
        @type {GLenum}
        @name PicoGL.CW
        @private
     */ CW: 2304,
    /**
        @type {GLenum}
        @name PicoGL.CCW
        @private
     */ CCW: 2305,
    /**
        @type {GLenum}
        @name PicoGL.LINE_WIDTH
        @private
     */ LINE_WIDTH: 2849,
    /**
        @type {GLenum}
        @name PicoGL.ALIASED_POINT_SIZE_RANGE
        @private
     */ ALIASED_POINT_SIZE_RANGE: 33901,
    /**
        @type {GLenum}
        @name PicoGL.ALIASED_LINE_WIDTH_RANGE
        @private
     */ ALIASED_LINE_WIDTH_RANGE: 33902,
    /**
        @type {GLenum}
        @name PicoGL.CULL_FACE_MODE
        @private
     */ CULL_FACE_MODE: 2885,
    /**
        @type {GLenum}
        @name PicoGL.FRONT_FACE
        @private
     */ FRONT_FACE: 2886,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_RANGE
        @private
     */ DEPTH_RANGE: 2928,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_WRITEMASK
        @private
     */ DEPTH_WRITEMASK: 2930,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_CLEAR_VALUE
        @private
     */ DEPTH_CLEAR_VALUE: 2931,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_FUNC
        @private
     */ DEPTH_FUNC: 2932,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_CLEAR_VALUE
        @private
     */ STENCIL_CLEAR_VALUE: 2961,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_FUNC
        @private
     */ STENCIL_FUNC: 2962,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_FAIL
        @private
     */ STENCIL_FAIL: 2964,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_PASS_DEPTH_FAIL
        @private
     */ STENCIL_PASS_DEPTH_FAIL: 2965,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_PASS_DEPTH_PASS
        @private
     */ STENCIL_PASS_DEPTH_PASS: 2966,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_REF
        @private
     */ STENCIL_REF: 2967,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_VALUE_MASK
        @private
     */ STENCIL_VALUE_MASK: 2963,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_WRITEMASK
        @private
     */ STENCIL_WRITEMASK: 2968,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BACK_FUNC
        @private
     */ STENCIL_BACK_FUNC: 34816,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BACK_FAIL
        @private
     */ STENCIL_BACK_FAIL: 34817,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BACK_PASS_DEPTH_FAIL
        @private
     */ STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BACK_PASS_DEPTH_PASS
        @private
     */ STENCIL_BACK_PASS_DEPTH_PASS: 34819,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BACK_REF
        @private
     */ STENCIL_BACK_REF: 36003,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BACK_VALUE_MASK
        @private
     */ STENCIL_BACK_VALUE_MASK: 36004,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BACK_WRITEMASK
        @private
     */ STENCIL_BACK_WRITEMASK: 36005,
    /**
        @type {GLenum}
        @name PicoGL.VIEWPORT
        @private
     */ VIEWPORT: 2978,
    /**
        @type {GLenum}
        @name PicoGL.SCISSOR_BOX
        @private
     */ SCISSOR_BOX: 3088,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_CLEAR_VALUE
        @private
     */ COLOR_CLEAR_VALUE: 3106,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_WRITEMASK
        @private
     */ COLOR_WRITEMASK: 3107,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_ALIGNMENT
        @private
     */ UNPACK_ALIGNMENT: 3317,
    /**
        @type {GLenum}
        @name PicoGL.PACK_ALIGNMENT
        @private
     */ PACK_ALIGNMENT: 3333,
    /**
        @type {GLenum}
        @name PicoGL.MAX_TEXTURE_SIZE
        @private
     */ MAX_TEXTURE_SIZE: 3379,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VIEWPORT_DIMS
        @private
     */ MAX_VIEWPORT_DIMS: 3386,
    /**
        @type {GLenum}
        @name PicoGL.SUBPIXEL_BITS
        @private
     */ SUBPIXEL_BITS: 3408,
    /**
        @type {GLenum}
        @name PicoGL.RED_BITS
        @private
     */ RED_BITS: 3410,
    /**
        @type {GLenum}
        @name PicoGL.GREEN_BITS
        @private
     */ GREEN_BITS: 3411,
    /**
        @type {GLenum}
        @name PicoGL.BLUE_BITS
        @private
     */ BLUE_BITS: 3412,
    /**
        @type {GLenum}
        @name PicoGL.ALPHA_BITS
        @private
     */ ALPHA_BITS: 3413,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_BITS
        @private
     */ DEPTH_BITS: 3414,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_BITS
        @private
     */ STENCIL_BITS: 3415,
    /**
        @type {GLenum}
        @name PicoGL.POLYGON_OFFSET_UNITS
        @private
     */ POLYGON_OFFSET_UNITS: 10752,
    /**
        @type {GLenum}
        @name PicoGL.POLYGON_OFFSET_FACTOR
        @private
     */ POLYGON_OFFSET_FACTOR: 32824,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_BINDING_2D
        @private
     */ TEXTURE_BINDING_2D: 32873,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLE_BUFFERS
        @private
     */ SAMPLE_BUFFERS: 32936,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLES
        @private
     */ SAMPLES: 32937,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLE_COVERAGE_VALUE
        @private
     */ SAMPLE_COVERAGE_VALUE: 32938,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLE_COVERAGE_INVERT
        @private
     */ SAMPLE_COVERAGE_INVERT: 32939,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_TEXTURE_FORMATS
        @private
     */ COMPRESSED_TEXTURE_FORMATS: 34467,
    /**
        @type {GLenum}
        @name PicoGL.DONT_CARE
        @private
     */ DONT_CARE: 4352,
    /**
        @type {GLenum}
        @name PicoGL.FASTEST
        @private
     */ FASTEST: 4353,
    /**
        @type {GLenum}
        @name PicoGL.NICEST
        @private
     */ NICEST: 4354,
    /**
        @type {GLenum}
        @name PicoGL.GENERATE_MIPMAP_HINT
        @private
     */ GENERATE_MIPMAP_HINT: 33170,
    /**
        @type {GLenum}
        @name PicoGL.BYTE
        @private
     */ BYTE: 5120,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_BYTE
        @private
     */ UNSIGNED_BYTE: 5121,
    /**
        @type {GLenum}
        @name PicoGL.SHORT
        @private
     */ SHORT: 5122,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_SHORT
        @private
     */ UNSIGNED_SHORT: 5123,
    /**
        @type {GLenum}
        @name PicoGL.INT
        @private
     */ INT: 5124,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT
        @private
     */ UNSIGNED_INT: 5125,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT
        @private
     */ FLOAT: 5126,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_COMPONENT
        @private
     */ DEPTH_COMPONENT: 6402,
    /**
        @type {GLenum}
        @name PicoGL.ALPHA
        @private
     */ ALPHA: 6406,
    /**
        @type {GLenum}
        @name PicoGL.RGB
        @private
     */ RGB: 6407,
    /**
        @type {GLenum}
        @name PicoGL.RGBA
        @private
     */ RGBA: 6408,
    /**
        @type {GLenum}
        @name PicoGL.LUMINANCE
        @private
     */ LUMINANCE: 6409,
    /**
        @type {GLenum}
        @name PicoGL.LUMINANCE_ALPHA
        @private
     */ LUMINANCE_ALPHA: 6410,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_SHORT_4_4_4_4
        @private
     */ UNSIGNED_SHORT_4_4_4_4: 32819,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_SHORT_5_5_5_1
        @private
     */ UNSIGNED_SHORT_5_5_5_1: 32820,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_SHORT_5_6_5
        @private
     */ UNSIGNED_SHORT_5_6_5: 33635,
    /**
        @type {GLenum}
        @name PicoGL.FRAGMENT_SHADER
        @private
     */ FRAGMENT_SHADER: 35632,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_SHADER
        @private
     */ VERTEX_SHADER: 35633,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VERTEX_ATTRIBS
        @private
     */ MAX_VERTEX_ATTRIBS: 34921,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VERTEX_UNIFORM_VECTORS
        @private
     */ MAX_VERTEX_UNIFORM_VECTORS: 36347,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VARYING_VECTORS
        @private
     */ MAX_VARYING_VECTORS: 36348,
    /**
        @type {GLenum}
        @name PicoGL.MAX_COMBINED_TEXTURE_IMAGE_UNITS
        @private
     */ MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VERTEX_TEXTURE_IMAGE_UNITS
        @private
     */ MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
    /**
        @type {GLenum}
        @name PicoGL.MAX_TEXTURE_IMAGE_UNITS
        @private
     */ MAX_TEXTURE_IMAGE_UNITS: 34930,
    /**
        @type {GLenum}
        @name PicoGL.MAX_FRAGMENT_UNIFORM_VECTORS
        @private
     */ MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
    /**
        @type {GLenum}
        @name PicoGL.SHADER_TYPE
        @private
     */ SHADER_TYPE: 35663,
    /**
        @type {GLenum}
        @name PicoGL.DELETE_STATUS
        @private
     */ DELETE_STATUS: 35712,
    /**
        @type {GLenum}
        @name PicoGL.LINK_STATUS
        @private
     */ LINK_STATUS: 35714,
    /**
        @type {GLenum}
        @name PicoGL.VALIDATE_STATUS
        @private
     */ VALIDATE_STATUS: 35715,
    /**
        @type {GLenum}
        @name PicoGL.ATTACHED_SHADERS
        @private
     */ ATTACHED_SHADERS: 35717,
    /**
        @type {GLenum}
        @name PicoGL.ACTIVE_UNIFORMS
        @private
     */ ACTIVE_UNIFORMS: 35718,
    /**
        @type {GLenum}
        @name PicoGL.ACTIVE_ATTRIBUTES
        @private
     */ ACTIVE_ATTRIBUTES: 35721,
    /**
        @type {GLenum}
        @name PicoGL.SHADING_LANGUAGE_VERSION
        @private
     */ SHADING_LANGUAGE_VERSION: 35724,
    /**
        @type {GLenum}
        @name PicoGL.CURRENT_PROGRAM
        @private
     */ CURRENT_PROGRAM: 35725,
    /**
        @type {GLenum}
        @name PicoGL.NEVER
        @private
     */ NEVER: 512,
    /**
        @type {GLenum}
        @name PicoGL.LESS
        @private
     */ LESS: 513,
    /**
        @type {GLenum}
        @name PicoGL.EQUAL
        @private
     */ EQUAL: 514,
    /**
        @type {GLenum}
        @name PicoGL.LEQUAL
        @private
     */ LEQUAL: 515,
    /**
        @type {GLenum}
        @name PicoGL.GREATER
        @private
     */ GREATER: 516,
    /**
        @type {GLenum}
        @name PicoGL.NOTEQUAL
        @private
     */ NOTEQUAL: 517,
    /**
        @type {GLenum}
        @name PicoGL.GEQUAL
        @private
     */ GEQUAL: 518,
    /**
        @type {GLenum}
        @name PicoGL.ALWAYS
        @private
     */ ALWAYS: 519,
    /**
        @type {GLenum}
        @name PicoGL.KEEP
        @private
     */ KEEP: 7680,
    /**
        @type {GLenum}
        @name PicoGL.REPLACE
        @private
     */ REPLACE: 7681,
    /**
        @type {GLenum}
        @name PicoGL.INCR
        @private
     */ INCR: 7682,
    /**
        @type {GLenum}
        @name PicoGL.DECR
        @private
     */ DECR: 7683,
    /**
        @type {GLenum}
        @name PicoGL.INVERT
        @private
     */ INVERT: 5386,
    /**
        @type {GLenum}
        @name PicoGL.INCR_WRAP
        @private
     */ INCR_WRAP: 34055,
    /**
        @type {GLenum}
        @name PicoGL.DECR_WRAP
        @private
     */ DECR_WRAP: 34056,
    /**
        @type {GLenum}
        @name PicoGL.VENDOR
        @private
     */ VENDOR: 7936,
    /**
        @type {GLenum}
        @name PicoGL.RENDERER
        @private
     */ RENDERER: 7937,
    /**
        @type {GLenum}
        @name PicoGL.VERSION
        @private
     */ VERSION: 7938,
    /**
        @type {GLenum}
        @name PicoGL.NEAREST
        @private
     */ NEAREST: 9728,
    /**
        @type {GLenum}
        @name PicoGL.LINEAR
        @private
     */ LINEAR: 9729,
    /**
        @type {GLenum}
        @name PicoGL.NEAREST_MIPMAP_NEAREST
        @private
     */ NEAREST_MIPMAP_NEAREST: 9984,
    /**
        @type {GLenum}
        @name PicoGL.LINEAR_MIPMAP_NEAREST
        @private
     */ LINEAR_MIPMAP_NEAREST: 9985,
    /**
        @type {GLenum}
        @name PicoGL.NEAREST_MIPMAP_LINEAR
        @private
     */ NEAREST_MIPMAP_LINEAR: 9986,
    /**
        @type {GLenum}
        @name PicoGL.LINEAR_MIPMAP_LINEAR
        @private
     */ LINEAR_MIPMAP_LINEAR: 9987,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_MAG_FILTER
        @private
     */ TEXTURE_MAG_FILTER: 10240,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_MIN_FILTER
        @private
     */ TEXTURE_MIN_FILTER: 10241,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_WRAP_S
        @private
     */ TEXTURE_WRAP_S: 10242,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_WRAP_T
        @private
     */ TEXTURE_WRAP_T: 10243,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_2D
        @private
     */ TEXTURE_2D: 3553,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE
        @private
     */ TEXTURE: 5890,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_CUBE_MAP
        @private
     */ TEXTURE_CUBE_MAP: 34067,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_BINDING_CUBE_MAP
        @private
     */ TEXTURE_BINDING_CUBE_MAP: 34068,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_CUBE_MAP_POSITIVE_X
        @private
     */ TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_CUBE_MAP_NEGATIVE_X
        @private
     */ TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_CUBE_MAP_POSITIVE_Y
        @private
     */ TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_CUBE_MAP_NEGATIVE_Y
        @private
     */ TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_CUBE_MAP_POSITIVE_Z
        @private
     */ TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_CUBE_MAP_NEGATIVE_Z
        @private
     */ TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
    /**
        @type {GLenum}
        @name PicoGL.MAX_CUBE_MAP_TEXTURE_SIZE
        @private
     */ MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE0
        @private
     */ TEXTURE0: 33984,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE1
        @private
     */ TEXTURE1: 33985,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE2
        @private
     */ TEXTURE2: 33986,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE3
        @private
     */ TEXTURE3: 33987,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE4
        @private
     */ TEXTURE4: 33988,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE5
        @private
     */ TEXTURE5: 33989,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE6
        @private
     */ TEXTURE6: 33990,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE7
        @private
     */ TEXTURE7: 33991,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE8
        @private
     */ TEXTURE8: 33992,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE9
        @private
     */ TEXTURE9: 33993,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE10
        @private
     */ TEXTURE10: 33994,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE11
        @private
     */ TEXTURE11: 33995,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE12
        @private
     */ TEXTURE12: 33996,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE13
        @private
     */ TEXTURE13: 33997,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE14
        @private
     */ TEXTURE14: 33998,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE15
        @private
     */ TEXTURE15: 33999,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE16
        @private
     */ TEXTURE16: 34000,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE17
        @private
     */ TEXTURE17: 34001,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE18
        @private
     */ TEXTURE18: 34002,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE19
        @private
     */ TEXTURE19: 34003,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE20
        @private
     */ TEXTURE20: 34004,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE21
        @private
     */ TEXTURE21: 34005,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE22
        @private
     */ TEXTURE22: 34006,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE23
        @private
     */ TEXTURE23: 34007,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE24
        @private
     */ TEXTURE24: 34008,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE25
        @private
     */ TEXTURE25: 34009,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE26
        @private
     */ TEXTURE26: 34010,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE27
        @private
     */ TEXTURE27: 34011,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE28
        @private
     */ TEXTURE28: 34012,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE29
        @private
     */ TEXTURE29: 34013,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE30
        @private
     */ TEXTURE30: 34014,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE31
        @private
     */ TEXTURE31: 34015,
    /**
        @type {GLenum}
        @name PicoGL.ACTIVE_TEXTURE
        @private
     */ ACTIVE_TEXTURE: 34016,
    /**
        @type {GLenum}
        @name PicoGL.REPEAT
        @private
     */ REPEAT: 10497,
    /**
        @type {GLenum}
        @name PicoGL.CLAMP_TO_EDGE
        @private
     */ CLAMP_TO_EDGE: 33071,
    /**
        @type {GLenum}
        @name PicoGL.MIRRORED_REPEAT
        @private
     */ MIRRORED_REPEAT: 33648,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_VEC2
        @private
     */ FLOAT_VEC2: 35664,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_VEC3
        @private
     */ FLOAT_VEC3: 35665,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_VEC4
        @private
     */ FLOAT_VEC4: 35666,
    /**
        @type {GLenum}
        @name PicoGL.INT_VEC2
        @private
     */ INT_VEC2: 35667,
    /**
        @type {GLenum}
        @name PicoGL.INT_VEC3
        @private
     */ INT_VEC3: 35668,
    /**
        @type {GLenum}
        @name PicoGL.INT_VEC4
        @private
     */ INT_VEC4: 35669,
    /**
        @type {GLenum}
        @name PicoGL.BOOL
        @private
     */ BOOL: 35670,
    /**
        @type {GLenum}
        @name PicoGL.BOOL_VEC2
        @private
     */ BOOL_VEC2: 35671,
    /**
        @type {GLenum}
        @name PicoGL.BOOL_VEC3
        @private
     */ BOOL_VEC3: 35672,
    /**
        @type {GLenum}
        @name PicoGL.BOOL_VEC4
        @private
     */ BOOL_VEC4: 35673,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT2
        @private
     */ FLOAT_MAT2: 35674,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT3
        @private
     */ FLOAT_MAT3: 35675,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT4
        @private
     */ FLOAT_MAT4: 35676,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLER_2D
        @private
     */ SAMPLER_2D: 35678,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLER_CUBE
        @private
     */ SAMPLER_CUBE: 35680,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_ENABLED
        @private
     */ VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_SIZE
        @private
     */ VERTEX_ATTRIB_ARRAY_SIZE: 34339,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_STRIDE
        @private
     */ VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_TYPE
        @private
     */ VERTEX_ATTRIB_ARRAY_TYPE: 34341,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_NORMALIZED
        @private
     */ VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_POINTER
        @private
     */ VERTEX_ATTRIB_ARRAY_POINTER: 34373,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
        @private
     */ VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
    /**
        @type {GLenum}
        @name PicoGL.IMPLEMENTATION_COLOR_READ_TYPE
        @private
     */ IMPLEMENTATION_COLOR_READ_TYPE: 35738,
    /**
        @type {GLenum}
        @name PicoGL.IMPLEMENTATION_COLOR_READ_FORMAT
        @private
     */ IMPLEMENTATION_COLOR_READ_FORMAT: 35739,
    /**
        @type {GLenum}
        @name PicoGL.COMPILE_STATUS
        @private
     */ COMPILE_STATUS: 35713,
    /**
        @type {GLenum}
        @name PicoGL.LOW_FLOAT
        @private
     */ LOW_FLOAT: 36336,
    /**
        @type {GLenum}
        @name PicoGL.MEDIUM_FLOAT
        @private
     */ MEDIUM_FLOAT: 36337,
    /**
        @type {GLenum}
        @name PicoGL.HIGH_FLOAT
        @private
     */ HIGH_FLOAT: 36338,
    /**
        @type {GLenum}
        @name PicoGL.LOW_INT
        @private
     */ LOW_INT: 36339,
    /**
        @type {GLenum}
        @name PicoGL.MEDIUM_INT
        @private
     */ MEDIUM_INT: 36340,
    /**
        @type {GLenum}
        @name PicoGL.HIGH_INT
        @private
     */ HIGH_INT: 36341,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER
        @private
     */ FRAMEBUFFER: 36160,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER
        @private
     */ RENDERBUFFER: 36161,
    /**
        @type {GLenum}
        @name PicoGL.RGBA4
        @private
     */ RGBA4: 32854,
    /**
        @type {GLenum}
        @name PicoGL.RGB5_A1
        @private
     */ RGB5_A1: 32855,
    /**
        @type {GLenum}
        @name PicoGL.RGB565
        @private
     */ RGB565: 36194,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_COMPONENT16
        @private
     */ DEPTH_COMPONENT16: 33189,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_INDEX
        @private
     */ STENCIL_INDEX: 6401,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_INDEX8
        @private
     */ STENCIL_INDEX8: 36168,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_STENCIL
        @private
     */ DEPTH_STENCIL: 34041,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_WIDTH
        @private
     */ RENDERBUFFER_WIDTH: 36162,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_HEIGHT
        @private
     */ RENDERBUFFER_HEIGHT: 36163,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_INTERNAL_FORMAT
        @private
     */ RENDERBUFFER_INTERNAL_FORMAT: 36164,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_RED_SIZE
        @private
     */ RENDERBUFFER_RED_SIZE: 36176,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_GREEN_SIZE
        @private
     */ RENDERBUFFER_GREEN_SIZE: 36177,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_BLUE_SIZE
        @private
     */ RENDERBUFFER_BLUE_SIZE: 36178,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_ALPHA_SIZE
        @private
     */ RENDERBUFFER_ALPHA_SIZE: 36179,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_DEPTH_SIZE
        @private
     */ RENDERBUFFER_DEPTH_SIZE: 36180,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_STENCIL_SIZE
        @private
     */ RENDERBUFFER_STENCIL_SIZE: 36181,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE
        @private
     */ FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME
        @private
     */ FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL
        @private
     */ FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE
        @private
     */ FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT0
        @private
     */ COLOR_ATTACHMENT0: 36064,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_ATTACHMENT
        @private
     */ DEPTH_ATTACHMENT: 36096,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL_ATTACHMENT
        @private
     */ STENCIL_ATTACHMENT: 36128,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_STENCIL_ATTACHMENT
        @private
     */ DEPTH_STENCIL_ATTACHMENT: 33306,
    /**
        @type {GLenum}
        @name PicoGL.NONE
        @private
     */ NONE: 0,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_COMPLETE
        @private
     */ FRAMEBUFFER_COMPLETE: 36053,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_INCOMPLETE_ATTACHMENT
        @private
     */ FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT
        @private
     */ FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_INCOMPLETE_DIMENSIONS
        @private
     */ FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_UNSUPPORTED
        @private
     */ FRAMEBUFFER_UNSUPPORTED: 36061,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_BINDING
        @private
     */ FRAMEBUFFER_BINDING: 36006,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_BINDING
        @private
     */ RENDERBUFFER_BINDING: 36007,
    /**
        @type {GLenum}
        @name PicoGL.MAX_RENDERBUFFER_SIZE
        @private
     */ MAX_RENDERBUFFER_SIZE: 34024,
    /**
        @type {GLenum}
        @name PicoGL.INVALID_FRAMEBUFFER_OPERATION
        @private
     */ INVALID_FRAMEBUFFER_OPERATION: 1286,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_FLIP_Y_WEBGL
        @private
     */ UNPACK_FLIP_Y_WEBGL: 37440,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL
        @private
     */ UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
    /**
        @type {GLenum}
        @name PicoGL.CONTEXT_LOST_WEBGL
        @private
     */ CONTEXT_LOST_WEBGL: 37442,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_COLORSPACE_CONVERSION_WEBGL
        @private
     */ UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
    /**
        @type {GLenum}
        @name PicoGL.BROWSER_DEFAULT_WEBGL
        @private
     */ BROWSER_DEFAULT_WEBGL: 37444,
    /**
        @type {GLenum}
        @name PicoGL.READ_BUFFER
        @private
     */ READ_BUFFER: 3074,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_ROW_LENGTH
        @private
     */ UNPACK_ROW_LENGTH: 3314,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_SKIP_ROWS
        @private
     */ UNPACK_SKIP_ROWS: 3315,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_SKIP_PIXELS
        @private
     */ UNPACK_SKIP_PIXELS: 3316,
    /**
        @type {GLenum}
        @name PicoGL.PACK_ROW_LENGTH
        @private
     */ PACK_ROW_LENGTH: 3330,
    /**
        @type {GLenum}
        @name PicoGL.PACK_SKIP_ROWS
        @private
     */ PACK_SKIP_ROWS: 3331,
    /**
        @type {GLenum}
        @name PicoGL.PACK_SKIP_PIXELS
        @private
     */ PACK_SKIP_PIXELS: 3332,
    /**
        @type {GLenum}
        @name PicoGL.COLOR
        @private
     */ COLOR: 6144,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH
        @private
     */ DEPTH: 6145,
    /**
        @type {GLenum}
        @name PicoGL.STENCIL
        @private
     */ STENCIL: 6146,
    /**
        @type {GLenum}
        @name PicoGL.RED
        @private
     */ RED: 6403,
    /**
        @type {GLenum}
        @name PicoGL.RGB8
        @private
     */ RGB8: 32849,
    /**
        @type {GLenum}
        @name PicoGL.RGBA8
        @private
     */ RGBA8: 32856,
    /**
        @type {GLenum}
        @name PicoGL.RGB10_A2
        @private
     */ RGB10_A2: 32857,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_BINDING_3D
        @private
     */ TEXTURE_BINDING_3D: 32874,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_SKIP_IMAGES
        @private
     */ UNPACK_SKIP_IMAGES: 32877,
    /**
        @type {GLenum}
        @name PicoGL.UNPACK_IMAGE_HEIGHT
        @private
     */ UNPACK_IMAGE_HEIGHT: 32878,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_3D
        @private
     */ TEXTURE_3D: 32879,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_WRAP_R
        @private
     */ TEXTURE_WRAP_R: 32882,
    /**
        @type {GLenum}
        @name PicoGL.MAX_3D_TEXTURE_SIZE
        @private
     */ MAX_3D_TEXTURE_SIZE: 32883,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_2_10_10_10_REV
        @private
     */ UNSIGNED_INT_2_10_10_10_REV: 33640,
    /**
        @type {GLenum}
        @name PicoGL.MAX_ELEMENTS_VERTICES
        @private
     */ MAX_ELEMENTS_VERTICES: 33000,
    /**
        @type {GLenum}
        @name PicoGL.MAX_ELEMENTS_INDICES
        @private
     */ MAX_ELEMENTS_INDICES: 33001,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_MIN_LOD
        @private
     */ TEXTURE_MIN_LOD: 33082,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_MAX_LOD
        @private
     */ TEXTURE_MAX_LOD: 33083,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_BASE_LEVEL
        @private
     */ TEXTURE_BASE_LEVEL: 33084,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_MAX_LEVEL
        @private
     */ TEXTURE_MAX_LEVEL: 33085,
    /**
        @type {GLenum}
        @name PicoGL.MIN
        @private
     */ MIN: 32775,
    /**
        @type {GLenum}
        @name PicoGL.MAX
        @private
     */ MAX: 32776,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_COMPONENT24
        @private
     */ DEPTH_COMPONENT24: 33190,
    /**
        @type {GLenum}
        @name PicoGL.MAX_TEXTURE_LOD_BIAS
        @private
     */ MAX_TEXTURE_LOD_BIAS: 34045,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_COMPARE_MODE
        @private
     */ TEXTURE_COMPARE_MODE: 34892,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_COMPARE_FUNC
        @private
     */ TEXTURE_COMPARE_FUNC: 34893,
    /**
        @type {GLenum}
        @name PicoGL.CURRENT_QUERY
        @private
     */ CURRENT_QUERY: 34917,
    /**
        @type {GLenum}
        @name PicoGL.QUERY_RESULT
        @private
     */ QUERY_RESULT: 34918,
    /**
        @type {GLenum}
        @name PicoGL.QUERY_RESULT_AVAILABLE
        @private
     */ QUERY_RESULT_AVAILABLE: 34919,
    /**
        @type {GLenum}
        @name PicoGL.STREAM_READ
        @private
     */ STREAM_READ: 35041,
    /**
        @type {GLenum}
        @name PicoGL.STREAM_COPY
        @private
     */ STREAM_COPY: 35042,
    /**
        @type {GLenum}
        @name PicoGL.STATIC_READ
        @private
     */ STATIC_READ: 35045,
    /**
        @type {GLenum}
        @name PicoGL.STATIC_COPY
        @private
     */ STATIC_COPY: 35046,
    /**
        @type {GLenum}
        @name PicoGL.DYNAMIC_READ
        @private
     */ DYNAMIC_READ: 35049,
    /**
        @type {GLenum}
        @name PicoGL.DYNAMIC_COPY
        @private
     */ DYNAMIC_COPY: 35050,
    /**
        @type {GLenum}
        @name PicoGL.MAX_DRAW_BUFFERS
        @private
     */ MAX_DRAW_BUFFERS: 34852,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER0
        @private
     */ DRAW_BUFFER0: 34853,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER1
        @private
     */ DRAW_BUFFER1: 34854,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER2
        @private
     */ DRAW_BUFFER2: 34855,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER3
        @private
     */ DRAW_BUFFER3: 34856,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER4
        @private
     */ DRAW_BUFFER4: 34857,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER5
        @private
     */ DRAW_BUFFER5: 34858,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER6
        @private
     */ DRAW_BUFFER6: 34859,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER7
        @private
     */ DRAW_BUFFER7: 34860,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER8
        @private
     */ DRAW_BUFFER8: 34861,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER9
        @private
     */ DRAW_BUFFER9: 34862,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER10
        @private
     */ DRAW_BUFFER10: 34863,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER11
        @private
     */ DRAW_BUFFER11: 34864,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER12
        @private
     */ DRAW_BUFFER12: 34865,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER13
        @private
     */ DRAW_BUFFER13: 34866,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER14
        @private
     */ DRAW_BUFFER14: 34867,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_BUFFER15
        @private
     */ DRAW_BUFFER15: 34868,
    /**
        @type {GLenum}
        @name PicoGL.MAX_FRAGMENT_UNIFORM_COMPONENTS
        @private
     */ MAX_FRAGMENT_UNIFORM_COMPONENTS: 35657,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VERTEX_UNIFORM_COMPONENTS
        @private
     */ MAX_VERTEX_UNIFORM_COMPONENTS: 35658,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLER_3D
        @private
     */ SAMPLER_3D: 35679,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLER_2D_SHADOW
        @private
     */ SAMPLER_2D_SHADOW: 35682,
    /**
        @type {GLenum}
        @name PicoGL.FRAGMENT_SHADER_DERIVATIVE_HINT
        @private
     */ FRAGMENT_SHADER_DERIVATIVE_HINT: 35723,
    /**
        @type {GLenum}
        @name PicoGL.PIXEL_PACK_BUFFER
        @private
     */ PIXEL_PACK_BUFFER: 35051,
    /**
        @type {GLenum}
        @name PicoGL.PIXEL_UNPACK_BUFFER
        @private
     */ PIXEL_UNPACK_BUFFER: 35052,
    /**
        @type {GLenum}
        @name PicoGL.PIXEL_PACK_BUFFER_BINDING
        @private
     */ PIXEL_PACK_BUFFER_BINDING: 35053,
    /**
        @type {GLenum}
        @name PicoGL.PIXEL_UNPACK_BUFFER_BINDING
        @private
     */ PIXEL_UNPACK_BUFFER_BINDING: 35055,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT2x3
        @private
     */ FLOAT_MAT2x3: 35685,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT2x4
        @private
     */ FLOAT_MAT2x4: 35686,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT3x2
        @private
     */ FLOAT_MAT3x2: 35687,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT3x4
        @private
     */ FLOAT_MAT3x4: 35688,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT4x2
        @private
     */ FLOAT_MAT4x2: 35689,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_MAT4x3
        @private
     */ FLOAT_MAT4x3: 35690,
    /**
        @type {GLenum}
        @name PicoGL.SRGB
        @private
     */ SRGB: 35904,
    /**
        @type {GLenum}
        @name PicoGL.SRGB8
        @private
     */ SRGB8: 35905,
    /**
        @type {GLenum}
        @name PicoGL.SRGB8_ALPHA8
        @private
     */ SRGB8_ALPHA8: 35907,
    /**
        @type {GLenum}
        @name PicoGL.COMPARE_REF_TO_TEXTURE
        @private
     */ COMPARE_REF_TO_TEXTURE: 34894,
    /**
        @type {GLenum}
        @name PicoGL.RGBA32F
        @private
     */ RGBA32F: 34836,
    /**
        @type {GLenum}
        @name PicoGL.RGB32F
        @private
     */ RGB32F: 34837,
    /**
        @type {GLenum}
        @name PicoGL.RGBA16F
        @private
     */ RGBA16F: 34842,
    /**
        @type {GLenum}
        @name PicoGL.RGB16F
        @private
     */ RGB16F: 34843,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_INTEGER
        @private
     */ VERTEX_ATTRIB_ARRAY_INTEGER: 35069,
    /**
        @type {GLenum}
        @name PicoGL.MAX_ARRAY_TEXTURE_LAYERS
        @private
     */ MAX_ARRAY_TEXTURE_LAYERS: 35071,
    /**
        @type {GLenum}
        @name PicoGL.MIN_PROGRAM_TEXEL_OFFSET
        @private
     */ MIN_PROGRAM_TEXEL_OFFSET: 35076,
    /**
        @type {GLenum}
        @name PicoGL.MAX_PROGRAM_TEXEL_OFFSET
        @private
     */ MAX_PROGRAM_TEXEL_OFFSET: 35077,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VARYING_COMPONENTS
        @private
     */ MAX_VARYING_COMPONENTS: 35659,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_2D_ARRAY
        @private
     */ TEXTURE_2D_ARRAY: 35866,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_BINDING_2D_ARRAY
        @private
     */ TEXTURE_BINDING_2D_ARRAY: 35869,
    /**
        @type {GLenum}
        @name PicoGL.R11F_G11F_B10F
        @private
     */ R11F_G11F_B10F: 35898,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_10F_11F_11F_REV
        @private
     */ UNSIGNED_INT_10F_11F_11F_REV: 35899,
    /**
        @type {GLenum}
        @name PicoGL.RGB9_E5
        @private
     */ RGB9_E5: 35901,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_5_9_9_9_REV
        @private
     */ UNSIGNED_INT_5_9_9_9_REV: 35902,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_BUFFER_MODE
        @private
     */ TRANSFORM_FEEDBACK_BUFFER_MODE: 35967,
    /**
        @type {GLenum}
        @name PicoGL.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
        @private
     */ MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 35968,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_VARYINGS
        @private
     */ TRANSFORM_FEEDBACK_VARYINGS: 35971,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_BUFFER_START
        @private
     */ TRANSFORM_FEEDBACK_BUFFER_START: 35972,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_BUFFER_SIZE
        @private
     */ TRANSFORM_FEEDBACK_BUFFER_SIZE: 35973,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
        @private
     */ TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 35976,
    /**
        @type {GLenum}
        @name PicoGL.RASTERIZER_DISCARD
        @private
     */ RASTERIZER_DISCARD: 35977,
    /**
        @type {GLenum}
        @name PicoGL.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS
        @private
     */ MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 35978,
    /**
        @type {GLenum}
        @name PicoGL.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS
        @private
     */ MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 35979,
    /**
        @type {GLenum}
        @name PicoGL.INTERLEAVED_ATTRIBS
        @private
     */ INTERLEAVED_ATTRIBS: 35980,
    /**
        @type {GLenum}
        @name PicoGL.SEPARATE_ATTRIBS
        @private
     */ SEPARATE_ATTRIBS: 35981,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_BUFFER
        @private
     */ TRANSFORM_FEEDBACK_BUFFER: 35982,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_BUFFER_BINDING
        @private
     */ TRANSFORM_FEEDBACK_BUFFER_BINDING: 35983,
    /**
        @type {GLenum}
        @name PicoGL.RGBA32UI
        @private
     */ RGBA32UI: 36208,
    /**
        @type {GLenum}
        @name PicoGL.RGB32UI
        @private
     */ RGB32UI: 36209,
    /**
        @type {GLenum}
        @name PicoGL.RGBA16UI
        @private
     */ RGBA16UI: 36214,
    /**
        @type {GLenum}
        @name PicoGL.RGB16UI
        @private
     */ RGB16UI: 36215,
    /**
        @type {GLenum}
        @name PicoGL.RGBA8UI
        @private
     */ RGBA8UI: 36220,
    /**
        @type {GLenum}
        @name PicoGL.RGB8UI
        @private
     */ RGB8UI: 36221,
    /**
        @type {GLenum}
        @name PicoGL.RGBA32I
        @private
     */ RGBA32I: 36226,
    /**
        @type {GLenum}
        @name PicoGL.RGB32I
        @private
     */ RGB32I: 36227,
    /**
        @type {GLenum}
        @name PicoGL.RGBA16I
        @private
     */ RGBA16I: 36232,
    /**
        @type {GLenum}
        @name PicoGL.RGB16I
        @private
     */ RGB16I: 36233,
    /**
        @type {GLenum}
        @name PicoGL.RGBA8I
        @private
     */ RGBA8I: 36238,
    /**
        @type {GLenum}
        @name PicoGL.RGB8I
        @private
     */ RGB8I: 36239,
    /**
        @type {GLenum}
        @name PicoGL.RED_INTEGER
        @private
     */ RED_INTEGER: 36244,
    /**
        @type {GLenum}
        @name PicoGL.RGB_INTEGER
        @private
     */ RGB_INTEGER: 36248,
    /**
        @type {GLenum}
        @name PicoGL.RGBA_INTEGER
        @private
     */ RGBA_INTEGER: 36249,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLER_2D_ARRAY
        @private
     */ SAMPLER_2D_ARRAY: 36289,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLER_2D_ARRAY_SHADOW
        @private
     */ SAMPLER_2D_ARRAY_SHADOW: 36292,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLER_CUBE_SHADOW
        @private
     */ SAMPLER_CUBE_SHADOW: 36293,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_VEC2
        @private
     */ UNSIGNED_INT_VEC2: 36294,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_VEC3
        @private
     */ UNSIGNED_INT_VEC3: 36295,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_VEC4
        @private
     */ UNSIGNED_INT_VEC4: 36296,
    /**
        @type {GLenum}
        @name PicoGL.INT_SAMPLER_2D
        @private
     */ INT_SAMPLER_2D: 36298,
    /**
        @type {GLenum}
        @name PicoGL.INT_SAMPLER_3D
        @private
     */ INT_SAMPLER_3D: 36299,
    /**
        @type {GLenum}
        @name PicoGL.INT_SAMPLER_CUBE
        @private
     */ INT_SAMPLER_CUBE: 36300,
    /**
        @type {GLenum}
        @name PicoGL.INT_SAMPLER_2D_ARRAY
        @private
     */ INT_SAMPLER_2D_ARRAY: 36303,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_SAMPLER_2D
        @private
     */ UNSIGNED_INT_SAMPLER_2D: 36306,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_SAMPLER_3D
        @private
     */ UNSIGNED_INT_SAMPLER_3D: 36307,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_SAMPLER_CUBE
        @private
     */ UNSIGNED_INT_SAMPLER_CUBE: 36308,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_SAMPLER_2D_ARRAY
        @private
     */ UNSIGNED_INT_SAMPLER_2D_ARRAY: 36311,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH_COMPONENT32F
        @private
     */ DEPTH_COMPONENT32F: 36012,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH32F_STENCIL8
        @private
     */ DEPTH32F_STENCIL8: 36013,
    /**
        @type {GLenum}
        @name PicoGL.FLOAT_32_UNSIGNED_INT_24_8_REV
        @private
     */ FLOAT_32_UNSIGNED_INT_24_8_REV: 36269,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING
        @private
     */ FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 33296,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE
        @private
     */ FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 33297,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_RED_SIZE
        @private
     */ FRAMEBUFFER_ATTACHMENT_RED_SIZE: 33298,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE
        @private
     */ FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 33299,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE
        @private
     */ FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 33300,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE
        @private
     */ FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 33301,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE
        @private
     */ FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 33302,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE
        @private
     */ FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 33303,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_DEFAULT
        @private
     */ FRAMEBUFFER_DEFAULT: 33304,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_INT_24_8
        @private
     */ UNSIGNED_INT_24_8: 34042,
    /**
        @type {GLenum}
        @name PicoGL.DEPTH24_STENCIL8
        @private
     */ DEPTH24_STENCIL8: 35056,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNED_NORMALIZED
        @private
     */ UNSIGNED_NORMALIZED: 35863,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_FRAMEBUFFER_BINDING
        @private
     */ DRAW_FRAMEBUFFER_BINDING: 36006,
    /**
        @type {GLenum}
        @name PicoGL.READ_FRAMEBUFFER
        @private
     */ READ_FRAMEBUFFER: 36008,
    /**
        @type {GLenum}
        @name PicoGL.DRAW_FRAMEBUFFER
        @private
     */ DRAW_FRAMEBUFFER: 36009,
    /**
        @type {GLenum}
        @name PicoGL.READ_FRAMEBUFFER_BINDING
        @private
     */ READ_FRAMEBUFFER_BINDING: 36010,
    /**
        @type {GLenum}
        @name PicoGL.RENDERBUFFER_SAMPLES
        @private
     */ RENDERBUFFER_SAMPLES: 36011,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER
        @private
     */ FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 36052,
    /**
        @type {GLenum}
        @name PicoGL.MAX_COLOR_ATTACHMENTS
        @private
     */ MAX_COLOR_ATTACHMENTS: 36063,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT1
        @private
     */ COLOR_ATTACHMENT1: 36065,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT2
        @private
     */ COLOR_ATTACHMENT2: 36066,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT3
        @private
     */ COLOR_ATTACHMENT3: 36067,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT4
        @private
     */ COLOR_ATTACHMENT4: 36068,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT5
        @private
     */ COLOR_ATTACHMENT5: 36069,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT6
        @private
     */ COLOR_ATTACHMENT6: 36070,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT7
        @private
     */ COLOR_ATTACHMENT7: 36071,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT8
        @private
     */ COLOR_ATTACHMENT8: 36072,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT9
        @private
     */ COLOR_ATTACHMENT9: 36073,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT10
        @private
     */ COLOR_ATTACHMENT10: 36074,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT11
        @private
     */ COLOR_ATTACHMENT11: 36075,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT12
        @private
     */ COLOR_ATTACHMENT12: 36076,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT13
        @private
     */ COLOR_ATTACHMENT13: 36077,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT14
        @private
     */ COLOR_ATTACHMENT14: 36078,
    /**
        @type {GLenum}
        @name PicoGL.COLOR_ATTACHMENT15
        @private
     */ COLOR_ATTACHMENT15: 36079,
    /**
        @type {GLenum}
        @name PicoGL.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE
        @private
     */ FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 36182,
    /**
        @type {GLenum}
        @name PicoGL.MAX_SAMPLES
        @private
     */ MAX_SAMPLES: 36183,
    /**
        @type {GLenum}
        @name PicoGL.HALF_FLOAT
        @private
     */ HALF_FLOAT: 5131,
    /**
        @type {GLenum}
        @name PicoGL.RG
        @private
     */ RG: 33319,
    /**
        @type {GLenum}
        @name PicoGL.RG_INTEGER
        @private
     */ RG_INTEGER: 33320,
    /**
        @type {GLenum}
        @name PicoGL.R8
        @private
     */ R8: 33321,
    /**
        @type {GLenum}
        @name PicoGL.RG8
        @private
     */ RG8: 33323,
    /**
        @type {GLenum}
        @name PicoGL.R16F
        @private
     */ R16F: 33325,
    /**
        @type {GLenum}
        @name PicoGL.R32F
        @private
     */ R32F: 33326,
    /**
        @type {GLenum}
        @name PicoGL.RG16F
        @private
     */ RG16F: 33327,
    /**
        @type {GLenum}
        @name PicoGL.RG32F
        @private
     */ RG32F: 33328,
    /**
        @type {GLenum}
        @name PicoGL.R8I
        @private
     */ R8I: 33329,
    /**
        @type {GLenum}
        @name PicoGL.R8UI
        @private
     */ R8UI: 33330,
    /**
        @type {GLenum}
        @name PicoGL.R16I
        @private
     */ R16I: 33331,
    /**
        @type {GLenum}
        @name PicoGL.R16UI
        @private
     */ R16UI: 33332,
    /**
        @type {GLenum}
        @name PicoGL.R32I
        @private
     */ R32I: 33333,
    /**
        @type {GLenum}
        @name PicoGL.R32UI
        @private
     */ R32UI: 33334,
    /**
        @type {GLenum}
        @name PicoGL.RG8I
        @private
     */ RG8I: 33335,
    /**
        @type {GLenum}
        @name PicoGL.RG8UI
        @private
     */ RG8UI: 33336,
    /**
        @type {GLenum}
        @name PicoGL.RG16I
        @private
     */ RG16I: 33337,
    /**
        @type {GLenum}
        @name PicoGL.RG16UI
        @private
     */ RG16UI: 33338,
    /**
        @type {GLenum}
        @name PicoGL.RG32I
        @private
     */ RG32I: 33339,
    /**
        @type {GLenum}
        @name PicoGL.RG32UI
        @private
     */ RG32UI: 33340,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ARRAY_BINDING
        @private
     */ VERTEX_ARRAY_BINDING: 34229,
    /**
        @type {GLenum}
        @name PicoGL.R8_SNORM
        @private
     */ R8_SNORM: 36756,
    /**
        @type {GLenum}
        @name PicoGL.RG8_SNORM
        @private
     */ RG8_SNORM: 36757,
    /**
        @type {GLenum}
        @name PicoGL.RGB8_SNORM
        @private
     */ RGB8_SNORM: 36758,
    /**
        @type {GLenum}
        @name PicoGL.RGBA8_SNORM
        @private
     */ RGBA8_SNORM: 36759,
    /**
        @type {GLenum}
        @name PicoGL.SIGNED_NORMALIZED
        @private
     */ SIGNED_NORMALIZED: 36764,
    /**
        @type {GLenum}
        @name PicoGL.COPY_READ_BUFFER
        @private
     */ COPY_READ_BUFFER: 36662,
    /**
        @type {GLenum}
        @name PicoGL.COPY_WRITE_BUFFER
        @private
     */ COPY_WRITE_BUFFER: 36663,
    /**
        @type {GLenum}
        @name PicoGL.COPY_READ_BUFFER_BINDING
        @private
     */ COPY_READ_BUFFER_BINDING: 36662,
    /**
        @type {GLenum}
        @name PicoGL.COPY_WRITE_BUFFER_BINDING
        @private
     */ COPY_WRITE_BUFFER_BINDING: 36663,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BUFFER
        @private
     */ UNIFORM_BUFFER: 35345,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BUFFER_BINDING
        @private
     */ UNIFORM_BUFFER_BINDING: 35368,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BUFFER_START
        @private
     */ UNIFORM_BUFFER_START: 35369,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BUFFER_SIZE
        @private
     */ UNIFORM_BUFFER_SIZE: 35370,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VERTEX_UNIFORM_BLOCKS
        @private
     */ MAX_VERTEX_UNIFORM_BLOCKS: 35371,
    /**
        @type {GLenum}
        @name PicoGL.MAX_FRAGMENT_UNIFORM_BLOCKS
        @private
     */ MAX_FRAGMENT_UNIFORM_BLOCKS: 35373,
    /**
        @type {GLenum}
        @name PicoGL.MAX_COMBINED_UNIFORM_BLOCKS
        @private
     */ MAX_COMBINED_UNIFORM_BLOCKS: 35374,
    /**
        @type {GLenum}
        @name PicoGL.MAX_UNIFORM_BUFFER_BINDINGS
        @private
     */ MAX_UNIFORM_BUFFER_BINDINGS: 35375,
    /**
        @type {GLenum}
        @name PicoGL.MAX_UNIFORM_BLOCK_SIZE
        @private
     */ MAX_UNIFORM_BLOCK_SIZE: 35376,
    /**
        @type {GLenum}
        @name PicoGL.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS
        @private
     */ MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 35377,
    /**
        @type {GLenum}
        @name PicoGL.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS
        @private
     */ MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 35379,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BUFFER_OFFSET_ALIGNMENT
        @private
     */ UNIFORM_BUFFER_OFFSET_ALIGNMENT: 35380,
    /**
        @type {GLenum}
        @name PicoGL.ACTIVE_UNIFORM_BLOCKS
        @private
     */ ACTIVE_UNIFORM_BLOCKS: 35382,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_TYPE
        @private
     */ UNIFORM_TYPE: 35383,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_SIZE
        @private
     */ UNIFORM_SIZE: 35384,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BLOCK_INDEX
        @private
     */ UNIFORM_BLOCK_INDEX: 35386,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_OFFSET
        @private
     */ UNIFORM_OFFSET: 35387,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_ARRAY_STRIDE
        @private
     */ UNIFORM_ARRAY_STRIDE: 35388,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_MATRIX_STRIDE
        @private
     */ UNIFORM_MATRIX_STRIDE: 35389,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_IS_ROW_MAJOR
        @private
     */ UNIFORM_IS_ROW_MAJOR: 35390,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BLOCK_BINDING
        @private
     */ UNIFORM_BLOCK_BINDING: 35391,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BLOCK_DATA_SIZE
        @private
     */ UNIFORM_BLOCK_DATA_SIZE: 35392,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BLOCK_ACTIVE_UNIFORMS
        @private
     */ UNIFORM_BLOCK_ACTIVE_UNIFORMS: 35394,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES
        @private
     */ UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 35395,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER
        @private
     */ UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 35396,
    /**
        @type {GLenum}
        @name PicoGL.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER
        @private
     */ UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 35398,
    /**
        @type {GLenum}
        @name PicoGL.INVALID_INDEX
        @private
     */ INVALID_INDEX: 4294967295,
    /**
        @type {GLenum}
        @name PicoGL.MAX_VERTEX_OUTPUT_COMPONENTS
        @private
     */ MAX_VERTEX_OUTPUT_COMPONENTS: 37154,
    /**
        @type {GLenum}
        @name PicoGL.MAX_FRAGMENT_INPUT_COMPONENTS
        @private
     */ MAX_FRAGMENT_INPUT_COMPONENTS: 37157,
    /**
        @type {GLenum}
        @name PicoGL.MAX_SERVER_WAIT_TIMEOUT
        @private
     */ MAX_SERVER_WAIT_TIMEOUT: 37137,
    /**
        @type {GLenum}
        @name PicoGL.OBJECT_TYPE
        @private
     */ OBJECT_TYPE: 37138,
    /**
        @type {GLenum}
        @name PicoGL.SYNC_CONDITION
        @private
     */ SYNC_CONDITION: 37139,
    /**
        @type {GLenum}
        @name PicoGL.SYNC_STATUS
        @private
     */ SYNC_STATUS: 37140,
    /**
        @type {GLenum}
        @name PicoGL.SYNC_FLAGS
        @private
     */ SYNC_FLAGS: 37141,
    /**
        @type {GLenum}
        @name PicoGL.SYNC_FENCE
        @private
     */ SYNC_FENCE: 37142,
    /**
        @type {GLenum}
        @name PicoGL.SYNC_GPU_COMMANDS_COMPLETE
        @private
     */ SYNC_GPU_COMMANDS_COMPLETE: 37143,
    /**
        @type {GLenum}
        @name PicoGL.UNSIGNALED
        @private
     */ UNSIGNALED: 37144,
    /**
        @type {GLenum}
        @name PicoGL.SIGNALED
        @private
     */ SIGNALED: 37145,
    /**
        @type {GLenum}
        @name PicoGL.ALREADY_SIGNALED
        @private
     */ ALREADY_SIGNALED: 37146,
    /**
        @type {GLenum}
        @name PicoGL.TIMEOUT_EXPIRED
        @private
     */ TIMEOUT_EXPIRED: 37147,
    /**
        @type {GLenum}
        @name PicoGL.CONDITION_SATISFIED
        @private
     */ CONDITION_SATISFIED: 37148,
    /**
        @type {GLenum}
        @name PicoGL.WAIT_FAILED
        @private
     */ WAIT_FAILED: 37149,
    /**
        @type {GLenum}
        @name PicoGL.SYNC_FLUSH_COMMANDS_BIT
        @private
     */ SYNC_FLUSH_COMMANDS_BIT: 1,
    /**
        @type {GLenum}
        @name PicoGL.VERTEX_ATTRIB_ARRAY_DIVISOR
        @private
     */ VERTEX_ATTRIB_ARRAY_DIVISOR: 35070,
    /**
        @type {GLenum}
        @name PicoGL.ANY_SAMPLES_PASSED
        @private
     */ ANY_SAMPLES_PASSED: 35887,
    /**
        @type {GLenum}
        @name PicoGL.ANY_SAMPLES_PASSED_CONSERVATIVE
        @private
     */ ANY_SAMPLES_PASSED_CONSERVATIVE: 36202,
    /**
        @type {GLenum}
        @name PicoGL.SAMPLER_BINDING
        @private
     */ SAMPLER_BINDING: 35097,
    /**
        @type {GLenum}
        @name PicoGL.RGB10_A2UI
        @private
     */ RGB10_A2UI: 36975,
    /**
        @type {GLenum}
        @name PicoGL.INT_2_10_10_10_REV
        @private
     */ INT_2_10_10_10_REV: 36255,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK
        @private
     */ TRANSFORM_FEEDBACK: 36386,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_PAUSED
        @private
     */ TRANSFORM_FEEDBACK_PAUSED: 36387,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_ACTIVE
        @private
     */ TRANSFORM_FEEDBACK_ACTIVE: 36388,
    /**
        @type {GLenum}
        @name PicoGL.TRANSFORM_FEEDBACK_BINDING
        @private
     */ TRANSFORM_FEEDBACK_BINDING: 36389,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_IMMUTABLE_FORMAT
        @private
     */ TEXTURE_IMMUTABLE_FORMAT: 37167,
    /**
        @type {GLenum}
        @name PicoGL.MAX_ELEMENT_INDEX
        @private
     */ MAX_ELEMENT_INDEX: 36203,
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_IMMUTABLE_LEVELS
        @private
     */ TEXTURE_IMMUTABLE_LEVELS: 33503,
    /**
        @type {GLenum}
        @name PicoGL.TIMEOUT_IGNORED
        @private
     */ TIMEOUT_IGNORED: -1,
    /**
        @type {GLenum}
        @name PicoGL.MAX_CLIENT_WAIT_TIMEOUT_WEBGL
        @private
     */ MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 37447,
    // https://www.khronos.org/registry/webgl/extensions/EXT_disjoint_timer_query_webgl2/
    /**
        @type {GLenum}
        @name PicoGL.QUERY_COUNTER_BITS_EXT
        @private
     */ QUERY_COUNTER_BITS_EXT: 34916,
    /**
        @type {GLenum}
        @name PicoGL.TIME_ELAPSED_EXT
        @private
     */ TIME_ELAPSED_EXT: 35007,
    /**
        @type {GLenum}
        @name PicoGL.TIMESTAMP_EXT
        @private
     */ TIMESTAMP_EXT: 36392,
    /**
        @type {GLenum}
        @name PicoGL.GPU_DISJOINT_EXT
        @private
     */ GPU_DISJOINT_EXT: 36795,
    // https://www.khronos.org/registry/webgl/extensions/EXT_texture_filter_anisotropic/
    /**
        @type {GLenum}
        @name PicoGL.TEXTURE_MAX_ANISOTROPY_EXT
        @private
     */ TEXTURE_MAX_ANISOTROPY_EXT: 34046,
    /**
        @type {GLenum}
        @name PicoGL.MAX_TEXTURE_MAX_ANISOTROPY_EXT
        @private
     */ MAX_TEXTURE_MAX_ANISOTROPY_EXT: 34047,
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_debug_renderer_info/
    /**
        @type {GLenum}
        @name PicoGL.UNMASKED_VENDOR_WEBGL
        @private
     */ UNMASKED_VENDOR_WEBGL: 37445,
    /**
        @type {GLenum}
        @name PicoGL.UNMASKED_RENDERER_WEBGL
        @private
     */ UNMASKED_RENDERER_WEBGL: 37446,
    // https://www.khronos.org/registry/webgl/extensions/KHR_parallel_shader_compile/
    /**
        @type {GLenum}
        @name PicoGL.COMPLETION_STATUS_KHR
        @private
     */ COMPLETION_STATUS_KHR: 37297,
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGB_S3TC_DXT1_EXT
        @private
     */ COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_S3TC_DXT1_EXT
        @private
     */ COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_S3TC_DXT3_EXT
        @private
     */ COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_S3TC_DXT5_EXT
        @private
     */ COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB_S3TC_DXT1_EXT
        @private
     */ COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT
        @private
     */ COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT
        @private
     */ COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
        @private
     */ COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919,
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_R11_EAC
        @private
     */ COMPRESSED_R11_EAC: 37488,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SIGNED_R11_EAC
        @private
     */ COMPRESSED_SIGNED_R11_EAC: 37489,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RG11_EAC
        @private
     */ COMPRESSED_RG11_EAC: 37490,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SIGNED_RG11_EAC
        @private
     */ COMPRESSED_SIGNED_RG11_EAC: 37491,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGB8_ETC2
        @private
     */ COMPRESSED_RGB8_ETC2: 37492,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ETC2
        @private
     */ COMPRESSED_SRGB8_ETC2: 37493,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2
        @private
     */ COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37494,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2
        @private
     */ COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37495,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA8_ETC2_EAC
        @private
     */ COMPRESSED_RGBA8_ETC2_EAC: 37496,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
        @private
     */ COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37497,
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
        @private
     */ COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
        @private
     */ COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
        @private
     */ COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
        @private
     */ COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_4x4_KHR
        @private
     */ COMPRESSED_RGBA_ASTC_4x4_KHR: 37808,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_5x4_KHR
        @private
     */ COMPRESSED_RGBA_ASTC_5x4_KHR: 37809,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_5x5_KHR
        @private
     */ COMPRESSED_RGBA_ASTC_5x5_KHR: 37810,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_6x5_KHR
        @private
     */ COMPRESSED_RGBA_ASTC_6x5_KHR: 37811,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_6x6_KHR
        @private
     */ COMPRESSED_RGBA_ASTC_6x6_KHR: 37812,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_8x5_KHR
        @private
     */ COMPRESSED_RGBA_ASTC_8x5_KHR: 37813,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_8x6_KHR
        @private
     */ COMPRESSED_RGBA_ASTC_8x6_KHR: 37814,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_8x8_KHR
        @private
     */ COMPRESSED_RGBA_ASTC_8x8_KHR: 37815,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_10x5_KHR
        @private
     */ COMPRESSED_RGBA_ASTC_10x5_KHR: 37816,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_10x6_KHR
        @private
     */ COMPRESSED_RGBA_ASTC_10x6_KHR: 37817,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_10x8_KHR
        @private
     */ COMPRESSED_RGBA_ASTC_10x8_KHR: 37818,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_10x10_KHR
        @private
     */ COMPRESSED_RGBA_ASTC_10x10_KHR: 37819,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_12x10_KHR
        @private
     */ COMPRESSED_RGBA_ASTC_12x10_KHR: 37820,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_RGBA_ASTC_12x12_KHR
        @private
     */ COMPRESSED_RGBA_ASTC_12x12_KHR: 37821,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
        @private
     */ COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR: 37840,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
        @private
     */ COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR: 37841,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
        @private
     */ COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR: 37842,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
        @private
     */ COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR: 37843,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
        @private
     */ COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR: 37844,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
        @private
     */ COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR: 37845,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
        @private
     */ COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR: 37846,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
        @private
     */ COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR: 37847,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
        @private
     */ COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR: 37848,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
        @private
     */ COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR: 37849,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
        @private
     */ COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR: 37850,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
        @private
     */ COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR: 37851,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
        @private
     */ COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR: 37852,
    /**
        @type {GLenum}
        @name PicoGL.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
        @private
     */ COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR: 37853
};
const TYPE_SIZE = {
    [GL.BYTE]: 1,
    [GL.UNSIGNED_BYTE]: 1,
    [GL.SHORT]: 2,
    [GL.UNSIGNED_SHORT]: 2,
    [GL.INT]: 4,
    [GL.UNSIGNED_INT]: 4,
    [GL.FLOAT]: 4
};
const TEXTURE_FORMATS = {
    [GL.R8]: [
        GL.RED,
        GL.UNSIGNED_BYTE
    ],
    [GL.R8_SNORM]: [
        GL.RED,
        GL.BYTE
    ],
    [GL.R16F]: [
        GL.RED,
        GL.FLOAT
    ],
    [GL.R32F]: [
        GL.RED,
        GL.FLOAT
    ],
    [GL.R8UI]: [
        GL.RED_INTEGER,
        GL.UNSIGNED_BYTE
    ],
    [GL.R8I]: [
        GL.RED_INTEGER,
        GL.BYTE
    ],
    [GL.R16UI]: [
        GL.RED_INTEGER,
        GL.UNSIGNED_SHORT
    ],
    [GL.R16I]: [
        GL.RED_INTEGER,
        GL.SHORT
    ],
    [GL.R32UI]: [
        GL.RED_INTEGER,
        GL.UNSIGNED_INT
    ],
    [GL.R32I]: [
        GL.RED_INTEGER,
        GL.INT
    ],
    [GL.RG8]: [
        GL.RG,
        GL.UNSIGNED_BYTE
    ],
    [GL.RG8_SNORM]: [
        GL.RG,
        GL.BYTE
    ],
    [GL.RG16F]: [
        GL.RG,
        GL.FLOAT
    ],
    [GL.RG32F]: [
        GL.RG,
        GL.FLOAT
    ],
    [GL.RG8UI]: [
        GL.RG_INTEGER,
        GL.UNSIGNED_BYTE
    ],
    [GL.RG8I]: [
        GL.RG_INTEGER,
        GL.BYTE
    ],
    [GL.RG16UI]: [
        GL.RG_INTEGER,
        GL.UNSIGNED_SHORT
    ],
    [GL.RG16I]: [
        GL.RG_INTEGER,
        GL.SHORT
    ],
    [GL.RG32UI]: [
        GL.RG_INTEGER,
        GL.UNSIGNED_INT
    ],
    [GL.RG32I]: [
        GL.RG_INTEGER,
        GL.INT
    ],
    [GL.RGB8]: [
        GL.RGB,
        GL.UNSIGNED_BYTE
    ],
    [GL.SRGB8]: [
        GL.RGB,
        GL.UNSIGNED_BYTE
    ],
    [GL.RGB565]: [
        GL.RGB,
        GL.UNSIGNED_SHORT_5_6_5
    ],
    [GL.RGB8_SNORM]: [
        GL.RGB,
        GL.BYTE
    ],
    [GL.R11F_G11F_B10F]: [
        GL.RGB,
        GL.UNSIGNED_INT_10F_11F_11F_REV
    ],
    [GL.RGB9_E5]: [
        GL.RGB,
        GL.UNSIGNED_INT_5_9_9_9_REV
    ],
    [GL.RGB16F]: [
        GL.RGB,
        GL.FLOAT
    ],
    [GL.RGB32F]: [
        GL.RGB,
        GL.FLOAT
    ],
    [GL.RGB8UI]: [
        GL.RGB_INTEGER,
        GL.UNSIGNED_BYTE
    ],
    [GL.RGB8I]: [
        GL.RGB_INTEGER,
        GL.BYTE
    ],
    [GL.RGB16UI]: [
        GL.RGB_INTEGER,
        GL.UNSIGNED_SHORT
    ],
    [GL.RGB16I]: [
        GL.RGB_INTEGER,
        GL.SHORT
    ],
    [GL.RGB32UI]: [
        GL.RGB_INTEGER,
        GL.UNSIGNED_INT
    ],
    [GL.RGB32I]: [
        GL.RGB_INTEGER,
        GL.INT
    ],
    [GL.RGBA8]: [
        GL.RGBA,
        GL.UNSIGNED_BYTE
    ],
    [GL.SRGB8_ALPHA8]: [
        GL.RGBA,
        GL.UNSIGNED_BYTE
    ],
    [GL.RGBA8_SNORM]: [
        GL.RGBA,
        GL.BYTE
    ],
    [GL.RGB5_A1]: [
        GL.RGBA,
        GL.UNSIGNED_SHORT_5_5_5_1
    ],
    [GL.RGBA4]: [
        GL.RGBA,
        GL.UNSIGNED_SHORT_4_4_4_4
    ],
    [GL.RGB10_A2]: [
        GL.RGBA,
        GL.UNSIGNED_INT_2_10_10_10_REV
    ],
    [GL.RGBA16F]: [
        GL.RGBA,
        GL.FLOAT
    ],
    [GL.RGBA32F]: [
        GL.RGBA,
        GL.FLOAT
    ],
    [GL.RGBA8UI]: [
        GL.RGBA_INTEGER,
        GL.UNSIGNED_BYTE
    ],
    [GL.RGBA8I]: [
        GL.RGBA_INTEGER,
        GL.BYTE
    ],
    [GL.RGB10_A2UI]: [
        GL.RGBA_INTEGER,
        GL.UNSIGNED_INT_2_10_10_10_REV
    ],
    [GL.RGBA16UI]: [
        GL.RGBA_INTEGER,
        GL.UNSIGNED_SHORT
    ],
    [GL.RGBA16I]: [
        GL.RGBA_INTEGER,
        GL.SHORT
    ],
    [GL.RGBA32I]: [
        GL.RGBA_INTEGER,
        GL.INT
    ],
    [GL.RGBA32UI]: [
        GL.RGBA_INTEGER,
        GL.UNSIGNED_INT
    ],
    [GL.DEPTH_COMPONENT16]: [
        GL.DEPTH_COMPONENT,
        GL.UNSIGNED_SHORT
    ],
    [GL.DEPTH_COMPONENT24]: [
        GL.DEPTH_COMPONENT,
        GL.UNSIGNED_INT
    ],
    [GL.DEPTH_COMPONENT32F]: [
        GL.DEPTH_COMPONENT,
        GL.FLOAT
    ],
    [GL.DEPTH24_STENCIL8]: [
        GL.DEPTH_STENCIL,
        GL.UNSIGNED_INT_24_8
    ],
    [GL.DEPTH32F_STENCIL8]: [
        GL.DEPTH_STENCIL,
        GL.FLOAT_32_UNSIGNED_INT_24_8_REV
    ]
};
const COMPRESSED_TEXTURE_TYPES = {
    [GL.COMPRESSED_RGB_S3TC_DXT1_EXT]: true,
    [GL.COMPRESSED_RGBA_S3TC_DXT1_EXT]: true,
    [GL.COMPRESSED_RGBA_S3TC_DXT3_EXT]: true,
    [GL.COMPRESSED_RGBA_S3TC_DXT5_EXT]: true,
    [GL.COMPRESSED_SRGB_S3TC_DXT1_EXT]: true,
    [GL.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT]: true,
    [GL.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT]: true,
    [GL.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT]: true,
    [GL.COMPRESSED_R11_EAC]: true,
    [GL.COMPRESSED_SIGNED_R11_EAC]: true,
    [GL.COMPRESSED_RG11_EAC]: true,
    [GL.COMPRESSED_SIGNED_RG11_EAC]: true,
    [GL.COMPRESSED_RGB8_ETC2]: true,
    [GL.COMPRESSED_SRGB8_ETC2]: true,
    [GL.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2]: true,
    [GL.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2]: true,
    [GL.COMPRESSED_RGBA8_ETC2_EAC]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC]: true,
    [GL.COMPRESSED_RGBA_ASTC_4x4_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_5x4_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_5x5_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_6x5_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_6x6_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_8x5_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_8x6_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_8x8_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_10x5_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_10x6_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_10x8_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_10x10_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_12x10_KHR]: true,
    [GL.COMPRESSED_RGBA_ASTC_12x12_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR]: true,
    [GL.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR]: true,
    [GL.COMPRESSED_RGB_PVRTC_4BPPV1_IMG]: true,
    [GL.COMPRESSED_RGB_PVRTC_2BPPV1_IMG]: true,
    [GL.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG]: true,
    [GL.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG]: true
};
const WEBGL_INFO = {
};
const DUMMY_UNIT_ARRAY = new Array(1);
const DUMMY_OBJECT = {
};
const TEXTURE_FORMAT_DEFAULTS = {
    [GL.UNSIGNED_BYTE]: {
        [GL.RED]: GL.R8,
        [GL.RG]: GL.RG8,
        [GL.RGB]: GL.RGB8,
        [GL.RGBA]: GL.RGBA8
    },
    [GL.UNSIGNED_SHORT]: {
        [GL.DEPTH_COMPONENT]: GL.DEPTH_COMPONENT16
    },
    [GL.FLOAT]: {
        [GL.RED]: GL.R16F,
        [GL.RG]: GL.RG16F,
        [GL.RGB]: GL.RGB16F,
        [GL.RGBA]: GL.RGBA16F,
        [GL.DEPTH_COMPONENT]: GL.DEPTH_COMPONENT32F
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gBzmW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
    Primary entry point to PicoGL. An app will store all parts of the WebGL
    state.

    @class App
    @param {WebGLRenderingContext} gl
    @prop {HTMLElement} canvas The canvas on which this app drawing.
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {number} width The width of the drawing surface.
    @prop {number} height The height of the drawing surface.
    @prop {Object} state Tracked GL state.
    @prop {Object} state.drawFramebufferBinding=GL.DRAW_FRAMEBUFFER Binding point to bind framebuffers to for draw. Should be set before any binding occurs. Should only have values GL.DRAW_FRAMEBUFFER or GL.FRAMEBUFFER (the latter with state.readFramebufferBinding set to the same).
    @prop {Object} state.readFramebufferBinding=GL.READ_FRAMEBUFFER  Binding point to bind framebuffers to for read. Should be set before any binding occurs. Should only have values GL.READ_FRAMEBUFFER or GL.FRAMEBUFFER (the latter with state.drawFramebufferBinding set to the same).
    @prop {GLenum} clearBits Current clear mask to use with clear().
*/ parcelHelpers.export(exports, "App", ()=>App
);
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////
var _constantsJs = require("./constants.js");
var _cubemapJs = require("./cubemap.js");
var _drawCallJs = require("./draw-call.js");
var _framebufferJs = require("./framebuffer.js");
var _renderbufferJs = require("./renderbuffer.js");
var _programJs = require("./program.js");
var _shaderJs = require("./shader.js");
var _textureJs = require("./texture.js");
var _timerJs = require("./timer.js");
var _transformFeedbackJs = require("./transform-feedback.js");
var _uniformBufferJs = require("./uniform-buffer.js");
var _vertexArrayJs = require("./vertex-array.js");
var _vertexBufferJs = require("./vertex-buffer.js");
var _queryJs = require("./query.js");
class App {
    constructor(gl){
        this.gl = gl;
        this.canvas = gl.canvas;
        this.width = this.gl.drawingBufferWidth;
        this.height = this.gl.drawingBufferHeight;
        this.viewportX = 0;
        this.viewportY = 0;
        this.viewportWidth = 0;
        this.viewportHeight = 0;
        this.currentDrawCalls = null;
        this.emptyFragmentShader = null;
        this.state = {
            program: null,
            vertexArray: null,
            transformFeedback: null,
            activeTexture: -1,
            textures: new Array(_constantsJs.WEBGL_INFO.MAX_TEXTURE_UNITS),
            uniformBuffers: new Array(_constantsJs.WEBGL_INFO.MAX_UNIFORM_BUFFERS),
            freeUniformBufferBases: [],
            framebuffers: {
            },
            drawFramebufferBinding: _constantsJs.GL.DRAW_FRAMEBUFFER,
            readFramebufferBinding: _constantsJs.GL.READ_FRAMEBUFFER,
            extensions: {
            }
        };
        this.clearBits = this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT | this.gl.STENCIL_BUFFER_BIT;
        this.cpuTime = 0;
        this.gpuTime = 0;
        this.viewport(0, 0, this.width, this.height);
        this.contextLostExt = null;
        this.contextLostListener = null;
        this.contextRestoredListener = null;
        this.contextRestoredHandler = null;
        this.initExtensions();
    }
    /**
        Simulate context loss.

        @method
        @return {App} The App object.
    */ loseContext() {
        if (this.contextLostExt) this.contextLostExt.loseContext();
        return this;
    }
    /**
        Simulate context restoration.

        @method
        @return {App} The App object.
    */ restoreContext() {
        if (this.contextLostExt) this.contextLostExt.restoreContext();
        return this;
    }
    /**
        Set function to handle context restoration after loss.

        @method
        @param {function} fn Context restored handler.
        @return {App} The App object.
    */ onContextRestored(fn) {
        this.contextRestoredHandler = fn;
        this.initContextListeners();
        return this;
    }
    /**
        Enable WebGL capability (e.g. depth testing, blending, etc.).

        @method
        @param {GLenum} cap Capability to enable.
        @return {App} The App object.
    */ enable(cap) {
        this.gl.enable(cap);
        return this;
    }
    /**
        Disable WebGL capability (e.g. depth testing, blending, etc.).

        @method
        @param {GLenum} cap Capability to disable.
        @return {App} The App object.
    */ disable(cap) {
        this.gl.disable(cap);
        return this;
    }
    /**
        Set the color mask to selectively enable or disable particular
        color channels while rendering.

        @method
        @param {boolean} r Red channel.
        @param {boolean} g Green channel.
        @param {boolean} b Blue channel.
        @param {boolean} a Alpha channel.
        @return {App} The App object.
    */ colorMask(r, g, b, a) {
        this.gl.colorMask(r, g, b, a);
        return this;
    }
    /**
        Set the clear color.

        @method
        @param {number} r Red channel.
        @param {number} g Green channel.
        @param {number} b Blue channel.
        @param {number} a Alpha channel.
        @return {App} The App object.
    */ clearColor(r, g, b, a) {
        this.gl.clearColor(r, g, b, a);
        return this;
    }
    /**
        Set the clear mask bits to use when calling clear().
        E.g. app.clearMask(PicoGL.COLOR_BUFFER_BIT).

        @method
        @param {GLenum} mask Bit mask of buffers to clear.
        @return {App} The App object.
    */ clearMask(mask) {
        this.clearBits = mask;
        return this;
    }
    /**
        Clear the canvas

        @method
        @return {App} The App object.
    */ clear() {
        this.gl.clear(this.clearBits);
        return this;
    }
    /**
        Bind a draw framebuffer to the WebGL context.

        @method
        @param {Framebuffer} framebuffer The Framebuffer object to bind.
        @see Framebuffer
        @return {App} The App object.
    */ drawFramebuffer(framebuffer) {
        framebuffer.bindForDraw();
        return this;
    }
    /**
        Bind a read framebuffer to the WebGL context.

        @method
        @param {Framebuffer} framebuffer The Framebuffer object to bind.
        @see Framebuffer
        @return {App} The App object.
    */ readFramebuffer(framebuffer) {
        framebuffer.bindForRead();
        return this;
    }
    /**
        Switch back to the default framebuffer for drawing (i.e. draw to the screen).
        Note that this method resets the viewport to match the default framebuffer.

        @method
        @return {App} The App object.
    */ defaultDrawFramebuffer() {
        let binding = this.state.drawFramebufferBinding;
        if (this.state.framebuffers[binding] !== null) {
            this.gl.bindFramebuffer(binding, null);
            this.state.framebuffers[binding] = null;
        }
        return this;
    }
    /**
        Switch back to the default framebuffer for reading (i.e. read from the screen).

        @method
        @return {App} The App object.
    */ defaultReadFramebuffer() {
        let binding = this.state.readFramebufferBinding;
        if (this.state.framebuffers[binding] !== null) {
            this.gl.bindFramebuffer(binding, null);
            this.state.framebuffers[binding] = null;
        }
        return this;
    }
    /**
        Copy data from framebuffer attached to READ_FRAMEBUFFER to framebuffer attached to DRAW_FRAMEBUFFER.

        @method
        @param {GLenum} mask Write mask (e.g. PicoGL.COLOR_BUFFER_BIT).
        @param {Object} [options] Blit options.
        @param {number} [options.srcStartX=0] Source start x coordinate.
        @param {number} [options.srcStartY=0] Source start y coordinate.
        @param {number} [options.srcEndX=Width of the read framebuffer] Source end x coordinate.
        @param {number} [options.srcEndY=Height of the read framebuffer] Source end y coordinate.
        @param {number} [options.dstStartX=0] Destination start x coordinate.
        @param {number} [options.dstStartY=0] Destination start y coordinate.
        @param {number} [options.dstEndX=Width of the draw framebuffer] Destination end x coordinate.
        @param {number} [options.dstEndY=Height of the draw framebuffer] Destination end y coordinate.
        @param {number} [options.filter=NEAREST] Sampling filter.
        @return {App} The App object.
    */ blitFramebuffer(mask, options = _constantsJs.DUMMY_OBJECT) {
        let readBinding = this.state.readFramebufferBinding;
        let drawBinding = this.state.drawFramebufferBinding;
        let readFramebuffer = this.state.framebuffers[readBinding];
        let drawFramebuffer = this.state.framebuffers[drawBinding];
        let defaultReadWidth = readFramebuffer ? readFramebuffer.width : this.width;
        let defaultReadHeight = readFramebuffer ? readFramebuffer.height : this.height;
        let defaultDrawWidth = drawFramebuffer ? drawFramebuffer.width : this.width;
        let defaultDrawHeight = drawFramebuffer ? drawFramebuffer.height : this.height;
        let { srcStartX =0 , srcStartY =0 , srcEndX =defaultReadWidth , srcEndY =defaultReadHeight , dstStartX =0 , dstStartY =0 , dstEndX =defaultDrawWidth , dstEndY =defaultDrawHeight , filter =_constantsJs.GL.NEAREST  } = options;
        this.gl.blitFramebuffer(srcStartX, srcStartY, srcEndX, srcEndY, dstStartX, dstStartY, dstEndX, dstEndY, mask, filter);
        return this;
    }
    /**
        Set the depth range.

        @method
        @param {number} near Minimum depth value.
        @param {number} far Maximum depth value.
        @return {App} The App object.
    */ depthRange(near, far) {
        this.gl.depthRange(near, far);
        return this;
    }
    /**
        Enable or disable writing to the depth buffer.

        @method
        @param {Boolean} mask The depth mask.
        @return {App} The App object.
    */ depthMask(mask) {
        this.gl.depthMask(mask);
        return this;
    }
    /**
        Set the depth test function. E.g. app.depthFunc(PicoGL.LEQUAL).

        @method
        @param {GLenum} func The depth testing function to use.
        @return {App} The App object.
    */ depthFunc(func) {
        this.gl.depthFunc(func);
        return this;
    }
    /**
        Set the blend function. E.g. app.blendFunc(PicoGL.ONE, PicoGL.ONE_MINUS_SRC_ALPHA).

        @method
        @param {GLenum} src The source blending weight.
        @param {GLenum} dest The destination blending weight.
        @return {App} The App object.
    */ blendFunc(src, dest) {
        this.gl.blendFunc(src, dest);
        return this;
    }
    /**
        Set the blend function, with separate weighting for color and alpha channels.
        E.g. app.blendFuncSeparate(PicoGL.ONE, PicoGL.ONE_MINUS_SRC_ALPHA, PicoGL.ONE, PicoGL.ONE).

        @method
        @param {GLenum} csrc The source blending weight for the RGB channels.
        @param {GLenum} cdest The destination blending weight for the RGB channels.
        @param {GLenum} asrc The source blending weight for the alpha channel.
        @param {GLenum} adest The destination blending weight for the alpha channel.
        @return {App} The App object.
    */ blendFuncSeparate(csrc, cdest, asrc, adest) {
        this.gl.blendFuncSeparate(csrc, cdest, asrc, adest);
        return this;
    }
    /**
        Set the blend equation. E.g. app.blendEquation(PicoGL.MIN).

        @method
        @param {GLenum} mode The operation to use in combining source and destination channels.
        @return {App} The App object.
    */ blendEquation(mode) {
        this.gl.blendEquation(mode);
        return this;
    }
    /**
        Set the bitmask to use for tested stencil values.
        E.g. app.stencilMask(0xFF).
        NOTE: Only works if { stencil: true } passed as a
        context attribute when creating the App!

        @method
        @param {number} mask The mask value.
        @return {App} The App object.

    */ stencilMask(mask) {
        this.gl.stencilMask(mask);
        return this;
    }
    /**
        Set the bitmask to use for tested stencil values for a particular face orientation.
        E.g. app.stencilMaskSeparate(PicoGL.FRONT, 0xFF).
        NOTE: Only works if { stencil: true } passed as a
        context attribute when creating the App!

        @method
        @param {GLenum} face The face orientation to apply the mask to.
        @param {number} mask The mask value.
        @return {App} The App object.
    */ stencilMaskSeparate(face, mask) {
        this.gl.stencilMaskSeparate(face, mask);
        return this;
    }
    /**
        Set the stencil function and reference value.
        E.g. app.stencilFunc(PicoGL.EQUAL, 1, 0xFF).
        NOTE: Only works if { stencil: true } passed as a
        context attribute when creating the App!

        @method
        @param {GLenum} func The testing function.
        @param {number} ref The reference value.
        @param {GLenum} mask The bitmask to use against tested values before applying
            the stencil function.
        @return {App} The App object.
    */ stencilFunc(func, ref, mask) {
        this.gl.stencilFunc(func, ref, mask);
        return this;
    }
    /**
        Set the stencil function and reference value for a particular face orientation.
        E.g. app.stencilFuncSeparate(PicoGL.FRONT, PicoGL.EQUAL, 1, 0xFF).
        NOTE: Only works if { stencil: true } passed as a
        context attribute when creating the App!

        @method
        @param {GLenum} face The face orientation to apply the function to.
        @param {GLenum} func The testing function.
        @param {number} ref The reference value.
        @param {GLenum} mask The bitmask to use against tested values before applying
            the stencil function.
        @return {App} The App object.
    */ stencilFuncSeparate(face, func, ref, mask) {
        this.gl.stencilFuncSeparate(face, func, ref, mask);
        return this;
    }
    /**
        Set the operations for updating stencil buffer values.
        E.g. app.stencilOp(PicoGL.KEEP, PicoGL.KEEP, PicoGL.REPLACE).
        NOTE: Only works if { stencil: true } passed as a
        context attribute when creating the App!

        @method
        @param {GLenum} stencilFail Operation to apply if the stencil test fails.
        @param {GLenum} depthFail Operation to apply if the depth test fails.
        @param {GLenum} pass Operation to apply if the both the depth and stencil tests pass.
        @return {App} The App object.
    */ stencilOp(stencilFail, depthFail, pass) {
        this.gl.stencilOp(stencilFail, depthFail, pass);
        return this;
    }
    /**
        Set the operations for updating stencil buffer values for a particular face orientation.
        E.g. app.stencilOpSeparate(PicoGL.FRONT, PicoGL.KEEP, PicoGL.KEEP, PicoGL.REPLACE).
        NOTE: Only works if { stencil: true } passed as a
        context attribute when creating the App!

        @method
        @param {GLenum} face The face orientation to apply the operations to.
        @param {GLenum} stencilFail Operation to apply if the stencil test fails.
        @param {GLenum} depthFail Operation to apply if the depth test fails.
        @param {GLenum} pass Operation to apply if the both the depth and stencil tests pass.
        @return {App} The App object.
    */ stencilOpSeparate(face, stencilFail, depthFail, pass) {
        this.gl.stencilOpSeparate(face, stencilFail, depthFail, pass);
        return this;
    }
    /**
        Define the scissor box.

        @method
        @param {Number} x Horizontal position of the scissor box.
        @param {Number} y Vertical position of the scissor box.
        @param {Number} width Width of the scissor box.
        @param {Number} height Height of the scissor box.
        @return {App} The App object.
    */ scissor(x, y, width, height) {
        this.gl.scissor(x, y, width, height);
        return this;
    }
    /**
        Set the scale and units used.

        @method
        @param {Number} factor Scale factor used to create a variable depth offset for each polygon.
        @param {Number} units Constant depth offset.
        @return {App} The App object.
    */ polygonOffset(factor, units) {
        this.gl.polygonOffset(factor, units);
        return this;
    }
    /**
        Read a pixel's color value from the currently-bound framebuffer.

        @method
        @param {number} x The x coordinate of the pixel.
        @param {number} y The y coordinate of the pixel.
        @param {ArrayBufferView} outColor Typed array to store the pixel's color.
        @param {object} [options] Options.
        @param {GLenum} [options.type=UNSIGNED_BYTE] Type of data stored in the read framebuffer.
        @param {GLenum} [options.format=RGBA] Read framebuffer data format.
        @return {App} The App object.
    */ readPixel(x, y, outColor, options = _constantsJs.DUMMY_OBJECT) {
        let { format =_constantsJs.GL.RGBA , type =_constantsJs.GL.UNSIGNED_BYTE  } = options;
        this.gl.readPixels(x, y, 1, 1, format, type, outColor);
        return this;
    }
    /**
        Set the viewport.

        @method
        @param {number} x Left bound of the viewport rectangle.
        @param {number} y Lower bound of the viewport rectangle.
        @param {number} width Width of the viewport rectangle.
        @param {number} height Height of the viewport rectangle.
        @return {App} The App object.
    */ viewport(x, y, width, height) {
        if (this.viewportWidth !== width || this.viewportHeight !== height || this.viewportX !== x || this.viewportY !== y) {
            this.viewportX = x;
            this.viewportY = y;
            this.viewportWidth = width;
            this.viewportHeight = height;
            this.gl.viewport(x, y, this.viewportWidth, this.viewportHeight);
        }
        return this;
    }
    /**
        Set the viewport to the full canvas.

        @method
        @return {App} The App object.
    */ defaultViewport() {
        this.viewport(0, 0, this.width, this.height);
        return this;
    }
    /**
        Resize the drawing surface.

        @method
        @param {number} width The new canvas width.
        @param {number} height The new canvas height.
        @return {App} The App object.
    */ resize(width, height) {
        this.canvas.width = width;
        this.canvas.height = height;
        this.width = this.gl.drawingBufferWidth;
        this.height = this.gl.drawingBufferHeight;
        this.viewport(0, 0, this.width, this.height);
        return this;
    }
    /**
        Create a program synchronously. It is highly recommended to use <b>createPrograms</b> instead as
            that method will compile shaders in parallel where possible.
        @method
        @param {Shader|string} vertexShader Vertex shader object or source code.
        @param {Shader|string} fragmentShader Fragment shader object or source code.
        @param {Object} [options] Texture options.
        @param {Object} [options.attributeLocations] Map of attribute names to locations (useful when using GLSL 1).
        @param {Array} [options.transformFeedbackVaryings] Array of varying names used for transform feedback output.
        @param {GLenum} [options.transformFeedbackMode] Capture mode of the transform feedback. (Default: PicoGL.SEPARATE_ATTRIBS).
        @return {Program} New Program object.
    */ createProgram(vsSource, fsSource, opts = {
    }) {
        let { transformFeedbackVaryings , attributeLocations , transformFeedbackMode  } = opts;
        return new _programJs.Program(this.gl, this.state, vsSource, fsSource, transformFeedbackVaryings, attributeLocations, transformFeedbackMode).link().checkLinkage();
    }
    /**
        Create several programs. Preferred method for program creation as it will compile shaders
        in parallel where possible.

        @method
        @param {...Array} sources Variable number of 2 or 3 element arrays, each containing:
            <ul>
                <li> (Shader|string) Vertex shader object or source code.
                <li> (Shader|string) Fragment shader object or source code.
                <li> (Object - optional) Optional program parameters.
                <ul>
                    <li>(Object - optional) <strong><code>attributeLocations</code></strong> Map of attribute names to locations (useful when using GLSL 1).
                    <li>(Array - optional) <strong><code>transformFeedbackVaryings</code></strong> Array of varying names used for transform feedback output.
                    <li>(GLenum - optional) <strong><code>transformFeedbackMode</code></strong> Capture mode of the transform feedback. (Default: PicoGL.SEPARATE_ATTRIBS).
                </ul>
                </ul>
            </ul>
        @return {Promise<Program[]>} Promise that will resolve to an array of Programs when compilation and
            linking are complete for all programs.
    */ createPrograms(...sources) {
        return new Promise((resolve, reject)=>{
            let numPrograms = sources.length;
            let programs = new Array(numPrograms);
            let pendingPrograms = new Array(numPrograms);
            let numPending = numPrograms;
            for(let i2 = 0; i2 < numPrograms; ++i2){
                let source = sources[i2];
                let vsSource = source[0];
                let fsSource = source[1];
                let opts = source[2] || {
                };
                let { transformFeedbackVaryings , attributeLocations , transformFeedbackMode  } = opts;
                programs[i2] = new _programJs.Program(this.gl, this.state, vsSource, fsSource, transformFeedbackVaryings, attributeLocations, transformFeedbackMode);
                pendingPrograms[i2] = programs[i2];
            }
            for(let i1 = 0; i1 < numPrograms; ++i1)programs[i1].link();
            let poll = ()=>{
                let linked = 0;
                for(let i = 0; i < numPending; ++i)if (pendingPrograms[i].checkCompletion()) {
                    pendingPrograms[i].checkLinkage();
                    if (pendingPrograms[i].linked) ++linked;
                    else {
                        reject(new Error("Program linkage failed"));
                        return;
                    }
                } else pendingPrograms[i - linked] = pendingPrograms[i];
                numPending -= linked;
                if (numPending === 0) resolve(programs);
                else requestAnimationFrame(poll);
            };
            poll();
        });
    }
    /**
        Restore several programs after a context loss. Will do so in parallel where available.

        @method
        @param {...Program} sources Variable number of programs to restore.

        @return {Promise<void>} Promise that will resolve once all programs have been restored.
    */ restorePrograms(...programs) {
        return new Promise((resolve, reject)=>{
            let numPrograms = programs.length;
            let pendingPrograms = programs.slice();
            let numPending = numPrograms;
            for(let i5 = 0; i5 < numPrograms; ++i5)programs[i5].initialize();
            for(let i3 = 0; i3 < numPrograms; ++i3)programs[i3].link();
            for(let i4 = 0; i4 < numPrograms; ++i4)programs[i4].checkCompletion();
            let poll = ()=>{
                let linked = 0;
                for(let i = 0; i < numPending; ++i)if (pendingPrograms[i].checkCompletion()) {
                    pendingPrograms[i].checkLinkage();
                    if (pendingPrograms[i].linked) ++linked;
                    else {
                        reject(new Error("Program linkage failed"));
                        return;
                    }
                } else pendingPrograms[i - linked] = pendingPrograms[i];
                numPending -= linked;
                if (numPending === 0) resolve();
                else requestAnimationFrame(poll);
            };
            poll();
        });
    }
    /**
        Create a shader. Creating a shader separately from a program allows for
        shader reuse.

        @method
        @param {GLenum} type Shader type.
        @param {string} source Shader source.
        @return {Shader} New Shader object.
    */ createShader(type, source) {
        return new _shaderJs.Shader(this.gl, this.state, type, source);
    }
    /**
        Create a vertex array.

        @method
        @return {VertexArray} New VertexArray object.
    */ createVertexArray() {
        return new _vertexArrayJs.VertexArray(this.gl, this.state);
    }
    /**
        Create a transform feedback object.

        @method
        @return {TransformFeedback} New TransformFeedback object.
    */ createTransformFeedback() {
        return new _transformFeedbackJs.TransformFeedback(this.gl, this.state);
    }
    /**
        Create a vertex buffer.

        @method
        @param {GLenum} type The data type stored in the vertex buffer.
        @param {number} itemSize Number of elements per vertex.
        @param {ArrayBufferView|number} data Buffer data itself or the total
            number of elements to be allocated.
        @param {GLenum} [usage=STATIC_DRAW] Buffer usage.
        @return {VertexBuffer} New VertexBuffer object.
    */ createVertexBuffer(type, itemSize, data, usage) {
        return new _vertexBufferJs.VertexBuffer(this.gl, this.state, type, itemSize, data, usage);
    }
    /**
        Create a per-vertex matrix buffer. Matrix buffers ensure that columns
        are correctly split across attribute locations.

        @method
        @param {GLenum} type The data type stored in the matrix buffer. Valid types
        are FLOAT_MAT4, FLOAT_MAT4x2, FLOAT_MAT4x3, FLOAT_MAT3, FLOAT_MAT3x2,
        FLOAT_MAT3x4, FLOAT_MAT2, FLOAT_MAT2x3, FLOAT_MAT2x4.
        @param {ArrayBufferView} data Matrix buffer data.
        @param {GLenum} [usage=STATIC_DRAW] Buffer usage.
        @return {VertexBuffer} New VertexBuffer object.
    */ createMatrixBuffer(type, data, usage) {
        return new _vertexBufferJs.VertexBuffer(this.gl, this.state, type, 0, data, usage);
    }
    /**
        Create an buffer without any structure information. Structure
        must be fully specified when binding to a VertexArray.

        @method
        @param {number} bytesPerVertex Number of bytes per vertex.
        @param {ArrayBufferView|number} data Buffer data itself or the total
            number of bytes to be allocated.
        @param {GLenum} [usage=STATIC_DRAW] Buffer usage.
        @return {VertexBuffer} New VertexBuffer object.
    */ createInterleavedBuffer(bytesPerVertex, data, usage) {
        return new _vertexBufferJs.VertexBuffer(this.gl, this.state, null, bytesPerVertex, data, usage);
    }
    /**
        Create an index buffer. If the `itemSize` is not specified, it defaults to 3

        @method
        @variation 1
        @param {GLenum} type The data type stored in the index buffer.
        @param {ArrayBufferView} data Index buffer data.
        @param {GLenum} [usage=STATIC_DRAW] Buffer usage.
        @return {VertexBuffer} New VertexBuffer object.
    */ /**
        Create an index buffer.

        @method
        @variation 2
        @param {GLenum} type The data type stored in the index buffer.
        @param {number} itemSize Number of elements per primitive.
        @param {ArrayBufferView} data Index buffer data.
        @param {GLenum} [usage=STATIC_DRAW] Buffer usage.
        @return {VertexBuffer} New VertexBuffer object.
    */ createIndexBuffer(type, itemSize, data, usage) {
        if (ArrayBuffer.isView(itemSize)) {
            usage = data;
            data = itemSize;
            itemSize = 3;
        }
        return new _vertexBufferJs.VertexBuffer(this.gl, this.state, type, itemSize, data, usage, true);
    }
    /**
        Create a uniform buffer in std140 layout. NOTE: FLOAT_MAT2, FLOAT_MAT3x2, FLOAT_MAT4x2,
        FLOAT_MAT3, FLOAT_MAT2x3, FLOAT_MAT4x3 are supported, but must be manually padded to
        4-float column alignment by the application!

        @method
        @param {Array} layout Array indicating the order and types of items to
                        be stored in the buffer.
        @param {GLenum} [usage=DYNAMIC_DRAW] Buffer usage.
        @return {UniformBuffer} New UniformBuffer object.
    */ createUniformBuffer(layout, usage) {
        return new _uniformBufferJs.UniformBuffer(this.gl, this.state, layout, usage);
    }
    /**
        Create empty 2D texture.
        @method
        @variation 1
        @param {number} width - Texture width. Required for array or empty data.
        @param {number} height - Texture height. Required for array or empty data.
        @param {Object} [options] Texture options.
        @param {GLenum} [options.internalFormat=RGBA8] Texture data internal format. Must be a sized format.
        @param {GLenum} [options.type] Type of data stored in the texture. Default based on
            <b>internalFormat</b>.
        @param {boolean} [options.flipY=false] Whether the y-axis should be flipped when unpacking the texture.
        @param {boolean} [options.premultiplyAlpha=false] Whether the alpha channel should be pre-multiplied when unpacking the texture.
        @param {GLenum} [options.minFilter] Minification filter. Defaults to
            LINEAR_MIPMAP_NEAREST if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.magFilter] Magnification filter. Defaults to LINEAR
            if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.wrapS=REPEAT] Horizontal wrap mode.
        @param {GLenum} [options.wrapT=REPEAT] Vertical wrap mode.
        @param {GLenum} [options.compareMode=NONE] Comparison mode.
        @param {GLenum} [options.compareFunc=LEQUAL] Comparison function.
        @param {GLenum} [options.baseLevel] Base mipmap level.
        @param {GLenum} [options.maxLevel] Maximum mipmap level.
        @param {GLenum} [options.minLOD] Mimimum level of detail.
        @param {GLenum} [options.maxLOD] Maximum level of detail.
        @param {GLenum} [options.maxAnisotropy] Maximum anisotropy in filtering.
        @return {Texture} New Texture object.
    */ /**
        Create a 2D texture from a DOM image element.
        @method
        @variation 2
        @param {HTMLImageElement|HTMLImageElement[]} image - Image data. An array can be passed to manually set all levels
            of the mipmap chain. If a single level is passed and mipmap filtering is being used,
            generateMipmap() will be called to produce the remaining levels.
        @param {Object} [options] Texture options.
        @param {GLenum} [options.internalFormat=RGBA8] Texture data internal format. Must be a sized format.
        @param {GLenum} [options.type] Type of data stored in the texture. Default based on
            <b>intrnalFormat</b>.
        @param {boolean} [options.flipY=false] Whether the y-axis should be flipped when unpacking the texture.
        @param {boolean} [options.premultiplyAlpha=false] Whether the alpha channel should be pre-multiplied when unpacking the texture.
        @param {GLenum} [options.minFilter] Minification filter. Defaults to
            LINEAR_MIPMAP_NEAREST if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.magFilter] Magnification filter. Defaults to LINEAR
            if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.wrapS=REPEAT] Horizontal wrap mode.
        @param {GLenum} [options.wrapT=REPEAT] Vertical wrap mode.
        @param {GLenum} [options.compareMode=NONE] Comparison mode.
        @param {GLenum} [options.compareFunc=LEQUAL] Comparison function.
        @param {GLenum} [options.baseLevel] Base mipmap level.
        @param {GLenum} [options.maxLevel] Maximum mipmap level.
        @param {GLenum} [options.minLOD] Mimimum level of detail.
        @param {GLenum} [options.maxLOD] Maximum level of detail.
        @param {GLenum} [options.maxAnisotropy] Maximum anisotropy in filtering.
        @return {Texture} New Texture object.
    */ /**
        Create 2D texture from a typed array.
        @method
        @variation 3
        @param {ArrayBufferView|ArrayBufferView[]} image - Image data. An array can be passed to manually set all levels
            of the mipmap chain. If a single level is passed and mipmap filtering is being used,
            generateMipmap() will be called to produce the remaining levels.
        @param {number} width - Texture width. Required for array or empty data.
        @param {number} height - Texture height. Required for array or empty data.
        @param {Object} [options] Texture options.
        @param {GLenum} [options.internalFormat=RGBA8] Texture data internal format. Must be a sized format.
        @param {GLenum} [options.type] Type of data stored in the texture. Default based on
            <b>internalFormat</b>.
        @param {boolean} [options.flipY=false] Whether the y-axis should be flipped when unpacking the texture.
        @param {boolean} [options.premultiplyAlpha=false] Whether the alpha channel should be pre-multiplied when unpacking the texture.
        @param {GLenum} [options.minFilter] Minification filter. Defaults to
            LINEAR_MIPMAP_NEAREST if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.magFilter] Magnification filter. Defaults to LINEAR
            if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.wrapS=REPEAT] Horizontal wrap mode.
        @param {GLenum} [options.wrapT=REPEAT] Vertical wrap mode.
        @param {GLenum} [options.compareMode=NONE] Comparison mode.
        @param {GLenum} [options.compareFunc=LEQUAL] Comparison function.
        @param {GLenum} [options.baseLevel] Base mipmap level.
        @param {GLenum} [options.maxLevel] Maximum mipmap level.
        @param {GLenum} [options.minLOD] Mimimum level of detail.
        @param {GLenum} [options.maxLOD] Maximum level of detail.
        @param {GLenum} [options.maxAnisotropy] Maximum anisotropy in filtering.
        @return {Texture} New Texture object.
    */ createTexture2D(image, width, height, options) {
        if (typeof image === "number") {
            // Create empty texture just give width/height.
            options = height;
            height = width;
            width = image;
            image = null;
        } else if (height === undefined) {
            // Passing in a DOM element. Height/width not required.
            options = width;
            width = image.width;
            height = image.height;
        }
        return new _textureJs.Texture(this.gl, this.state, this.gl.TEXTURE_2D, image, width, height, undefined, false, options);
    }
    /**
        Create a 2D texture array.

        @method
        @param {ArrayBufferView|Array} image Pixel data. An array can be passed to manually set all levels
            of the mipmap chain. If a single level is passed and mipmap filtering is being used,
            generateMipmap() will be called to produce the remaining levels.
        @param {number} width Texture width.
        @param {number} height Texture height.
        @param {number} size Number of images in the array.
        @param {Object} [options] Texture options.
        @param {GLenum} [options.internalFormat=RGBA8] Texture data internal format. Must be a sized format.
        @param {GLenum} [options.type] Type of data stored in the texture. Default based on
            <b>internalFormat</b>.
        @param {boolean} [options.flipY=false] Whether the y-axis should be flipped when unpacking the texture.
        @param {GLenum} [options.minFilter] Minification filter. Defaults to
            LINEAR_MIPMAP_NEAREST if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.magFilter] Magnification filter. Defaults to LINEAR
            if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.wrapS=REPEAT] Horizontal wrap mode.
        @param {GLenum} [options.wrapT=REPEAT] Vertical wrap mode.
        @param {GLenum} [options.wrapR=REPEAT] Depth wrap mode.
        @param {GLenum} [options.compareMode=NONE] Comparison mode.
        @param {GLenum} [options.compareFunc=LEQUAL] Comparison function.
        @param {GLenum} [options.baseLevel] Base mipmap level.
        @param {GLenum} [options.maxLevel] Maximum mipmap level.
        @param {GLenum} [options.minLOD] Mimimum level of detail.
        @param {GLenum} [options.maxLOD] Maximum level of detail.
        @param {GLenum} [options.maxAnisotropy] Maximum anisotropy in filtering.
        @return {Texture} New Texture object.
    */ createTextureArray(image, width, height, depth, options) {
        if (typeof image === "number") {
            // Create empty texture just give width/height/depth.
            options = depth;
            depth = height;
            height = width;
            width = image;
            image = null;
        }
        return new _textureJs.Texture(this.gl, this.state, this.gl.TEXTURE_2D_ARRAY, image, width, height, depth, true, options);
    }
    /**
        Create a 3D texture.

        @method
        @param {ArrayBufferView|Array} image Pixel data. An array can be passed to manually set all levels
            of the mipmap chain. If a single level is passed and mipmap filtering is being used,
            generateMipmap() will be called to produce the remaining levels.
        @param {number} width Texture width.
        @param {number} height Texture height.
        @param {number} depth Texture depth.
        @param {Object} [options] Texture options.
        @param {GLenum} [options.internalFormat=RGBA8] Texture data internal format. Must be a sized format.
        @param {GLenum} [options.type] Type of data stored in the texture. Default based on
            <b>internalFormat</b>.
        @param {boolean} [options.flipY=false] Whether the y-axis should be flipped when unpacking the texture.
        @param {GLenum} [options.minFilter] Minification filter. Defaults to
            LINEAR_MIPMAP_NEAREST if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.magFilter] Magnification filter. Defaults to LINEAR
            if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.wrapS=REPEAT] Horizontal wrap mode.
        @param {GLenum} [options.wrapT=REPEAT] Vertical wrap mode.
        @param {GLenum} [options.wrapR=REPEAT] Depth wrap mode.
        @param {GLenum} [options.compareMode=NONE] Comparison mode.
        @param {GLenum} [options.compareFunc=LEQUAL] Comparison function.
        @param {GLenum} [options.baseLevel] Base mipmap level.
        @param {GLenum} [options.maxLevel] Maximum mipmap level.
        @param {GLenum} [options.minLOD] Mimimum level of detail.
        @param {GLenum} [options.maxLOD] Maximum level of detail.
        @param {GLenum} [options.maxAnisotropy] Maximum anisotropy in filtering.
        @return {Texture} New Texture object.
    */ createTexture3D(image, width, height, depth, options) {
        if (typeof image === "number") {
            // Create empty texture just give width/height/depth.
            options = depth;
            depth = height;
            height = width;
            width = image;
            image = null;
        }
        return new _textureJs.Texture(this.gl, this.state, this.gl.TEXTURE_3D, image, width, height, depth, true, options);
    }
    /**
        Create a cubemap.

        @method
        @param {Object} options Texture options.
        @param {HTMLElement|ArrayBufferView} [options.negX] The image data for the negative X direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.posX] The image data for the positive X direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.negY] The image data for the negative Y direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.posY] The image data for the positive Y direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.negZ] The image data for the negative Z direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.posZ] The image data for the positive Z direction.
                Can be any format that would be accepted by texImage2D.
        @param {number} [options.width] Cubemap side width. Defaults to the width of negX if negX is an image.
        @param {number} [options.height] Cubemap side height. Defaults to the height of negX if negX is an image.
        @param {GLenum} [options.internalFormat=RGBA8] Texture data internal format. Must be a sized format.
        @param {GLenum} [options.type] Type of data stored in the texture. Default based on
            <b>internalFormat</b>.
        @param {boolean} [options.flipY=false] Whether the y-axis should be flipped when unpacking the image.
        @param {boolean} [options.premultiplyAlpha=false] Whether the alpha channel should be pre-multiplied when unpacking the image.
        @param {GLenum} [options.minFilter] Minification filter. Defaults to
            LINEAR_MIPMAP_NEAREST if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.magFilter] Magnification filter. Defaults to LINEAR
            if image data is provided, NEAREST otherwise.
        @param {GLenum} [options.wrapS=REPEAT] Horizontal wrap mode.
        @param {GLenum} [options.wrapT=REPEAT] Vertical wrap mode.
        @param {GLenum} [options.compareMode=NONE] Comparison mode.
        @param {GLenum} [options.compareFunc=LEQUAL] Comparison function.
        @param {GLenum} [options.baseLevel] Base mipmap level.
        @param {GLenum} [options.maxLevel] Maximum mipmap level.
        @param {GLenum} [options.minLOD] Mimimum level of detail.
        @param {GLenum} [options.maxLOD] Maximum level of detail.
        @param {GLenum} [options.maxAnisotropy] Maximum anisotropy in filtering.
        @return {Cubemap} New Cubemap object.
    */ createCubemap(options) {
        return new _cubemapJs.Cubemap(this.gl, this.state, options);
    }
    /**
        Create a renderbuffer.

        @method
        @param {number} width Renderbuffer width.
        @param {number} height Renderbuffer height.
        @param {GLenum} internalFormat Internal arrangement of the renderbuffer data.
        @param {number} [samples=0] Number of MSAA samples.
        @return {Renderbuffer} New Renderbuffer object.
    */ createRenderbuffer(width, height, internalFormat, samples = 0) {
        return new _renderbufferJs.Renderbuffer(this.gl, width, height, internalFormat, samples);
    }
    /**
        Create a framebuffer.

        @method
        @return {Framebuffer} New Framebuffer object.
    */ createFramebuffer() {
        return new _framebufferJs.Framebuffer(this.gl, this.state);
    }
    /**
        Create a query.

        @method
        @param {GLenum} target Information to query.
        @return {Query} New Query object.
    */ createQuery(target) {
        return new _queryJs.Query(this.gl, target);
    }
    /**
        Create a timer.

        @method
        @return {Timer} New Timer object.
    */ createTimer() {
        return new _timerJs.Timer(this.gl);
    }
    /**
        Create a DrawCall. A DrawCall manages the state associated with
        a WebGL draw call including a program and associated vertex data, textures,
        uniforms and uniform blocks.

        @method
        @param {Program} program The program to use for this DrawCall.
        @param {VertexArray} [vertexArray=null] Vertex data to use for drawing.
        @return {DrawCall} New DrawCall object.
    */ createDrawCall(program, vertexArray, primitive) {
        return new _drawCallJs.DrawCall(this.gl, this.state, program, vertexArray, primitive);
    }
    // Enable extensions
    initExtensions() {
        this.gl.getExtension("EXT_color_buffer_float");
        this.gl.getExtension("OES_texture_float_linear");
        this.gl.getExtension("WEBGL_compressed_texture_s3tc");
        this.gl.getExtension("WEBGL_compressed_texture_s3tc_srgb");
        this.gl.getExtension("WEBGL_compressed_texture_etc");
        this.gl.getExtension("WEBGL_compressed_texture_astc");
        this.gl.getExtension("WEBGL_compressed_texture_pvrtc");
        this.gl.getExtension("EXT_disjoint_timer_query_webgl2");
        this.gl.getExtension("EXT_disjoint_timer_query");
        this.gl.getExtension("EXT_texture_filter_anisotropic");
        this.state.extensions.debugShaders = this.gl.getExtension("WEBGL_debug_shaders");
        this.contextLostExt = this.gl.getExtension("WEBGL_lose_context");
        // Draft extensions
        this.gl.getExtension("KHR_parallel_shader_compile");
        this.state.extensions.multiDrawInstanced = this.gl.getExtension("WEBGL_multi_draw_instanced");
        this.state.extensions.drawInstancedBaseVertexBaseInstance = this.gl.getExtension("WEBGL_draw_instanced_base_vertex_base_instance");
        this.state.extensions.multiDrawInstancedBaseVertexBaseInstance = this.gl.getExtension("WEBGL_multi_draw_instanced_base_vertex_base_instance");
    }
    initContextListeners() {
        if (this.contextRestoredHandler) {
            this.contextLostListener = (e)=>{
                e.preventDefault();
            };
            this.contextRestoredListener = ()=>{
                this.initExtensions();
                this.contextRestoredHandler();
            };
            this.canvas.addEventListener("webglcontextlost", this.contextLostListener);
            this.canvas.addEventListener("webglcontextrestored", this.contextRestoredListener);
        } else {
            this.canvas.removeEventListener("webglcontextlost", this.contextLostListener);
            this.canvas.removeEventListener("webglcontextrestored", this.contextRestoredListener);
            this.contextLostListener = null;
            this.contextRestoredListener = null;
        }
    }
    // DEPRECATED
    depthTest() {
        console.warn("App.depthTest is deprecated. Use App.enable(PicoGL.DEPTH_TEST) instead.");
        this.enable(_constantsJs.GL.DEPTH_TEST);
        return this;
    }
    noDepthTest() {
        console.warn("App.noDepthTest is deprecated. Use App.disable(PicoGL.DEPTH_TEST) instead.");
        this.disable(_constantsJs.GL.DEPTH_TEST);
        return this;
    }
    blend() {
        console.warn("App.blend is deprecated. Use App.enable(PicoGL.BLEND) instead.");
        this.enable(_constantsJs.GL.BLEND);
        return this;
    }
    noBlend() {
        console.warn("App.noBlend is deprecated. Use App.disable(PicoGL.BLEND) instead.");
        this.disable(_constantsJs.GL.BLEND);
        return this;
    }
    stencilTest() {
        console.warn("App.stencilTest is deprecated. Use App.enable(PicoGL.STENCIL_TEST) instead.");
        this.enable(_constantsJs.GL.STENCIL_TEST);
        return this;
    }
    noStencilTest() {
        console.warn("App.noStencilTest is deprecated. Use App.disable(PicoGL.STENCIL_TEST) instead.");
        this.disable(_constantsJs.GL.STENCIL_TEST);
        return this;
    }
    scissorTest() {
        console.warn("App.scissorTest is deprecated. Use App.enable(PicoGL.SCISSOR_TEST) instead.");
        this.enable(_constantsJs.GL.SCISSOR_TEST);
        return this;
    }
    noScissorTest() {
        console.warn("App.noScissorTest is deprecated. Use App.disable(PicoGL.SCISSOR_TEST) instead.");
        this.disable(_constantsJs.GL.SCISSOR_TEST);
        return this;
    }
    rasterize() {
        console.warn("App.noRasterize is deprecated. Use App.disable(PicoGL.RASTERIZER_DISCARD) instead.");
        this.disable(_constantsJs.GL.RASTERIZER_DISCARD);
        return this;
    }
    noRasterize() {
        console.warn("App.rasterize is deprecated. Use App.enable(PicoGL.RASTERIZER_DISCARD) instead.");
        this.enable(_constantsJs.GL.RASTERIZER_DISCARD);
        return this;
    }
    cullBackfaces() {
        console.warn("App.cullBackfaces is deprecated. Use App.enable(PicoGL.CULL_FACE) instead.");
        this.enable(_constantsJs.GL.CULL_FACE);
        return this;
    }
    drawBackfaces() {
        console.warn("App.drawBackfaces is deprecated. Use App.disable(PicoGL.CULL_FACE) instead.");
        this.disable(_constantsJs.GL.CULL_FACE);
        return this;
    }
}

},{"./constants.js":"jCl2R","./cubemap.js":"385PL","./draw-call.js":"bSGsx","./framebuffer.js":"3QRlD","./renderbuffer.js":"4BxUD","./program.js":"cwgWW","./shader.js":"gDRJa","./texture.js":"9g3ZT","./timer.js":"667UB","./transform-feedback.js":"hbtoF","./uniform-buffer.js":"ls9jB","./vertex-array.js":"5Pw5A","./vertex-buffer.js":"6Sv9B","./query.js":"b0pz6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"385PL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
    Cubemap for environment mapping.

    @class Cubemap
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLTexture} texture Handle to the texture.
    @prop {GLenum} type Type of data stored in the texture.
    @prop {GLenum} format Layout of texture data.
    @prop {GLenum} internalFormat Internal arrangement of the texture data.
    @prop {Number} currentUnit The current texture unit this cubemap is bound to.
    @prop {boolean} flipY Whether the y-axis is flipped for this cubemap.
    @prop {boolean} premultiplyAlpha Whether alpha should be pre-multiplied when loading this cubemap.
    @prop {Object} appState Tracked GL state.
*/ parcelHelpers.export(exports, "Cubemap", ()=>Cubemap
);
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////
var _constantsJs = require("./constants.js");
class Cubemap {
    constructor(gl, appState, options){
        this.gl = gl;
        this.texture = null;
        this.appState = appState;
        this.compressed = _constantsJs.COMPRESSED_TEXTURE_TYPES[options.internalFormat];
        if (options.format !== undefined) {
            console.warn("Cubemap option 'format' is deprecated and will be removed. Use 'internalFormat' with a sized format instead.");
            this.compressed = Boolean(_constantsJs.COMPRESSED_TEXTURE_TYPES[options.format]);
            if (options.type === undefined) options.type = options.format === _constantsJs.GL.DEPTH_COMPONENT ? _constantsJs.GL.UNSIGNED_SHORT : _constantsJs.GL.UNSIGNED_BYTE;
            if (options.internalFormat === undefined) {
                if (this.compressed) options.internalFormat = options.format;
                else options.internalFormat = _constantsJs.TEXTURE_FORMAT_DEFAULTS[options.type][options.format];
            }
        }
        if (this.compressed) {
            // For compressed textures, just need to provide one of format, internalFormat.
            // The other will be the same.
            this.internalFormat = options.internalFormat;
            this.format = options.internalFormat;
            this.type = _constantsJs.GL.UNSIGNED_BYTE;
        } else {
            this.internalFormat = options.internalFormat !== undefined ? options.internalFormat : _constantsJs.GL.RGBA8;
            let formatInfo = _constantsJs.TEXTURE_FORMATS[this.internalFormat];
            this.format = formatInfo[0];
            this.type = options.type !== undefined ? options.type : formatInfo[1];
        }
        // -1 indicates unbound
        this.currentUnit = -1;
        let arrayData = Array.isArray(options.negX);
        let negX = arrayData ? options.negX[0] : options.negX;
        let { width =negX.width , height =negX.height , flipY =false , premultiplyAlpha =false , minFilter =negX ? _constantsJs.GL.LINEAR_MIPMAP_NEAREST : _constantsJs.GL.NEAREST , magFilter =negX ? _constantsJs.GL.LINEAR : _constantsJs.GL.NEAREST , wrapS =_constantsJs.GL.REPEAT , wrapT =_constantsJs.GL.REPEAT , compareMode =_constantsJs.GL.NONE , compareFunc =_constantsJs.GL.LEQUAL , minLOD =null , maxLOD =null , baseLevel =null , maxLevel =null , maxAnisotropy =1  } = options;
        this.width = width;
        this.height = height;
        this.flipY = flipY;
        this.premultiplyAlpha = premultiplyAlpha;
        this.minFilter = minFilter;
        this.magFilter = magFilter;
        this.wrapS = wrapS;
        this.wrapT = wrapT;
        this.compareMode = compareMode;
        this.compareFunc = compareFunc;
        this.minLOD = minLOD;
        this.maxLOD = maxLOD;
        this.baseLevel = baseLevel;
        this.maxLevel = maxLevel;
        this.maxAnisotropy = Math.min(maxAnisotropy, _constantsJs.WEBGL_INFO.MAX_TEXTURE_ANISOTROPY);
        this.mipmaps = minFilter === _constantsJs.GL.LINEAR_MIPMAP_NEAREST || minFilter === _constantsJs.GL.LINEAR_MIPMAP_LINEAR;
        this.miplevelsProvided = arrayData && options.negX.length > 1;
        this.levels = this.mipmaps ? Math.floor(Math.log2(Math.min(this.width, this.height))) + 1 : 1;
        this.restore(options);
    }
    /**
        Restore cubemap after context loss.

        @method
        @param {Object} [options] Texture options.
        @param {HTMLElement|ArrayBufferView} [options.negX] The image data for the negative X direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.posX] The image data for the positive X direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.negY] The image data for the negative Y direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.posY] The image data for the positive Y direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.negZ] The image data for the negative Z direction.
                Can be any format that would be accepted by texImage2D.
        @param {HTMLElement|ArrayBufferView} [options.posZ] The image data for the positive Z direction.
                Can be any format that would be accepted by texImage2D.
        @return {Cubemap} The Cubemap object.
    */ restore(options = _constantsJs.DUMMY_OBJECT) {
        this.texture = this.gl.createTexture();
        if (this.currentUnit !== -1) this.appState.textures[this.currentUnit] = null;
        this.bind(0);
        this.gl.texParameteri(_constantsJs.GL.TEXTURE_CUBE_MAP, _constantsJs.GL.TEXTURE_MAG_FILTER, this.magFilter);
        this.gl.texParameteri(_constantsJs.GL.TEXTURE_CUBE_MAP, _constantsJs.GL.TEXTURE_MIN_FILTER, this.minFilter);
        this.gl.texParameteri(_constantsJs.GL.TEXTURE_CUBE_MAP, _constantsJs.GL.TEXTURE_WRAP_S, this.wrapS);
        this.gl.texParameteri(_constantsJs.GL.TEXTURE_CUBE_MAP, _constantsJs.GL.TEXTURE_WRAP_T, this.wrapT);
        this.gl.texParameteri(_constantsJs.GL.TEXTURE_CUBE_MAP, _constantsJs.GL.TEXTURE_COMPARE_FUNC, this.compareFunc);
        this.gl.texParameteri(_constantsJs.GL.TEXTURE_CUBE_MAP, _constantsJs.GL.TEXTURE_COMPARE_MODE, this.compareMode);
        if (this.baseLevel !== null) this.gl.texParameteri(_constantsJs.GL.TEXTURE_CUBE_MAP, _constantsJs.GL.TEXTURE_BASE_LEVEL, this.baseLevel);
        if (this.maxLevel !== null) this.gl.texParameteri(_constantsJs.GL.TEXTURE_CUBE_MAP, _constantsJs.GL.TEXTURE_MAX_LEVEL, this.maxLevel);
        if (this.minLOD !== null) this.gl.texParameteri(_constantsJs.GL.TEXTURE_CUBE_MAP, _constantsJs.GL.TEXTURE_MIN_LOD, this.minLOD);
        if (this.maxLOD !== null) this.gl.texParameteri(_constantsJs.GL.TEXTURE_CUBE_MAP, _constantsJs.GL.TEXTURE_MAX_LOD, this.maxLOD);
        if (this.maxAnisotropy > 1) this.gl.texParameteri(_constantsJs.GL.TEXTURE_CUBE_MAP, _constantsJs.GL.TEXTURE_MAX_ANISOTROPY_EXT, this.maxAnisotropy);
        this.gl.texStorage2D(_constantsJs.GL.TEXTURE_CUBE_MAP, this.levels, this.internalFormat, this.width, this.height);
        let { negX , posX , negY , posY , negZ , posZ  } = options;
        if (negX) {
            this.faceData(_constantsJs.GL.TEXTURE_CUBE_MAP_NEGATIVE_X, negX);
            this.faceData(_constantsJs.GL.TEXTURE_CUBE_MAP_POSITIVE_X, posX);
            this.faceData(_constantsJs.GL.TEXTURE_CUBE_MAP_NEGATIVE_Y, negY);
            this.faceData(_constantsJs.GL.TEXTURE_CUBE_MAP_POSITIVE_Y, posY);
            this.faceData(_constantsJs.GL.TEXTURE_CUBE_MAP_NEGATIVE_Z, negZ);
            this.faceData(_constantsJs.GL.TEXTURE_CUBE_MAP_POSITIVE_Z, posZ);
        }
        if (this.mipmaps && !this.miplevelsProvided) this.gl.generateMipmap(_constantsJs.GL.TEXTURE_CUBE_MAP);
        return this;
    }
    /**
        Delete this cubemap.

        @method
        @return {Cubemap} The Cubemap object.
    */ delete() {
        if (this.texture) {
            this.gl.deleteTexture(this.texture);
            this.texture = null;
            this.appState.textures[this.currentUnit] = null;
            this.currentUnit = -1;
        }
        return this;
    }
    // Input data for one cubemap face.
    faceData(face, data) {
        if (!Array.isArray(data)) {
            _constantsJs.DUMMY_UNIT_ARRAY[0] = data;
            data = _constantsJs.DUMMY_UNIT_ARRAY;
        }
        let numLevels = this.mipmaps ? data.length : 1;
        let width = this.width;
        let height = this.height;
        let i;
        this.gl.pixelStorei(_constantsJs.GL.UNPACK_FLIP_Y_WEBGL, this.flipY);
        this.gl.pixelStorei(_constantsJs.GL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
        if (this.compressed) for(i = 0; i < numLevels; ++i){
            this.gl.compressedTexSubImage2D(face, i, 0, 0, width, height, this.format, data[i]);
            width = Math.max(width >> 1, 1);
            height = Math.max(height >> 1, 1);
        }
        else for(i = 0; i < numLevels; ++i){
            this.gl.texSubImage2D(face, i, 0, 0, width, height, this.format, this.type, data[i]);
            width = Math.max(width >> 1, 1);
            height = Math.max(height >> 1, 1);
        }
        return this;
    }
    // Bind this cubemap to a texture unit.
    bind(unit) {
        let currentTexture = this.appState.textures[unit];
        if (this.appState.activeTexture !== unit) {
            this.gl.activeTexture(_constantsJs.GL.TEXTURE0 + unit);
            this.appState.activeTexture = unit;
        }
        if (currentTexture !== this) {
            if (currentTexture) currentTexture.currentUnit = -1;
            if (this.currentUnit !== -1) this.appState.textures[this.currentUnit] = null;
            this.gl.bindTexture(_constantsJs.GL.TEXTURE_CUBE_MAP, this.texture);
            this.appState.textures[unit] = this;
            this.currentUnit = unit;
        }
        return this;
    }
}

},{"./constants.js":"jCl2R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bSGsx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
    A DrawCall represents the program and values of associated
    attributes, uniforms and textures for a single draw call.

    @class DrawCall
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {Program} currentProgram The program to use for this draw call.
    @prop {VertexArray} currentVertexArray Vertex array to use for this draw call.
    @prop {TransformFeedback} currentTransformFeedback Transform feedback to use for this draw call.
    @prop {Array} uniformBuffers Ordered list of active uniform buffers.
    @prop {Array} uniformBlockNames Ordered list of uniform block names.
    @prop {Number} uniformBlockCount Number of active uniform blocks for this draw call.
    @prop {Object} uniformIndices Map of uniform names to indices in the uniform arrays.
    @prop {Array} uniformNames Ordered list of uniform names.
    @prop {Array} uniformValue Ordered list of uniform values.
    @prop {number} uniformCount The number of active uniforms for this draw call.
    @prop {Array} textures Array of active textures.
    @prop {number} textureCount The number of active textures for this draw call.
    @prop {Object} appState Tracked GL state.
    @prop {GLsizei} numElements The number of element to draw.
    @prop {GLsizei} numInstances The number of instances to draw.
*/ parcelHelpers.export(exports, "DrawCall", ()=>DrawCall
);
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////
var _constantsJs = require("./constants.js");
class DrawCall {
    constructor(gl, appState, program, vertexArray = null, primitive){
        this.gl = gl;
        this.currentProgram = program;
        this.drawPrimitive = _constantsJs.GL.TRIANGLES;
        this.currentVertexArray = vertexArray;
        this.currentTransformFeedback = null;
        this.appState = appState;
        this.uniformIndices = {
        };
        this.uniformNames = new Array(_constantsJs.WEBGL_INFO.MAX_UNIFORMS);
        this.uniformValues = new Array(_constantsJs.WEBGL_INFO.MAX_UNIFORMS);
        this.uniformCount = 0;
        this.uniformBuffers = new Array(_constantsJs.WEBGL_INFO.MAX_UNIFORM_BUFFERS);
        this.uniformBlockNames = new Array(_constantsJs.WEBGL_INFO.MAX_UNIFORM_BUFFERS);
        this.uniformBlockCount = 0;
        this.textures = new Array(_constantsJs.WEBGL_INFO.MAX_TEXTURE_UNITS);
        this.textureCount = 0;
        this.offsets = new Int32Array(1);
        this.numElements = new Int32Array(1);
        this.numInstances = new Int32Array(1);
        this.baseVertices = new Int32Array(1);
        this.baseInstances = new Uint32Array(1);
        this.hasBaseInstancesOrBaseVertices = false;
        this.missingExtensionWarningDispatched = false;
        this.numDraws = 1;
        this.drawCountsFromVertexArray = true;
        if (primitive !== undefined) {
            console.warn("Primitive argument to 'App.createDrawCall' is deprecated and will be removed. Use 'DrawCall.primitive' instead.");
            this.primitive(primitive);
        }
    }
    /**
        Set the current draw primitive for this draw call.

        @method
        @param {GLenum} primitive Primitive to draw.
        @return {DrawCall} The DrawCall object.
    */ primitive(primitive) {
        this.drawPrimitive = primitive;
        return this;
    }
    /**
        Set the current TransformFeedback object for draw.

        @method
        @param {TransformFeedback} transformFeedback Transform Feedback to set.
        @return {DrawCall} The DrawCall object.
    */ transformFeedback(transformFeedback) {
        this.currentTransformFeedback = transformFeedback;
        return this;
    }
    /**
        Set the value for a uniform. Array uniforms are supported by
        using appending "[0]" to the array name and passing a flat array
        with all required values.

        @method
        @param {string} name Uniform name.
        @param {any} value Uniform value.
        @return {DrawCall} The DrawCall object.
    */ uniform(name, value) {
        let index = this.uniformIndices[name];
        if (index === undefined) {
            index = this.uniformCount++;
            this.uniformIndices[name] = index;
            this.uniformNames[index] = name;
        }
        this.uniformValues[index] = value;
        return this;
    }
    /**
        Set texture to bind to a sampler uniform.

        @method
        @param {string} name Sampler uniform name.
        @param {Texture|Cubemap} texture Texture or Cubemap to bind.
        @return {DrawCall} The DrawCall object.
    */ texture(name, texture) {
        let unit = this.currentProgram.samplers[name];
        this.textures[unit] = texture;
        return this;
    }
    /**
        Set uniform buffer to bind to a uniform block.

        @method
        @param {string} name Uniform block name.
        @param {UniformBuffer} buffer Uniform buffer to bind.
        @return {DrawCall} The DrawCall object.
    */ uniformBlock(name, buffer) {
        let base = this.currentProgram.uniformBlocks[name];
        this.uniformBuffers[base] = buffer;
        return this;
    }
    /**
        Ranges in the vertex array to draw. Multiple arguments can be provided to set up
        a multi-draw. Note that after this method is called, draw counts will no longer
        automatically be pulled from the VertexArray.

        @method
        @param {...Array} counts Variable number of 2 or 3 element arrays, each containing:
            <ul>
                <li> (Number) Number of elements to skip at the start of the array.
                <li> (Number) Number of elements to draw.
                <li> (Number - optional) Number of instances to draw of the given range.
                <li> (Number - optional) Base instance to begin drawing.
                <li> (Number - optional) Base vertex to begin drawing.
            </ul>
        @return {DrawCall} The DrawCall object.
    */ drawRanges(...counts) {
        this.numDraws = counts.length;
        if (this.offsets.length < this.numDraws) this.offsets = new Int32Array(this.numDraws);
        if (this.numElements.length < this.numDraws) this.numElements = new Int32Array(this.numDraws);
        if (this.numInstances.length < this.numDraws) this.numInstances = new Int32Array(this.numDraws);
        if (this.baseInstances.length < this.numDraws) this.baseInstances = new Uint32Array(this.numDraws);
        if (this.baseVertices.length < this.numDraws) this.baseVertices = new Int32Array(this.numDraws);
        for(let i = 0; i < this.numDraws; ++i){
            let count = counts[i];
            this.offsets[i] = count[0];
            this.numElements[i] = count[1];
            this.numInstances[i] = count[2] || 1;
            this.baseInstances[i] = count[3] || 0;
            this.baseVertices[i] = count[4] || 0;
            this.hasBaseVertices = this.hasBaseVertices || this.baseVertices[i];
            this.hasBaseInstances = this.hasBaseInstances || this.baseInstances[i];
            this.hasBaseInstancesOrBaseVertices = this.hasBaseInstances || this.hasBaseVertices;
        }
        this.drawCountsFromVertexArray = false;
        return this;
    }
    /**
        Draw based on current state.

        @method
        @return {DrawCall} The DrawCall object.
    */ draw() {
        let uniformNames = this.uniformNames;
        let uniformValues = this.uniformValues;
        let uniformBuffers = this.uniformBuffers;
        let uniformBlockCount = this.currentProgram.uniformBlockCount;
        let textures = this.textures;
        let textureCount = this.currentProgram.samplerCount;
        let indexed = false;
        this.currentProgram.bind();
        if (this.currentVertexArray) {
            this.currentVertexArray.bind();
            indexed = this.currentVertexArray.indexed;
            if (this.drawCountsFromVertexArray) {
                this.numElements[0] = this.currentVertexArray.numElements;
                this.numInstances[0] = this.currentVertexArray.numInstances;
            }
        }
        for(let uIndex = 0; uIndex < this.uniformCount; ++uIndex)this.currentProgram.uniform(uniformNames[uIndex], uniformValues[uIndex]);
        for(let base = 0; base < uniformBlockCount; ++base)uniformBuffers[base].bind(base);
        for(let tIndex = 0; tIndex < textureCount; ++tIndex)textures[tIndex].bind(tIndex);
        if (this.currentTransformFeedback) {
            this.currentTransformFeedback.bind();
            this.gl.beginTransformFeedback(this.drawPrimitive);
        } else if (this.appState.transformFeedback) {
            this.gl.bindTransformFeedback(_constantsJs.GL.TRANSFORM_FEEDBACK, null);
            this.appState.transformFeedback = null;
        }
        if (this.hasBaseInstancesOrBaseVertices && !(_constantsJs.WEBGL_INFO.DRAW_INSTANCED_BASE_VERTEX_BASE_INSTANCE || _constantsJs.WEBGL_INFO.MULTI_DRAW_INSTANCED_BASE_VERTEX_BASE_INSTANCE) && !this.missingExtensionWarningDispatched) {
            console.warn("DrawCall.draw 'baseInstances' or 'baseVertices' have been set but supporting WebGL extensions are not available; Without 'WEBGL_multidraw_instanced_base_vertex_base_instance' or 'WEBGL_draw_instanced_base_vertex_base_instance' are needed for optimal performance.");
            this.missingExtensionWarningDispatched = true;
        }
        if (_constantsJs.WEBGL_INFO.MULTI_DRAW_INSTANCED_BASE_VERTEX_BASE_INSTANCE) {
            let ext = this.appState.extensions.multiDrawInstancedBaseVertexBaseInstance;
            if (indexed) ext.multiDrawElementsInstancedBaseVertexBaseInstanceWEBGL(this.drawPrimitive, this.numElements, 0, this.currentVertexArray.indexType, this.offsets, 0, this.numInstances, 0, this.baseVertices, 0, this.baseInstances, 0, this.numDraws);
            else ext.multiDrawArraysInstancedBaseInstanceWEBGL(this.drawPrimitive, this.offsets, 0, this.numElements, 0, this.numInstances, 0, this.baseInstances, 0, this.numDraws);
        } else if (this.hasBaseInstancesOrBaseVertices && _constantsJs.WEBGL_INFO.DRAW_INSTANCED_BASE_VERTEX_BASE_INSTANCE) {
            let ext = this.appState.extensions.drawInstancedBaseVertexBaseInstance;
            if (indexed) for(let i = 0; i < this.numDraws; ++i)ext.drawElementsInstancedBaseVertexBaseInstanceWEBGL(this.drawPrimitive, this.numElements[i], this.currentVertexArray.indexType, this.offsets[i], this.numInstances[i], this.baseVertices[i], this.baseInstances[i]);
            else for(let i2 = 0; i2 < this.numDraws; ++i2)ext.drawArraysInstancedBaseInstanceWEBGL(this.drawPrimitive, this.offsets[i2], this.numElements[i2], this.numInstances[i2], this.baseInstances[i2]);
        } else if (_constantsJs.WEBGL_INFO.MULTI_DRAW_INSTANCED && !this.hasBaseInstancesOrBaseVertices) {
            let ext = this.appState.extensions.multiDrawInstanced;
            if (indexed) ext.multiDrawElementsInstancedWEBGL(this.drawPrimitive, this.numElements, 0, this.currentVertexArray.indexType, this.offsets, 0, this.numInstances, 0, this.numDraws);
            else ext.multiDrawArraysInstancedWEBGL(this.drawPrimitive, this.offsets, 0, this.numElements, 0, this.numInstances, 0, this.numDraws);
        } else if (indexed) for(let i = 0; i < this.numDraws; ++i){
            if (this.hasBaseInstances) {
                if (this.currentVertexArray) this.currentVertexArray.baseOffsetInstanceAttributeBuffers(this.baseInstances[i]);
            }
            this.gl.drawElementsInstanced(this.drawPrimitive, this.numElements[i], this.currentVertexArray.indexType, this.offsets[i], this.numInstances[i]);
        }
        else for(let i1 = 0; i1 < this.numDraws; ++i1){
            if (this.hasBaseInstances) {
                if (this.currentVertexArray) this.currentVertexArray.baseOffsetInstanceAttributeBuffers(this.baseInstances[i1]);
            }
            this.gl.drawArraysInstanced(this.drawPrimitive, this.offsets[i1], this.numElements[i1], this.numInstances[i1]);
        }
        if (this.currentTransformFeedback) this.gl.endTransformFeedback();
        return this;
    }
}

},{"./constants.js":"jCl2R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3QRlD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
    Offscreen drawing surface.

    @class Framebuffer
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLFramebuffer} framebuffer Handle to the framebuffer.
    @prop {number} width Framebuffer width.
    @prop {number} height Framebuffer height.
    @prop {Array} colorAttachments Array of color attachments.
    @prop {Texture|Renderbuffer} depthAttachment Depth attachment.
    @prop {Object} appState Tracked GL state.
*/ parcelHelpers.export(exports, "Framebuffer", ()=>Framebuffer
);
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////
var _constantsJs = require("./constants.js");
var _textureJs = require("./texture.js");
var _renderbufferJs = require("./renderbuffer.js");
class Framebuffer {
    constructor(gl, appState){
        this.gl = gl;
        this.framebuffer = null;
        this.appState = appState;
        this.numColorTargets = 0;
        this.colorAttachments = [];
        this.colorAttachmentEnums = [];
        this.colorAttachmentTargets = [];
        this.depthAttachment = null;
        this.depthAttachmentTarget = null;
        this.width = 0;
        this.height = 0;
        this.restore();
    }
    /**
        Restore framebuffer after context loss.

        @method
        @return {Framebuffer} The Framebuffer object.
    */ restore() {
        let currentFramebuffers = this.appState.framebuffers;
        for(let binding in currentFramebuffers)if (currentFramebuffers[binding] === this) currentFramebuffers[binding] = null;
        this.framebuffer = this.gl.createFramebuffer();
        return this;
    }
    /**
        Attach a color target to this framebuffer.

        @method
        @param {number} index Color attachment index.
        @param {Texture|Cubemap|Renderbuffer} attachment The texture, cubemap or renderbuffer to attach.
        @param {GLenum} [target] The texture target or layer to attach. If the texture is 3D or a texture array,
            defaults to 0, otherwise to TEXTURE_2D. Ignored for renderbuffers.
        @return {Framebuffer} The Framebuffer object.
    */ colorTarget(index, attachment, target = attachment.is3D ? 0 : _constantsJs.GL.TEXTURE_2D) {
        if (index >= this.numColorTargets) {
            let numColorTargets = index + 1;
            this.colorAttachmentEnums.length = numColorTargets;
            this.colorAttachments.length = numColorTargets;
            this.colorAttachmentTargets.length = numColorTargets;
            for(let i = this.numColorTargets; i < numColorTargets - 1; ++i){
                this.colorAttachmentEnums[i] = _constantsJs.GL.NONE;
                this.colorAttachments[i] = null;
                this.colorAttachmentTargets[i] = 0;
            }
            this.numColorTargets = numColorTargets;
        }
        this.colorAttachmentEnums[index] = _constantsJs.GL.COLOR_ATTACHMENT0 + index;
        this.colorAttachments[index] = attachment;
        this.colorAttachmentTargets[index] = target;
        let currentFramebuffer = this.bindAndCaptureState();
        let binding = this.appState.drawFramebufferBinding;
        if (attachment instanceof _renderbufferJs.Renderbuffer) this.gl.framebufferRenderbuffer(binding, this.colorAttachmentEnums[index], _constantsJs.GL.RENDERBUFFER, attachment.renderbuffer);
        else if (attachment.is3D) this.gl.framebufferTextureLayer(binding, this.colorAttachmentEnums[index], attachment.texture, 0, target);
        else this.gl.framebufferTexture2D(binding, this.colorAttachmentEnums[index], target, attachment.texture, 0);
        this.gl.drawBuffers(this.colorAttachmentEnums);
        this.width = attachment.width;
        this.height = attachment.height;
        this.restoreState(currentFramebuffer);
        return this;
    }
    /**
        Attach a depth target to this framebuffer.

        @method
        @param {Texture|Cubemap|Renderbuffer} texture The texture, cubemap or renderbuffer to attach.
        @param {GLenum} [target] The texture target or layer to attach. If the texture is 3D or a texture array or renderbuffer,
            defaults to 0, otherwise to TEXTURE_2D. Ignored for renderbuffers.
        @return {Framebuffer} The Framebuffer object.
    */ depthTarget(attachment, target = attachment.is3D ? 0 : _constantsJs.GL.TEXTURE_2D) {
        let currentFramebuffer = this.bindAndCaptureState();
        let binding = this.appState.drawFramebufferBinding;
        this.depthAttachment = attachment;
        this.depthAttachmentTarget = target;
        if (attachment instanceof _renderbufferJs.Renderbuffer) this.gl.framebufferRenderbuffer(binding, _constantsJs.GL.DEPTH_ATTACHMENT, _constantsJs.GL.RENDERBUFFER, attachment.renderbuffer);
        else if (attachment.is3D) this.gl.framebufferTextureLayer(binding, _constantsJs.GL.DEPTH_ATTACHMENT, attachment.texture, 0, target);
        else this.gl.framebufferTexture2D(binding, _constantsJs.GL.DEPTH_ATTACHMENT, target, attachment.texture, 0);
        this.width = attachment.width;
        this.height = attachment.height;
        this.restoreState(currentFramebuffer);
        return this;
    }
    /**
        Resize all attachments.

        @method
        @param {number} [width=app.width] New width of the framebuffer.
        @param {number} [height=app.height] New height of the framebuffer.
        @return {Framebuffer} The Framebuffer object.
    */ resize(width = this.gl.drawingBufferWidth, height = this.gl.drawingBufferHeight) {
        let currentFramebuffer = this.bindAndCaptureState();
        let binding = this.appState.drawFramebufferBinding;
        for(let i = 0; i < this.numColorTargets; ++i){
            let attachment = this.colorAttachments[i];
            if (!attachment) continue;
            attachment.resize(width, height);
            if (attachment instanceof _textureJs.Texture) {
                // Texture resizing recreates the texture object.
                if (attachment.is3D) this.gl.framebufferTextureLayer(binding, this.colorAttachmentEnums[i], attachment.texture, 0, this.colorAttachmentTargets[i]);
                else this.gl.framebufferTexture2D(binding, this.colorAttachmentEnums[i], this.colorAttachmentTargets[i], attachment.texture, 0);
            }
        }
        if (this.depthAttachment) {
            this.depthAttachment.resize(width, height);
            if (this.depthAttachment instanceof _textureJs.Texture) {
                // Texture resizing recreates the texture object.
                if (this.depthAttachment.is3D) this.gl.framebufferTextureLayer(binding, _constantsJs.GL.DEPTH_ATTACHMENT, this.depthAttachment.texture, 0, this.depthAttachmentTarget);
                else this.gl.framebufferTexture2D(binding, _constantsJs.GL.DEPTH_ATTACHMENT, this.depthAttachmentTarget, this.depthAttachment.texture, 0);
            }
        }
        this.width = width;
        this.height = height;
        this.restoreState(currentFramebuffer);
        return this;
    }
    /**
        Delete this framebuffer.

        @method
        @return {Framebuffer} The Framebuffer object.
    */ delete() {
        if (this.framebuffer) {
            this.gl.deleteFramebuffer(this.framebuffer);
            this.framebuffer = null;
            let currentFramebuffers = this.appState.framebuffers;
            for(let binding in currentFramebuffers)if (currentFramebuffers[binding] === this) {
                this.gl.bindFramebuffer(binding, null);
                currentFramebuffers[binding] = null;
            }
        }
        return this;
    }
    /**
        Get the current status of this framebuffer.

        @method
        @return {GLenum} The current status of this framebuffer.
    */ getStatus() {
        let currentFramebuffer = this.bindAndCaptureState();
        let binding = this.appState.drawFramebufferBinding;
        let status = this.gl.checkFramebufferStatus(binding);
        this.restoreState(currentFramebuffer);
        return status;
    }
    /**
        Bind as the draw framebuffer

        @method
        @ignore
        @return {Framebuffer} The Framebuffer object.
    */ bindForDraw() {
        let binding = this.appState.drawFramebufferBinding;
        let currentFramebuffers = this.appState.framebuffers;
        if (currentFramebuffers[binding] !== this) {
            this.gl.bindFramebuffer(binding, this.framebuffer);
            currentFramebuffers[binding] = this;
        }
        return this;
    }
    /**
        Bind as the read framebuffer

        @method
        @ignore
        @return {Framebuffer} The Framebuffer object.
    */ bindForRead() {
        let binding = this.appState.readFramebufferBinding;
        let currentFramebuffers = this.appState.framebuffers;
        if (currentFramebuffers[binding] !== this) {
            this.gl.bindFramebuffer(binding, this.framebuffer);
            currentFramebuffers[binding] = this;
        }
        return this;
    }
    /**
        Bind for a framebuffer state update.
        Capture current binding so we can restore it later.

        @method
        @ignore
        @return {Framebuffer} The Framebuffer object.
    */ bindAndCaptureState() {
        let binding = this.appState.drawFramebufferBinding;
        let currentFramebuffer = this.appState.framebuffers[binding];
        if (currentFramebuffer !== this) this.gl.bindFramebuffer(binding, this.framebuffer);
        return currentFramebuffer;
    }
    /**
        Bind restore previous binding after state update

        @method
        @ignore
        @return {Framebuffer} The Framebuffer object.
    */ restoreState(framebuffer) {
        if (framebuffer !== this) {
            let binding = this.appState.drawFramebufferBinding;
            this.gl.bindFramebuffer(binding, framebuffer ? framebuffer.framebuffer : null);
        }
        return this;
    }
    // TODO(Tarek): Transitional support for deprecated properties.
    get colorTextures() {
        console.error("Framebuffer.colorTextures is deprecated and will be removed. Please use Framebuffer.colorAttachments.");
        return this.colorAttachments;
    }
    get depthTexture() {
        console.error("Framebuffer.depthTexture is deprecated and will be removed. Please use Framebuffer.depthAttachment.");
        return this.depthAttachment;
    }
}

},{"./constants.js":"jCl2R","./texture.js":"9g3ZT","./renderbuffer.js":"4BxUD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9g3ZT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
    General-purpose texture.

    @class Texture
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLTexture} texture Handle to the texture.
    @prop {number} width Texture width.
    @prop {number} height Texture height.
    @prop {number} depth Texture depth.
    @prop {GLenum} binding Binding point for the texture.
    @prop {GLenum} type Type of data stored in the texture.
    @prop {GLenum} format Layout of texture data.
    @prop {GLenum} internalFormat Internal arrangement of the texture data.
    @prop {number} currentUnit The current texture unit this texture is bound to.
    @prop {boolean} is3D Whether this texture contains 3D data.
    @prop {boolean} flipY Whether the y-axis is flipped for this texture.
    @prop {boolean} premultiplyAlpha Whether alpha should be pre-multiplied when loading this texture.
    @prop {boolean} mipmaps Whether this texture is using mipmap filtering
        (and thus should have a complete mipmap chain).
    @prop {Object} appState Tracked GL state.
*/ parcelHelpers.export(exports, "Texture", ()=>Texture
);
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////
var _constantsJs = require("./constants.js");
class Texture {
    constructor(gl, appState, binding, image, width = image.width, height = image.height, depth, is3D, options = _constantsJs.DUMMY_OBJECT){
        this.gl = gl;
        this.binding = binding;
        this.texture = null;
        this.width = width || 0;
        this.height = height || 0;
        this.depth = depth || 0;
        this.is3D = is3D;
        this.appState = appState;
        this.compressed = Boolean(_constantsJs.COMPRESSED_TEXTURE_TYPES[options.internalFormat]);
        if (options.format !== undefined) {
            console.warn("Texture option 'format' is deprecated and will be removed. Use 'internalFormat' with a sized format instead.");
            this.compressed = Boolean(_constantsJs.COMPRESSED_TEXTURE_TYPES[options.format]);
            if (options.type === undefined) options.type = options.format === _constantsJs.GL.DEPTH_COMPONENT ? _constantsJs.GL.UNSIGNED_SHORT : _constantsJs.GL.UNSIGNED_BYTE;
            if (options.internalFormat === undefined) {
                if (this.compressed) options.internalFormat = options.format;
                else options.internalFormat = _constantsJs.TEXTURE_FORMAT_DEFAULTS[options.type][options.format];
            }
        }
        if (this.compressed) {
            // For compressed textures, just need to provide one of format, internalFormat.
            // The other will be the same.
            this.internalFormat = options.internalFormat;
            this.format = this.internalFormat;
            this.type = _constantsJs.GL.UNSIGNED_BYTE;
        } else {
            this.internalFormat = options.internalFormat !== undefined ? options.internalFormat : _constantsJs.GL.RGBA8;
            let formatInfo = _constantsJs.TEXTURE_FORMATS[this.internalFormat];
            this.format = formatInfo[0];
            this.type = options.type !== undefined ? options.type : formatInfo[1];
        }
        // -1 indicates unbound
        this.currentUnit = -1;
        // Sampling parameters
        let { minFilter =image ? _constantsJs.GL.LINEAR_MIPMAP_NEAREST : _constantsJs.GL.NEAREST , magFilter =image ? _constantsJs.GL.LINEAR : _constantsJs.GL.NEAREST , wrapS =_constantsJs.GL.REPEAT , wrapT =_constantsJs.GL.REPEAT , wrapR =_constantsJs.GL.REPEAT , compareMode =_constantsJs.GL.NONE , compareFunc =_constantsJs.GL.LEQUAL , minLOD =null , maxLOD =null , baseLevel =null , maxLevel =null , maxAnisotropy =1 , flipY =false , premultiplyAlpha =false  } = options;
        this.minFilter = minFilter;
        this.magFilter = magFilter;
        this.wrapS = wrapS;
        this.wrapT = wrapT;
        this.wrapR = wrapR;
        this.compareMode = compareMode;
        this.compareFunc = compareFunc;
        this.minLOD = minLOD;
        this.maxLOD = maxLOD;
        this.baseLevel = baseLevel;
        this.maxLevel = maxLevel;
        this.maxAnisotropy = Math.min(maxAnisotropy, _constantsJs.WEBGL_INFO.MAX_TEXTURE_ANISOTROPY);
        this.flipY = flipY;
        this.premultiplyAlpha = premultiplyAlpha;
        this.mipmaps = minFilter === _constantsJs.GL.LINEAR_MIPMAP_NEAREST || minFilter === _constantsJs.GL.LINEAR_MIPMAP_LINEAR;
        this.restore(image);
    }
    /**
        Restore texture after context loss.

        @method
        @param {HTMLElement|ArrayBufferView|Array} [image] Image data. An array can be passed to manually set all levels
            of the mipmap chain. If a single level is passed and mipmap filtering is being used,
            generateMipmap() will be called to produce the remaining levels.
        @return {Texture} The Texture object.
    */ restore(image) {
        this.texture = null;
        this.resize(this.width, this.height, this.depth);
        if (image) this.data(image);
        return this;
    }
    /**
        Re-allocate texture storage.

        @method
        @param {number} width Image width.
        @param {number} height Image height.
        @param {number} [depth] Image depth or number of images. Required when passing 3D or texture array data.
        @return {Texture} The Texture object.
    */ resize(width, height, depth) {
        depth = depth || 0;
        if (this.texture && width === this.width && height === this.height && depth === this.depth) return this;
        this.gl.deleteTexture(this.texture);
        if (this.currentUnit !== -1) this.appState.textures[this.currentUnit] = null;
        this.texture = this.gl.createTexture();
        this.bind(Math.max(this.currentUnit, 0));
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.gl.texParameteri(this.binding, _constantsJs.GL.TEXTURE_MIN_FILTER, this.minFilter);
        this.gl.texParameteri(this.binding, _constantsJs.GL.TEXTURE_MAG_FILTER, this.magFilter);
        this.gl.texParameteri(this.binding, _constantsJs.GL.TEXTURE_WRAP_S, this.wrapS);
        this.gl.texParameteri(this.binding, _constantsJs.GL.TEXTURE_WRAP_T, this.wrapT);
        this.gl.texParameteri(this.binding, _constantsJs.GL.TEXTURE_WRAP_R, this.wrapR);
        this.gl.texParameteri(this.binding, _constantsJs.GL.TEXTURE_COMPARE_FUNC, this.compareFunc);
        this.gl.texParameteri(this.binding, _constantsJs.GL.TEXTURE_COMPARE_MODE, this.compareMode);
        if (this.minLOD !== null) this.gl.texParameterf(this.binding, _constantsJs.GL.TEXTURE_MIN_LOD, this.minLOD);
        if (this.maxLOD !== null) this.gl.texParameterf(this.binding, _constantsJs.GL.TEXTURE_MAX_LOD, this.maxLOD);
        if (this.baseLevel !== null) this.gl.texParameteri(this.binding, _constantsJs.GL.TEXTURE_BASE_LEVEL, this.baseLevel);
        if (this.maxLevel !== null) this.gl.texParameteri(this.binding, _constantsJs.GL.TEXTURE_MAX_LEVEL, this.maxLevel);
        if (this.maxAnisotropy > 1) this.gl.texParameteri(this.binding, _constantsJs.GL.TEXTURE_MAX_ANISOTROPY_EXT, this.maxAnisotropy);
        let levels;
        if (this.is3D) {
            if (this.mipmaps) levels = Math.floor(Math.log2(Math.max(Math.max(this.width, this.height), this.depth))) + 1;
            else levels = 1;
            this.gl.texStorage3D(this.binding, levels, this.internalFormat, this.width, this.height, this.depth);
        } else {
            if (this.mipmaps) levels = Math.floor(Math.log2(Math.max(this.width, this.height))) + 1;
            else levels = 1;
            this.gl.texStorage2D(this.binding, levels, this.internalFormat, this.width, this.height);
        }
        return this;
    }
    /**
        Set the image data for the texture. An array can be passed to manually set all levels
        of the mipmap chain. If a single level is passed and mipmap filtering is being used,
        generateMipmap() will be called to produce the remaining levels.
        NOTE: the data must fit the currently-allocated storage!

        @method
        @param {HTMLImageElement|ArrayBufferView|Array} data Image data. If an array is passed, it will be
            used to set mip map levels.
        @return {Texture} The Texture object.
    */ data(data) {
        if (!Array.isArray(data)) {
            _constantsJs.DUMMY_UNIT_ARRAY[0] = data;
            data = _constantsJs.DUMMY_UNIT_ARRAY;
        }
        let numLevels = this.mipmaps ? data.length : 1;
        let width = this.width;
        let height = this.height;
        let depth = this.depth;
        let generateMipmaps = this.mipmaps && data.length === 1;
        let i;
        this.bind(Math.max(this.currentUnit, 0));
        this.gl.pixelStorei(_constantsJs.GL.UNPACK_FLIP_Y_WEBGL, this.flipY);
        this.gl.pixelStorei(_constantsJs.GL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
        if (this.compressed) {
            if (this.is3D) for(i = 0; i < numLevels; ++i){
                this.gl.compressedTexSubImage3D(this.binding, i, 0, 0, 0, width, height, depth, this.format, data[i]);
                width = Math.max(width >> 1, 1);
                height = Math.max(height >> 1, 1);
                depth = Math.max(depth >> 1, 1);
            }
            else for(i = 0; i < numLevels; ++i){
                this.gl.compressedTexSubImage2D(this.binding, i, 0, 0, width, height, this.format, data[i]);
                width = Math.max(width >> 1, 1);
                height = Math.max(height >> 1, 1);
            }
        } else if (this.is3D) for(i = 0; i < numLevels; ++i){
            this.gl.texSubImage3D(this.binding, i, 0, 0, 0, width, height, depth, this.format, this.type, data[i]);
            width = Math.max(width >> 1, 1);
            height = Math.max(height >> 1, 1);
            depth = Math.max(depth >> 1, 1);
        }
        else for(i = 0; i < numLevels; ++i){
            this.gl.texSubImage2D(this.binding, i, 0, 0, width, height, this.format, this.type, data[i]);
            width = Math.max(width >> 1, 1);
            height = Math.max(height >> 1, 1);
        }
        if (generateMipmaps) this.gl.generateMipmap(this.binding);
        return this;
    }
    /**
        Delete this texture.

        @method
        @return {Texture} The Texture object.
    */ delete() {
        if (this.texture) {
            this.gl.deleteTexture(this.texture);
            this.texture = null;
            if (this.currentUnit !== -1 && this.appState.textures[this.currentUnit] === this) {
                this.appState.textures[this.currentUnit] = null;
                this.currentUnit = -1;
            }
        }
        return this;
    }
    /**
        Bind this texture to a texture unit.

        @method
        @ignore
        @return {Texture} The Texture object.
    */ bind(unit) {
        let currentTexture = this.appState.textures[unit];
        if (this.appState.activeTexture !== unit) {
            this.gl.activeTexture(_constantsJs.GL.TEXTURE0 + unit);
            this.appState.activeTexture = unit;
        }
        if (currentTexture !== this) {
            if (currentTexture) currentTexture.currentUnit = -1;
            if (this.currentUnit !== -1) this.appState.textures[this.currentUnit] = null;
            this.gl.bindTexture(this.binding, this.texture);
            this.appState.textures[unit] = this;
            this.currentUnit = unit;
        }
        return this;
    }
}

},{"./constants.js":"jCl2R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4BxUD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
    Offscreen drawing attachment.

    @class Renderbuffer
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLRenderbuffer} renderbuffer Handle to the renderbuffer.
    @prop {number} width Renderbuffer width.
    @prop {number} height Renderbuffer height.
    @prop {GLenum} internalFormat Internal arrangement of the renderbuffer data.
    @prop {number} samples Number of MSAA samples.
*/ parcelHelpers.export(exports, "Renderbuffer", ()=>Renderbuffer
);
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////
var _constantsJs = require("./constants.js");
class Renderbuffer {
    constructor(gl, width, height, internalFormat, samples = 0){
        this.gl = gl;
        this.renderbuffer = null;
        this.width = width;
        this.height = height;
        this.internalFormat = internalFormat;
        this.samples = samples;
        this.restore();
    }
    /**
        Restore renderbuffer after context loss.

        @method
        @return {Renderbuffer} The Renderbuffer object.
    */ restore() {
        this.renderbuffer = this.gl.createRenderbuffer();
        this.resize(this.width, this.height);
        return this;
    }
    /**
        Resize the renderbuffer.

        @method
        @param {number} width New width of the renderbuffer.
        @param {number} height New height of the renderbuffer.
        @return {Renderbuffer} The Renderbuffer object.
    */ resize(width, height) {
        this.width = width;
        this.height = height;
        this.gl.bindRenderbuffer(_constantsJs.GL.RENDERBUFFER, this.renderbuffer);
        this.gl.renderbufferStorageMultisample(_constantsJs.GL.RENDERBUFFER, this.samples, this.internalFormat, this.width, this.height);
        this.gl.bindRenderbuffer(_constantsJs.GL.RENDERBUFFER, null);
        return this;
    }
    /**
        Delete this renderbuffer.

        @method
        @return {Renderbuffer} The Renderbuffer object.
    */ delete() {
        this.gl.deleteRenderbuffer(this.renderbuffer);
        this.renderbuffer = null;
        return this;
    }
}

},{"./constants.js":"jCl2R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cwgWW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
    WebGL program consisting of compiled and linked vertex and fragment
    shaders.

    @class Program
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLProgram} program The WebGL program.
    @prop {array} transformFeedbackVaryings Names of transform feedback varyings, if any.
    @prop {GLenum} transformFeedbackMode Capture mode of the transform feedback.
    @prop {Object.<string, number>} attributeLocations Map of user-provided attribute names to indices, if any.
    @prop {Object} uniforms Map of uniform names to handles.
    @prop {Object} appState Tracked GL state.
*/ parcelHelpers.export(exports, "Program", ()=>Program
);
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////
var _constantsJs = require("./constants.js");
var _shaderJs = require("./shader.js");
var _uniformsJs = require("./uniforms.js");
class Program {
    constructor(gl, appState, vsSource, fsSource, xformFeebackVars, attributeLocations, transformFeedbackMode){
        this.gl = gl;
        this.appState = appState;
        this.program = null;
        this.transformFeedbackVaryings = xformFeebackVars || null;
        this.transformFeedbackMode = transformFeedbackMode || _constantsJs.GL.SEPARATE_ATTRIBS;
        this.attributeLocations = attributeLocations || null;
        this.uniforms = {
        };
        this.uniformBlocks = {
        };
        this.uniformBlockCount = 0;
        this.samplers = {
        };
        this.samplerCount = 0;
        this.vertexSource = null;
        this.vertexShader = null;
        this.fragmentSource = null;
        this.fragmentShader = null;
        this.linked = false;
        if (typeof vsSource === "string") this.vertexSource = vsSource;
        else this.vertexShader = vsSource;
        if (typeof fsSource === "string") this.fragmentSource = fsSource;
        else this.fragmentShader = fsSource;
        this.initialize();
    }
    /**
        Restore program after context loss. Note that this
        will stall for completion. <b>App.restorePrograms</b>
        is the preferred method for program restoration as
        it will parallelize compilation where available.

        @method
        @return {Program} The Program object.
    */ restore() {
        this.initialize();
        this.link();
        this.checkLinkage();
        return this;
    }
    /**
        Get the vertex shader source translated for the platform's API.

        @method
        @return {String} The translated vertex shader source.
    */ translatedVertexSource() {
        if (this.vertexShader) return this.vertexShader.translatedSource();
        else {
            let vertexShader = new _shaderJs.Shader(this.gl, this.appState, _constantsJs.GL.VERTEX_SHADER, this.vertexSource);
            let translatedSource = vertexShader.translatedSource();
            vertexShader.delete();
            return translatedSource;
        }
    }
    /**
        Get the fragment shader source translated for the platform's API.

        @method
        @return {String} The translated fragment shader source.
    */ translatedFragmentSource() {
        if (this.fragmentShader) return this.fragmentShader.translatedSource();
        else {
            let fragmentShader = new _shaderJs.Shader(this.gl, this.appState, _constantsJs.GL.FRAGMENT_SHADER, this.fragmentSource);
            let translatedSource = fragmentShader.translatedSource();
            fragmentShader.delete();
            return translatedSource;
        }
    }
    /**
        Delete this program.

        @method
        @return {Program} The Program object.
    */ delete() {
        if (this.program) {
            this.gl.deleteProgram(this.program);
            this.program = null;
            if (this.appState.program === this) {
                this.gl.useProgram(null);
                this.appState.program = null;
            }
        }
        return this;
    }
    // Initialize program state
    initialize() {
        if (this.appState.program === this) {
            this.gl.useProgram(null);
            this.appState.program = null;
        }
        this.linked = false;
        this.uniformBlockCount = 0;
        this.samplerCount = 0;
        if (this.vertexSource) this.vertexShader = new _shaderJs.Shader(this.gl, this.appState, _constantsJs.GL.VERTEX_SHADER, this.vertexSource);
        if (this.fragmentSource) this.fragmentShader = new _shaderJs.Shader(this.gl, this.appState, _constantsJs.GL.FRAGMENT_SHADER, this.fragmentSource);
        this.program = this.gl.createProgram();
        return this;
    }
    // Attach shaders and link program.
    // Done as a separate step to avoid stalls on compileShader
    // when doing async compile.
    link() {
        this.gl.attachShader(this.program, this.vertexShader.shader);
        this.gl.attachShader(this.program, this.fragmentShader.shader);
        if (this.transformFeedbackVaryings) this.gl.transformFeedbackVaryings(this.program, this.transformFeedbackVaryings, this.transformFeedbackMode);
        if (this.attributeLocations) for(let name in this.attributeLocations)this.gl.bindAttribLocation(this.program, this.attributeLocations[name], name);
        this.gl.linkProgram(this.program);
        return this;
    }
    // Check if compilation is complete
    checkCompletion() {
        if (_constantsJs.WEBGL_INFO.PARALLEL_SHADER_COMPILE) return this.gl.getProgramParameter(this.program, _constantsJs.GL.COMPLETION_STATUS_KHR);
        return true;
    }
    // Check if program linked.
    // Will stall for completion.
    checkLinkage() {
        if (this.linked) return this;
        if (this.gl.getProgramParameter(this.program, _constantsJs.GL.LINK_STATUS)) {
            this.linked = true;
            this.initVariables();
        } else {
            console.error(this.gl.getProgramInfoLog(this.program));
            this.vertexShader.checkCompilation();
            this.fragmentShader.checkCompilation();
        }
        if (this.vertexSource) {
            this.vertexShader.delete();
            this.vertexShader = null;
        }
        if (this.fragmentSource) {
            this.fragmentShader.delete();
            this.fragmentShader = null;
        }
        return this;
    }
    // Get variable handles from program
    initVariables() {
        this.bind();
        let numUniforms = this.gl.getProgramParameter(this.program, _constantsJs.GL.ACTIVE_UNIFORMS);
        let textureUnit;
        for(let i = 0; i < numUniforms; ++i){
            let uniformInfo = this.gl.getActiveUniform(this.program, i);
            let uniformHandle = this.gl.getUniformLocation(this.program, uniformInfo.name);
            let UniformClass = null;
            let type = uniformInfo.type;
            let numElements = uniformInfo.size;
            switch(type){
                case _constantsJs.GL.SAMPLER_2D:
                case _constantsJs.GL.INT_SAMPLER_2D:
                case _constantsJs.GL.UNSIGNED_INT_SAMPLER_2D:
                case _constantsJs.GL.SAMPLER_2D_SHADOW:
                case _constantsJs.GL.SAMPLER_2D_ARRAY:
                case _constantsJs.GL.INT_SAMPLER_2D_ARRAY:
                case _constantsJs.GL.UNSIGNED_INT_SAMPLER_2D_ARRAY:
                case _constantsJs.GL.SAMPLER_2D_ARRAY_SHADOW:
                case _constantsJs.GL.SAMPLER_CUBE:
                case _constantsJs.GL.INT_SAMPLER_CUBE:
                case _constantsJs.GL.UNSIGNED_INT_SAMPLER_CUBE:
                case _constantsJs.GL.SAMPLER_CUBE_SHADOW:
                case _constantsJs.GL.SAMPLER_3D:
                case _constantsJs.GL.INT_SAMPLER_3D:
                case _constantsJs.GL.UNSIGNED_INT_SAMPLER_3D:
                    textureUnit = this.samplerCount++;
                    this.samplers[uniformInfo.name] = textureUnit;
                    this.gl.uniform1i(uniformHandle, textureUnit);
                    break;
                case _constantsJs.GL.INT:
                case _constantsJs.GL.UNSIGNED_INT:
                case _constantsJs.GL.FLOAT:
                    UniformClass = numElements > 1 ? _uniformsJs.MultiNumericUniform : _uniformsJs.SingleComponentUniform;
                    break;
                case _constantsJs.GL.BOOL:
                    UniformClass = numElements > 1 ? _uniformsJs.MultiBoolUniform : _uniformsJs.SingleComponentUniform;
                    break;
                case _constantsJs.GL.FLOAT_VEC2:
                case _constantsJs.GL.INT_VEC2:
                case _constantsJs.GL.UNSIGNED_INT_VEC2:
                case _constantsJs.GL.FLOAT_VEC3:
                case _constantsJs.GL.INT_VEC3:
                case _constantsJs.GL.UNSIGNED_INT_VEC3:
                case _constantsJs.GL.FLOAT_VEC4:
                case _constantsJs.GL.INT_VEC4:
                case _constantsJs.GL.UNSIGNED_INT_VEC4:
                    UniformClass = _uniformsJs.MultiNumericUniform;
                    break;
                case _constantsJs.GL.BOOL_VEC2:
                case _constantsJs.GL.BOOL_VEC3:
                case _constantsJs.GL.BOOL_VEC4:
                    UniformClass = _uniformsJs.MultiBoolUniform;
                    break;
                case _constantsJs.GL.FLOAT_MAT2:
                case _constantsJs.GL.FLOAT_MAT3:
                case _constantsJs.GL.FLOAT_MAT4:
                case _constantsJs.GL.FLOAT_MAT2x3:
                case _constantsJs.GL.FLOAT_MAT2x4:
                case _constantsJs.GL.FLOAT_MAT3x2:
                case _constantsJs.GL.FLOAT_MAT3x4:
                case _constantsJs.GL.FLOAT_MAT4x2:
                case _constantsJs.GL.FLOAT_MAT4x3:
                    UniformClass = _uniformsJs.MatrixUniform;
                    break;
                default:
                    console.error("Unrecognized type for uniform ", uniformInfo.name);
                    break;
            }
            if (UniformClass) this.uniforms[uniformInfo.name] = new UniformClass(this.gl, uniformHandle, type, numElements);
        }
        let numUniformBlocks = this.gl.getProgramParameter(this.program, _constantsJs.GL.ACTIVE_UNIFORM_BLOCKS);
        for(let i1 = 0; i1 < numUniformBlocks; ++i1){
            let blockName = this.gl.getActiveUniformBlockName(this.program, i1);
            let blockIndex = this.gl.getUniformBlockIndex(this.program, blockName);
            let uniformBlockBase = this.uniformBlockCount++;
            this.gl.uniformBlockBinding(this.program, blockIndex, uniformBlockBase);
            this.uniformBlocks[blockName] = uniformBlockBase;
        }
    }
    // Set the value of a uniform.
    uniform(name, value) {
        // some uniforms are optimized out
        if (this.uniforms[name]) this.uniforms[name].set(value);
        return this;
    }
    // Use this program.
    bind() {
        if (this.appState.program !== this) {
            this.gl.useProgram(this.program);
            this.appState.program = this;
        }
        return this;
    }
}

},{"./constants.js":"jCl2R","./shader.js":"gDRJa","./uniforms.js":"l1hk4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gDRJa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
    WebGL shader.

    @class Shader
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLShader} shader The shader.
*/ parcelHelpers.export(exports, "Shader", ()=>Shader
);
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////
var _constantsJs = require("./constants.js");
class Shader {
    constructor(gl, appState, type, source){
        this.gl = gl;
        this.appState = appState;
        this.shader = null;
        this.type = type;
        this.source = source.trim();
        this.restore();
    }
    /**
        Restore shader after context loss.

        @method
        @return {Shader} The Shader object.
    */ restore() {
        this.shader = this.gl.createShader(this.type);
        this.gl.shaderSource(this.shader, this.source);
        this.gl.compileShader(this.shader);
        return this;
    }
    /**
        Get the shader source translated for the platform's API.

        @method
        @return {String} The translated shader source.
    */ translatedSource() {
        if (_constantsJs.WEBGL_INFO.DEBUG_SHADERS) return this.appState.extensions.debugShaders.getTranslatedShaderSource(this.shader);
        else return "(Unavailable)";
    }
    /**
        Delete this shader.

        @method
        @return {Shader} The Shader object.
    */ delete() {
        if (this.shader) {
            this.gl.deleteShader(this.shader);
            this.shader = null;
        }
        return this;
    }
    checkCompilation() {
        if (!this.gl.getShaderParameter(this.shader, _constantsJs.GL.COMPILE_STATUS)) {
            let i, lines;
            console.error(this.gl.getShaderInfoLog(this.shader));
            lines = this.source.split("\n");
            for(i = 0; i < lines.length; ++i)console.error(`${i + 1}: ${lines[i]}`);
        }
        return this;
    }
}

},{"./constants.js":"jCl2R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l1hk4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SingleComponentUniform", ()=>SingleComponentUniform
);
parcelHelpers.export(exports, "MultiNumericUniform", ()=>MultiNumericUniform
);
parcelHelpers.export(exports, "MultiBoolUniform", ()=>MultiBoolUniform
);
parcelHelpers.export(exports, "MatrixUniform", ()=>MatrixUniform
);
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////
var _constantsJs = require("./constants.js");
// Classes to manage uniform value updates, including
// caching current values.
const UNIFORM_FUNC_NAME = {
};
UNIFORM_FUNC_NAME[_constantsJs.GL.BOOL] = "uniform1i";
UNIFORM_FUNC_NAME[_constantsJs.GL.INT] = "uniform1i";
UNIFORM_FUNC_NAME[_constantsJs.GL.SAMPLER_2D] = "uniform1i";
UNIFORM_FUNC_NAME[_constantsJs.GL.INT_SAMPLER_2D] = "uniform1i";
UNIFORM_FUNC_NAME[_constantsJs.GL.UNSIGNED_INT_SAMPLER_2D] = "uniform1i";
UNIFORM_FUNC_NAME[_constantsJs.GL.SAMPLER_2D_SHADOW] = "uniform1i";
UNIFORM_FUNC_NAME[_constantsJs.GL.SAMPLER_2D_ARRAY] = "uniform1i";
UNIFORM_FUNC_NAME[_constantsJs.GL.INT_SAMPLER_2D_ARRAY] = "uniform1i";
UNIFORM_FUNC_NAME[_constantsJs.GL.UNSIGNED_INT_SAMPLER_2D_ARRAY] = "uniform1i";
UNIFORM_FUNC_NAME[_constantsJs.GL.SAMPLER_2D_ARRAY_SHADOW] = "uniform1i";
UNIFORM_FUNC_NAME[_constantsJs.GL.SAMPLER_CUBE] = "uniform1i";
UNIFORM_FUNC_NAME[_constantsJs.GL.INT_SAMPLER_CUBE] = "uniform1i";
UNIFORM_FUNC_NAME[_constantsJs.GL.UNSIGNED_INT_SAMPLER_CUBE] = "uniform1i";
UNIFORM_FUNC_NAME[_constantsJs.GL.SAMPLER_CUBE_SHADOW] = "uniform1i";
UNIFORM_FUNC_NAME[_constantsJs.GL.SAMPLER_3D] = "uniform1i";
UNIFORM_FUNC_NAME[_constantsJs.GL.INT_SAMPLER_3D] = "uniform1i";
UNIFORM_FUNC_NAME[_constantsJs.GL.UNSIGNED_INT_SAMPLER_3D] = "uniform1i";
UNIFORM_FUNC_NAME[_constantsJs.GL.UNSIGNED_INT] = "uniform1ui";
UNIFORM_FUNC_NAME[_constantsJs.GL.FLOAT] = "uniform1f";
UNIFORM_FUNC_NAME[_constantsJs.GL.FLOAT_VEC2] = "uniform2f";
UNIFORM_FUNC_NAME[_constantsJs.GL.FLOAT_VEC3] = "uniform3f";
UNIFORM_FUNC_NAME[_constantsJs.GL.FLOAT_VEC4] = "uniform4f";
UNIFORM_FUNC_NAME[_constantsJs.GL.INT_VEC2] = "uniform2i";
UNIFORM_FUNC_NAME[_constantsJs.GL.INT_VEC3] = "uniform3i";
UNIFORM_FUNC_NAME[_constantsJs.GL.INT_VEC4] = "uniform4i";
UNIFORM_FUNC_NAME[_constantsJs.GL.UNSIGNED_INT_VEC2] = "uniform2ui";
UNIFORM_FUNC_NAME[_constantsJs.GL.UNSIGNED_INT_VEC3] = "uniform3ui";
UNIFORM_FUNC_NAME[_constantsJs.GL.UNSIGNED_INT_VEC4] = "uniform4ui";
UNIFORM_FUNC_NAME[_constantsJs.GL.BOOL_VEC2] = "uniform2i";
UNIFORM_FUNC_NAME[_constantsJs.GL.BOOL_VEC3] = "uniform3i";
UNIFORM_FUNC_NAME[_constantsJs.GL.BOOL_VEC4] = "uniform4i";
UNIFORM_FUNC_NAME[_constantsJs.GL.FLOAT_MAT2] = "uniformMatrix2fv";
UNIFORM_FUNC_NAME[_constantsJs.GL.FLOAT_MAT3] = "uniformMatrix3fv";
UNIFORM_FUNC_NAME[_constantsJs.GL.FLOAT_MAT4] = "uniformMatrix4fv";
UNIFORM_FUNC_NAME[_constantsJs.GL.FLOAT_MAT2x3] = "uniformMatrix2x3fv";
UNIFORM_FUNC_NAME[_constantsJs.GL.FLOAT_MAT2x4] = "uniformMatrix2x4fv";
UNIFORM_FUNC_NAME[_constantsJs.GL.FLOAT_MAT3x2] = "uniformMatrix3x2fv";
UNIFORM_FUNC_NAME[_constantsJs.GL.FLOAT_MAT3x4] = "uniformMatrix3x4fv";
UNIFORM_FUNC_NAME[_constantsJs.GL.FLOAT_MAT4x2] = "uniformMatrix4x2fv";
UNIFORM_FUNC_NAME[_constantsJs.GL.FLOAT_MAT4x3] = "uniformMatrix4x3fv";
const UNIFORM_COMPONENT_COUNT = {
};
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.BOOL] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.INT] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.SAMPLER_2D] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.INT_SAMPLER_2D] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.UNSIGNED_INT_SAMPLER_2D] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.SAMPLER_2D_SHADOW] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.SAMPLER_2D_ARRAY] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.INT_SAMPLER_2D_ARRAY] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.UNSIGNED_INT_SAMPLER_2D_ARRAY] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.SAMPLER_2D_ARRAY_SHADOW] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.SAMPLER_CUBE] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.INT_SAMPLER_CUBE] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.UNSIGNED_INT_SAMPLER_CUBE] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.SAMPLER_CUBE_SHADOW] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.SAMPLER_3D] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.INT_SAMPLER_3D] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.UNSIGNED_INT_SAMPLER_3D] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.UNSIGNED_INT] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.FLOAT] = 1;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.FLOAT_VEC2] = 2;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.FLOAT_VEC3] = 3;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.FLOAT_VEC4] = 4;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.INT_VEC2] = 2;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.INT_VEC3] = 3;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.INT_VEC4] = 4;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.UNSIGNED_INT_VEC2] = 2;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.UNSIGNED_INT_VEC3] = 3;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.UNSIGNED_INT_VEC4] = 4;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.BOOL_VEC2] = 2;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.BOOL_VEC3] = 3;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.BOOL_VEC4] = 4;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.FLOAT_MAT2] = 4;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.FLOAT_MAT3] = 9;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.FLOAT_MAT4] = 16;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.FLOAT_MAT2x3] = 6;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.FLOAT_MAT2x4] = 8;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.FLOAT_MAT3x2] = 6;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.FLOAT_MAT3x4] = 12;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.FLOAT_MAT4x2] = 8;
UNIFORM_COMPONENT_COUNT[_constantsJs.GL.FLOAT_MAT4x3] = 12;
const UNIFORM_CACHE_CLASS = {
};
UNIFORM_CACHE_CLASS[_constantsJs.GL.INT] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.SAMPLER_2D] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.INT_SAMPLER_2D] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.UNSIGNED_INT_SAMPLER_2D] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.SAMPLER_2D_SHADOW] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.SAMPLER_2D_ARRAY] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.INT_SAMPLER_2D_ARRAY] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.UNSIGNED_INT_SAMPLER_2D_ARRAY] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.SAMPLER_2D_ARRAY_SHADOW] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.SAMPLER_CUBE] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.INT_SAMPLER_CUBE] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.UNSIGNED_INT_SAMPLER_CUBE] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.SAMPLER_CUBE_SHADOW] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.SAMPLER_3D] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.INT_SAMPLER_3D] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.UNSIGNED_INT_SAMPLER_3D] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.UNSIGNED_INT] = Uint32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.FLOAT] = Float32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.FLOAT_VEC2] = Float32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.FLOAT_VEC3] = Float32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.FLOAT_VEC4] = Float32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.INT_VEC2] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.INT_VEC3] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.INT_VEC4] = Int32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.UNSIGNED_INT_VEC2] = Uint32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.UNSIGNED_INT_VEC3] = Uint32Array;
UNIFORM_CACHE_CLASS[_constantsJs.GL.UNSIGNED_INT_VEC4] = Uint32Array;
class SingleComponentUniform {
    constructor(gl, handle, type){
        this.gl = gl;
        this.handle = handle;
        this.glFuncName = UNIFORM_FUNC_NAME[type];
        this.cache = type === _constantsJs.GL.BOOL ? false : 0;
    }
    set(value) {
        if (this.cache !== value) {
            this.gl[this.glFuncName](this.handle, value);
            this.cache = value;
        }
    }
}
class MultiNumericUniform {
    constructor(gl, handle, type, count){
        this.gl = gl;
        this.handle = handle;
        this.glFuncName = UNIFORM_FUNC_NAME[type] + "v";
        this.count = count;
        this.cache = new UNIFORM_CACHE_CLASS[type](UNIFORM_COMPONENT_COUNT[type] * count);
    }
    set(value) {
        for(let i = 0, len = value.length; i < len; ++i)if (this.cache[i] !== value[i]) {
            this.gl[this.glFuncName](this.handle, value);
            this.cache.set(value);
            return;
        }
    }
}
class MultiBoolUniform {
    constructor(gl, handle, type, count){
        this.gl = gl;
        this.handle = handle;
        this.glFuncName = UNIFORM_FUNC_NAME[type] + "v";
        this.count = count;
        this.cache = new Array(UNIFORM_COMPONENT_COUNT[type] * count).fill(false);
    }
    set(value) {
        for(let i = 0, len = value.length; i < len; ++i)if (this.cache[i] !== value[i]) {
            this.gl[this.glFuncName](this.handle, value);
            for(let j = i; j < len; j++)this.cache[j] = value[j];
            return;
        }
    }
}
class MatrixUniform {
    constructor(gl, handle, type, count){
        this.gl = gl;
        this.handle = handle;
        this.glFuncName = UNIFORM_FUNC_NAME[type];
        this.count = count;
        this.cache = new Float32Array(UNIFORM_COMPONENT_COUNT[type] * count);
    }
    set(value) {
        for(let i = 0, len = value.length; i < len; ++i)if (this.cache[i] !== value[i]) {
            this.gl[this.glFuncName](this.handle, false, value);
            this.cache.set(value);
            return;
        }
    }
}

},{"./constants.js":"jCl2R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"667UB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
    Rendering timer.

    @class Timer
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {Object} cpuTimer Timer for CPU. Will be window.performance, if available, or window.Date.
    @prop {WebGLQuery} gpuTimerQuery Timer query object for GPU (if gpu timing is supported).
    @prop {boolean} gpuTimerQueryInProgress Whether a gpu timer query is currently in progress.
    @prop {number} cpuStartTime When the last CPU timing started.
    @prop {number} cpuTime Time spent on CPU during last timing. Only valid if ready() returns true.
    @prop {number} gpuTime Time spent on GPU during last timing. Only valid if ready() returns true.
            Will remain 0 if extension EXT_disjoint_timer_query_webgl2 is unavailable.
*/ parcelHelpers.export(exports, "Timer", ()=>Timer
);
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////
var _constantsJs = require("./constants.js");
var _queryJs = require("./query.js");
class Timer {
    constructor(gl){
        this.gl = gl;
        this.cpuTimer = window.performance || window.Date;
        this.gpuTimerQuery = null;
        this.cpuStartTime = 0;
        this.cpuTime = 0;
        this.gpuTime = 0;
        this.restore();
    }
    /**
        Restore timer after context loss.

        @method
        @return {Timer} The Timer object.
    */ restore() {
        if (_constantsJs.WEBGL_INFO.GPU_TIMER) {
            if (this.gpuTimerQuery) this.gpuTimerQuery.restore();
            else this.gpuTimerQuery = new _queryJs.Query(this.gl, _constantsJs.GL.TIME_ELAPSED_EXT);
        }
        this.cpuStartTime = 0;
        this.cpuTime = 0;
        this.gpuTime = 0;
        return this;
    }
    /**
        Start timing.

        @method
        @return {Timer} The Timer object.
    */ start() {
        if (_constantsJs.WEBGL_INFO.GPU_TIMER) {
            if (!this.gpuTimerQuery.active) {
                this.gpuTimerQuery.begin();
                this.cpuStartTime = this.cpuTimer.now();
            }
        } else this.cpuStartTime = this.cpuTimer.now();
        return this;
    }
    /**
        Stop timing.

        @method
        @return {Timer} The Timer object.
    */ end() {
        if (_constantsJs.WEBGL_INFO.GPU_TIMER) {
            if (!this.gpuTimerQuery.active) {
                this.gpuTimerQuery.end();
                this.cpuTime = this.cpuTimer.now() - this.cpuStartTime;
            }
        } else this.cpuTime = this.cpuTimer.now() - this.cpuStartTime;
        return this;
    }
    /**
        Check if timing results are available. If
        this method returns true, the cpuTime and
        gpuTime properties will be set to valid
        values.

        @method
        @return {boolean} If results are available.
    */ ready() {
        if (_constantsJs.WEBGL_INFO.GPU_TIMER) {
            if (!this.gpuTimerQuery.active) return false;
            var gpuTimerAvailable = this.gpuTimerQuery.ready();
            var gpuTimerDisjoint = this.gl.getParameter(_constantsJs.GL.GPU_DISJOINT_EXT);
            if (gpuTimerAvailable && !gpuTimerDisjoint) {
                this.gpuTime = this.gpuTimerQuery.result / 1000000;
                return true;
            } else return false;
        } else return Boolean(this.cpuStartTime);
    }
    /**
        Delete this timer.

        @method
        @return {Timer} The Timer object.
    */ delete() {
        if (this.gpuTimerQuery) {
            this.gpuTimerQuery.delete();
            this.gpuTimerQuery = null;
        }
        return this;
    }
}

},{"./constants.js":"jCl2R","./query.js":"b0pz6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b0pz6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
    Generic query object.

    @class Query
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLQuery} query Query object.
    @prop {GLenum} target The type of information being queried.
    @prop {boolean} active Whether or not a query is currently in progress.
    @prop {Any} result The result of the query (only available after a call to ready() returns true).
*/ parcelHelpers.export(exports, "Query", ()=>Query
);
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////
var _constantsJs = require("./constants.js");
class Query {
    constructor(gl, target){
        this.gl = gl;
        this.query = null;
        this.target = target;
        this.active = false;
        this.result = null;
        this.restore();
    }
    /**
        Restore query after context loss.

        @method
        @return {Query} The Query object.
    */ restore() {
        this.query = this.gl.createQuery();
        this.active = false;
        this.result = null;
        return this;
    }
    /**
        Begin a query.

        @method
        @return {Query} The Query object.
    */ begin() {
        if (!this.active) {
            this.gl.beginQuery(this.target, this.query);
            this.result = null;
        }
        return this;
    }
    /**
        End a query.

        @method
        @return {Query} The Query object.
    */ end() {
        if (!this.active) {
            this.gl.endQuery(this.target);
            this.active = true;
        }
        return this;
    }
    /**
        Check if query result is available.

        @method
        @return {boolean} If results are available.
    */ ready() {
        if (this.active && this.gl.getQueryParameter(this.query, _constantsJs.GL.QUERY_RESULT_AVAILABLE)) {
            this.active = false;
            // Note(Tarek): Casting because FF incorrectly returns booleans.
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1422714
            this.result = Number(this.gl.getQueryParameter(this.query, _constantsJs.GL.QUERY_RESULT));
            return true;
        }
        return false;
    }
    /**
        Delete this query.

        @method
        @return {Query} The Query object.
    */ delete() {
        if (this.query) {
            this.gl.deleteQuery(this.query);
            this.query = null;
        }
        return this;
    }
}

},{"./constants.js":"jCl2R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hbtoF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
    Tranform feedback object.

    @class TransformFeedback
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLTransformFeedback} transformFeedback Transform feedback object.
    @prop {Object} appState Tracked GL state.
*/ parcelHelpers.export(exports, "TransformFeedback", ()=>TransformFeedback
);
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////
var _constantsJs = require("./constants.js");
class TransformFeedback {
    constructor(gl, appState){
        this.gl = gl;
        this.appState = appState;
        this.transformFeedback = null;
        this.restore();
    }
    /**
        Restore transform feedback after context loss.

        @method
        @return {TransformFeedback} The TransformFeedback object.
    */ restore() {
        if (this.appState.transformFeedback === this) this.appState.transformFeedback = null;
        this.transformFeedback = this.gl.createTransformFeedback();
        return this;
    }
    /**
        Bind a feedback buffer to capture transform output.

        @method
        @param {number} index Index of transform feedback varying to capture.
        @param {VertexBuffer} buffer Buffer to record output into.
        @return {TransformFeedback} The TransformFeedback object.
    */ feedbackBuffer(index, buffer) {
        this.gl.bindTransformFeedback(_constantsJs.GL.TRANSFORM_FEEDBACK, this.transformFeedback);
        this.gl.bindBufferBase(_constantsJs.GL.TRANSFORM_FEEDBACK_BUFFER, index, buffer.buffer);
        // TODO(Tarek): Firefox doesn't properly unbind TRANSFORM_FEEDBACK_BUFFER
        // bindings when TRANSFORM_FEEDBACK is unbound.
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1541396
        this.gl.bindTransformFeedback(_constantsJs.GL.TRANSFORM_FEEDBACK, null);
        this.gl.bindBufferBase(_constantsJs.GL.TRANSFORM_FEEDBACK_BUFFER, index, null);
        return this;
    }
    /**
        Delete this transform feedback.

        @method
        @return {TransformFeedback} The TransformFeedback object.
    */ delete() {
        if (this.transformFeedback) {
            this.gl.deleteTransformFeedback(this.transformFeedback);
            this.transformFeedback = null;
            if (this.appState.transformFeedback === this) {
                this.gl.bindTransformFeedback(_constantsJs.GL.TRANSFORM_FEEDBACK, null);
                this.appState.transformFeedback = null;
            }
        }
        return this;
    }
    /**
        Bind this transform feedback.

        @method
        @ignore
        @return {TransformFeedback} The TransformFeedback object.
    */ bind() {
        if (this.appState.transformFeedback !== this) {
            this.gl.bindTransformFeedback(_constantsJs.GL.TRANSFORM_FEEDBACK, this.transformFeedback);
            this.appState.transformFeedback = this;
        }
        return this;
    }
}

},{"./constants.js":"jCl2R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ls9jB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
    Storage for uniform data. Data is stored in std140 layout.

    @class UniformBuffer
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLBuffer} buffer Allocated buffer storage.
    @prop {Float32Array} data Buffer data.
    @prop {Object} dataViews Map of base data types to matching ArrayBufferViews of the buffer data.
    @prop {Array} offsets Offsets into the array for each item in the buffer.
    @prop {Array} sizes Size of the item at the given offset.
    @prop {Array} types The base type of the item at the given offset (FLOAT, INT or UNSIGNED_INT).
    @prop {number} size The size of the buffer (in 4-byte items).
    @prop {GLenum} usage Usage pattern of the buffer.
*/ parcelHelpers.export(exports, "UniformBuffer", ()=>UniformBuffer
);
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////
var _constantsJs = require("./constants.js");
class UniformBuffer {
    constructor(gl, appState, layout, usage = gl.DYNAMIC_DRAW){
        this.gl = gl;
        this.buffer = null;
        this.dataViews = {
        };
        this.offsets = new Array(layout.length);
        this.sizes = new Array(layout.length);
        this.types = new Array(layout.length);
        this.size = 0;
        this.usage = usage;
        this.appState = appState;
        // -1 indicates unbound
        this.currentBase = -1;
        for(let i = 0, len = layout.length; i < len; ++i){
            let type = layout[i];
            switch(type){
                case _constantsJs.GL.FLOAT:
                case _constantsJs.GL.INT:
                case _constantsJs.GL.UNSIGNED_INT:
                case _constantsJs.GL.BOOL:
                    this.offsets[i] = this.size;
                    this.sizes[i] = 1;
                    if (type === _constantsJs.GL.INT) this.types[i] = _constantsJs.GL.INT;
                    else if (type === _constantsJs.GL.UNSIGNED_INT) this.types[i] = _constantsJs.GL.UNSIGNED_INT;
                    else this.types[i] = _constantsJs.GL.FLOAT;
                    this.size++;
                    break;
                case _constantsJs.GL.FLOAT_VEC2:
                case _constantsJs.GL.INT_VEC2:
                case _constantsJs.GL.UNSIGNED_INT_VEC2:
                case _constantsJs.GL.BOOL_VEC2:
                    this.size += this.size % 2;
                    this.offsets[i] = this.size;
                    this.sizes[i] = 2;
                    if (type === _constantsJs.GL.INT_VEC2) this.types[i] = _constantsJs.GL.INT;
                    else if (type === _constantsJs.GL.UNSIGNED_INT_VEC2) this.types[i] = _constantsJs.GL.UNSIGNED_INT;
                    else this.types[i] = _constantsJs.GL.FLOAT;
                    this.size += 2;
                    break;
                case _constantsJs.GL.FLOAT_VEC3:
                case _constantsJs.GL.INT_VEC3:
                case _constantsJs.GL.UNSIGNED_INT_VEC3:
                case _constantsJs.GL.BOOL_VEC3:
                case _constantsJs.GL.FLOAT_VEC4:
                case _constantsJs.GL.INT_VEC4:
                case _constantsJs.GL.UNSIGNED_INT_VEC4:
                case _constantsJs.GL.BOOL_VEC4:
                    this.size += (4 - this.size % 4) % 4;
                    this.offsets[i] = this.size;
                    this.sizes[i] = 4;
                    if (type === _constantsJs.GL.INT_VEC4 || type === _constantsJs.GL.INT_VEC3) this.types[i] = _constantsJs.GL.INT;
                    else if (type === _constantsJs.GL.UNSIGNED_INT_VEC4 || type === _constantsJs.GL.UNSIGNED_INT_VEC3) this.types[i] = _constantsJs.GL.UNSIGNED_INT;
                    else this.types[i] = _constantsJs.GL.FLOAT;
                    this.size += 4;
                    break;
                case _constantsJs.GL.FLOAT_MAT2:
                case _constantsJs.GL.FLOAT_MAT2x3:
                case _constantsJs.GL.FLOAT_MAT2x4:
                    this.size += (4 - this.size % 4) % 4;
                    this.offsets[i] = this.size;
                    this.sizes[i] = 8;
                    this.types[i] = _constantsJs.GL.FLOAT;
                    this.size += 8;
                    break;
                case _constantsJs.GL.FLOAT_MAT3:
                case _constantsJs.GL.FLOAT_MAT3x2:
                case _constantsJs.GL.FLOAT_MAT3x4:
                    this.size += (4 - this.size % 4) % 4;
                    this.offsets[i] = this.size;
                    this.sizes[i] = 12;
                    this.types[i] = _constantsJs.GL.FLOAT;
                    this.size += 12;
                    break;
                case _constantsJs.GL.FLOAT_MAT4:
                case _constantsJs.GL.FLOAT_MAT4x2:
                case _constantsJs.GL.FLOAT_MAT4x3:
                    this.size += (4 - this.size % 4) % 4;
                    this.offsets[i] = this.size;
                    this.sizes[i] = 16;
                    this.types[i] = _constantsJs.GL.FLOAT;
                    this.size += 16;
                    break;
                default:
                    console.error("Unsupported type for uniform buffer.");
            }
        }
        this.size += (4 - this.size % 4) % 4;
        this.data = new Float32Array(this.size);
        this.dataViews[_constantsJs.GL.FLOAT] = this.data;
        this.dataViews[_constantsJs.GL.INT] = new Int32Array(this.data.buffer);
        this.dataViews[_constantsJs.GL.UNSIGNED_INT] = new Uint32Array(this.data.buffer);
        this.dirtyStart = this.size;
        this.dirtyEnd = 0;
        this.restore();
    }
    /**
        Restore uniform buffer after context loss.

        @method
        @return {UniformBuffer} The UniformBuffer object.
    */ restore() {
        if (this.currentBase !== -1 && this.appState.uniformBuffers[this.currentBase] === this) this.appState.uniformBuffers[this.currentBase] = null;
        this.buffer = this.gl.createBuffer();
        this.gl.bindBuffer(_constantsJs.GL.UNIFORM_BUFFER, this.buffer);
        this.gl.bufferData(_constantsJs.GL.UNIFORM_BUFFER, this.size * 4, this.usage);
        this.gl.bindBuffer(_constantsJs.GL.UNIFORM_BUFFER, null);
        return this;
    }
    /**
        Update data for a given item in the buffer. NOTE: Data is not
        sent the the GPU until the update() method is called!

        @method
        @param {number} index Index in the layout of item to set.
        @param {ArrayBufferView} value Value to store at the layout location.
        @return {UniformBuffer} The UniformBuffer object.
    */ set(index, value) {
        let view = this.dataViews[this.types[index]];
        let offset = this.offsets[index];
        let size = this.sizes[index];
        if (this.sizes[index] === 1) view[offset] = value;
        else view.set(value, offset);
        if (offset < this.dirtyStart) this.dirtyStart = offset;
        if (this.dirtyEnd < offset + size) this.dirtyEnd = offset + size;
        return this;
    }
    /**
        Send stored buffer data to the GPU.

        @method
        @return {UniformBuffer} The UniformBuffer object.
    */ update() {
        if (this.dirtyStart >= this.dirtyEnd) return this;
        let data = this.data.subarray(this.dirtyStart, this.dirtyEnd);
        let offset = this.dirtyStart * 4;
        this.gl.bindBuffer(this.gl.UNIFORM_BUFFER, this.buffer);
        this.gl.bufferSubData(this.gl.UNIFORM_BUFFER, offset, data);
        this.gl.bindBuffer(this.gl.UNIFORM_BUFFER, null);
        this.dirtyStart = this.size;
        this.dirtyEnd = 0;
        return this;
    }
    /**
        Delete this uniform buffer.

        @method
        @return {UniformBuffer} The UniformBuffer object.
    */ delete() {
        if (this.buffer) {
            this.gl.deleteBuffer(this.buffer);
            this.buffer = null;
            if (this.currentBase !== -1 && this.appState.uniformBuffers[this.currentBase] === this) this.appState.uniformBuffers[this.currentBase] = null;
            this.currentBase = -1;
        }
        return this;
    }
    /**
        Bind this uniform buffer to the given base.

        @method
        @ignore
        @return {UniformBuffer} The UniformBuffer object.
    */ bind(base) {
        let currentBuffer = this.appState.uniformBuffers[base];
        if (currentBuffer !== this) {
            if (currentBuffer) currentBuffer.currentBase = -1;
            if (this.currentBase !== -1) this.appState.uniformBuffers[this.currentBase] = null;
            this.gl.bindBufferBase(this.gl.UNIFORM_BUFFER, base, this.buffer);
            this.appState.uniformBuffers[base] = this;
            this.currentBase = base;
        }
        return this;
    }
}

},{"./constants.js":"jCl2R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Pw5A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
    Organizes vertex buffer and attribute state.

    @class VertexArray
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLVertexArrayObject} vertexArray Vertex array object.
    @prop {number} numElements Number of elements in the vertex array.
    @prop {boolean} indexed Whether this vertex array is set up for indexed drawing.
    @prop {GLenum} indexType Data type of the indices.
    @prop {number} numInstances Number of instances to draw with this vertex array.
    @prop {Object} appState Tracked GL state.
*/ parcelHelpers.export(exports, "VertexArray", ()=>VertexArray
);
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////
var _constantsJs = require("./constants.js");
class VertexArray {
    constructor(gl, appState){
        this.gl = gl;
        this.appState = appState;
        this.vertexArray = null;
        this.indexType = null;
        this.indexed = false;
        this.numElements = 0;
        this.numInstances = 1;
        this.offsets = 0;
        this.numDraws = 1;
        this.instanceAttributeBuffers = {
        };
    }
    /**
        Restore vertex array after context loss.

        @method
        @return {VertexArray} The VertexArray object.
    */ restore() {
        if (this.appState.vertexArray === this) this.appState.vertexArray = null;
        // re-allocate at gl level, if necessary
        if (this.vertexArray !== null) this.vertexArray = this.gl.createVertexArray();
        return this;
    }
    /**
        Bind an per-vertex attribute buffer to this vertex array.

        @method
        @param {number} attributeIndex The attribute location to bind to.
        @param {VertexBuffer} vertexBuffer The VertexBuffer to bind.
        @param {Object} [options] Attribute pointer options. These will override those provided in the
            VertexBuffer.
        @param {GLenum} [options.type] Type of data stored in the buffer.
        @param {GLenum} [options.size] Number of components per vertex.
        @param {GLenum} [options.stride] Number of bytes between the start of data for each vertex.
        @param {GLenum} [options.offset] Number of bytes before the start of data for the first vertex.
        @param {boolean} [options.normalized] Data is integer data that should be normalized to a float.
        @param {GLenum} [options.integer] Pass data as integers.
        @return {VertexArray} The VertexArray object.
    */ vertexAttributeBuffer(attributeIndex, vertexBuffer, options = _constantsJs.DUMMY_OBJECT) {
        this.attributeBuffer(attributeIndex, vertexBuffer, options, false);
        return this;
    }
    /**
        Bind an per-instance attribute buffer to this vertex array.

        @method
        @param {number} attributeIndex The attribute location to bind to.
        @param {VertexBuffer} vertexBuffer The VertexBuffer to bind.
        @param {Object} [options] Attribute pointer options. These will override those provided in the
            VertexBuffer.
        @param {GLenum} [options.type] Type of data stored in the buffer.
        @param {GLenum} [options.size] Number of components per vertex.
        @param {GLenum} [options.stride] Number of bytes between the start of data for each vertex.
        @param {GLenum} [options.offset] Number of bytes before the start of data for the first vertex.
        @param {GLenum} [options.normalized] Data is integer data that should be normalized to a float.
        @param {GLenum} [options.integer] Pass data as integers.
        @return {VertexArray} The VertexArray object.
    */ instanceAttributeBuffer(attributeIndex, vertexBuffer, options = _constantsJs.DUMMY_OBJECT) {
        this.attributeBuffer(attributeIndex, vertexBuffer, options, true);
        this.instanceAttributeBuffers[attributeIndex] = {
            vertexBuffer,
            options
        };
        return this;
    }
    baseOffsetInstanceAttributeBuffers(baseOffset = 0) {
        Object.entries(this.instanceAttributeBuffers).forEach(([attributeIndex, { vertexBuffer , options  }])=>{
            this.attributeBuffer(Number(attributeIndex), vertexBuffer, options, true, baseOffset);
        });
    }
    /**
        Bind an index buffer to this vertex array.

        @method
        @param {VertexBuffer} vertexBuffer The VertexBuffer to bind.
        @return {VertexArray} The VertexArray object.
    */ indexBuffer(vertexBuffer) {
        // allocate at gl level, if necessary
        if (this.vertexArray === null) this.vertexArray = this.gl.createVertexArray();
        this.bind();
        this.gl.bindBuffer(_constantsJs.GL.ELEMENT_ARRAY_BUFFER, vertexBuffer.buffer);
        this.numElements = vertexBuffer.numItems * 3;
        this.indexType = vertexBuffer.type;
        this.indexed = true;
        return this;
    }
    /**
        Delete this vertex array.

        @method
        @return {VertexArray} The VertexArray object.
    */ delete() {
        if (this.vertexArray) {
            this.gl.deleteVertexArray(this.vertexArray);
            this.vertexArray = null;
            if (this.appState.vertexArray === this) {
                this.gl.bindVertexArray(null);
                this.appState.vertexArray = null;
            }
        }
        return this;
    }
    // Bind this vertex array.
    bind() {
        if (this.appState.vertexArray !== this) {
            this.gl.bindVertexArray(this.vertexArray);
            this.appState.vertexArray = this;
        }
        return this;
    }
    // Generic attribute buffer attachment
    attributeBuffer(attributeIndex, vertexBuffer, options = {
    }, instanced, baseInstance = 0) {
        // allocate at gl level, if necessary
        if (this.vertexArray === null) this.vertexArray = this.gl.createVertexArray();
        this.bind();
        this.gl.bindBuffer(_constantsJs.GL.ARRAY_BUFFER, vertexBuffer.buffer);
        let { type =vertexBuffer.type , size =vertexBuffer.itemSize , stride =0 , offset =0 , normalized =false , integer =Boolean(vertexBuffer.integer && !normalized)  } = options;
        let numColumns = vertexBuffer.numColumns;
        if (stride === 0) // Set explicitly for matrix buffers
        stride = numColumns * size * _constantsJs.TYPE_SIZE[type];
        let numItems = Math.ceil((vertexBuffer.byteLength - offset) / stride);
        for(let i = 0; i < numColumns; ++i){
            if (integer) this.gl.vertexAttribIPointer(attributeIndex + i, size, type, stride, offset + i * size * _constantsJs.TYPE_SIZE[type] + baseInstance * stride);
            else this.gl.vertexAttribPointer(attributeIndex + i, size, type, normalized, stride, offset + i * size * _constantsJs.TYPE_SIZE[type] + baseInstance * stride);
            if (instanced) this.gl.vertexAttribDivisor(attributeIndex + i, 1);
            this.gl.enableVertexAttribArray(attributeIndex + i);
        }
        if (this.numDraws === 1) {
            if (instanced) this.numInstances = numItems;
            else if (!this.indexed) this.numElements = numItems;
        }
        this.gl.bindBuffer(_constantsJs.GL.ARRAY_BUFFER, null);
        return this;
    }
}

},{"./constants.js":"jCl2R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Sv9B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
    Storage for vertex data.

    @class VertexBuffer
    @prop {WebGLRenderingContext} gl The WebGL context.
    @prop {WebGLBuffer} buffer Allocated buffer storage.
    @prop {GLenum} type The type of data stored in the buffer.
    @prop {number} itemSize Number of array elements per vertex.
    @prop {number} numItems Number of vertices represented.
    @prop {GLenum} usage The usage pattern of the buffer.
    @prop {boolean} indexArray Whether this is an index array.
    @prop {GLenum} binding GL binding point (ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER).
    @prop {Object} appState Tracked GL state.
*/ parcelHelpers.export(exports, "VertexBuffer", ()=>VertexBuffer
);
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////
var _constantsJs = require("./constants.js");
const INTEGER_TYPES = {
    [_constantsJs.GL.BYTE]: true,
    [_constantsJs.GL.UNSIGNED_BYTE]: true,
    [_constantsJs.GL.SHORT]: true,
    [_constantsJs.GL.UNSIGNED_SHORT]: true,
    [_constantsJs.GL.INT]: true,
    [_constantsJs.GL.UNSIGNED_INT]: true
};
class VertexBuffer {
    constructor(gl, appState, type, itemSize, data, usage = gl.STATIC_DRAW, indexArray){
        let numColumns;
        switch(type){
            case _constantsJs.GL.FLOAT_MAT4:
            case _constantsJs.GL.FLOAT_MAT4x2:
            case _constantsJs.GL.FLOAT_MAT4x3:
                numColumns = 4;
                break;
            case _constantsJs.GL.FLOAT_MAT3:
            case _constantsJs.GL.FLOAT_MAT3x2:
            case _constantsJs.GL.FLOAT_MAT3x4:
                numColumns = 3;
                break;
            case _constantsJs.GL.FLOAT_MAT2:
            case _constantsJs.GL.FLOAT_MAT2x3:
            case _constantsJs.GL.FLOAT_MAT2x4:
                numColumns = 2;
                break;
            default:
                numColumns = 1;
        }
        switch(type){
            case _constantsJs.GL.FLOAT_MAT4:
            case _constantsJs.GL.FLOAT_MAT3x4:
            case _constantsJs.GL.FLOAT_MAT2x4:
                itemSize = 4;
                type = _constantsJs.GL.FLOAT;
                break;
            case _constantsJs.GL.FLOAT_MAT3:
            case _constantsJs.GL.FLOAT_MAT4x3:
            case _constantsJs.GL.FLOAT_MAT2x3:
                itemSize = 3;
                type = _constantsJs.GL.FLOAT;
                break;
            case _constantsJs.GL.FLOAT_MAT2:
            case _constantsJs.GL.FLOAT_MAT3x2:
            case _constantsJs.GL.FLOAT_MAT4x2:
                itemSize = 2;
                type = _constantsJs.GL.FLOAT;
                break;
        }
        let dataLength;
        let byteLength;
        if (typeof data === "number") {
            dataLength = data;
            if (type) data *= _constantsJs.TYPE_SIZE[type];
            byteLength = data;
        } else {
            dataLength = data.length;
            byteLength = data.byteLength;
        }
        this.gl = gl;
        this.buffer = null;
        this.appState = appState;
        this.type = type;
        this.itemSize = itemSize; // In bytes for interleaved arrays.
        this.numItems = type ? dataLength / (itemSize * numColumns) : byteLength / itemSize;
        this.numColumns = numColumns;
        this.byteLength = byteLength;
        this.usage = usage;
        this.indexArray = Boolean(indexArray);
        this.integer = Boolean(INTEGER_TYPES[this.type]);
        this.binding = this.indexArray ? _constantsJs.GL.ELEMENT_ARRAY_BUFFER : _constantsJs.GL.ARRAY_BUFFER;
        this.restore(data);
    }
    /**
        Restore vertex buffer after context loss.

        @method
        @param {ArrayBufferView|number} data Buffer data itself or the total
            number of elements to be allocated.
        @return {VertexBuffer} The VertexBuffer object.
    */ restore(data) {
        if (!data) data = this.byteLength;
        // Don't want to update vertex array bindings
        if (this.appState.vertexArray) {
            this.gl.bindVertexArray(null);
            this.appState.vertexArray = null;
        }
        this.buffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.binding, this.buffer);
        this.gl.bufferData(this.binding, data, this.usage);
        this.gl.bindBuffer(this.binding, null);
        return this;
    }
    /**
        Update data in this buffer. NOTE: the data must fit
        the originally-allocated buffer!

        @method
        @param {ArrayBufferView} data Data to store in the buffer.
        @param {number} [offset=0] Byte offset into the buffer at which to start writing.
        @return {VertexBuffer} The VertexBuffer object.
    */ data(data, offset = 0) {
        // Don't want to update vertex array bindings
        if (this.appState.vertexArray) {
            this.gl.bindVertexArray(null);
            this.appState.vertexArray = null;
        }
        this.gl.bindBuffer(this.binding, this.buffer);
        this.gl.bufferSubData(this.binding, offset, data);
        this.gl.bindBuffer(this.binding, null);
        return this;
    }
    /**
        Delete this array buffer.

        @method
        @return {VertexBuffer} The VertexBuffer object.
    */ delete() {
        if (this.buffer) {
            this.gl.deleteBuffer(this.buffer);
            this.buffer = null;
        }
        return this;
    }
}

},{"./constants.js":"jCl2R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4kohm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "loadTessellationAtlas", ()=>loadTessellationAtlas
);
var _barycentric = require("barycentric");
var _barycentricDefault = parcelHelpers.interopDefault(_barycentric);
var _lodashEs = require("lodash-es");
var _combinatorialGenerators = require("combinatorial-generators");
var _cumulativeSum = require("cumulative-sum");
var _cumulativeSumDefault = parcelHelpers.interopDefault(_cumulativeSum);
var _permutator = require("./permutator");
var _threads = require("threads");
const pool = _threads.Pool(()=>_threads.spawn(new _threads.Worker(new URL(require("bf1a8a611b96061d")), {
        type: "module"
    }))
); //, 8 /* optional size */)
const loadTessellationAtlas = async (LODs)=>{
    console.log();
    const reducedLODs = _lodashEs.uniqBy([
        ..._combinatorialGenerators.permutationsWithReplacement(LODs.sort((a, b)=>b - a
        ), 3), 
    ], (x)=>JSON.stringify(_lodashEs.sortBy(x))
    );
    console.log(reducedLODs);
    // const meshes = reducedLODs.map()
    // const meshes = reducedLODs.map(k => allTessellations[JSON.stringify(k)])
    // console.log(meshes);
    //
    const meshes = await Promise.all(reducedLODs.map((lods)=>pool.queue(({ tessellationMesh  })=>tessellationMesh(lods)
        )
    ));
    // const meshes = reducedLODs.map((sideLODs) => tessellationMesh(sideLODs as triResolutions)
    // );
    // const combinedMesh = meshCombine(meshes);
    const combinedMesh = meshes.reduce((acc, next)=>{
        console.log(acc, next);
        // next.cellPositions = next.cells.map(cell => cell.map(i => next.positions[i]));
        return {
            cells: [
                ...acc.cells,
                ...next.cells
            ],
            positions: [
                ...acc.positions,
                ..._lodashEs.flatten(next.cellPositions).map((xyz)=>_barycentricDefault.default([
                        [
                            0,
                            0
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            0,
                            1
                        ], 
                    ], xyz.slice(0, 2)).map((x)=>x * 32768
                    ).map(Math.floor)
                ), 
            ]
        };
    }, {
        cells: [],
        positions: []
    });
    const counts = reducedLODs.map((_, i)=>meshes[i].cellPositions.length * 3
    );
    const baseIndices = [
        0,
        ..._cumulativeSumDefault.default(counts.map((x)=>x
        )).slice(0, -1)
    ];
    const lookup = _lodashEs.fromPairs(_lodashEs.uniqWith(reducedLODs.flatMap((lod, i)=>_permutator.permutationIndices3.map((pidxs)=>[
                JSON.stringify(pidxs.map((pi)=>lod[pi]
                )),
                i,
                lod,
                pidxs, 
            ]
        )
    ), ([a], [b])=>a === b
    ).map(([prm_i, lod_i, lod, edgePermutation])=>[
            prm_i,
            {
                lod,
                baseIndex: baseIndices[lod_i],
                count: counts[lod_i],
                edgePermutation,
                permutation: _permutator.vertPermFromEdgePerm(edgePermutation)
            }, 
        ]
    ));
    return {
        meshes,
        combinedMesh,
        counts,
        baseIndices,
        lookup
    };
};

},{"barycentric":"cdKXu","lodash-es":"bXNwz","combinatorial-generators":"gSDHb","cumulative-sum":"bHOQu","./permutator":"2tdcB","threads":"hstN5","bf1a8a611b96061d":"fHdDH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cdKXu":[function(require,module,exports) {
'use strict';
module.exports = barycentric;
var solve = require('robust-linear-solve');
function reduce(x) {
    var r = 0;
    for(var i = 0; i < x.length; ++i)r += x[i];
    return r;
}
function barycentric(simplex, point) {
    var d = point.length;
    var A = new Array(d + 1);
    for(var i = 0; i < d; ++i){
        var row = new Array(d + 1);
        for(var j = 0; j <= d; ++j)row[j] = simplex[j][i];
        A[i] = row;
    }
    A[d] = new Array(d + 1);
    for(var i = 0; i <= d; ++i)A[d][i] = 1;
    var b = new Array(d + 1);
    for(var i = 0; i < d; ++i)b[i] = point[i];
    b[d] = 1;
    var x = solve(A, b);
    var w = reduce(x[d + 1]);
    if (w === 0) w = 1;
    var y = new Array(d + 1);
    for(var i = 0; i <= d; ++i)y[i] = reduce(x[i]) / w;
    return y;
}

},{"robust-linear-solve":"iYZGk"}],"iYZGk":[function(require,module,exports) {
"use strict";
var determinant = require("robust-determinant");
var NUM_EXPAND = 6;
function generateSolver(n) {
    var funcName = "robustLinearSolve" + n + "d";
    var code = [
        "function ",
        funcName,
        "(A,b){return ["
    ];
    for(var i = 0; i < n; ++i){
        code.push("det([");
        for(var j = 0; j < n; ++j){
            if (j > 0) code.push(",");
            code.push("[");
            for(var k = 0; k < n; ++k){
                if (k > 0) code.push(",");
                if (k === i) code.push("+b[", j, "]");
                else code.push("+A[", j, "][", k, "]");
            }
            code.push("]");
        }
        code.push("]),");
    }
    code.push("det(A)]}return ", funcName);
    var proc = new Function("det", code.join(""));
    if (n < 6) return proc(determinant[n]);
    return proc(determinant);
}
function robustLinearSolve0d() {
    return [
        0
    ];
}
function robustLinearSolve1d(A, b) {
    return [
        [
            b[0]
        ],
        [
            A[0][0]
        ]
    ];
}
var CACHE = [
    robustLinearSolve0d,
    robustLinearSolve1d
];
function generateDispatch() {
    while(CACHE.length < NUM_EXPAND)CACHE.push(generateSolver(CACHE.length));
    var procArgs = [];
    var code = [
        "function dispatchLinearSolve(A,b){switch(A.length){"
    ];
    for(var i = 0; i < NUM_EXPAND; ++i){
        procArgs.push("s" + i);
        code.push("case ", i, ":return s", i, "(A,b);");
    }
    code.push("}var s=CACHE[A.length];if(!s)s=CACHE[A.length]=g(A.length);return s(A,b)}return dispatchLinearSolve");
    procArgs.push("CACHE", "g", code.join(""));
    var proc = Function.apply(undefined, procArgs);
    module.exports = proc.apply(undefined, CACHE.concat([
        CACHE,
        generateSolver
    ]));
    for(var i = 0; i < NUM_EXPAND; ++i)module.exports[i] = CACHE[i];
}
generateDispatch();

},{"robust-determinant":"8JpWu"}],"8JpWu":[function(require,module,exports) {
"use strict";
var twoProduct = require("two-product");
var robustSum = require("robust-sum");
var robustScale = require("robust-scale");
var compress = require("robust-compress");
var NUM_EXPANDED = 6;
function cofactor(m, c) {
    var result = new Array(m.length - 1);
    for(var i = 1; i < m.length; ++i){
        var r = result[i - 1] = new Array(m.length - 1);
        for(var j = 0, k = 0; j < m.length; ++j){
            if (j === c) continue;
            r[k++] = m[i][j];
        }
    }
    return result;
}
function matrix(n) {
    var result = new Array(n);
    for(var i = 0; i < n; ++i){
        result[i] = new Array(n);
        for(var j = 0; j < n; ++j)result[i][j] = [
            "m[",
            i,
            "][",
            j,
            "]"
        ].join("");
    }
    return result;
}
function sign(n) {
    if (n & 1) return "-";
    return "";
}
function generateSum(expr) {
    if (expr.length === 1) return expr[0];
    else if (expr.length === 2) return [
        "sum(",
        expr[0],
        ",",
        expr[1],
        ")"
    ].join("");
    else {
        var m = expr.length >> 1;
        return [
            "sum(",
            generateSum(expr.slice(0, m)),
            ",",
            generateSum(expr.slice(m)),
            ")"
        ].join("");
    }
}
function determinant(m) {
    if (m.length === 2) return [
        "sum(prod(",
        m[0][0],
        ",",
        m[1][1],
        "),prod(-",
        m[0][1],
        ",",
        m[1][0],
        "))"
    ].join("");
    else {
        var expr = [];
        for(var i = 0; i < m.length; ++i)expr.push([
            "scale(",
            determinant(cofactor(m, i)),
            ",",
            sign(i),
            m[0][i],
            ")"
        ].join(""));
        return generateSum(expr);
    }
}
function compileDeterminant(n) {
    var proc = new Function("sum", "scale", "prod", "compress", [
        "function robustDeterminant",
        n,
        "(m){return compress(",
        determinant(matrix(n)),
        ")};return robustDeterminant",
        n
    ].join(""));
    return proc(robustSum, robustScale, twoProduct, compress);
}
var CACHE = [
    function robustDeterminant0() {
        return [
            0
        ];
    },
    function robustDeterminant1(m) {
        return [
            m[0][0]
        ];
    }
];
function generateDispatch() {
    while(CACHE.length < NUM_EXPANDED)CACHE.push(compileDeterminant(CACHE.length));
    var procArgs = [];
    var code = [
        "function robustDeterminant(m){switch(m.length){"
    ];
    for(var i = 0; i < NUM_EXPANDED; ++i){
        procArgs.push("det" + i);
        code.push("case ", i, ":return det", i, "(m);");
    }
    code.push("}\
var det=CACHE[m.length];\
if(!det)\
det=CACHE[m.length]=gen(m.length);\
return det(m);\
}\
return robustDeterminant");
    procArgs.push("CACHE", "gen", code.join(""));
    var proc = Function.apply(undefined, procArgs);
    module.exports = proc.apply(undefined, CACHE.concat([
        CACHE,
        compileDeterminant
    ]));
    for(var i = 0; i < CACHE.length; ++i)module.exports[i] = CACHE[i];
}
generateDispatch();

},{"two-product":"5JWSk","robust-sum":"dv3pE","robust-scale":"ipmvR","robust-compress":"kRFyX"}],"5JWSk":[function(require,module,exports) {
"use strict";
module.exports = twoProduct;
var SPLITTER = +(Math.pow(2, 27) + 1);
function twoProduct(a, b, result) {
    var x = a * b;
    var c = SPLITTER * a;
    var abig = c - a;
    var ahi = c - abig;
    var alo = a - ahi;
    var d = SPLITTER * b;
    var bbig = d - b;
    var bhi = d - bbig;
    var blo = b - bhi;
    var err1 = x - ahi * bhi;
    var err2 = err1 - alo * bhi;
    var err3 = err2 - ahi * blo;
    var y = alo * blo - err3;
    if (result) {
        result[0] = y;
        result[1] = x;
        return result;
    }
    return [
        y,
        x
    ];
}

},{}],"dv3pE":[function(require,module,exports) {
"use strict";
module.exports = linearExpansionSum;
//Easy case: Add two scalars
function scalarScalar(a, b) {
    var x = a + b;
    var bv = x - a;
    var av = x - bv;
    var br = b - bv;
    var ar = a - av;
    var y = ar + br;
    if (y) return [
        y,
        x
    ];
    return [
        x
    ];
}
function linearExpansionSum(e, f) {
    var ne = e.length | 0;
    var nf = f.length | 0;
    if (ne === 1 && nf === 1) return scalarScalar(e[0], f[0]);
    var n = ne + nf;
    var g = new Array(n);
    var count = 0;
    var eptr = 0;
    var fptr = 0;
    var abs = Math.abs;
    var ei = e[eptr];
    var ea = abs(ei);
    var fi = f[fptr];
    var fa = abs(fi);
    var a, b;
    if (ea < fa) {
        b = ei;
        eptr += 1;
        if (eptr < ne) {
            ei = e[eptr];
            ea = abs(ei);
        }
    } else {
        b = fi;
        fptr += 1;
        if (fptr < nf) {
            fi = f[fptr];
            fa = abs(fi);
        }
    }
    if (eptr < ne && ea < fa || fptr >= nf) {
        a = ei;
        eptr += 1;
        if (eptr < ne) {
            ei = e[eptr];
            ea = abs(ei);
        }
    } else {
        a = fi;
        fptr += 1;
        if (fptr < nf) {
            fi = f[fptr];
            fa = abs(fi);
        }
    }
    var x = a + b;
    var bv = x - a;
    var y = b - bv;
    var q0 = y;
    var q1 = x;
    var _x, _bv, _av, _br, _ar;
    while(eptr < ne && fptr < nf){
        if (ea < fa) {
            a = ei;
            eptr += 1;
            if (eptr < ne) {
                ei = e[eptr];
                ea = abs(ei);
            }
        } else {
            a = fi;
            fptr += 1;
            if (fptr < nf) {
                fi = f[fptr];
                fa = abs(fi);
            }
        }
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) g[count++] = y;
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
    }
    while(eptr < ne){
        a = ei;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) g[count++] = y;
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        eptr += 1;
        if (eptr < ne) ei = e[eptr];
    }
    while(fptr < nf){
        a = fi;
        b = q0;
        x = a + b;
        bv = x - a;
        y = b - bv;
        if (y) g[count++] = y;
        _x = q1 + x;
        _bv = _x - q1;
        _av = _x - _bv;
        _br = x - _bv;
        _ar = q1 - _av;
        q0 = _ar + _br;
        q1 = _x;
        fptr += 1;
        if (fptr < nf) fi = f[fptr];
    }
    if (q0) g[count++] = q0;
    if (q1) g[count++] = q1;
    if (!count) g[count++] = 0;
    g.length = count;
    return g;
}

},{}],"ipmvR":[function(require,module,exports) {
"use strict";
var twoProduct = require("two-product");
var twoSum = require("two-sum");
module.exports = scaleLinearExpansion;
function scaleLinearExpansion(e, scale) {
    var n = e.length;
    if (n === 1) {
        var ts = twoProduct(e[0], scale);
        if (ts[0]) return ts;
        return [
            ts[1]
        ];
    }
    var g = new Array(2 * n);
    var q = [
        0.1,
        0.1
    ];
    var t = [
        0.1,
        0.1
    ];
    var count = 0;
    twoProduct(e[0], scale, q);
    if (q[0]) g[count++] = q[0];
    for(var i = 1; i < n; ++i){
        twoProduct(e[i], scale, t);
        var pq = q[1];
        twoSum(pq, t[0], q);
        if (q[0]) g[count++] = q[0];
        var a = t[1];
        var b = q[1];
        var x = a + b;
        var bv = x - a;
        var y = b - bv;
        q[1] = x;
        if (y) g[count++] = y;
    }
    if (q[1]) g[count++] = q[1];
    if (count === 0) g[count++] = 0;
    g.length = count;
    return g;
}

},{"two-product":"5JWSk","two-sum":"bwaTN"}],"bwaTN":[function(require,module,exports) {
"use strict";
module.exports = fastTwoSum;
function fastTwoSum(a, b, result) {
    var x = a + b;
    var bv = x - a;
    var av = x - bv;
    var br = b - bv;
    var ar = a - av;
    if (result) {
        result[0] = ar + br;
        result[1] = x;
        return result;
    }
    return [
        ar + br,
        x
    ];
}

},{}],"kRFyX":[function(require,module,exports) {
"use strict";
module.exports = compressExpansion;
function compressExpansion(e) {
    var m = e.length;
    var Q = e[e.length - 1];
    var bottom = m;
    for(var i = m - 2; i >= 0; --i){
        var a = Q;
        var b = e[i];
        Q = a + b;
        var bv = Q - a;
        var q = b - bv;
        if (q) {
            e[--bottom] = Q;
            Q = q;
        }
    }
    var top = 0;
    for(var i = bottom; i < m; ++i){
        var a = e[i];
        var b = Q;
        Q = a + b;
        var bv = Q - a;
        var q = b - bv;
        if (q) e[top++] = q;
    }
    e[top++] = Q;
    e.length = top;
    return e;
}

},{}],"gSDHb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// This module is browser compatible.
var _combinationsJs = require("./combinations.js");
parcelHelpers.exportAll(_combinationsJs, exports);
var _permutationsJs = require("./permutations.js");
parcelHelpers.exportAll(_permutationsJs, exports);
var _combinationsWithReplacementJs = require("./combinations_with_replacement.js");
parcelHelpers.exportAll(_combinationsWithReplacementJs, exports);
var _permutationsWithReplacementJs = require("./permutations_with_replacement.js");
parcelHelpers.exportAll(_permutationsWithReplacementJs, exports);
var _cartesianProductJs = require("./cartesian_product.js");
parcelHelpers.exportAll(_cartesianProductJs, exports);
var _powerSetJs = require("./power_set.js");
parcelHelpers.exportAll(_powerSetJs, exports);

},{"./combinations.js":"rgvVn","./permutations.js":"iBUnr","./combinations_with_replacement.js":"gIZ2L","./permutations_with_replacement.js":"1SmaF","./cartesian_product.js":"8eR9o","./power_set.js":"gBbF0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"rgvVn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// This module is browser compatible.
/**
 * Yields `r` length `Arrays` from the input `iterable`. Order of selection does
 * not matter and elements are chosen without replacement.
 *
 * ```ts
 * import { assertEquals } from "https://deno.land/std/testing/asserts.ts";
 * import { combinations } from "https://deno.land/x/combinatorics/mod.ts";
 *
 * const sequences = [...combinations([1, 2, 3, 4], 2)];
 *
 * assertEquals(sequences, [
 *   [1, 2],
 *   [1, 3],
 *   [1, 4],
 *   [2, 3],
 *   [2, 4],
 *   [3, 4],
 * ]);
 * ```
 */ parcelHelpers.export(exports, "combinations", ()=>combinations
);
function* combinations(iterable, r) {
    if (!Number.isInteger(r) || r < 0) throw RangeError("r must be a non-negative integer");
    const pool = [
        ...iterable
    ];
    const n = pool.length;
    if (r > n) return;
    const indices = new Uint32Array(r).map((_, index)=>index
    );
    yield pool.slice(0, r);
    while(true){
        let i;
        loop: {
            for(i = r - 1; i >= 0; i--){
                if (indices[i] !== i + n - r) break loop;
            }
            return;
        }
        const result = Array(r);
        for(let j = 0; j < i; j++)result[j] = pool[indices[j]];
        let index = indices[i] += 1;
        result[i] = pool[index];
        for(let j1 = i + 1; j1 < r; j1++){
            indices[j1] = index += 1;
            result[j1] = pool[index];
        }
        yield result;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iBUnr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// This module is browser compatible.
/**
 * Yields `r` length `Arrays` from the input `iterable`. Order of selection is
 * important and elements are chosen without replacement. If `r` is undefined, then
 * the length of the `iterable` is used.
 *
 * ```ts
 * import { assertEquals } from "https://deno.land/std/testing/asserts.ts";
 * import { permutations } from "https://deno.land/x/combinatorics/mod.ts";
 *
 * const sequences = [...permutations([1, 2, 3, 4], 2)];
 *
 * assertEquals(sequences, [
 *   [1, 2], [1, 3], [1, 4],
 *   [2, 1], [2, 3], [2, 4],
 *   [3, 1], [3, 2], [3, 4],
 *   [4, 1], [4, 2], [4, 3],
 * ]);
 * ```
 */ parcelHelpers.export(exports, "permutations", ()=>permutations
);
function* permutations(iterable, r) {
    const pool = [
        ...iterable
    ];
    const n = pool.length;
    if (r === undefined) r = n;
    else if (!Number.isInteger(r) || r < 0) throw RangeError("r must be a non-negative integer");
    else if (r > n) return;
    const cycles = Array(r).fill(0).map((_, index)=>n - index
    );
    const indices = new Uint32Array(n).map((_, index)=>index
    );
    yield pool.slice(0, r);
    while(true)loop: {
        for(let i = r - 1; i >= 0; i--){
            cycles[i] -= 1;
            if (cycles[i] === 0) {
                let index = indices[i];
                for(let j = n - 1; j >= i; j--){
                    const temp = index;
                    index = indices[j];
                    indices[j] = temp;
                }
                cycles[i] = n - i;
            } else {
                const j = n - cycles[i];
                const temp = indices[i];
                indices[i] = indices[j];
                indices[j] = temp;
                const result = Array(r);
                for(i = 0; i < r; i++)result[i] = pool[indices[i]];
                yield result;
                break loop;
            }
        }
        return;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gIZ2L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// This module is browser compatible.
/**
 * Yields `r` length `Arrays` from the input `iterable`. Order of selection is not
 * important and elements are chosen with replacement.
 *
 * ```ts
 * import { assertEquals } from "https://deno.land/std/testing/asserts.ts";
 * import { combinationsWithReplacement } from "https://deno.land/x/combinatorics/mod.ts";
 *
 * const sequences = [...combinationsWithReplacement([1, 2, 3, 4], 2)];
 *
 * assertEquals(sequences, [
 *   [1, 1],
 *   [1, 2],
 *   [1, 3],
 *   [1, 4],
 *   [2, 2],
 *   [2, 3],
 *   [2, 4],
 *   [3, 3],
 *   [3, 4],
 *   [4, 4],
 * ]);
 * ```
 */ parcelHelpers.export(exports, "combinationsWithReplacement", ()=>combinationsWithReplacement
);
function* combinationsWithReplacement(iterable, r) {
    if (!Number.isInteger(r) || r < 0) throw RangeError("r must be a non-negative integer");
    const pool = [
        ...iterable
    ];
    const n = pool.length;
    if (n === 0 && r > 0) return;
    const indices = new Uint32Array(r);
    yield Array(r).fill(pool[0]);
    while(true){
        let i;
        loop: {
            for(i = r - 1; i >= 0; i--){
                if (indices[i] !== n - 1) break loop;
            }
            return;
        }
        const result = Array(r);
        for(let j = 0; j < i; j++)result[j] = pool[indices[j]];
        const index = indices[i] + 1;
        const element = pool[index];
        for(let j1 = i; j1 < r; j1++){
            indices[j1] = index;
            result[j1] = element;
        }
        yield result;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1SmaF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// This module is browser compatible.
/**
 * Yields `r` length `Arrays` from the input `iterable`. Order of selection is
 * important and elements are chosen with replacement.
 *
 * ```ts
 * import { assertEquals } from "https://deno.land/std/testing/asserts.ts";
 * import { permutationsWithReplacement } from "https://deno.land/x/combinatorics/mod.ts";
 *
 * const sequences = [...permutationsWithReplacement([1, 2, 3, 4], 2)];
 *
 * assertEquals(sequences, [
 *   [1, 1], [1, 2], [1, 3], [1, 4],
 *   [2, 1], [2, 2], [2, 3], [2, 4],
 *   [3, 1], [3, 2], [3, 3], [3, 4],
 *   [4, 1], [4, 2], [4, 3], [4, 4],
 * ]);
 * ```
 */ parcelHelpers.export(exports, "permutationsWithReplacement", ()=>permutationsWithReplacement
);
function* permutationsWithReplacement(iterable, r) {
    if (!Number.isInteger(r) || r < 0) throw RangeError("r must be a non-negative integer");
    const pool = [
        ...iterable
    ];
    const n = pool.length;
    if (r === 0) {
        yield [];
        return;
    }
    if (n === 0 && r > 0) return;
    const indices = new Uint32Array(r);
    yield Array(r).fill(pool[0]);
    while(true){
        let i;
        loop: {
            for(i = r - 1; i >= 0; i--){
                if (indices[i] === n - 1) continue;
                const result = Array(r);
                for(let j = 0; j < i; j++)result[j] = pool[indices[j]];
                const index = indices[i] += 1;
                result[i] = pool[index];
                for(let j1 = i + 1; j1 < r; j1++){
                    indices[j1] = 0;
                    result[j1] = pool[0];
                }
                yield result;
                break loop;
            }
            return;
        }
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8eR9o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// This module is browser compatible.
/**
 * Roughly equivalent to running nested `for...of` loops using one of the inputs to
 * provide the element at each index for the yielded `Array`.
 *
 * ```ts
 * import { assertEquals } from "https://deno.land/std/testing/asserts.ts";
 * import { cartesianProduct } from "https://deno.land/x/combinatorics/mod.ts";
 *
 * const sequences = [...cartesianProduct([1, 2, 3], [4, 5, 6], [7, 8, 9])];
 *
 * assertEquals(sequences, [
 *   [1, 4, 7], [1, 4, 8], [1, 4, 9],
 *   [1, 5, 7], [1, 5, 8], [1, 5, 9],
 *   [1, 6, 7], [1, 6, 8], [1, 6, 9],
 *   [2, 4, 7], [2, 4, 8], [2, 4, 9],
 *   [2, 5, 7], [2, 5, 8], [2, 5, 9],
 *   [2, 6, 7], [2, 6, 8], [2, 6, 9],
 *   [3, 4, 7], [3, 4, 8], [3, 4, 9],
 *   [3, 5, 7], [3, 5, 8], [3, 5, 9],
 *   [3, 6, 7], [3, 6, 8], [3, 6, 9],
 * ]);
 * ```
 */ parcelHelpers.export(exports, "cartesianProduct", ()=>cartesianProduct
);
function* cartesianProduct(...iterables) {
    const pools = iterables.map((iterable)=>[
            ...iterable
        ]
    );
    const n = pools.length;
    if (n === 0) {
        yield [];
        return;
    }
    if (pools.some((pool)=>pool.length === 0
    )) return;
    const indices = new Uint32Array(n);
    yield pools.map((pool)=>pool[0]
    );
    while(true)loop: {
        for(let i = n - 1; i >= 0; i--){
            if (indices[i] === pools[i].length - 1) continue;
            const result = Array(n);
            for(let j = 0; j < i; j++)result[j] = pools[j][indices[j]];
            const index = indices[i] += 1;
            result[i] = pools[i][index];
            for(let j1 = i + 1; j1 < n; j1++){
                indices[j1] = 0;
                result[j1] = pools[j1][0];
            }
            yield result;
            break loop;
        }
        return;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gBbF0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// This module is browser compatible.
/**
 * The set of all subsets of the given `iterable`. Equivalent to running
 * `combinations` with `0 <= r <= iterable.length` and flattening the results. The
 * first subset is the empty set given when `r = 0`.
 *
 * ```ts
 * import { assertEquals } from "https://deno.land/std/testing/asserts.ts";
 * import { powerSet } from "https://deno.land/x/combinatorics/mod.ts";
 *
 * const sequences = [...powerSet([1, 2, 3])];
 *
 * assertEquals(sequences, [
 *   [],
 *   [1],
 *   [2],
 *   [3],
 *   [1, 2],
 *   [1, 3],
 *   [2, 3],
 *   [1, 2, 3],
 * ]);
 * ```
 */ parcelHelpers.export(exports, "powerSet", ()=>powerSet
);
function* powerSet(iterable) {
    const pool = [
        ...iterable
    ];
    const n = pool.length;
    const indices = new Uint32Array(n);
    for(let r = 0; r <= n; r++){
        const result = Array(r);
        for(let i = 0; i < r; i++){
            indices[i] = i;
            result[i] = pool[i];
        }
        yield result;
        while(true){
            let i;
            loop: {
                for(i = r - 1; i >= 0; i--){
                    if (indices[i] !== i + n - r) break loop;
                }
                break;
            }
            const result = Array(r);
            for(let j = 0; j < i; j++)result[j] = pool[indices[j]];
            let index = indices[i] += 1;
            result[i] = pool[index];
            for(let j1 = i + 1; j1 < r; j1++){
                indices[j1] = index += 1;
                result[j1] = pool[index];
            }
            yield result;
        }
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bHOQu":[function(require,module,exports) {
"use strict";
module.exports = (array)=>{
    if (!Array.isArray(array)) throw new TypeError(`Expected an array of numbers, got ${typeof array}`);
    let sum = 0;
    return array.map((value)=>sum += value
    ) // eslint-disable-line no-return-assign
    ;
};

},{}],"2tdcB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "permutator", ()=>permutator
);
parcelHelpers.export(exports, "permutationIndices3", ()=>permutationIndices3
);
parcelHelpers.export(exports, "vertPermFromEdgePerm", ()=>vertPermFromEdgePerm
);
function permutator(inputArr) {
    var results = [];
    function permute(arr, memo) {
        var cur, memo = memo || [];
        for(var i = 0; i < arr.length; i++){
            cur = arr.splice(i, 1);
            if (arr.length === 0) results.push(memo.concat(cur));
            permute(arr.slice(), memo.concat(cur));
            arr.splice(i, 0, cur[0]);
        }
        return results;
    }
    return permute(inputArr, null);
}
const permutationIndices3 = permutator([
    0,
    1,
    2
]);
const vertPermFromEdgePerm = (edgePerm)=>{
    return ({
        "[0,1,2]": [
            1,
            0,
            2
        ],
        "[1,2,0]": [
            0,
            2,
            1
        ],
        "[2,0,1]": [
            2,
            1,
            0
        ],
        "[0,2,1]": [
            0,
            2,
            1
        ],
        "[1,0,2]": [
            2,
            0,
            1
        ],
        "[2,1,0]": [
            1,
            2,
            0
        ]
    })[JSON.stringify(edgePerm)];
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hstN5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "registerSerializer", ()=>_common.registerSerializer
);
parcelHelpers.export(exports, "expose", ()=>_index1.expose
);
parcelHelpers.export(exports, "DefaultSerializer", ()=>_serializers.DefaultSerializer
);
parcelHelpers.export(exports, "Transfer", ()=>_transferable.Transfer
);
var _common = require("./common");
var _index = require("./master/index");
parcelHelpers.exportAll(_index, exports);
var _index1 = require("./worker/index");
var _serializers = require("./serializers");
var _transferable = require("./transferable");

},{"./common":"5D80z","./master/index":"aueZv","./worker/index":"1U8ue","./serializers":"dd9cn","./transferable":"6VlW9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5D80z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "registerSerializer", ()=>registerSerializer
);
parcelHelpers.export(exports, "deserialize", ()=>deserialize
);
parcelHelpers.export(exports, "serialize", ()=>serialize
);
var _serializers = require("./serializers");
let registeredSerializer = _serializers.DefaultSerializer;
function registerSerializer(serializer) {
    registeredSerializer = _serializers.extendSerializer(registeredSerializer, serializer);
}
function deserialize(message) {
    return registeredSerializer.deserialize(message);
}
function serialize(input) {
    return registeredSerializer.serialize(input);
}

},{"./serializers":"dd9cn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dd9cn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extendSerializer", ()=>extendSerializer
);
parcelHelpers.export(exports, "DefaultSerializer", ()=>DefaultSerializer
);
function extendSerializer(extend, implementation) {
    const fallbackDeserializer = extend.deserialize.bind(extend);
    const fallbackSerializer = extend.serialize.bind(extend);
    return {
        deserialize (message) {
            return implementation.deserialize(message, fallbackDeserializer);
        },
        serialize (input) {
            return implementation.serialize(input, fallbackSerializer);
        }
    };
}
const DefaultErrorSerializer = {
    deserialize (message) {
        return Object.assign(Error(message.message), {
            name: message.name,
            stack: message.stack
        });
    },
    serialize (error) {
        return {
            __error_marker: "$$error",
            message: error.message,
            name: error.name,
            stack: error.stack
        };
    }
};
const isSerializedError = (thing)=>thing && typeof thing === "object" && "__error_marker" in thing && thing.__error_marker === "$$error"
;
const DefaultSerializer = {
    deserialize (message) {
        if (isSerializedError(message)) return DefaultErrorSerializer.deserialize(message);
        else return message;
    },
    serialize (input) {
        if (input instanceof Error) return DefaultErrorSerializer.serialize(input);
        else return input;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aueZv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Pool", ()=>_pool.Pool
);
parcelHelpers.export(exports, "spawn", ()=>_spawn.spawn
);
parcelHelpers.export(exports, "Thread", ()=>_thread.Thread
);
parcelHelpers.export(exports, "isWorkerRuntime", ()=>_implementation.isWorkerRuntime
);
parcelHelpers.export(exports, "BlobWorker", ()=>BlobWorker
);
parcelHelpers.export(exports, "Worker", ()=>Worker
);
var _implementation = require("./implementation");
var _pool = require("./pool");
var _spawn = require("./spawn");
var _thread = require("./thread");
const BlobWorker = _implementation.getWorkerImplementation().blob;
const Worker = _implementation.getWorkerImplementation().default;

},{"./implementation":"etws1","./pool":"jjO8u","./spawn":"9dksw","./thread":"jdWSi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"etws1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultPoolSize", ()=>defaultPoolSize
);
parcelHelpers.export(exports, "getWorkerImplementation", ()=>getWorkerImplementation
);
parcelHelpers.export(exports, "isWorkerRuntime", ()=>isWorkerRuntime
);
// tslint:disable max-classes-per-file
var _getBundleUrlBrowser = require("./get-bundle-url.browser");
const defaultPoolSize = typeof navigator !== "undefined" && navigator.hardwareConcurrency ? navigator.hardwareConcurrency : 4;
const isAbsoluteURL = (value)=>/^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(value)
;
function createSourceBlobURL(code) {
    const blob = new Blob([
        code
    ], {
        type: "application/javascript"
    });
    return URL.createObjectURL(blob);
}
function selectWorkerImplementation() {
    if (typeof Worker === "undefined") // Might happen on Safari, for instance
    // The idea is to only fail if the constructor is actually used
    return class NoWebWorker {
        constructor(){
            throw Error("No web worker implementation available. You might have tried to spawn a worker within a worker in a browser that doesn't support workers in workers.");
        }
    };
    class WebWorker extends Worker {
        constructor(url, options){
            var _a, _b;
            if (typeof url === "string" && options && options._baseURL) url = new URL(url, options._baseURL);
            else if (typeof url === "string" && !isAbsoluteURL(url) && _getBundleUrlBrowser.getBundleURL().match(/^file:\/\//i)) {
                url = new URL(url, _getBundleUrlBrowser.getBundleURL().replace(/\/[^\/]+$/, "/"));
                if ((_a = options === null || options === void 0 ? void 0 : options.CORSWorkaround) !== null && _a !== void 0 ? _a : true) url = createSourceBlobURL(`importScripts(${JSON.stringify(url)});`);
            }
            if (typeof url === "string" && isAbsoluteURL(url)) // Create source code blob loading JS file via `importScripts()`
            // to circumvent worker CORS restrictions
            {
                if ((_b = options === null || options === void 0 ? void 0 : options.CORSWorkaround) !== null && _b !== void 0 ? _b : true) url = createSourceBlobURL(`importScripts(${JSON.stringify(url)});`);
            }
            super(url, options);
        }
    }
    class BlobWorker extends WebWorker {
        constructor(blob, options){
            const url = window.URL.createObjectURL(blob);
            super(url, options);
        }
        static fromText(source, options) {
            const blob = new window.Blob([
                source
            ], {
                type: "text/javascript"
            });
            return new BlobWorker(blob, options);
        }
    }
    return {
        blob: BlobWorker,
        default: WebWorker
    };
}
let implementation;
function getWorkerImplementation() {
    if (!implementation) implementation = selectWorkerImplementation();
    return implementation;
}
function isWorkerRuntime() {
    const isWindowContext = typeof self !== "undefined" && typeof Window !== "undefined" && self instanceof Window;
    return typeof self !== "undefined" && self.postMessage && !isWindowContext ? true : false;
}

},{"./get-bundle-url.browser":"d6vtG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d6vtG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getBaseURL", ()=>getBaseURL
);
parcelHelpers.export(exports, "getBundleURL", ()=>getBundleURLCached
);
// Source: <https://github.com/parcel-bundler/parcel/blob/master/packages/core/parcel-bundler/src/builtins/bundle-url.js>
let bundleURL;
function getBundleURLCached() {
    if (!bundleURL) bundleURL = getBundleURL();
    return bundleURL;
}
function getBundleURL() {
    // Attempt to find the URL of the current script and use that as the base URL
    try {
        throw new Error;
    } catch (err) {
        const matches = ("" + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);
        if (matches) return getBaseURL(matches[0]);
    }
    return "/";
}
function getBaseURL(url) {
    return ("" + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)?\/[^/]+(?:\?.*)?$/, '$1') + '/';
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jjO8u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PoolEventType", ()=>_poolTypes.PoolEventType
);
parcelHelpers.export(exports, "Thread", ()=>_thread.Thread
);
parcelHelpers.export(exports, "Pool", ()=>Pool
);
var _debug = require("debug");
var _debugDefault = parcelHelpers.interopDefault(_debug);
var _observableFns = require("observable-fns");
var _ponyfills = require("../ponyfills");
var _implementation = require("./implementation");
var _poolTypes = require("./pool-types");
var _thread = require("./thread");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
let nextPoolID = 1;
function createArray(size) {
    const array = [];
    for(let index = 0; index < size; index++)array.push(index);
    return array;
}
function delay(ms) {
    return new Promise((resolve)=>setTimeout(resolve, ms)
    );
}
function flatMap(array, mapper) {
    return array.reduce((flattened, element)=>[
            ...flattened,
            ...mapper(element)
        ]
    , []);
}
function slugify(text) {
    return text.replace(/\W/g, " ").trim().replace(/\s+/g, "-");
}
function spawnWorkers(spawnWorker, count) {
    return createArray(count).map(()=>({
            init: spawnWorker(),
            runningTasks: []
        })
    );
}
class WorkerPool {
    constructor(spawnWorker, optionsOrSize){
        this.eventSubject = new _observableFns.Subject();
        this.initErrors = [];
        this.isClosing = false;
        this.nextTaskID = 1;
        this.taskQueue = [];
        const options = typeof optionsOrSize === "number" ? {
            size: optionsOrSize
        } : optionsOrSize || {
        };
        const { size =_implementation.defaultPoolSize  } = options;
        this.debug = _debugDefault.default(`threads:pool:${slugify(options.name || String(nextPoolID++))}`);
        this.options = options;
        this.workers = spawnWorkers(spawnWorker, size);
        this.eventObservable = _observableFns.multicast(_observableFns.Observable.from(this.eventSubject));
        Promise.all(this.workers.map((worker)=>worker.init
        )).then(()=>this.eventSubject.next({
                type: _poolTypes.PoolEventType.initialized,
                size: this.workers.length
            })
        , (error)=>{
            this.debug("Error while initializing pool worker:", error);
            this.eventSubject.error(error);
            this.initErrors.push(error);
        });
    }
    findIdlingWorker() {
        const { concurrency =1  } = this.options;
        return this.workers.find((worker)=>worker.runningTasks.length < concurrency
        );
    }
    runPoolTask(worker, task) {
        return __awaiter(this, void 0, void 0, function*() {
            const workerID = this.workers.indexOf(worker) + 1;
            this.debug(`Running task #${task.id} on worker #${workerID}...`);
            this.eventSubject.next({
                type: _poolTypes.PoolEventType.taskStart,
                taskID: task.id,
                workerID
            });
            try {
                const returnValue = yield task.run((yield worker.init));
                this.debug(`Task #${task.id} completed successfully`);
                this.eventSubject.next({
                    type: _poolTypes.PoolEventType.taskCompleted,
                    returnValue,
                    taskID: task.id,
                    workerID
                });
            } catch (error) {
                this.debug(`Task #${task.id} failed`);
                this.eventSubject.next({
                    type: _poolTypes.PoolEventType.taskFailed,
                    taskID: task.id,
                    error,
                    workerID
                });
            }
        });
    }
    run(worker, task) {
        return __awaiter(this, void 0, void 0, function*() {
            const runPromise = (()=>__awaiter(this, void 0, void 0, function*() {
                    const removeTaskFromWorkersRunningTasks = ()=>{
                        worker.runningTasks = worker.runningTasks.filter((someRunPromise)=>someRunPromise !== runPromise
                        );
                    };
                    // Defer task execution by one tick to give handlers time to subscribe
                    yield delay(0);
                    try {
                        yield this.runPoolTask(worker, task);
                    } finally{
                        removeTaskFromWorkersRunningTasks();
                        if (!this.isClosing) this.scheduleWork();
                    }
                })
            )();
            worker.runningTasks.push(runPromise);
        });
    }
    scheduleWork() {
        this.debug(`Attempt de-queueing a task in order to run it...`);
        const availableWorker = this.findIdlingWorker();
        if (!availableWorker) return;
        const nextTask = this.taskQueue.shift();
        if (!nextTask) {
            this.debug(`Task queue is empty`);
            this.eventSubject.next({
                type: _poolTypes.PoolEventType.taskQueueDrained
            });
            return;
        }
        this.run(availableWorker, nextTask);
    }
    taskCompletion(taskID) {
        return new Promise((resolve, reject)=>{
            const eventSubscription = this.events().subscribe((event)=>{
                if (event.type === _poolTypes.PoolEventType.taskCompleted && event.taskID === taskID) {
                    eventSubscription.unsubscribe();
                    resolve(event.returnValue);
                } else if (event.type === _poolTypes.PoolEventType.taskFailed && event.taskID === taskID) {
                    eventSubscription.unsubscribe();
                    reject(event.error);
                } else if (event.type === _poolTypes.PoolEventType.terminated) {
                    eventSubscription.unsubscribe();
                    reject(Error("Pool has been terminated before task was run."));
                }
            });
        });
    }
    settled(allowResolvingImmediately = false) {
        return __awaiter(this, void 0, void 0, function*() {
            const getCurrentlyRunningTasks = ()=>flatMap(this.workers, (worker)=>worker.runningTasks
                )
            ;
            const taskFailures = [];
            const failureSubscription = this.eventObservable.subscribe((event)=>{
                if (event.type === _poolTypes.PoolEventType.taskFailed) taskFailures.push(event.error);
            });
            if (this.initErrors.length > 0) return Promise.reject(this.initErrors[0]);
            if (allowResolvingImmediately && this.taskQueue.length === 0) {
                yield _ponyfills.allSettled(getCurrentlyRunningTasks());
                return taskFailures;
            }
            yield new Promise((resolve, reject)=>{
                const subscription = this.eventObservable.subscribe({
                    next (event) {
                        if (event.type === _poolTypes.PoolEventType.taskQueueDrained) {
                            subscription.unsubscribe();
                            resolve(void 0);
                        }
                    },
                    error: reject // make a pool-wide error reject the completed() result promise
                });
            });
            yield _ponyfills.allSettled(getCurrentlyRunningTasks());
            failureSubscription.unsubscribe();
            return taskFailures;
        });
    }
    completed(allowResolvingImmediately = false) {
        return __awaiter(this, void 0, void 0, function*() {
            const settlementPromise = this.settled(allowResolvingImmediately);
            const earlyExitPromise = new Promise((resolve, reject)=>{
                const subscription = this.eventObservable.subscribe({
                    next (event) {
                        if (event.type === _poolTypes.PoolEventType.taskQueueDrained) {
                            subscription.unsubscribe();
                            resolve(settlementPromise);
                        } else if (event.type === _poolTypes.PoolEventType.taskFailed) {
                            subscription.unsubscribe();
                            reject(event.error);
                        }
                    },
                    error: reject // make a pool-wide error reject the completed() result promise
                });
            });
            const errors = yield Promise.race([
                settlementPromise,
                earlyExitPromise
            ]);
            if (errors.length > 0) throw errors[0];
        });
    }
    events() {
        return this.eventObservable;
    }
    queue(taskFunction) {
        const { maxQueuedJobs =Infinity  } = this.options;
        if (this.isClosing) throw Error(`Cannot schedule pool tasks after terminate() has been called.`);
        if (this.initErrors.length > 0) throw this.initErrors[0];
        const taskID = this.nextTaskID++;
        const taskCompletion = this.taskCompletion(taskID);
        taskCompletion.catch((error)=>{
            // Prevent unhandled rejections here as we assume the user will use
            // `pool.completed()`, `pool.settled()` or `task.catch()` to handle errors
            this.debug(`Task #${taskID} errored:`, error);
        });
        const task = {
            id: taskID,
            run: taskFunction,
            cancel: ()=>{
                if (this.taskQueue.indexOf(task) === -1) return;
                this.taskQueue = this.taskQueue.filter((someTask)=>someTask !== task
                );
                this.eventSubject.next({
                    type: _poolTypes.PoolEventType.taskCanceled,
                    taskID: task.id
                });
            },
            then: taskCompletion.then.bind(taskCompletion)
        };
        if (this.taskQueue.length >= maxQueuedJobs) throw Error("Maximum number of pool tasks queued. Refusing to queue another one.\nThis usually happens for one of two reasons: We are either at peak workload right now or some tasks just won't finish, thus blocking the pool.");
        this.debug(`Queueing task #${task.id}...`);
        this.taskQueue.push(task);
        this.eventSubject.next({
            type: _poolTypes.PoolEventType.taskQueued,
            taskID: task.id
        });
        this.scheduleWork();
        return task;
    }
    terminate(force) {
        return __awaiter(this, void 0, void 0, function*() {
            this.isClosing = true;
            if (!force) yield this.completed(true);
            this.eventSubject.next({
                type: _poolTypes.PoolEventType.terminated,
                remainingQueue: [
                    ...this.taskQueue
                ]
            });
            this.eventSubject.complete();
            yield Promise.all(this.workers.map((worker)=>__awaiter(this, void 0, void 0, function*() {
                    return _thread.Thread.terminate((yield worker.init));
                })
            ));
        });
    }
}
WorkerPool.EventType = _poolTypes.PoolEventType;
/**
 * Thread pool constructor. Creates a new pool and spawns its worker threads.
 */ function PoolConstructor(spawnWorker, optionsOrSize) {
    // The function exists only so we don't need to use `new` to create a pool (we still can, though).
    // If the Pool is a class or not is an implementation detail that should not concern the user.
    return new WorkerPool(spawnWorker, optionsOrSize);
}
PoolConstructor.EventType = _poolTypes.PoolEventType;
const Pool = PoolConstructor;

},{"debug":"l0oUb","observable-fns":"jxjzk","../ponyfills":"as2Zc","./implementation":"etws1","./pool-types":"h3H76","./thread":"jdWSi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l0oUb":[function(require,module,exports) {
var process = require("process");
/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) return true;
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
    if (!this.useColors) return;
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === '%%') return;
        index++;
        if (match === '%c') // We only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{
});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) exports.storage.setItem('debug', namespaces);
        else exports.storage.removeItem('debug');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem('debug');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) r = undefined;
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = require('./common')(exports);
const { formatters  } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
    }
};

},{"process":"jhUEF","./common":"6Yq2n"}],"jhUEF":[function(require,module,exports) {
"use strict";

},{}],"6Yq2n":[function(require,module,exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require('ms');
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {
    };
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) return;
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') // Anything else let's inspect with %O
            args.unshift('%O');
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') return '%';
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) return enableOverride;
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') createDebug.init(debug);
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
        const len = split.length;
        for(i = 0; i < len; i++){
            if (!split[i]) continue;
            namespaces = split[i].replace(/\*/g, '.*?');
            if (namespaces[0] === '-') createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
            else createDebug.names.push(new RegExp('^' + namespaces + '$'));
        }
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace)=>'-' + namespace
            )
        ].join(',');
        createDebug.enable('');
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        if (name[name.length - 1] === '*') return true;
        let i;
        let len;
        for(i = 0, len = createDebug.skips.length; i < len; i++){
            if (createDebug.skips[i].test(name)) return false;
        }
        for(i = 0, len = createDebug.names.length; i < len; i++){
            if (createDebug.names[i].test(name)) return true;
        }
        return false;
    }
    /**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/ function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) return val.stack || val.message;
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;

},{"ms":"2FEgr"}],"2FEgr":[function(require,module,exports) {
/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {
    };
    var type = typeof val;
    if (type === 'string' && val.length > 0) return parse(val);
    else if (type === 'number' && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) return;
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) return;
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch(type){
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) return Math.round(ms / d) + 'd';
    if (msAbs >= h) return Math.round(ms / h) + 'h';
    if (msAbs >= m) return Math.round(ms / m) + 'm';
    if (msAbs >= s) return Math.round(ms / s) + 's';
    return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) return plural(ms, msAbs, d, 'day');
    if (msAbs >= h) return plural(ms, msAbs, h, 'hour');
    if (msAbs >= m) return plural(ms, msAbs, m, 'minute');
    if (msAbs >= s) return plural(ms, msAbs, s, 'second');
    return ms + ' ms';
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],"jxjzk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filter", ()=>_filterDefault.default
);
parcelHelpers.export(exports, "flatMap", ()=>_flatMapDefault.default
);
parcelHelpers.export(exports, "interval", ()=>_intervalDefault.default
);
parcelHelpers.export(exports, "map", ()=>_mapDefault.default
);
parcelHelpers.export(exports, "merge", ()=>_mergeDefault.default
);
parcelHelpers.export(exports, "multicast", ()=>_multicastDefault.default
);
parcelHelpers.export(exports, "Observable", ()=>_observableDefault.default
);
parcelHelpers.export(exports, "scan", ()=>_scanDefault.default
);
parcelHelpers.export(exports, "Subject", ()=>_subjectDefault.default
);
parcelHelpers.export(exports, "unsubscribe", ()=>_unsubscribeDefault.default
);
var _filter = require("./filter");
var _filterDefault = parcelHelpers.interopDefault(_filter);
var _flatMap = require("./flatMap");
var _flatMapDefault = parcelHelpers.interopDefault(_flatMap);
var _interval = require("./interval");
var _intervalDefault = parcelHelpers.interopDefault(_interval);
var _map = require("./map");
var _mapDefault = parcelHelpers.interopDefault(_map);
var _merge = require("./merge");
var _mergeDefault = parcelHelpers.interopDefault(_merge);
var _multicast = require("./multicast");
var _multicastDefault = parcelHelpers.interopDefault(_multicast);
var _observable = require("./observable");
var _observableDefault = parcelHelpers.interopDefault(_observable);
var _scan = require("./scan");
var _scanDefault = parcelHelpers.interopDefault(_scan);
var _subject = require("./subject");
var _subjectDefault = parcelHelpers.interopDefault(_subject);
var _unsubscribe = require("./unsubscribe");
var _unsubscribeDefault = parcelHelpers.interopDefault(_unsubscribe);

},{"./filter":"7XDqR","./flatMap":"dZ69r","./interval":"hMaTK","./map":"iOHUN","./merge":"e4X3b","./multicast":"cCEIW","./observable":"hn8JF","./scan":"4fjK7","./subject":"htPKv","./unsubscribe":"5w1dL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7XDqR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _scheduler = require("./_scheduler");
var _observable = require("./observable");
var _observableDefault = parcelHelpers.interopDefault(_observable);
var _unsubscribe = require("./unsubscribe");
var _unsubscribeDefault = parcelHelpers.interopDefault(_unsubscribe);
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Filters the values emitted by another observable.
 * To be applied to an input observable using `pipe()`.
 */ function filter(test) {
    return (observable)=>{
        return new _observableDefault.default((observer)=>{
            const scheduler = new _scheduler.AsyncSerialScheduler(observer);
            const subscription = observable.subscribe({
                complete () {
                    scheduler.complete();
                },
                error (error) {
                    scheduler.error(error);
                },
                next (input) {
                    scheduler.schedule((next)=>__awaiter(this, void 0, void 0, function*() {
                            if (yield test(input)) next(input);
                        })
                    );
                }
            });
            return ()=>_unsubscribeDefault.default(subscription)
            ;
        });
    };
}
exports.default = filter;

},{"./_scheduler":"cfQMb","./observable":"hn8JF","./unsubscribe":"5w1dL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cfQMb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsyncSerialScheduler", ()=>AsyncSerialScheduler
);
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class AsyncSerialScheduler {
    constructor(observer){
        this._baseObserver = observer;
        this._pendingPromises = new Set();
    }
    complete() {
        Promise.all(this._pendingPromises).then(()=>this._baseObserver.complete()
        ).catch((error)=>this._baseObserver.error(error)
        );
    }
    error(error) {
        this._baseObserver.error(error);
    }
    schedule(task) {
        const prevPromisesCompletion = Promise.all(this._pendingPromises);
        const values = [];
        const next = (value)=>values.push(value)
        ;
        const promise = Promise.resolve().then(()=>__awaiter(this, void 0, void 0, function*() {
                yield prevPromisesCompletion;
                yield task(next);
                this._pendingPromises.delete(promise);
                for (const value of values)this._baseObserver.next(value);
            })
        ).catch((error)=>{
            this._pendingPromises.delete(promise);
            this._baseObserver.error(error);
        });
        this._pendingPromises.add(promise);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hn8JF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Subscription", ()=>Subscription
);
parcelHelpers.export(exports, "SubscriptionObserver", ()=>SubscriptionObserver
);
/**
 * The basic Observable class. This primitive is used to wrap asynchronous
 * data streams in a common standardized data type that is interoperable
 * between libraries and can be composed to represent more complex processes.
 */ parcelHelpers.export(exports, "Observable", ()=>Observable
);
/**
 * Based on <https://raw.githubusercontent.com/zenparsing/zen-observable/master/src/Observable.js>
 * At commit: f63849a8c60af5d514efc8e9d6138d8273c49ad6
 */ var _symbols = require("./symbols");
var _symbols1 = require("./_symbols");
const SymbolIterator = _symbols1.getSymbol("iterator");
const SymbolObservable = _symbols1.getSymbol("observable");
const SymbolSpecies = _symbols1.getSymbol("species");
// === Abstract Operations ===
function getMethod(obj, key) {
    const value = obj[key];
    if (value == null) return undefined;
    if (typeof value !== "function") throw new TypeError(value + " is not a function");
    return value;
}
function getSpecies(obj) {
    let ctor = obj.constructor;
    if (ctor !== undefined) {
        ctor = ctor[SymbolSpecies];
        if (ctor === null) ctor = undefined;
    }
    return ctor !== undefined ? ctor : Observable;
}
function isObservable(x) {
    return x instanceof Observable; // SPEC: Brand check
}
function hostReportError(error) {
    if (hostReportError.log) hostReportError.log(error);
    else setTimeout(()=>{
        throw error;
    }, 0);
}
function enqueue(fn) {
    Promise.resolve().then(()=>{
        try {
            fn();
        } catch (e) {
            hostReportError(e);
        }
    });
}
function cleanupSubscription(subscription) {
    const cleanup = subscription._cleanup;
    if (cleanup === undefined) return;
    subscription._cleanup = undefined;
    if (!cleanup) return;
    try {
        if (typeof cleanup === "function") cleanup();
        else {
            const unsubscribe = getMethod(cleanup, "unsubscribe");
            if (unsubscribe) unsubscribe.call(cleanup);
        }
    } catch (e) {
        hostReportError(e);
    }
}
function closeSubscription(subscription) {
    subscription._observer = undefined;
    subscription._queue = undefined;
    subscription._state = "closed";
}
function flushSubscription(subscription) {
    const queue = subscription._queue;
    if (!queue) return;
    subscription._queue = undefined;
    subscription._state = "ready";
    for (const item of queue){
        notifySubscription(subscription, item.type, item.value);
        if (subscription._state === "closed") break;
    }
}
function notifySubscription(subscription, type, value) {
    subscription._state = "running";
    const observer = subscription._observer;
    try {
        const m = observer ? getMethod(observer, type) : undefined;
        switch(type){
            case "next":
                if (m) m.call(observer, value);
                break;
            case "error":
                closeSubscription(subscription);
                if (m) m.call(observer, value);
                else throw value;
                break;
            case "complete":
                closeSubscription(subscription);
                if (m) m.call(observer);
                break;
        }
    } catch (e) {
        hostReportError(e);
    }
    if (subscription._state === "closed") cleanupSubscription(subscription);
    else if (subscription._state === "running") subscription._state = "ready";
}
function onNotify(subscription, type, value) {
    if (subscription._state === "closed") return;
    if (subscription._state === "buffering") {
        subscription._queue = subscription._queue || [];
        subscription._queue.push({
            type,
            value
        });
        return;
    }
    if (subscription._state !== "ready") {
        subscription._state = "buffering";
        subscription._queue = [
            {
                type,
                value
            }
        ];
        enqueue(()=>flushSubscription(subscription)
        );
        return;
    }
    notifySubscription(subscription, type, value);
}
class Subscription {
    constructor(observer, subscriber){
        // ASSERT: observer is an object
        // ASSERT: subscriber is callable
        this._cleanup = undefined;
        this._observer = observer;
        this._queue = undefined;
        this._state = "initializing";
        const subscriptionObserver = new SubscriptionObserver(this);
        try {
            this._cleanup = subscriber.call(undefined, subscriptionObserver);
        } catch (e) {
            subscriptionObserver.error(e);
        }
        if (this._state === "initializing") this._state = "ready";
    }
    get closed() {
        return this._state === "closed";
    }
    unsubscribe() {
        if (this._state !== "closed") {
            closeSubscription(this);
            cleanupSubscription(this);
        }
    }
}
class SubscriptionObserver {
    constructor(subscription){
        this._subscription = subscription;
    }
    get closed() {
        return this._subscription._state === "closed";
    }
    next(value) {
        onNotify(this._subscription, "next", value);
    }
    error(value) {
        onNotify(this._subscription, "error", value);
    }
    complete() {
        onNotify(this._subscription, "complete");
    }
}
class Observable {
    constructor(subscriber){
        if (!(this instanceof Observable)) throw new TypeError("Observable cannot be called as a function");
        if (typeof subscriber !== "function") throw new TypeError("Observable initializer must be a function");
        this._subscriber = subscriber;
    }
    subscribe(nextOrObserver, onError, onComplete) {
        if (typeof nextOrObserver !== "object" || nextOrObserver === null) nextOrObserver = {
            next: nextOrObserver,
            error: onError,
            complete: onComplete
        };
        return new Subscription(nextOrObserver, this._subscriber);
    }
    pipe(first, ...mappers) {
        // tslint:disable-next-line no-this-assignment
        let intermediate = this;
        for (const mapper of [
            first,
            ...mappers
        ])intermediate = mapper(intermediate);
        return intermediate;
    }
    tap(nextOrObserver, onError, onComplete) {
        const tapObserver = typeof nextOrObserver !== "object" || nextOrObserver === null ? {
            next: nextOrObserver,
            error: onError,
            complete: onComplete
        } : nextOrObserver;
        return new Observable((observer)=>{
            return this.subscribe({
                next (value) {
                    tapObserver.next && tapObserver.next(value);
                    observer.next(value);
                },
                error (error) {
                    tapObserver.error && tapObserver.error(error);
                    observer.error(error);
                },
                complete () {
                    tapObserver.complete && tapObserver.complete();
                    observer.complete();
                },
                start (subscription) {
                    tapObserver.start && tapObserver.start(subscription);
                }
            });
        });
    }
    forEach(fn) {
        return new Promise((resolve, reject)=>{
            if (typeof fn !== "function") {
                reject(new TypeError(fn + " is not a function"));
                return;
            }
            function done() {
                subscription.unsubscribe();
                resolve(undefined);
            }
            const subscription = this.subscribe({
                next (value) {
                    try {
                        fn(value, done);
                    } catch (e) {
                        reject(e);
                        subscription.unsubscribe();
                    }
                },
                error (error) {
                    reject(error);
                },
                complete () {
                    resolve(undefined);
                }
            });
        });
    }
    map(fn) {
        if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
        const C = getSpecies(this);
        return new C((observer)=>this.subscribe({
                next (value) {
                    let propagatedValue = value;
                    try {
                        propagatedValue = fn(value);
                    } catch (e) {
                        return observer.error(e);
                    }
                    observer.next(propagatedValue);
                },
                error (e) {
                    observer.error(e);
                },
                complete () {
                    observer.complete();
                }
            })
        );
    }
    filter(fn) {
        if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
        const C = getSpecies(this);
        return new C((observer)=>this.subscribe({
                next (value) {
                    try {
                        if (!fn(value)) return;
                    } catch (e) {
                        return observer.error(e);
                    }
                    observer.next(value);
                },
                error (e) {
                    observer.error(e);
                },
                complete () {
                    observer.complete();
                }
            })
        );
    }
    reduce(fn, seed) {
        if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
        const C = getSpecies(this);
        const hasSeed = arguments.length > 1;
        let hasValue = false;
        let acc = seed;
        return new C((observer)=>this.subscribe({
                next (value) {
                    const first = !hasValue;
                    hasValue = true;
                    if (!first || hasSeed) try {
                        acc = fn(acc, value);
                    } catch (e) {
                        return observer.error(e);
                    }
                    else acc = value;
                },
                error (e) {
                    observer.error(e);
                },
                complete () {
                    if (!hasValue && !hasSeed) return observer.error(new TypeError("Cannot reduce an empty sequence"));
                    observer.next(acc);
                    observer.complete();
                }
            })
        );
    }
    concat(...sources) {
        const C = getSpecies(this);
        return new C((observer)=>{
            let subscription;
            let index = 0;
            function startNext(next) {
                subscription = next.subscribe({
                    next (v) {
                        observer.next(v);
                    },
                    error (e) {
                        observer.error(e);
                    },
                    complete () {
                        if (index === sources.length) {
                            subscription = undefined;
                            observer.complete();
                        } else startNext(C.from(sources[index++]));
                    }
                });
            }
            startNext(this);
            return ()=>{
                if (subscription) {
                    subscription.unsubscribe();
                    subscription = undefined;
                }
            };
        });
    }
    flatMap(fn) {
        if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
        const C = getSpecies(this);
        return new C((observer)=>{
            const subscriptions = [];
            const outer = this.subscribe({
                next (value) {
                    let normalizedValue;
                    if (fn) try {
                        normalizedValue = fn(value);
                    } catch (e1) {
                        return observer.error(e1);
                    }
                    else normalizedValue = value;
                    const inner = C.from(normalizedValue).subscribe({
                        next (innerValue) {
                            observer.next(innerValue);
                        },
                        error (e) {
                            observer.error(e);
                        },
                        complete () {
                            const i = subscriptions.indexOf(inner);
                            if (i >= 0) subscriptions.splice(i, 1);
                            completeIfDone();
                        }
                    });
                    subscriptions.push(inner);
                },
                error (e) {
                    observer.error(e);
                },
                complete () {
                    completeIfDone();
                }
            });
            function completeIfDone() {
                if (outer.closed && subscriptions.length === 0) observer.complete();
            }
            return ()=>{
                subscriptions.forEach((s)=>s.unsubscribe()
                );
                outer.unsubscribe();
            };
        });
    }
    [(Symbol.observable, SymbolObservable)]() {
        return this;
    }
    static from(x) {
        const C = typeof this === "function" ? this : Observable;
        if (x == null) throw new TypeError(x + " is not an object");
        const observableMethod = getMethod(x, SymbolObservable);
        if (observableMethod) {
            const observable = observableMethod.call(x);
            if (Object(observable) !== observable) throw new TypeError(observable + " is not an object");
            if (isObservable(observable) && observable.constructor === C) return observable;
            return new C((observer)=>observable.subscribe(observer)
            );
        }
        if (_symbols1.hasSymbol("iterator")) {
            const iteratorMethod = getMethod(x, SymbolIterator);
            if (iteratorMethod) return new C((observer)=>{
                enqueue(()=>{
                    if (observer.closed) return;
                    for (const item of iteratorMethod.call(x)){
                        observer.next(item);
                        if (observer.closed) return;
                    }
                    observer.complete();
                });
            });
        }
        if (Array.isArray(x)) return new C((observer)=>{
            enqueue(()=>{
                if (observer.closed) return;
                for (const item of x){
                    observer.next(item);
                    if (observer.closed) return;
                }
                observer.complete();
            });
        });
        throw new TypeError(x + " is not observable");
    }
    static of(...items) {
        const C = typeof this === "function" ? this : Observable;
        return new C((observer)=>{
            enqueue(()=>{
                if (observer.closed) return;
                for (const item of items){
                    observer.next(item);
                    if (observer.closed) return;
                }
                observer.complete();
            });
        });
    }
    static get [SymbolSpecies]() {
        return this;
    }
}
if (_symbols1.hasSymbols()) Object.defineProperty(Observable, Symbol("extensions"), {
    value: {
        symbol: SymbolObservable,
        hostReportError
    },
    configurable: true
});
exports.default = Observable;

},{"./symbols":"gYS2S","./_symbols":"fbORS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gYS2S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fbORS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasSymbols", ()=>hasSymbols
);
parcelHelpers.export(exports, "hasSymbol", ()=>hasSymbol
);
parcelHelpers.export(exports, "getSymbol", ()=>getSymbol
);
parcelHelpers.export(exports, "registerObservableSymbol", ()=>registerObservableSymbol
);
const hasSymbols = ()=>typeof Symbol === "function"
;
const hasSymbol = (name)=>hasSymbols() && Boolean(Symbol[name])
;
const getSymbol = (name)=>hasSymbol(name) ? Symbol[name] : "@@" + name
;
function registerObservableSymbol() {
    if (hasSymbols() && !hasSymbol("observable")) Symbol.observable = Symbol("observable");
}
if (!hasSymbol("asyncIterator")) Symbol.asyncIterator = Symbol.asyncIterator || Symbol.for("Symbol.asyncIterator");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5w1dL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Unsubscribe from a subscription returned by something that looks like an observable,
 * but is not necessarily our observable implementation.
 */ function unsubscribe(subscription) {
    if (typeof subscription === "function") subscription();
    else if (subscription && typeof subscription.unsubscribe === "function") subscription.unsubscribe();
}
exports.default = unsubscribe;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dZ69r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _scheduler = require("./_scheduler");
var _util = require("./_util");
var _observable = require("./observable");
var _observableDefault = parcelHelpers.interopDefault(_observable);
var _unsubscribe = require("./unsubscribe");
var _unsubscribeDefault = parcelHelpers.interopDefault(_unsubscribe);
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = undefined && undefined.__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v1) {
        Promise.resolve(v1).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {
    }, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
};
/**
 * Maps the values emitted by another observable. In contrast to `map()`
 * the `mapper` function returns an array of values that will be emitted
 * separately.
 * Use `flatMap()` to map input values to zero, one or multiple output
 * values. To be applied to an input observable using `pipe()`.
 */ function flatMap(mapper) {
    return (observable)=>{
        return new _observableDefault.default((observer)=>{
            const scheduler = new _scheduler.AsyncSerialScheduler(observer);
            const subscription = observable.subscribe({
                complete () {
                    scheduler.complete();
                },
                error (error) {
                    scheduler.error(error);
                },
                next (input) {
                    scheduler.schedule((next)=>__awaiter(this, void 0, void 0, function*() {
                            var e_1, _a;
                            const mapped = yield mapper(input);
                            if (_util.isIterator(mapped) || _util.isAsyncIterator(mapped)) try {
                                for(var mapped_1 = __asyncValues(mapped), mapped_1_1; mapped_1_1 = yield mapped_1.next(), !mapped_1_1.done;){
                                    const element = mapped_1_1.value;
                                    next(element);
                                }
                            } catch (e_1_1) {
                                e_1 = {
                                    error: e_1_1
                                };
                            } finally{
                                try {
                                    if (mapped_1_1 && !mapped_1_1.done && (_a = mapped_1.return)) yield _a.call(mapped_1);
                                } finally{
                                    if (e_1) throw e_1.error;
                                }
                            }
                            else mapped.map((output)=>next(output)
                            );
                        })
                    );
                }
            });
            return ()=>_unsubscribeDefault.default(subscription)
            ;
        });
    };
}
exports.default = flatMap;

},{"./_scheduler":"cfQMb","./_util":"fNpD1","./observable":"hn8JF","./unsubscribe":"5w1dL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fNpD1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isAsyncIterator", ()=>isAsyncIterator
);
parcelHelpers.export(exports, "isIterator", ()=>isIterator
);
/// <reference lib="es2018" />
var _symbols = require("./_symbols");
function isAsyncIterator(thing) {
    return thing && _symbols.hasSymbol("asyncIterator") && thing[Symbol.asyncIterator];
}
function isIterator(thing) {
    return thing && _symbols.hasSymbol("iterator") && thing[Symbol.iterator];
}

},{"./_symbols":"fbORS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hMaTK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _observable = require("./observable");
function interval(period) {
    return new _observable.Observable((observer)=>{
        let counter = 0;
        const handle = setInterval(()=>{
            observer.next(counter++);
        }, period);
        return ()=>clearInterval(handle)
        ;
    });
}
exports.default = interval;

},{"./observable":"hn8JF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iOHUN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _scheduler = require("./_scheduler");
var _observable = require("./observable");
var _observableDefault = parcelHelpers.interopDefault(_observable);
var _unsubscribe = require("./unsubscribe");
var _unsubscribeDefault = parcelHelpers.interopDefault(_unsubscribe);
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Maps the values emitted by another observable to different values.
 * To be applied to an input observable using `pipe()`.
 */ function map(mapper) {
    return (observable)=>{
        return new _observableDefault.default((observer)=>{
            const scheduler = new _scheduler.AsyncSerialScheduler(observer);
            const subscription = observable.subscribe({
                complete () {
                    scheduler.complete();
                },
                error (error) {
                    scheduler.error(error);
                },
                next (input) {
                    scheduler.schedule((next)=>__awaiter(this, void 0, void 0, function*() {
                            const mapped = yield mapper(input);
                            next(mapped);
                        })
                    );
                }
            });
            return ()=>_unsubscribeDefault.default(subscription)
            ;
        });
    };
}
exports.default = map;

},{"./_scheduler":"cfQMb","./observable":"hn8JF","./unsubscribe":"5w1dL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e4X3b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _observable = require("./observable");
var _unsubscribe = require("./unsubscribe");
var _unsubscribeDefault = parcelHelpers.interopDefault(_unsubscribe);
function merge(...observables) {
    if (observables.length === 0) return _observable.Observable.from([]);
    return new _observable.Observable((observer)=>{
        let completed = 0;
        const subscriptions = observables.map((input)=>{
            return input.subscribe({
                error (error) {
                    observer.error(error);
                    unsubscribeAll();
                },
                next (value) {
                    observer.next(value);
                },
                complete () {
                    if (++completed === observables.length) {
                        observer.complete();
                        unsubscribeAll();
                    }
                }
            });
        });
        const unsubscribeAll = ()=>{
            subscriptions.forEach((subscription)=>_unsubscribeDefault.default(subscription)
            );
        };
        return unsubscribeAll;
    });
}
exports.default = merge;

},{"./observable":"hn8JF","./unsubscribe":"5w1dL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cCEIW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _observable = require("./observable");
var _observableDefault = parcelHelpers.interopDefault(_observable);
var _subject = require("./subject");
var _subjectDefault = parcelHelpers.interopDefault(_subject);
var _unsubscribe = require("./unsubscribe");
var _unsubscribeDefault = parcelHelpers.interopDefault(_unsubscribe);
// TODO: Subject already creates additional observables "under the hood",
//       now we introduce even more. A true native MulticastObservable
//       would be preferable.
/**
 * Takes a "cold" observable and returns a wrapping "hot" observable that
 * proxies the input observable's values and errors.
 *
 * An observable is called "cold" when its initialization function is run
 * for each new subscriber. This is how observable-fns's `Observable`
 * implementation works.
 *
 * A hot observable is an observable where new subscribers subscribe to
 * the upcoming values of an already-initialiazed observable.
 *
 * The multicast observable will lazily subscribe to the source observable
 * once it has its first own subscriber and will unsubscribe from the
 * source observable when its last own subscriber unsubscribed.
 */ function multicast(coldObservable) {
    const subject = new _subjectDefault.default();
    let sourceSubscription;
    let subscriberCount = 0;
    return new _observableDefault.default((observer)=>{
        // Init source subscription lazily
        if (!sourceSubscription) sourceSubscription = coldObservable.subscribe(subject);
        // Pipe all events from `subject` into this observable
        const subscription = subject.subscribe(observer);
        subscriberCount++;
        return ()=>{
            subscriberCount--;
            subscription.unsubscribe();
            // Close source subscription once last subscriber has unsubscribed
            if (subscriberCount === 0) {
                _unsubscribeDefault.default(sourceSubscription);
                sourceSubscription = undefined;
            }
        };
    });
}
exports.default = multicast;

},{"./observable":"hn8JF","./subject":"htPKv","./unsubscribe":"5w1dL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"htPKv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _observable = require("./observable");
var _observableDefault = parcelHelpers.interopDefault(_observable);
// TODO: This observer iteration approach looks inelegant and expensive
// Idea: Come up with super class for Subscription that contains the
//       notify*, ... methods and use it here
/**
 * A subject is a "hot" observable (see `multicast`) that has its observer
 * methods (`.next(value)`, `.error(error)`, `.complete()`) exposed.
 *
 * Be careful, though! With great power comes great responsibility. Only use
 * the `Subject` when you really need to trigger updates "from the outside" and
 * try to keep the code that can access it to a minimum. Return
 * `Observable.from(mySubject)` to not allow other code to mutate.
 */ class MulticastSubject extends _observableDefault.default {
    constructor(){
        super((observer)=>{
            this._observers.add(observer);
            return ()=>this._observers.delete(observer)
            ;
        });
        this._observers = new Set();
    }
    next(value) {
        for (const observer of this._observers)observer.next(value);
    }
    error(error) {
        for (const observer of this._observers)observer.error(error);
    }
    complete() {
        for (const observer of this._observers)observer.complete();
    }
}
exports.default = MulticastSubject;

},{"./observable":"hn8JF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4fjK7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _scheduler = require("./_scheduler");
var _observable = require("./observable");
var _observableDefault = parcelHelpers.interopDefault(_observable);
var _unsubscribe = require("./unsubscribe");
var _unsubscribeDefault = parcelHelpers.interopDefault(_unsubscribe);
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function scan(accumulator, seed) {
    return (observable)=>{
        return new _observableDefault.default((observer)=>{
            let accumulated;
            let index = 0;
            const scheduler = new _scheduler.AsyncSerialScheduler(observer);
            const subscription = observable.subscribe({
                complete () {
                    scheduler.complete();
                },
                error (error) {
                    scheduler.error(error);
                },
                next (value) {
                    scheduler.schedule((next)=>__awaiter(this, void 0, void 0, function*() {
                            const prevAcc = index === 0 ? typeof seed === "undefined" ? value : seed : accumulated;
                            accumulated = yield accumulator(prevAcc, value, index++);
                            next(accumulated);
                        })
                    );
                }
            });
            return ()=>_unsubscribeDefault.default(subscription)
            ;
        });
    };
}
exports.default = scan;

},{"./_scheduler":"cfQMb","./observable":"hn8JF","./unsubscribe":"5w1dL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"as2Zc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Based on <https://github.com/es-shims/Promise.allSettled/blob/master/implementation.js>
parcelHelpers.export(exports, "allSettled", ()=>allSettled
);
function allSettled(values) {
    return Promise.all(values.map((item)=>{
        const onFulfill = (value)=>{
            return {
                status: 'fulfilled',
                value
            };
        };
        const onReject = (reason)=>{
            return {
                status: 'rejected',
                reason
            };
        };
        const itemPromise = Promise.resolve(item);
        try {
            return itemPromise.then(onFulfill, onReject);
        } catch (error) {
            return Promise.reject(error);
        }
    }));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h3H76":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PoolEventType", ()=>PoolEventType
);
var PoolEventType;
(function(PoolEventType1) {
    PoolEventType1["initialized"] = "initialized";
    PoolEventType1["taskCanceled"] = "taskCanceled";
    PoolEventType1["taskCompleted"] = "taskCompleted";
    PoolEventType1["taskFailed"] = "taskFailed";
    PoolEventType1["taskQueued"] = "taskQueued";
    PoolEventType1["taskQueueDrained"] = "taskQueueDrained";
    PoolEventType1["taskStart"] = "taskStart";
    PoolEventType1["terminated"] = "terminated";
})(PoolEventType || (PoolEventType = {
}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jdWSi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Thread", ()=>Thread
);
var _symbols = require("../symbols");
function fail(message) {
    throw Error(message);
}
const Thread = {
    /** Return an observable that can be used to subscribe to all errors happening in the thread. */ errors (thread) {
        return thread[_symbols.$errors] || fail("Error observable not found. Make sure to pass a thread instance as returned by the spawn() promise.");
    },
    /** Return an observable that can be used to subscribe to internal events happening in the thread. Useful for debugging. */ events (thread) {
        return thread[_symbols.$events] || fail("Events observable not found. Make sure to pass a thread instance as returned by the spawn() promise.");
    },
    /** Terminate a thread. Remember to terminate every thread when you are done using it. */ terminate (thread) {
        return thread[_symbols.$terminate]();
    }
};

},{"../symbols":"78yrD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"78yrD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "$errors", ()=>$errors
);
parcelHelpers.export(exports, "$events", ()=>$events
);
parcelHelpers.export(exports, "$terminate", ()=>$terminate
);
parcelHelpers.export(exports, "$transferable", ()=>$transferable
);
parcelHelpers.export(exports, "$worker", ()=>$worker
);
const $errors = Symbol("thread.errors");
const $events = Symbol("thread.events");
const $terminate = Symbol("thread.terminate");
const $transferable = Symbol("thread.transferable");
const $worker = Symbol("thread.worker");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9dksw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Spawn a new thread. Takes a fresh worker instance, wraps it in a thin
 * abstraction layer to provide the transparent API and verifies that
 * the worker has initialized successfully.
 *
 * @param worker Instance of `Worker`. Either a web worker, `worker_threads` worker or `tiny-worker` worker.
 * @param [options]
 * @param [options.timeout] Init message timeout. Default: 10000 or set by environment variable.
 */ parcelHelpers.export(exports, "spawn", ()=>spawn
);
var _debug = require("debug");
var _debugDefault = parcelHelpers.interopDefault(_debug);
var _observableFns = require("observable-fns");
var _common = require("../common");
var _promise = require("../promise");
var _symbols = require("../symbols");
var _master = require("../types/master");
var _invocationProxy = require("./invocation-proxy");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const debugMessages = _debugDefault.default("threads:master:messages");
const debugSpawn = _debugDefault.default("threads:master:spawn");
const debugThreadUtils = _debugDefault.default("threads:master:thread-utils");
const isInitMessage = (data)=>data && data.type === "init"
;
const isUncaughtErrorMessage = (data)=>data && data.type === "uncaughtError"
;
const initMessageTimeout = 10000;
function withTimeout(promise, timeoutInMs, errorMessage) {
    return __awaiter(this, void 0, void 0, function*() {
        let timeoutHandle;
        const timeout = new Promise((resolve, reject)=>{
            timeoutHandle = setTimeout(()=>reject(Error(errorMessage))
            , timeoutInMs);
        });
        const result = yield Promise.race([
            promise,
            timeout
        ]);
        clearTimeout(timeoutHandle);
        return result;
    });
}
function receiveInitMessage(worker) {
    return new Promise((resolve, reject)=>{
        const messageHandler = (event)=>{
            debugMessages("Message from worker before finishing initialization:", event.data);
            if (isInitMessage(event.data)) {
                worker.removeEventListener("message", messageHandler);
                resolve(event.data);
            } else if (isUncaughtErrorMessage(event.data)) {
                worker.removeEventListener("message", messageHandler);
                reject(_common.deserialize(event.data.error));
            }
        };
        worker.addEventListener("message", messageHandler);
    });
}
function createEventObservable(worker, workerTermination) {
    return new _observableFns.Observable((observer)=>{
        const messageHandler = (messageEvent)=>{
            const workerEvent = {
                type: _master.WorkerEventType.message,
                data: messageEvent.data
            };
            observer.next(workerEvent);
        };
        const rejectionHandler = (errorEvent)=>{
            debugThreadUtils("Unhandled promise rejection event in thread:", errorEvent);
            const workerEvent = {
                type: _master.WorkerEventType.internalError,
                error: Error(errorEvent.reason)
            };
            observer.next(workerEvent);
        };
        worker.addEventListener("message", messageHandler);
        worker.addEventListener("unhandledrejection", rejectionHandler);
        workerTermination.then(()=>{
            const terminationEvent = {
                type: _master.WorkerEventType.termination
            };
            worker.removeEventListener("message", messageHandler);
            worker.removeEventListener("unhandledrejection", rejectionHandler);
            observer.next(terminationEvent);
            observer.complete();
        });
    });
}
function createTerminator(worker) {
    const [termination, resolver] = _promise.createPromiseWithResolver();
    const terminate = ()=>__awaiter(this, void 0, void 0, function*() {
            debugThreadUtils("Terminating worker");
            // Newer versions of worker_threads workers return a promise
            yield worker.terminate();
            resolver();
        })
    ;
    return {
        terminate,
        termination
    };
}
function setPrivateThreadProps(raw, worker, workerEvents, terminate) {
    const workerErrors = workerEvents.filter((event)=>event.type === _master.WorkerEventType.internalError
    ).map((errorEvent)=>errorEvent.error
    );
    // tslint:disable-next-line prefer-object-spread
    return Object.assign(raw, {
        [_symbols.$errors]: workerErrors,
        [_symbols.$events]: workerEvents,
        [_symbols.$terminate]: terminate,
        [_symbols.$worker]: worker
    });
}
function spawn(worker, options) {
    return __awaiter(this, void 0, void 0, function*() {
        debugSpawn("Initializing new thread");
        const timeout = options && options.timeout ? options.timeout : initMessageTimeout;
        const initMessage = yield withTimeout(receiveInitMessage(worker), timeout, `Timeout: Did not receive an init message from worker after ${timeout}ms. Make sure the worker calls expose().`);
        const exposed = initMessage.exposed;
        const { termination , terminate  } = createTerminator(worker);
        const events = createEventObservable(worker, termination);
        if (exposed.type === "function") {
            const proxy = _invocationProxy.createProxyFunction(worker);
            return setPrivateThreadProps(proxy, worker, events, terminate);
        } else if (exposed.type === "module") {
            const proxy = _invocationProxy.createProxyModule(worker, exposed.methods);
            return setPrivateThreadProps(proxy, worker, events, terminate);
        } else {
            const type = exposed.type;
            throw Error(`Worker init message states unexpected type of expose(): ${type}`);
        }
    });
}

},{"debug":"l0oUb","observable-fns":"jxjzk","../common":"5D80z","../promise":"dyiD8","../symbols":"78yrD","../types/master":"lN0v5","./invocation-proxy":"7T6Ug","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dyiD8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a new promise and exposes its resolver function.
 * Use with care!
 */ parcelHelpers.export(exports, "createPromiseWithResolver", ()=>createPromiseWithResolver
);
const doNothing = ()=>undefined
;
function createPromiseWithResolver() {
    let alreadyResolved = false;
    let resolvedTo;
    let resolver = doNothing;
    const promise = new Promise((resolve)=>{
        if (alreadyResolved) resolve(resolvedTo);
        else resolver = resolve;
    });
    const exposedResolver = (value)=>{
        alreadyResolved = true;
        resolvedTo = value;
        resolver(resolvedTo);
    };
    return [
        promise,
        exposedResolver
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lN0v5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WorkerEventType", ()=>WorkerEventType
);
/// <reference lib="dom" />
// tslint:disable max-classes-per-file
var _symbols = require("../symbols");
var WorkerEventType;
(function(WorkerEventType1) {
    WorkerEventType1["internalError"] = "internalError";
    WorkerEventType1["message"] = "message";
    WorkerEventType1["termination"] = "termination";
})(WorkerEventType || (WorkerEventType = {
}));

},{"../symbols":"78yrD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7T6Ug":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createProxyFunction", ()=>createProxyFunction
);
parcelHelpers.export(exports, "createProxyModule", ()=>createProxyModule
);
/*
 * This source file contains the code for proxying calls in the master thread to calls in the workers
 * by `.postMessage()`-ing.
 *
 * Keep in mind that this code can make or break the program's performance! Need to optimize more
 */ var _debug = require("debug");
var _debugDefault = parcelHelpers.interopDefault(_debug);
var _observableFns = require("observable-fns");
var _common = require("../common");
var _observablePromise = require("../observable-promise");
var _transferable = require("../transferable");
var _messages = require("../types/messages");
const debugMessages = _debugDefault.default("threads:master:messages");
let nextJobUID = 1;
const dedupe = (array)=>Array.from(new Set(array))
;
const isJobErrorMessage = (data)=>data && data.type === _messages.WorkerMessageType.error
;
const isJobResultMessage = (data)=>data && data.type === _messages.WorkerMessageType.result
;
const isJobStartMessage = (data)=>data && data.type === _messages.WorkerMessageType.running
;
function createObservableForJob(worker, jobUID) {
    return new _observableFns.Observable((observer)=>{
        let asyncType;
        const messageHandler = (event)=>{
            debugMessages("Message from worker:", event.data);
            if (!event.data || event.data.uid !== jobUID) return;
            if (isJobStartMessage(event.data)) asyncType = event.data.resultType;
            else if (isJobResultMessage(event.data)) {
                if (asyncType === "promise") {
                    if (typeof event.data.payload !== "undefined") observer.next(_common.deserialize(event.data.payload));
                    observer.complete();
                    worker.removeEventListener("message", messageHandler);
                } else {
                    if (event.data.payload) observer.next(_common.deserialize(event.data.payload));
                    if (event.data.complete) {
                        observer.complete();
                        worker.removeEventListener("message", messageHandler);
                    }
                }
            } else if (isJobErrorMessage(event.data)) {
                const error = _common.deserialize(event.data.error);
                if (asyncType === "promise" || !asyncType) observer.error(error);
                else observer.error(error);
                worker.removeEventListener("message", messageHandler);
            }
        };
        worker.addEventListener("message", messageHandler);
        return ()=>{
            if (asyncType === "observable" || !asyncType) {
                const cancelMessage = {
                    type: _messages.MasterMessageType.cancel,
                    uid: jobUID
                };
                worker.postMessage(cancelMessage);
            }
            worker.removeEventListener("message", messageHandler);
        };
    });
}
function prepareArguments(rawArgs) {
    if (rawArgs.length === 0) // Exit early if possible
    return {
        args: [],
        transferables: []
    };
    const args = [];
    const transferables = [];
    for (const arg of rawArgs)if (_transferable.isTransferDescriptor(arg)) {
        args.push(_common.serialize(arg.send));
        transferables.push(...arg.transferables);
    } else args.push(_common.serialize(arg));
    return {
        args,
        transferables: transferables.length === 0 ? transferables : dedupe(transferables)
    };
}
function createProxyFunction(worker, method) {
    return (...rawArgs)=>{
        const uid = nextJobUID++;
        const { args , transferables  } = prepareArguments(rawArgs);
        const runMessage = {
            type: _messages.MasterMessageType.run,
            uid,
            method,
            args
        };
        debugMessages("Sending command to run function to worker:", runMessage);
        try {
            worker.postMessage(runMessage, transferables);
        } catch (error) {
            return _observablePromise.ObservablePromise.from(Promise.reject(error));
        }
        return _observablePromise.ObservablePromise.from(_observableFns.multicast(createObservableForJob(worker, uid)));
    };
}
function createProxyModule(worker, methodNames) {
    const proxy = {
    };
    for (const methodName of methodNames)proxy[methodName] = createProxyFunction(worker, methodName);
    return proxy;
}

},{"debug":"l0oUb","observable-fns":"jxjzk","../common":"5D80z","../observable-promise":"a5BWZ","../transferable":"6VlW9","../types/messages":"dYHt9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a5BWZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a hybrid, combining the APIs of an Observable and a Promise.
 *
 * It is used to proxy async process states when we are initially not sure
 * if that async process will yield values once (-> Promise) or multiple
 * times (-> Observable).
 *
 * Note that the observable promise inherits some of the observable's characteristics:
 * The `init` function will be called *once for every time anyone subscribes to it*.
 *
 * If this is undesired, derive a hot observable from it using `makeHot()` and
 * subscribe to that.
 */ parcelHelpers.export(exports, "ObservablePromise", ()=>ObservablePromise
);
var _observableFns = require("observable-fns");
const doNothing = ()=>undefined
;
const returnInput = (input)=>input
;
const runDeferred = (fn)=>Promise.resolve().then(fn)
;
function fail(error) {
    throw error;
}
function isThenable(thing) {
    return thing && typeof thing.then === "function";
}
class ObservablePromise extends _observableFns.Observable {
    constructor(init){
        super((originalObserver)=>{
            // tslint:disable-next-line no-this-assignment
            const self = this;
            const observer = Object.assign(Object.assign({
            }, originalObserver), {
                complete () {
                    originalObserver.complete();
                    self.onCompletion();
                },
                error (error) {
                    originalObserver.error(error);
                    self.onError(error);
                },
                next (value) {
                    originalObserver.next(value);
                    self.onNext(value);
                }
            });
            try {
                this.initHasRun = true;
                return init(observer);
            } catch (error) {
                observer.error(error);
            }
        });
        this.initHasRun = false;
        this.fulfillmentCallbacks = [];
        this.rejectionCallbacks = [];
        this.firstValueSet = false;
        this.state = "pending";
    }
    onNext(value) {
        if (!this.firstValueSet) {
            this.firstValue = value;
            this.firstValueSet = true;
        }
    }
    onError(error) {
        this.state = "rejected";
        this.rejection = error;
        for (const onRejected of this.rejectionCallbacks)// Promisifying the call to turn errors into unhandled promise rejections
        // instead of them failing sync and cancelling the iteration
        runDeferred(()=>onRejected(error)
        );
    }
    onCompletion() {
        this.state = "fulfilled";
        for (const onFulfilled of this.fulfillmentCallbacks)// Promisifying the call to turn errors into unhandled promise rejections
        // instead of them failing sync and cancelling the iteration
        runDeferred(()=>onFulfilled(this.firstValue)
        );
    }
    then(onFulfilledRaw, onRejectedRaw) {
        const onFulfilled = onFulfilledRaw || returnInput;
        const onRejected = onRejectedRaw || fail;
        let onRejectedCalled = false;
        return new Promise((resolve, reject)=>{
            const rejectionCallback = (error)=>{
                if (onRejectedCalled) return;
                onRejectedCalled = true;
                try {
                    resolve(onRejected(error));
                } catch (anotherError) {
                    reject(anotherError);
                }
            };
            const fulfillmentCallback = (value)=>{
                try {
                    resolve(onFulfilled(value));
                } catch (error) {
                    rejectionCallback(error);
                }
            };
            if (!this.initHasRun) this.subscribe({
                error: rejectionCallback
            });
            if (this.state === "fulfilled") return resolve(onFulfilled(this.firstValue));
            if (this.state === "rejected") {
                onRejectedCalled = true;
                return resolve(onRejected(this.rejection));
            }
            this.fulfillmentCallbacks.push(fulfillmentCallback);
            this.rejectionCallbacks.push(rejectionCallback);
        });
    }
    catch(onRejected) {
        return this.then(undefined, onRejected);
    }
    finally(onCompleted) {
        const handler = onCompleted || doNothing;
        return this.then((value)=>{
            handler();
            return value;
        }, ()=>handler()
        );
    }
    static from(thing) {
        if (isThenable(thing)) return new ObservablePromise((observer)=>{
            const onFulfilled = (value)=>{
                observer.next(value);
                observer.complete();
            };
            const onRejected = (error)=>{
                observer.error(error);
            };
            thing.then(onFulfilled, onRejected);
        });
        else return super.from(thing);
    }
}

},{"observable-fns":"jxjzk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6VlW9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isTransferDescriptor", ()=>isTransferDescriptor
);
parcelHelpers.export(exports, "Transfer", ()=>Transfer
);
var _symbols = require("./symbols");
function isTransferable(thing) {
    if (!thing || typeof thing !== "object") return false;
    // Don't check too thoroughly, since the list of transferable things in JS might grow over time
    return true;
}
function isTransferDescriptor(thing) {
    return thing && typeof thing === "object" && thing[_symbols.$transferable];
}
function Transfer(payload, transferables) {
    if (!transferables) {
        if (!isTransferable(payload)) throw Error();
        transferables = [
            payload
        ];
    }
    return {
        [_symbols.$transferable]: true,
        send: payload,
        transferables
    };
}

},{"./symbols":"78yrD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dYHt9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MasterMessageType", ()=>MasterMessageType
);
parcelHelpers.export(exports, "WorkerMessageType", ()=>WorkerMessageType
);
var MasterMessageType;
(function(MasterMessageType1) {
    MasterMessageType1["cancel"] = "cancel";
    MasterMessageType1["run"] = "run";
})(MasterMessageType || (MasterMessageType = {
}));
var WorkerMessageType;
(function(WorkerMessageType1) {
    WorkerMessageType1["error"] = "error";
    WorkerMessageType1["init"] = "init";
    WorkerMessageType1["result"] = "result";
    WorkerMessageType1["running"] = "running";
    WorkerMessageType1["uncaughtError"] = "uncaughtError";
})(WorkerMessageType || (WorkerMessageType = {
}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1U8ue":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "registerSerializer", ()=>_common.registerSerializer
);
parcelHelpers.export(exports, "Transfer", ()=>_transferable.Transfer
);
parcelHelpers.export(exports, "isWorkerRuntime", ()=>isWorkerRuntime
);
/**
 * Expose a function or a module (an object whose values are functions)
 * to the main thread. Must be called exactly once in every worker thread
 * to signal its API to the main thread.
 *
 * @param exposed Function or object whose values are functions
 */ parcelHelpers.export(exports, "expose", ()=>expose
);
var _isObservable = require("is-observable");
var _isObservableDefault = parcelHelpers.interopDefault(_isObservable);
var _common = require("../common");
var _transferable = require("../transferable");
var _messages = require("../types/messages");
var _implementation = require("./implementation");
var _implementationDefault = parcelHelpers.interopDefault(_implementation);
var process = require("process");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const isWorkerRuntime = _implementationDefault.default.isWorkerRuntime;
let exposeCalled = false;
const activeSubscriptions = new Map();
const isMasterJobCancelMessage = (thing)=>thing && thing.type === _messages.MasterMessageType.cancel
;
const isMasterJobRunMessage = (thing)=>thing && thing.type === _messages.MasterMessageType.run
;
/**
 * There are issues with `is-observable` not recognizing zen-observable's instances.
 * We are using `observable-fns`, but it's based on zen-observable, too.
 */ const isObservable = (thing)=>_isObservableDefault.default(thing) || isZenObservable(thing)
;
function isZenObservable(thing) {
    return thing && typeof thing === "object" && typeof thing.subscribe === "function";
}
function deconstructTransfer(thing) {
    return _transferable.isTransferDescriptor(thing) ? {
        payload: thing.send,
        transferables: thing.transferables
    } : {
        payload: thing,
        transferables: undefined
    };
}
function postFunctionInitMessage() {
    const initMessage = {
        type: _messages.WorkerMessageType.init,
        exposed: {
            type: "function"
        }
    };
    _implementationDefault.default.postMessageToMaster(initMessage);
}
function postModuleInitMessage(methodNames) {
    const initMessage = {
        type: _messages.WorkerMessageType.init,
        exposed: {
            type: "module",
            methods: methodNames
        }
    };
    _implementationDefault.default.postMessageToMaster(initMessage);
}
function postJobErrorMessage(uid, rawError) {
    const { payload: error , transferables  } = deconstructTransfer(rawError);
    const errorMessage = {
        type: _messages.WorkerMessageType.error,
        uid,
        error: _common.serialize(error)
    };
    _implementationDefault.default.postMessageToMaster(errorMessage, transferables);
}
function postJobResultMessage(uid, completed, resultValue) {
    const { payload , transferables  } = deconstructTransfer(resultValue);
    const resultMessage = {
        type: _messages.WorkerMessageType.result,
        uid,
        complete: completed ? true : undefined,
        payload
    };
    _implementationDefault.default.postMessageToMaster(resultMessage, transferables);
}
function postJobStartMessage(uid, resultType) {
    const startMessage = {
        type: _messages.WorkerMessageType.running,
        uid,
        resultType
    };
    _implementationDefault.default.postMessageToMaster(startMessage);
}
function postUncaughtErrorMessage(error) {
    try {
        const errorMessage = {
            type: _messages.WorkerMessageType.uncaughtError,
            error: _common.serialize(error)
        };
        _implementationDefault.default.postMessageToMaster(errorMessage);
    } catch (subError) {
        // tslint:disable-next-line no-console
        console.error("Not reporting uncaught error back to master thread as it occured while reporting an uncaught error already.\nLatest error:", subError, "\nOriginal error:", error);
    }
}
function runFunction(jobUID, fn, args) {
    return __awaiter(this, void 0, void 0, function*() {
        let syncResult;
        try {
            syncResult = fn(...args);
        } catch (error1) {
            return postJobErrorMessage(jobUID, error1);
        }
        const resultType = isObservable(syncResult) ? "observable" : "promise";
        postJobStartMessage(jobUID, resultType);
        if (isObservable(syncResult)) {
            const subscription = syncResult.subscribe((value)=>postJobResultMessage(jobUID, false, _common.serialize(value))
            , (error)=>{
                postJobErrorMessage(jobUID, _common.serialize(error));
                activeSubscriptions.delete(jobUID);
            }, ()=>{
                postJobResultMessage(jobUID, true);
                activeSubscriptions.delete(jobUID);
            });
            activeSubscriptions.set(jobUID, subscription);
        } else try {
            const result = yield syncResult;
            postJobResultMessage(jobUID, true, _common.serialize(result));
        } catch (error) {
            postJobErrorMessage(jobUID, _common.serialize(error));
        }
    });
}
function expose(exposed) {
    if (!_implementationDefault.default.isWorkerRuntime()) throw Error("expose() called in the master thread.");
    if (exposeCalled) throw Error("expose() called more than once. This is not possible. Pass an object to expose() if you want to expose multiple functions.");
    exposeCalled = true;
    if (typeof exposed === "function") {
        _implementationDefault.default.subscribeToMasterMessages((messageData)=>{
            if (isMasterJobRunMessage(messageData) && !messageData.method) runFunction(messageData.uid, exposed, messageData.args.map(_common.deserialize));
        });
        postFunctionInitMessage();
    } else if (typeof exposed === "object" && exposed) {
        _implementationDefault.default.subscribeToMasterMessages((messageData)=>{
            if (isMasterJobRunMessage(messageData) && messageData.method) runFunction(messageData.uid, exposed[messageData.method], messageData.args.map(_common.deserialize));
        });
        const methodNames = Object.keys(exposed).filter((key)=>typeof exposed[key] === "function"
        );
        postModuleInitMessage(methodNames);
    } else throw Error(`Invalid argument passed to expose(). Expected a function or an object, got: ${exposed}`);
    _implementationDefault.default.subscribeToMasterMessages((messageData)=>{
        if (isMasterJobCancelMessage(messageData)) {
            const jobUID = messageData.uid;
            const subscription = activeSubscriptions.get(jobUID);
            if (subscription) {
                subscription.unsubscribe();
                activeSubscriptions.delete(jobUID);
            }
        }
    });
}
if (typeof self !== "undefined" && typeof self.addEventListener === "function" && _implementationDefault.default.isWorkerRuntime()) {
    self.addEventListener("error", (event)=>{
        // Post with some delay, so the master had some time to subscribe to messages
        setTimeout(()=>postUncaughtErrorMessage(event.error || event)
        , 250);
    });
    self.addEventListener("unhandledrejection", (event)=>{
        const error = event.reason;
        if (error && typeof error.message === "string") // Post with some delay, so the master had some time to subscribe to messages
        setTimeout(()=>postUncaughtErrorMessage(error)
        , 250);
    });
}
if (typeof process !== "undefined" && typeof process.on === "function" && _implementationDefault.default.isWorkerRuntime()) {
    process.on("uncaughtException", (error)=>{
        // Post with some delay, so the master had some time to subscribe to messages
        setTimeout(()=>postUncaughtErrorMessage(error)
        , 250);
    });
    process.on("unhandledRejection", (error)=>{
        if (error && typeof error.message === "string") // Post with some delay, so the master had some time to subscribe to messages
        setTimeout(()=>postUncaughtErrorMessage(error)
        , 250);
    });
}

},{"is-observable":"2UHUF","../common":"5D80z","../transferable":"6VlW9","../types/messages":"dYHt9","./implementation":"bT2F7","process":"jhUEF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2UHUF":[function(require,module,exports) {
'use strict';
module.exports = (value)=>{
    if (!value) return false;
    // eslint-disable-next-line no-use-extend-native/no-use-extend-native
    if (typeof Symbol.observable === 'symbol' && typeof value[Symbol.observable] === 'function') // eslint-disable-next-line no-use-extend-native/no-use-extend-native
    return value === value[Symbol.observable]();
    if (typeof value['@@observable'] === 'function') return value === value['@@observable']();
    return false;
};

},{}],"bT2F7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/// <reference lib="dom" />
// tslint:disable no-shadowed-variable
const isWorkerRuntime = function isWorkerRuntime() {
    const isWindowContext = typeof self !== "undefined" && typeof Window !== "undefined" && self instanceof Window;
    return typeof self !== "undefined" && self.postMessage && !isWindowContext ? true : false;
};
const postMessageToMaster = function postMessageToMaster(data, transferList) {
    self.postMessage(data, transferList);
};
const subscribeToMasterMessages = function subscribeToMasterMessages(onMessage) {
    const messageHandler = (messageEvent)=>{
        onMessage(messageEvent.data);
    };
    const unsubscribe = ()=>{
        self.removeEventListener("message", messageHandler);
    };
    self.addEventListener("message", messageHandler);
    return unsubscribe;
};
exports.default = {
    isWorkerRuntime,
    postMessageToMaster,
    subscribeToMasterMessages
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fHdDH":[function(require,module,exports) {
module.exports = require('./helpers/bundle-url').getBundleURL('6sKm4') + "tessellation-worker.d50efc29.js";

},{"./helpers/bundle-url":"lgJ39"}],"lgJ39":[function(require,module,exports) {
"use strict";
var bundleURL = {
};
function getBundleURLCached(id) {
    var value = bundleURL[id];
    if (!value) {
        value = getBundleURL();
        bundleURL[id] = value;
    }
    return value;
}
function getBundleURL() {
    try {
        throw new Error();
    } catch (err) {
        var matches = ('' + err.stack).match(/(https?|file|ftp):\/\/[^)\n]+/g);
        if (matches) // The first two stack frames will be this function and getBundleURLCached.
        // Use the 3rd one, which will be a runtime in the original bundle.
        return getBaseURL(matches[2]);
    }
    return '/';
}
function getBaseURL(url) {
    return ('' + url).replace(/^((?:https?|file|ftp):\/\/.+)\/[^/]+$/, '$1') + '/';
} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.
function getOrigin(url) {
    var matches = ('' + url).match(/(https?|file|ftp):\/\/[^/]+/);
    if (!matches) throw new Error('Origin not found');
    return matches[0];
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
exports.getOrigin = getOrigin;

},{}],"5Adn4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2017 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////
(function() {
    let translateMat;
    let rotateXMat;
    let rotateYMat;
    let rotateZMat;
    let scaleMat;
    if (window.mat4) {
        translateMat = mat4.create();
        rotateXMat = mat4.create();
        rotateYMat = mat4.create();
        rotateZMat = mat4.create();
        scaleMat = mat4.create();
    }
    let zeros = [
        0,
        0,
        0
    ];
    let ones = [
        1,
        1,
        1
    ];
    const NUM_TIMING_SAMPLES = 10;
    let cpuTimeSum = 0;
    let gpuTimeSum = 0;
    let timeSampleCount = NUM_TIMING_SAMPLES - 1;
    let randS = 1;
    let randC = 1;
    let frame = 0;
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    function pvrtc2bppSize(width, height) {
        width = Math.max(width, 16);
        height = Math.max(height, 8);
        return width * height / 4;
    }
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    function pvrtc4bppSize(width, height) {
        width = Math.max(width, 8);
        height = Math.max(height, 8);
        return width * height / 2;
    }
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/
    // Size for:
    // COMPRESSED_RGB_S3TC_DXT1_EXT
    // COMPRESSED_R11_EAC
    // COMPRESSED_SIGNED_R11_EAC
    // COMPRESSED_RGB8_ETC2
    // COMPRESSED_SRGB8_ETC2
    // COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2
    // COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2
    function dxtEtcSmallSize(width, height) {
        return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    }
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/
    // Size for:
    // COMPRESSED_RGBA_S3TC_DXT3_EXT
    // COMPRESSED_RGBA_S3TC_DXT5_EXT
    // COMPRESSED_RG11_EAC
    // COMPRESSED_SIGNED_RG11_EAC
    // COMPRESSED_RGBA8_ETC2_EAC
    // COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
    // COMPRESSED_RGBA_ASTC_4x4_KHR
    function dxtEtcAstcBigSize(width, height) {
        return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    }
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/
    function atc5x4Size(width, height) {
        return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
    }
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/
    function atc5x5Size(width, height) {
        return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
    }
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/
    function atc6x5Size(width, height) {
        return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
    }
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/
    function atc6x6Size(width, height) {
        return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
    }
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/
    function atc8x5Size(width, height) {
        return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
    }
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/
    function atc8x6Size(width, height) {
        return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
    }
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/
    function atc8x8Size(width, height) {
        return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
    }
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/
    function atc10x5Size(width, height) {
        return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
    }
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/
    function atc10x6Size(width, height) {
        return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
    }
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/
    function atc10x8Size(width, height) {
        return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
    }
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/
    function atc10x10Size(width, height) {
        return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
    }
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/
    function atc12x10Size(width, height) {
        return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
    }
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/
    function atc12x12Size(width, height) {
        return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;
    }
    const PVR_CONSTANTS = {
        MAGIC_NUMBER: 55727696,
        HEADER_LENGTH: 13,
        HEADER_SIZE: 52,
        MAGIC_NUMBER_INDEX: 0,
        PIXEL_FORMAT_INDEX: 2,
        HEIGHT_INDEX: 6,
        WIDTH_INDEX: 7,
        MIPMAPCOUNT_INDEX: 11,
        METADATA_SIZE_INDEX: 12,
        FORMATS: {
            0: "COMPRESSED_RGB_PVRTC_2BPPV1_IMG",
            1: "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG",
            2: "COMPRESSED_RGB_PVRTC_4BPPV1_IMG",
            3: "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG",
            6: "COMPRESSED_RGB8_ETC2",
            7: "COMPRESSED_RGB_S3TC_DXT1_EXT",
            9: "COMPRESSED_RGBA_S3TC_DXT3_EXT",
            11: "COMPRESSED_RGBA_S3TC_DXT5_EXT",
            22: "COMPRESSED_RGB8_ETC2",
            23: "COMPRESSED_RGBA8_ETC2_EAC",
            24: "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2",
            25: "COMPRESSED_R11_EAC",
            26: "COMPRESSED_RG11_EAC",
            27: "COMPRESSED_RGBA_ASTC_4x4_KHR",
            28: "COMPRESSED_RGBA_ASTC_5x4_KHR",
            29: "COMPRESSED_RGBA_ASTC_5x5_KHR",
            30: "COMPRESSED_RGBA_ASTC_6x5_KHR",
            31: "COMPRESSED_RGBA_ASTC_6x6_KHR",
            32: "COMPRESSED_RGBA_ASTC_8x5_KHR",
            33: "COMPRESSED_RGBA_ASTC_8x6_KHR",
            34: "COMPRESSED_RGBA_ASTC_8x8_KHR",
            35: "COMPRESSED_RGBA_ASTC_10x5_KHR",
            36: "COMPRESSED_RGBA_ASTC_10x6_KHR",
            37: "COMPRESSED_RGBA_ASTC_10x8_KHR",
            38: "COMPRESSED_RGBA_ASTC_10x10_KHR",
            39: "COMPRESSED_RGBA_ASTC_12x10_KHR",
            40: "COMPRESSED_RGBA_ASTC_12x12_KHR"
        },
        SIZE_FUNCTIONS: {
            0: pvrtc2bppSize,
            1: pvrtc2bppSize,
            2: pvrtc4bppSize,
            3: pvrtc4bppSize,
            6: dxtEtcSmallSize,
            7: dxtEtcSmallSize,
            9: dxtEtcAstcBigSize,
            11: dxtEtcAstcBigSize,
            22: dxtEtcSmallSize,
            23: dxtEtcAstcBigSize,
            24: dxtEtcSmallSize,
            25: dxtEtcSmallSize,
            26: dxtEtcAstcBigSize,
            27: dxtEtcAstcBigSize,
            28: atc5x4Size,
            29: atc5x5Size,
            30: atc6x5Size,
            31: atc6x6Size,
            32: atc8x5Size,
            33: atc8x6Size,
            34: atc8x8Size,
            35: atc10x5Size,
            36: atc10x6Size,
            37: atc10x8Size,
            38: atc10x10Size,
            39: atc12x10Size,
            40: atc12x12Size
        }
    };
    window.utils = {
        random () {
            randS = Math.sin(randC * 18.42);
            randC = Math.cos(randS * 984.21);
            let n = Math.abs(randS * randC) * 4532.3454;
            return n - Math.floor(n);
        },
        instrumentAnimationFrame (numFrames = 1) {
            if (window.glcheck_setRAFCount) window.glcheck_setRAFCount(numFrames);
        },
        xformMatrix (xform, translate, rotate, scale) {
            translate = translate || zeros;
            rotate = rotate || zeros;
            scale = scale || ones;
            mat4.fromTranslation(translateMat, translate);
            mat4.fromXRotation(rotateXMat, rotate[0]);
            mat4.fromYRotation(rotateYMat, rotate[1]);
            mat4.fromZRotation(rotateZMat, rotate[2]);
            mat4.fromScaling(scaleMat, scale);
            mat4.multiply(xform, rotateXMat, scaleMat);
            mat4.multiply(xform, rotateYMat, xform);
            mat4.multiply(xform, rotateZMat, xform);
            mat4.multiply(xform, translateMat, xform);
        },
        loadImages (urls) {
            return new Promise((resolve)=>{
                let numImages = urls.length;
                let images = new Array(numImages);
                function onload() {
                    if (--numImages === 0) resolve(images);
                }
                for(let i = 0; i < numImages; ++i){
                    images[i] = new Image();
                    images[i].onload = onload;
                    images[i].src = urls[i];
                }
            });
        },
        loadImageArray (urls) {
            return this.loadImages(urls).then((images)=>{
                let canvas = document.createElement("canvas");
                let ctx = canvas.getContext("2d");
                let width = images[0].width;
                let height = images[0].height;
                canvas.width = width;
                canvas.height = height * images.length;
                for(let i = 0, len = images.length; i < len; ++i)ctx.drawImage(images[i], 0, i * height);
                return new Promise((resolve)=>{
                    let image = new Image();
                    image.onload = ()=>{
                        resolve({
                            data: image,
                            width: width,
                            height: height,
                            length: images.length
                        });
                    };
                    image.src = canvas.toDataURL();
                });
            });
        },
        createBox (options) {
            options = options || {
            };
            let dimensions = options.dimensions || [
                1,
                1,
                1
            ];
            let position = options.position || [
                -dimensions[0] / 2,
                -dimensions[1] / 2,
                -dimensions[2] / 2
            ];
            let x = position[0];
            let y = position[1];
            let z = position[2];
            let width = dimensions[0];
            let height = dimensions[1];
            let depth = dimensions[2];
            let fbl = {
                x: x,
                y: y,
                z: z + depth
            };
            let fbr = {
                x: x + width,
                y: y,
                z: z + depth
            };
            let ftl = {
                x: x,
                y: y + height,
                z: z + depth
            };
            let ftr = {
                x: x + width,
                y: y + height,
                z: z + depth
            };
            let bbl = {
                x: x,
                y: y,
                z: z
            };
            let bbr = {
                x: x + width,
                y: y,
                z: z
            };
            let btl = {
                x: x,
                y: y + height,
                z: z
            };
            let btr = {
                x: x + width,
                y: y + height,
                z: z
            };
            let positions = new Float32Array([
                //front
                fbl.x,
                fbl.y,
                fbl.z,
                fbr.x,
                fbr.y,
                fbr.z,
                ftl.x,
                ftl.y,
                ftl.z,
                ftl.x,
                ftl.y,
                ftl.z,
                fbr.x,
                fbr.y,
                fbr.z,
                ftr.x,
                ftr.y,
                ftr.z,
                //right
                fbr.x,
                fbr.y,
                fbr.z,
                bbr.x,
                bbr.y,
                bbr.z,
                ftr.x,
                ftr.y,
                ftr.z,
                ftr.x,
                ftr.y,
                ftr.z,
                bbr.x,
                bbr.y,
                bbr.z,
                btr.x,
                btr.y,
                btr.z,
                //back
                fbr.x,
                bbr.y,
                bbr.z,
                bbl.x,
                bbl.y,
                bbl.z,
                btr.x,
                btr.y,
                btr.z,
                btr.x,
                btr.y,
                btr.z,
                bbl.x,
                bbl.y,
                bbl.z,
                btl.x,
                btl.y,
                btl.z,
                //left
                bbl.x,
                bbl.y,
                bbl.z,
                fbl.x,
                fbl.y,
                fbl.z,
                btl.x,
                btl.y,
                btl.z,
                btl.x,
                btl.y,
                btl.z,
                fbl.x,
                fbl.y,
                fbl.z,
                ftl.x,
                ftl.y,
                ftl.z,
                //top
                ftl.x,
                ftl.y,
                ftl.z,
                ftr.x,
                ftr.y,
                ftr.z,
                btl.x,
                btl.y,
                btl.z,
                btl.x,
                btl.y,
                btl.z,
                ftr.x,
                ftr.y,
                ftr.z,
                btr.x,
                btr.y,
                btr.z,
                //bottom
                bbl.x,
                bbl.y,
                bbl.z,
                bbr.x,
                bbr.y,
                bbr.z,
                fbl.x,
                fbl.y,
                fbl.z,
                fbl.x,
                fbl.y,
                fbl.z,
                bbr.x,
                bbr.y,
                bbr.z,
                fbr.x,
                fbr.y,
                fbr.z
            ]);
            let uvs = new Float32Array([
                //front
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                1,
                1,
                0,
                1,
                1,
                //right
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                1,
                1,
                0,
                1,
                1,
                //back
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                1,
                1,
                0,
                1,
                1,
                //left
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                1,
                1,
                0,
                1,
                1,
                //top
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                1,
                1,
                0,
                1,
                1,
                //bottom
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                1,
                1,
                0,
                1,
                1
            ]);
            let normals = new Float32Array([
                // front
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                1,
                // right
                1,
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                // back
                0,
                0,
                -1,
                0,
                0,
                -1,
                0,
                0,
                -1,
                0,
                0,
                -1,
                0,
                0,
                -1,
                0,
                0,
                -1,
                // left
                -1,
                0,
                0,
                -1,
                0,
                0,
                -1,
                0,
                0,
                -1,
                0,
                0,
                -1,
                0,
                0,
                -1,
                0,
                0,
                // top
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                // bottom
                0,
                -1,
                0,
                0,
                -1,
                0,
                0,
                -1,
                0,
                0,
                -1,
                0,
                0,
                -1,
                0,
                0,
                -1,
                0
            ]);
            return {
                positions: positions,
                normals: normals,
                uvs: uvs
            };
        },
        createSphere (options) {
            options = options || {
            };
            let longBands = options.longBands || 32;
            let latBands = options.latBands || 32;
            let radius = options.radius || 1;
            let lat_step = Math.PI / latBands;
            let long_step = 2 * Math.PI / longBands;
            let num_positions = longBands * latBands * 4;
            let num_indices = longBands * latBands * 6;
            let lat_angle, long_angle;
            let positions = new Float32Array(num_positions * 3);
            let normals = new Float32Array(num_positions * 3);
            let uvs = new Float32Array(num_positions * 2);
            let indices = new Uint16Array(num_indices);
            let x1, x2, x3, x4, y1, y2, z1, z2, z3, z4, u1, u2, v1, v2;
            let i, j;
            let k = 0, l = 0;
            let vi, ti;
            for(i = 0; i < latBands; i++){
                lat_angle = i * lat_step;
                y1 = Math.cos(lat_angle);
                y2 = Math.cos(lat_angle + lat_step);
                for(j = 0; j < longBands; j++){
                    long_angle = j * long_step;
                    x1 = Math.sin(lat_angle) * Math.cos(long_angle);
                    x2 = Math.sin(lat_angle) * Math.cos(long_angle + long_step);
                    x3 = Math.sin(lat_angle + lat_step) * Math.cos(long_angle);
                    x4 = Math.sin(lat_angle + lat_step) * Math.cos(long_angle + long_step);
                    z1 = Math.sin(lat_angle) * Math.sin(long_angle);
                    z2 = Math.sin(lat_angle) * Math.sin(long_angle + long_step);
                    z3 = Math.sin(lat_angle + lat_step) * Math.sin(long_angle);
                    z4 = Math.sin(lat_angle + lat_step) * Math.sin(long_angle + long_step);
                    u1 = 1 - j / longBands;
                    u2 = 1 - (j + 1) / longBands;
                    v1 = 1 - i / latBands;
                    v2 = 1 - (i + 1) / latBands;
                    vi = k * 3;
                    ti = k * 2;
                    positions[vi] = x1 * radius;
                    positions[vi + 1] = y1 * radius;
                    positions[vi + 2] = z1 * radius; //v0
                    positions[vi + 3] = x2 * radius;
                    positions[vi + 4] = y1 * radius;
                    positions[vi + 5] = z2 * radius; //v1
                    positions[vi + 6] = x3 * radius;
                    positions[vi + 7] = y2 * radius;
                    positions[vi + 8] = z3 * radius; // v2
                    positions[vi + 9] = x4 * radius;
                    positions[vi + 10] = y2 * radius;
                    positions[vi + 11] = z4 * radius; // v3
                    normals[vi] = x1;
                    normals[vi + 1] = y1;
                    normals[vi + 2] = z1;
                    normals[vi + 3] = x2;
                    normals[vi + 4] = y1;
                    normals[vi + 5] = z2;
                    normals[vi + 6] = x3;
                    normals[vi + 7] = y2;
                    normals[vi + 8] = z3;
                    normals[vi + 9] = x4;
                    normals[vi + 10] = y2;
                    normals[vi + 11] = z4;
                    uvs[ti] = u1;
                    uvs[ti + 1] = v1;
                    uvs[ti + 2] = u2;
                    uvs[ti + 3] = v1;
                    uvs[ti + 4] = u1;
                    uvs[ti + 5] = v2;
                    uvs[ti + 6] = u2;
                    uvs[ti + 7] = v2;
                    indices[l] = k;
                    indices[l + 1] = k + 1;
                    indices[l + 2] = k + 2;
                    indices[l + 3] = k + 2;
                    indices[l + 4] = k + 1;
                    indices[l + 5] = k + 3;
                    k += 4;
                    l += 6;
                }
            }
            return {
                positions: positions,
                normals: normals,
                uvs: uvs,
                indices: indices
            };
        },
        computeBoundingBox (position, options) {
            options = options || {
            };
            let buildGeometry = options.buildGeometry || false;
            let boundary = {
                min: vec3.create(),
                max: vec3.create()
            };
            vec3.set(boundary.min, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
            vec3.set(boundary.max, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
            for(let i = 0, len = position.length; i < len; i += 3){
                boundary.min[0] = Math.min(position[i], boundary.min[0]);
                boundary.max[0] = Math.max(position[i], boundary.max[0]);
                boundary.min[1] = Math.min(position[i + 1], boundary.min[1]);
                boundary.max[1] = Math.max(position[i + 1], boundary.max[1]);
                boundary.min[2] = Math.min(position[i + 2], boundary.min[2]);
                boundary.max[2] = Math.max(position[i + 2], boundary.max[2]);
            }
            if (buildGeometry) {
                let size = vec3.create();
                vec3.subtract(size, boundary.max, boundary.min);
                boundary.geometry = utils.createBox({
                    position: boundary.min,
                    dimensions: size
                });
            }
            return boundary;
        },
        addTimerElement () {
            this.timerDiv = document.createElement("div");
            this.timerDiv.id = "timer";
            this.cpuTimeElement = document.createElement("div");
            this.gpuTimeElement = document.createElement("div");
            this.timerDiv.appendChild(this.cpuTimeElement);
            this.timerDiv.appendChild(this.gpuTimeElement);
            document.body.appendChild(this.timerDiv);
        },
        updateTimerElement (cpuTime, gpuTime) {
            cpuTimeSum += cpuTime;
            gpuTimeSum += gpuTime;
            ++timeSampleCount;
            if (timeSampleCount === NUM_TIMING_SAMPLES) {
                let cpuTimeAve = cpuTimeSum / NUM_TIMING_SAMPLES;
                let gpuTimeAve = gpuTimeSum / NUM_TIMING_SAMPLES;
                this.cpuTimeElement.innerText = "CPU time: " + cpuTimeAve.toFixed(3) + "ms";
                if (gpuTimeAve > 0) this.gpuTimeElement.innerText = "GPU time: " + gpuTimeAve.toFixed(3) + "ms";
                else this.gpuTimeElement.innerText = "GPU time: (Unavailable)";
                cpuTimeSum = 0;
                gpuTimeSum = 0;
                timeSampleCount = 0;
            }
        },
        loadBinary (url) {
            return new Promise((resolve)=>{
                let xhr = new XMLHttpRequest();
                xhr.open("GET", url);
                xhr.responseType = "arraybuffer";
                xhr.onload = function() {
                    resolve(xhr.response);
                };
                xhr.send(null);
            });
        },
        loadBinaries (urls) {
            return Promise.all(urls.map((url)=>this.loadBinary(url)
            ));
        },
        // http://cdn.imgtec.com/sdk-documentation/PVR+File+Format.Specification.pdf
        parsePVR (data) {
            let header = new Uint32Array(data, 0, PVR_CONSTANTS.HEADER_LENGTH);
            let pvrFormat = header[PVR_CONSTANTS.PIXEL_FORMAT_INDEX];
            let formatEnum = PVR_CONSTANTS.FORMATS[pvrFormat];
            let sizeFunction = PVR_CONSTANTS.SIZE_FUNCTIONS[pvrFormat];
            let mipMapLevels = header[PVR_CONSTANTS.MIPMAPCOUNT_INDEX];
            let width = header[PVR_CONSTANTS.WIDTH_INDEX];
            let height = header[PVR_CONSTANTS.HEIGHT_INDEX];
            let dataOffset = PVR_CONSTANTS.HEADER_SIZE + header[PVR_CONSTANTS.METADATA_SIZE_INDEX];
            let image = new Uint8Array(data, dataOffset);
            let levels = new Array(mipMapLevels);
            let levelWidth = width;
            let levelHeight = height;
            let offset = 0;
            for(let i = 0; i < mipMapLevels; ++i){
                let levelSize = sizeFunction(levelWidth, levelHeight);
                levels[i] = new Uint8Array(image.buffer, image.byteOffset + offset, levelSize);
                levelWidth = Math.max(1, levelWidth >> 1);
                levelHeight = Math.max(1, levelHeight >> 1);
                offset += levelSize;
            }
            return {
                data: levels,
                width: width,
                height: height,
                format: formatEnum
            };
        }
    };
})();
exports.default = "lol";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7wzGb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "glsl", ()=>glsl
);
parcelHelpers.export(exports, "bufferGetter", ()=>bufferGetter
);
parcelHelpers.export(exports, "setStructUniforms", ()=>setStructUniforms
);
const glsl = function(s, ...values) {
    let str = "";
    s.forEach((string, i)=>{
        str += string + (values[i] || "");
    });
    return str;
};
const bufferGetter = (gl, sourceBuffer)=>(destination)=>{
        gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, sourceBuffer);
        gl.getBufferSubData(gl.TRANSFORM_FEEDBACK_BUFFER, 0, destination);
    }
;
const setStructUniforms = (drawer1, baseName, values)=>Object.entries(values).reduce((drawer, [k, v])=>drawer.uniform(`${baseName}.${k}`, v)
    , drawer1)
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ckB5R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _delaunator = require("delaunator");
var _delaunatorDefault = parcelHelpers.interopDefault(_delaunator);
var _lodashEs = require("lodash-es");
var _tessellation = require("../src/tessellation");
var _rbush = require("rbush");
var _rbushDefault = parcelHelpers.interopDefault(_rbush);
exports.default = function(points = 100, width = 1, height = 1, center = [
    0,
    0
]) {
    let coords = _lodashEs.flatten(new Array(3 * points).fill(null).map(()=>[
            center[0] + (Math.random() - 0.5) * width + center[1] + (Math.random() - 0.5) * height, 
        ]
    ));
    // coords = flatten(uvGrid(Math.sqrt(points)).map(([x,y])=>[x-0.5,y-0.5]))
    const delaunay = new _delaunatorDefault.default(coords);
    const mesh = _tessellation.prepareMesh(delaunay);
    const eps = 0.001;
    const faceBounds = mesh.mda.vertices.map((vertex)=>{
        const [x, y] = mesh.mda.positions[vertex.index];
        return {
            minX: x - eps,
            minY: y - eps,
            maxX: x + eps,
            maxY: y + eps,
            index: vertex.index
        };
    //.map(([[minX, maxX], [minY, maxY]]) => ({ minX, maxX, minY, maxY }))
    });
    // console.log('faceBounds',faceBounds)
    mesh.rbush = new _rbushDefault.default();
    mesh.rbush.load(faceBounds);
    // mesh.mda.faces
    // return mesh.mda.
    return mesh;
};

},{"delaunator":"1U5NA","lodash-es":"bXNwz","../src/tessellation":"0FAPM","rbush":"k2VZu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1U5NA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _robustPredicates = require("robust-predicates");
const EPSILON = Math.pow(2, -52);
const EDGE_STACK = new Uint32Array(512);
class Delaunator {
    static from(points, getX = defaultGetX, getY = defaultGetY) {
        const n = points.length;
        const coords = new Float64Array(n * 2);
        for(let i = 0; i < n; i++){
            const p = points[i];
            coords[2 * i] = getX(p);
            coords[2 * i + 1] = getY(p);
        }
        return new Delaunator(coords);
    }
    constructor(coords){
        const n = coords.length >> 1;
        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');
        this.coords = coords;
        // arrays that will store the triangulation graph
        const maxTriangles = Math.max(2 * n - 5, 0);
        this._triangles = new Uint32Array(maxTriangles * 3);
        this._halfedges = new Int32Array(maxTriangles * 3);
        // temporary arrays for tracking the edges of the advancing convex hull
        this._hashSize = Math.ceil(Math.sqrt(n));
        this._hullPrev = new Uint32Array(n); // edge to prev edge
        this._hullNext = new Uint32Array(n); // edge to next edge
        this._hullTri = new Uint32Array(n); // edge to adjacent triangle
        this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash
        // temporary arrays for sorting points
        this._ids = new Uint32Array(n);
        this._dists = new Float64Array(n);
        this.update();
    }
    update() {
        const { coords , _hullPrev: hullPrev , _hullNext: hullNext , _hullTri: hullTri , _hullHash: hullHash  } = this;
        const n = coords.length >> 1;
        // populate an array of point indices; calculate input data bbox
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        for(let i = 0; i < n; i++){
            const x = coords[2 * i];
            const y = coords[2 * i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            this._ids[i] = i;
        }
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;
        let minDist = Infinity;
        let i0, i1, i2;
        // pick a seed point close to the center
        for(let i3 = 0; i3 < n; i3++){
            const d = dist(cx, cy, coords[2 * i3], coords[2 * i3 + 1]);
            if (d < minDist) {
                i0 = i3;
                minDist = d;
            }
        }
        const i0x = coords[2 * i0];
        const i0y = coords[2 * i0 + 1];
        minDist = Infinity;
        // find the point closest to the seed
        for(let i4 = 0; i4 < n; i4++){
            if (i4 === i0) continue;
            const d = dist(i0x, i0y, coords[2 * i4], coords[2 * i4 + 1]);
            if (d < minDist && d > 0) {
                i1 = i4;
                minDist = d;
            }
        }
        let i1x = coords[2 * i1];
        let i1y = coords[2 * i1 + 1];
        let minRadius = Infinity;
        // find the third point which forms the smallest circumcircle with the first two
        for(let i5 = 0; i5 < n; i5++){
            if (i5 === i0 || i5 === i1) continue;
            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i5], coords[2 * i5 + 1]);
            if (r < minRadius) {
                i2 = i5;
                minRadius = r;
            }
        }
        let i2x = coords[2 * i2];
        let i2y = coords[2 * i2 + 1];
        if (minRadius === Infinity) {
            // order collinear points by dx (or dy if all x are identical)
            // and return the list as a hull
            for(let i = 0; i < n; i++)this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
            quicksort(this._ids, this._dists, 0, n - 1);
            const hull = new Uint32Array(n);
            let j = 0;
            for(let i8 = 0, d0 = -Infinity; i8 < n; i8++){
                const id = this._ids[i8];
                if (this._dists[id] > d0) {
                    hull[j++] = id;
                    d0 = this._dists[id];
                }
            }
            this.hull = hull.subarray(0, j);
            this.triangles = new Uint32Array(0);
            this.halfedges = new Uint32Array(0);
            return;
        }
        // swap the order of the seed points for counter-clockwise orientation
        if (_robustPredicates.orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
            const i = i1;
            const x = i1x;
            const y = i1y;
            i1 = i2;
            i1x = i2x;
            i1y = i2y;
            i2 = i;
            i2x = x;
            i2y = y;
        }
        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
        this._cx = center.x;
        this._cy = center.y;
        for(let i6 = 0; i6 < n; i6++)this._dists[i6] = dist(coords[2 * i6], coords[2 * i6 + 1], center.x, center.y);
        // sort the points by distance from the seed triangle circumcenter
        quicksort(this._ids, this._dists, 0, n - 1);
        // set up the seed triangle as the starting hull
        this._hullStart = i0;
        let hullSize = 3;
        hullNext[i0] = hullPrev[i2] = i1;
        hullNext[i1] = hullPrev[i0] = i2;
        hullNext[i2] = hullPrev[i1] = i0;
        hullTri[i0] = 0;
        hullTri[i1] = 1;
        hullTri[i2] = 2;
        hullHash.fill(-1);
        hullHash[this._hashKey(i0x, i0y)] = i0;
        hullHash[this._hashKey(i1x, i1y)] = i1;
        hullHash[this._hashKey(i2x, i2y)] = i2;
        this.trianglesLen = 0;
        this._addTriangle(i0, i1, i2, -1, -1, -1);
        for(let k = 0, xp, yp; k < this._ids.length; k++){
            const i = this._ids[k];
            const x = coords[2 * i];
            const y = coords[2 * i + 1];
            // skip near-duplicate points
            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
            xp = x;
            yp = y;
            // skip seed triangle points
            if (i === i0 || i === i1 || i === i2) continue;
            // find a visible edge on the convex hull using edge hash
            let start = 0;
            for(let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++){
                start = hullHash[(key + j) % this._hashSize];
                if (start !== -1 && start !== hullNext[start]) break;
            }
            start = hullPrev[start];
            let e = start, q;
            while(q = hullNext[e], _robustPredicates.orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0){
                e = q;
                if (e === start) {
                    e = -1;
                    break;
                }
            }
            if (e === -1) continue; // likely a near-duplicate point; skip it
            // add the first triangle from the point
            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);
            // recursively flip triangles from the point until they satisfy the Delaunay condition
            hullTri[i] = this._legalize(t + 2);
            hullTri[e] = t; // keep track of boundary triangles on the hull
            hullSize++;
            // walk forward through the hull, adding more triangles and flipping recursively
            let n = hullNext[e];
            while(q = hullNext[n], _robustPredicates.orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0){
                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                hullTri[i] = this._legalize(t + 2);
                hullNext[n] = n; // mark as removed
                hullSize--;
                n = q;
            }
            // walk backward from the other side, adding more triangles and flipping
            if (e === start) while(q = hullPrev[e], _robustPredicates.orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0){
                t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                this._legalize(t + 2);
                hullTri[q] = t;
                hullNext[e] = e; // mark as removed
                hullSize--;
                e = q;
            }
            // update the hull indices
            this._hullStart = hullPrev[i] = e;
            hullNext[e] = hullPrev[n] = i;
            hullNext[i] = n;
            // save the two new edges in the hash table
            hullHash[this._hashKey(x, y)] = i;
            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
        }
        this.hull = new Uint32Array(hullSize);
        for(let i7 = 0, e = this._hullStart; i7 < hullSize; i7++){
            this.hull[i7] = e;
            e = hullNext[e];
        }
        // trim typed triangle mesh arrays
        this.triangles = this._triangles.subarray(0, this.trianglesLen);
        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
    }
    _hashKey(x, y) {
        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
    }
    _legalize(a) {
        const { _triangles: triangles , _halfedges: halfedges , coords  } = this;
        let i = 0;
        let ar = 0;
        // recursion eliminated with a fixed-size stack
        while(true){
            const b = halfedges[a];
            /* if the pair of triangles doesn't satisfy the Delaunay condition
             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
             * then do the same check/flip recursively for the new pair of triangles
             *
             *           pl                    pl
             *          /||\                  /  \
             *       al/ || \bl            al/    \a
             *        /  ||  \              /      \
             *       /  a||b  \    flip    /___ar___\
             *     p0\   ||   /p1   =>   p0\---bl---/p1
             *        \  ||  /              \      /
             *       ar\ || /br             b\    /br
             *          \||/                  \  /
             *           pr                    pr
             */ const a0 = a - a % 3;
            ar = a0 + (a + 2) % 3;
            if (b === -1) {
                if (i === 0) break;
                a = EDGE_STACK[--i];
                continue;
            }
            const b0 = b - b % 3;
            const al = a0 + (a + 1) % 3;
            const bl = b0 + (b + 2) % 3;
            const p0 = triangles[ar];
            const pr = triangles[a];
            const pl = triangles[al];
            const p1 = triangles[bl];
            const illegal = inCircle(coords[2 * p0], coords[2 * p0 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1]);
            if (illegal) {
                triangles[a] = p1;
                triangles[b] = p0;
                const hbl = halfedges[bl];
                // edge swapped on the other side of the hull (rare); fix the halfedge reference
                if (hbl === -1) {
                    let e = this._hullStart;
                    do {
                        if (this._hullTri[e] === bl) {
                            this._hullTri[e] = a;
                            break;
                        }
                        e = this._hullPrev[e];
                    }while (e !== this._hullStart)
                }
                this._link(a, hbl);
                this._link(b, halfedges[ar]);
                this._link(ar, bl);
                const br = b0 + (b + 1) % 3;
                // don't worry about hitting the cap: it can only happen on extremely degenerate input
                if (i < EDGE_STACK.length) EDGE_STACK[i++] = br;
            } else {
                if (i === 0) break;
                a = EDGE_STACK[--i];
            }
        }
        return ar;
    }
    _link(a, b) {
        this._halfedges[a] = b;
        if (b !== -1) this._halfedges[b] = a;
    }
    // add a new triangle given vertex indices and adjacent half-edge ids
    _addTriangle(i0, i1, i2, a, b, c) {
        const t = this.trianglesLen;
        this._triangles[t] = i0;
        this._triangles[t + 1] = i1;
        this._triangles[t + 2] = i2;
        this._link(t, a);
        this._link(t + 1, b);
        this._link(t + 2, c);
        this.trianglesLen += 3;
        return t;
    }
}
exports.default = Delaunator;
// monotonically increases with real angle, but doesn't need expensive trigonometry
function pseudoAngle(dx, dy) {
    const p = dx / (Math.abs(dx) + Math.abs(dy));
    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
}
function dist(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx * dx + dy * dy;
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
    const dx = ax - px;
    const dy = ay - py;
    const ex = bx - px;
    const ey = by - py;
    const fx = cx - px;
    const fy = cy - py;
    const ap = dx * dx + dy * dy;
    const bp = ex * ex + ey * ey;
    const cp = fx * fx + fy * fy;
    return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;
    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);
    const x = (ey * bl - dy * cl) * d;
    const y = (dx * cl - ex * bl) * d;
    return x * x + y * y;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;
    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);
    const x = ax + (ey * bl - dy * cl) * d;
    const y = ay + (dx * cl - ex * bl) * d;
    return {
        x,
        y
    };
}
function quicksort(ids, dists, left, right) {
    if (right - left <= 20) for(let i = left + 1; i <= right; i++){
        const temp = ids[i];
        const tempDist = dists[temp];
        let j = i - 1;
        while(j >= left && dists[ids[j]] > tempDist)ids[j + 1] = ids[j--];
        ids[j + 1] = temp;
    }
    else {
        const median = left + right >> 1;
        let i = left + 1;
        let j = right;
        swap(ids, median, i);
        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);
        const temp = ids[i];
        const tempDist = dists[temp];
        while(true){
            do i++;
            while (dists[ids[i]] < tempDist)
            do j--;
            while (dists[ids[j]] > tempDist)
            if (j < i) break;
            swap(ids, i, j);
        }
        ids[left + 1] = ids[j];
        ids[j] = temp;
        if (right - i + 1 >= j - left) {
            quicksort(ids, dists, i, right);
            quicksort(ids, dists, left, j - 1);
        } else {
            quicksort(ids, dists, left, j - 1);
            quicksort(ids, dists, i, right);
        }
    }
}
function swap(arr, i, j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
function defaultGetX(p) {
    return p[0];
}
function defaultGetY(p) {
    return p[1];
}

},{"robust-predicates":"7e0QE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7e0QE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "orient2d", ()=>_orient2DJs.orient2d
);
parcelHelpers.export(exports, "orient2dfast", ()=>_orient2DJs.orient2dfast
);
parcelHelpers.export(exports, "orient3d", ()=>_orient3DJs.orient3d
);
parcelHelpers.export(exports, "orient3dfast", ()=>_orient3DJs.orient3dfast
);
parcelHelpers.export(exports, "incircle", ()=>_incircleJs.incircle
);
parcelHelpers.export(exports, "incirclefast", ()=>_incircleJs.incirclefast
);
parcelHelpers.export(exports, "insphere", ()=>_insphereJs.insphere
);
parcelHelpers.export(exports, "inspherefast", ()=>_insphereJs.inspherefast
);
var _orient2DJs = require("./esm/orient2d.js");
var _orient3DJs = require("./esm/orient3d.js");
var _incircleJs = require("./esm/incircle.js");
var _insphereJs = require("./esm/insphere.js");

},{"./esm/orient2d.js":"gHqC4","./esm/orient3d.js":"dt5pN","./esm/incircle.js":"6yBsv","./esm/insphere.js":"6qjhA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gHqC4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "orient2d", ()=>orient2d
);
parcelHelpers.export(exports, "orient2dfast", ()=>orient2dfast
);
var _utilJs = require("./util.js");
const ccwerrboundA = (3 + 16 * _utilJs.epsilon) * _utilJs.epsilon;
const ccwerrboundB = (2 + 12 * _utilJs.epsilon) * _utilJs.epsilon;
const ccwerrboundC = (9 + 64 * _utilJs.epsilon) * _utilJs.epsilon * _utilJs.epsilon;
const B = _utilJs.vec(4);
const C1 = _utilJs.vec(8);
const C2 = _utilJs.vec(12);
const D = _utilJs.vec(16);
const u = _utilJs.vec(4);
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
    let acxtail, acytail, bcxtail, bcytail;
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;
    const acx = ax - cx;
    const bcx = bx - cx;
    const acy = ay - cy;
    const bcy = by - cy;
    s1 = acx * bcy;
    c = _utilJs.splitter * acx;
    ahi = c - (c - acx);
    alo = acx - ahi;
    c = _utilJs.splitter * bcy;
    bhi = c - (c - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acy * bcx;
    c = _utilJs.splitter * acy;
    ahi = c - (c - acy);
    alo = acy - ahi;
    c = _utilJs.splitter * bcx;
    bhi = c - (c - bcx);
    blo = bcx - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    B[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    B[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    B[2] = _j - (u3 - bvirt) + (_i - bvirt);
    B[3] = u3;
    let det = _utilJs.estimate(4, B);
    let errbound = ccwerrboundB * detsum;
    if (det >= errbound || -det >= errbound) return det;
    bvirt = ax - acx;
    acxtail = ax - (acx + bvirt) + (bvirt - cx);
    bvirt = bx - bcx;
    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
    bvirt = ay - acy;
    acytail = ay - (acy + bvirt) + (bvirt - cy);
    bvirt = by - bcy;
    bcytail = by - (bcy + bvirt) + (bvirt - cy);
    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) return det;
    errbound = ccwerrboundC * detsum + _utilJs.resulterrbound * Math.abs(det);
    det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
    if (det >= errbound || -det >= errbound) return det;
    s1 = acxtail * bcy;
    c = _utilJs.splitter * acxtail;
    ahi = c - (c - acxtail);
    alo = acxtail - ahi;
    c = _utilJs.splitter * bcy;
    bhi = c - (c - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acytail * bcx;
    c = _utilJs.splitter * acytail;
    ahi = c - (c - acytail);
    alo = acytail - ahi;
    c = _utilJs.splitter * bcx;
    bhi = c - (c - bcx);
    blo = bcx - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const C1len = _utilJs.sum(4, B, 4, u, C1);
    s1 = acx * bcytail;
    c = _utilJs.splitter * acx;
    ahi = c - (c - acx);
    alo = acx - ahi;
    c = _utilJs.splitter * bcytail;
    bhi = c - (c - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acy * bcxtail;
    c = _utilJs.splitter * acy;
    ahi = c - (c - acy);
    alo = acy - ahi;
    c = _utilJs.splitter * bcxtail;
    bhi = c - (c - bcxtail);
    blo = bcxtail - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const C2len = _utilJs.sum(C1len, C1, 4, u, C2);
    s1 = acxtail * bcytail;
    c = _utilJs.splitter * acxtail;
    ahi = c - (c - acxtail);
    alo = acxtail - ahi;
    c = _utilJs.splitter * bcytail;
    bhi = c - (c - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acytail * bcxtail;
    c = _utilJs.splitter * acytail;
    ahi = c - (c - acytail);
    alo = acytail - ahi;
    c = _utilJs.splitter * bcxtail;
    bhi = c - (c - bcxtail);
    blo = bcxtail - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const Dlen = _utilJs.sum(C2len, C2, 4, u, D);
    return D[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
    const detleft = (ay - cy) * (bx - cx);
    const detright = (ax - cx) * (by - cy);
    const det = detleft - detright;
    if (detleft === 0 || detright === 0 || detleft > 0 !== detright > 0) return det;
    const detsum = Math.abs(detleft + detright);
    if (Math.abs(det) >= ccwerrboundA * detsum) return det;
    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}
function orient2dfast(ax, ay, bx, by, cx, cy) {
    return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);
}

},{"./util.js":"3OxkP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3OxkP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "epsilon", ()=>epsilon
);
parcelHelpers.export(exports, "splitter", ()=>splitter
);
parcelHelpers.export(exports, "resulterrbound", ()=>resulterrbound
);
// fast_expansion_sum_zeroelim routine from oritinal code
parcelHelpers.export(exports, "sum", ()=>sum
);
parcelHelpers.export(exports, "sum_three", ()=>sum_three
);
// scale_expansion_zeroelim routine from oritinal code
parcelHelpers.export(exports, "scale", ()=>scale
);
parcelHelpers.export(exports, "negate", ()=>negate
);
parcelHelpers.export(exports, "estimate", ()=>estimate
);
parcelHelpers.export(exports, "vec", ()=>vec
);
const epsilon = 0.00000000000000011102230246251565;
const splitter = 134217729;
const resulterrbound = (3 + 8 * epsilon) * epsilon;
function sum(elen, e, flen, f, h) {
    let Q, Qnew, hh, bvirt;
    let enow = e[0];
    let fnow = f[0];
    let eindex = 0;
    let findex = 0;
    if (fnow > enow === fnow > -enow) {
        Q = enow;
        enow = e[++eindex];
    } else {
        Q = fnow;
        fnow = f[++findex];
    }
    let hindex = 0;
    if (eindex < elen && findex < flen) {
        if (fnow > enow === fnow > -enow) {
            Qnew = enow + Q;
            hh = Q - (Qnew - enow);
            enow = e[++eindex];
        } else {
            Qnew = fnow + Q;
            hh = Q - (Qnew - fnow);
            fnow = f[++findex];
        }
        Q = Qnew;
        if (hh !== 0) h[hindex++] = hh;
        while(eindex < elen && findex < flen){
            if (fnow > enow === fnow > -enow) {
                Qnew = Q + enow;
                bvirt = Qnew - Q;
                hh = Q - (Qnew - bvirt) + (enow - bvirt);
                enow = e[++eindex];
            } else {
                Qnew = Q + fnow;
                bvirt = Qnew - Q;
                hh = Q - (Qnew - bvirt) + (fnow - bvirt);
                fnow = f[++findex];
            }
            Q = Qnew;
            if (hh !== 0) h[hindex++] = hh;
        }
    }
    while(eindex < elen){
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
        Q = Qnew;
        if (hh !== 0) h[hindex++] = hh;
    }
    while(findex < flen){
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
        Q = Qnew;
        if (hh !== 0) h[hindex++] = hh;
    }
    if (Q !== 0 || hindex === 0) h[hindex++] = Q;
    return hindex;
}
function sum_three(alen, a, blen, b, clen, c, tmp, out) {
    return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);
}
function scale(elen, e, b, h) {
    let Q, sum1, hh, product1, product0;
    let bvirt, c, ahi, alo, bhi, blo;
    c = splitter * b;
    bhi = c - (c - b);
    blo = b - bhi;
    let enow = e[0];
    Q = enow * b;
    c = splitter * enow;
    ahi = c - (c - enow);
    alo = enow - ahi;
    hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);
    let hindex = 0;
    if (hh !== 0) h[hindex++] = hh;
    for(let i = 1; i < elen; i++){
        enow = e[i];
        product1 = enow * b;
        c = splitter * enow;
        ahi = c - (c - enow);
        alo = enow - ahi;
        product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);
        sum1 = Q + product0;
        bvirt = sum1 - Q;
        hh = Q - (sum1 - bvirt) + (product0 - bvirt);
        if (hh !== 0) h[hindex++] = hh;
        Q = product1 + sum1;
        hh = sum1 - (Q - product1);
        if (hh !== 0) h[hindex++] = hh;
    }
    if (Q !== 0 || hindex === 0) h[hindex++] = Q;
    return hindex;
}
function negate(elen, e) {
    for(let i = 0; i < elen; i++)e[i] = -e[i];
    return elen;
}
function estimate(elen, e) {
    let Q = e[0];
    for(let i = 1; i < elen; i++)Q += e[i];
    return Q;
}
function vec(n) {
    return new Float64Array(n);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dt5pN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "orient3d", ()=>orient3d
);
parcelHelpers.export(exports, "orient3dfast", ()=>orient3dfast
);
var _utilJs = require("./util.js");
const o3derrboundA = (7 + 56 * _utilJs.epsilon) * _utilJs.epsilon;
const o3derrboundB = (3 + 28 * _utilJs.epsilon) * _utilJs.epsilon;
const o3derrboundC = (26 + 288 * _utilJs.epsilon) * _utilJs.epsilon * _utilJs.epsilon;
const bc = _utilJs.vec(4);
const ca = _utilJs.vec(4);
const ab = _utilJs.vec(4);
const at_b = _utilJs.vec(4);
const at_c = _utilJs.vec(4);
const bt_c = _utilJs.vec(4);
const bt_a = _utilJs.vec(4);
const ct_a = _utilJs.vec(4);
const ct_b = _utilJs.vec(4);
const bct = _utilJs.vec(8);
const cat = _utilJs.vec(8);
const abt = _utilJs.vec(8);
const u = _utilJs.vec(4);
const _8 = _utilJs.vec(8);
const _8b = _utilJs.vec(8);
const _16 = _utilJs.vec(8);
const _12 = _utilJs.vec(12);
let fin = _utilJs.vec(192);
let fin2 = _utilJs.vec(192);
function finadd(finlen, alen, a) {
    finlen = _utilJs.sum(finlen, fin, alen, a, fin2);
    const tmp = fin;
    fin = fin2;
    fin2 = tmp;
    return finlen;
}
function tailinit(xtail, ytail, ax, ay, bx, by, a, b) {
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, t1, t0, u3, negate;
    if (xtail === 0) {
        if (ytail === 0) {
            a[0] = 0;
            b[0] = 0;
            return 1;
        } else {
            negate = -ytail;
            s1 = negate * ax;
            c = _utilJs.splitter * negate;
            ahi = c - (c - negate);
            alo = negate - ahi;
            c = _utilJs.splitter * ax;
            bhi = c - (c - ax);
            blo = ax - bhi;
            a[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            a[1] = s1;
            s1 = ytail * bx;
            c = _utilJs.splitter * ytail;
            ahi = c - (c - ytail);
            alo = ytail - ahi;
            c = _utilJs.splitter * bx;
            bhi = c - (c - bx);
            blo = bx - bhi;
            b[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            b[1] = s1;
            return 2;
        }
    } else if (ytail === 0) {
        s1 = xtail * ay;
        c = _utilJs.splitter * xtail;
        ahi = c - (c - xtail);
        alo = xtail - ahi;
        c = _utilJs.splitter * ay;
        bhi = c - (c - ay);
        blo = ay - bhi;
        a[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        a[1] = s1;
        negate = -xtail;
        s1 = negate * by;
        c = _utilJs.splitter * negate;
        ahi = c - (c - negate);
        alo = negate - ahi;
        c = _utilJs.splitter * by;
        bhi = c - (c - by);
        blo = by - bhi;
        b[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        b[1] = s1;
        return 2;
    } else {
        s1 = xtail * ay;
        c = _utilJs.splitter * xtail;
        ahi = c - (c - xtail);
        alo = xtail - ahi;
        c = _utilJs.splitter * ay;
        bhi = c - (c - ay);
        blo = ay - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = ytail * ax;
        c = _utilJs.splitter * ytail;
        ahi = c - (c - ytail);
        alo = ytail - ahi;
        c = _utilJs.splitter * ax;
        bhi = c - (c - ax);
        blo = ax - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        a[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        a[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        a[2] = _j - (u3 - bvirt) + (_i - bvirt);
        a[3] = u3;
        s1 = ytail * bx;
        c = _utilJs.splitter * ytail;
        ahi = c - (c - ytail);
        alo = ytail - ahi;
        c = _utilJs.splitter * bx;
        bhi = c - (c - bx);
        blo = bx - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = xtail * by;
        c = _utilJs.splitter * xtail;
        ahi = c - (c - xtail);
        alo = xtail - ahi;
        c = _utilJs.splitter * by;
        bhi = c - (c - by);
        blo = by - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        b[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        b[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        b[2] = _j - (u3 - bvirt) + (_i - bvirt);
        b[3] = u3;
        return 4;
    }
}
function tailadd(finlen, a, b, k, z) {
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, u3;
    s1 = a * b;
    c = _utilJs.splitter * a;
    ahi = c - (c - a);
    alo = a - ahi;
    c = _utilJs.splitter * b;
    bhi = c - (c - b);
    blo = b - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    c = _utilJs.splitter * k;
    bhi = c - (c - k);
    blo = k - bhi;
    _i = s0 * k;
    c = _utilJs.splitter * s0;
    ahi = c - (c - s0);
    alo = s0 - ahi;
    u[0] = alo * blo - (_i - ahi * bhi - alo * bhi - ahi * blo);
    _j = s1 * k;
    c = _utilJs.splitter * s1;
    ahi = c - (c - s1);
    alo = s1 - ahi;
    _0 = alo * blo - (_j - ahi * bhi - alo * bhi - ahi * blo);
    _k = _i + _0;
    bvirt = _k - _i;
    u[1] = _i - (_k - bvirt) + (_0 - bvirt);
    u3 = _j + _k;
    u[2] = _k - (u3 - _j);
    u[3] = u3;
    finlen = finadd(finlen, 4, u);
    if (z !== 0) {
        c = _utilJs.splitter * z;
        bhi = c - (c - z);
        blo = z - bhi;
        _i = s0 * z;
        c = _utilJs.splitter * s0;
        ahi = c - (c - s0);
        alo = s0 - ahi;
        u[0] = alo * blo - (_i - ahi * bhi - alo * bhi - ahi * blo);
        _j = s1 * z;
        c = _utilJs.splitter * s1;
        ahi = c - (c - s1);
        alo = s1 - ahi;
        _0 = alo * blo - (_j - ahi * bhi - alo * bhi - ahi * blo);
        _k = _i + _0;
        bvirt = _k - _i;
        u[1] = _i - (_k - bvirt) + (_0 - bvirt);
        u3 = _j + _k;
        u[2] = _k - (u3 - _j);
        u[3] = u3;
        finlen = finadd(finlen, 4, u);
    }
    return finlen;
}
function orient3dadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, permanent) {
    let finlen;
    let adxtail, bdxtail, cdxtail;
    let adytail, bdytail, cdytail;
    let adztail, bdztail, cdztail;
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, t1, t0, u3;
    const adx = ax - dx;
    const bdx = bx - dx;
    const cdx = cx - dx;
    const ady = ay - dy;
    const bdy = by - dy;
    const cdy = cy - dy;
    const adz = az - dz;
    const bdz = bz - dz;
    const cdz = cz - dz;
    s1 = bdx * cdy;
    c = _utilJs.splitter * bdx;
    ahi = c - (c - bdx);
    alo = bdx - ahi;
    c = _utilJs.splitter * cdy;
    bhi = c - (c - cdy);
    blo = cdy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = cdx * bdy;
    c = _utilJs.splitter * cdx;
    ahi = c - (c - cdx);
    alo = cdx - ahi;
    c = _utilJs.splitter * bdy;
    bhi = c - (c - bdy);
    blo = bdy - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    bc[2] = _j - (u3 - bvirt) + (_i - bvirt);
    bc[3] = u3;
    s1 = cdx * ady;
    c = _utilJs.splitter * cdx;
    ahi = c - (c - cdx);
    alo = cdx - ahi;
    c = _utilJs.splitter * ady;
    bhi = c - (c - ady);
    blo = ady - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = adx * cdy;
    c = _utilJs.splitter * adx;
    ahi = c - (c - adx);
    alo = adx - ahi;
    c = _utilJs.splitter * cdy;
    bhi = c - (c - cdy);
    blo = cdy - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ca[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ca[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    ca[2] = _j - (u3 - bvirt) + (_i - bvirt);
    ca[3] = u3;
    s1 = adx * bdy;
    c = _utilJs.splitter * adx;
    ahi = c - (c - adx);
    alo = adx - ahi;
    c = _utilJs.splitter * bdy;
    bhi = c - (c - bdy);
    blo = bdy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = bdx * ady;
    c = _utilJs.splitter * bdx;
    ahi = c - (c - bdx);
    alo = bdx - ahi;
    c = _utilJs.splitter * ady;
    bhi = c - (c - ady);
    blo = ady - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    ab[2] = _j - (u3 - bvirt) + (_i - bvirt);
    ab[3] = u3;
    finlen = _utilJs.sum(_utilJs.sum(_utilJs.scale(4, bc, adz, _8), _8, _utilJs.scale(4, ca, bdz, _8b), _8b, _16), _16, _utilJs.scale(4, ab, cdz, _8), _8, fin);
    let det = _utilJs.estimate(finlen, fin);
    let errbound = o3derrboundB * permanent;
    if (det >= errbound || -det >= errbound) return det;
    bvirt = ax - adx;
    adxtail = ax - (adx + bvirt) + (bvirt - dx);
    bvirt = bx - bdx;
    bdxtail = bx - (bdx + bvirt) + (bvirt - dx);
    bvirt = cx - cdx;
    cdxtail = cx - (cdx + bvirt) + (bvirt - dx);
    bvirt = ay - ady;
    adytail = ay - (ady + bvirt) + (bvirt - dy);
    bvirt = by - bdy;
    bdytail = by - (bdy + bvirt) + (bvirt - dy);
    bvirt = cy - cdy;
    cdytail = cy - (cdy + bvirt) + (bvirt - dy);
    bvirt = az - adz;
    adztail = az - (adz + bvirt) + (bvirt - dz);
    bvirt = bz - bdz;
    bdztail = bz - (bdz + bvirt) + (bvirt - dz);
    bvirt = cz - cdz;
    cdztail = cz - (cdz + bvirt) + (bvirt - dz);
    if (adxtail === 0 && bdxtail === 0 && cdxtail === 0 && adytail === 0 && bdytail === 0 && cdytail === 0 && adztail === 0 && bdztail === 0 && cdztail === 0) return det;
    errbound = o3derrboundC * permanent + _utilJs.resulterrbound * Math.abs(det);
    det += adz * (bdx * cdytail + cdy * bdxtail - (bdy * cdxtail + cdx * bdytail)) + adztail * (bdx * cdy - bdy * cdx) + bdz * (cdx * adytail + ady * cdxtail - (cdy * adxtail + adx * cdytail)) + bdztail * (cdx * ady - cdy * adx) + cdz * (adx * bdytail + bdy * adxtail - (ady * bdxtail + bdx * adytail)) + cdztail * (adx * bdy - ady * bdx);
    if (det >= errbound || -det >= errbound) return det;
    const at_len = tailinit(adxtail, adytail, bdx, bdy, cdx, cdy, at_b, at_c);
    const bt_len = tailinit(bdxtail, bdytail, cdx, cdy, adx, ady, bt_c, bt_a);
    const ct_len = tailinit(cdxtail, cdytail, adx, ady, bdx, bdy, ct_a, ct_b);
    const bctlen = _utilJs.sum(bt_len, bt_c, ct_len, ct_b, bct);
    finlen = finadd(finlen, _utilJs.scale(bctlen, bct, adz, _16), _16);
    const catlen = _utilJs.sum(ct_len, ct_a, at_len, at_c, cat);
    finlen = finadd(finlen, _utilJs.scale(catlen, cat, bdz, _16), _16);
    const abtlen = _utilJs.sum(at_len, at_b, bt_len, bt_a, abt);
    finlen = finadd(finlen, _utilJs.scale(abtlen, abt, cdz, _16), _16);
    if (adztail !== 0) {
        finlen = finadd(finlen, _utilJs.scale(4, bc, adztail, _12), _12);
        finlen = finadd(finlen, _utilJs.scale(bctlen, bct, adztail, _16), _16);
    }
    if (bdztail !== 0) {
        finlen = finadd(finlen, _utilJs.scale(4, ca, bdztail, _12), _12);
        finlen = finadd(finlen, _utilJs.scale(catlen, cat, bdztail, _16), _16);
    }
    if (cdztail !== 0) {
        finlen = finadd(finlen, _utilJs.scale(4, ab, cdztail, _12), _12);
        finlen = finadd(finlen, _utilJs.scale(abtlen, abt, cdztail, _16), _16);
    }
    if (adxtail !== 0) {
        if (bdytail !== 0) finlen = tailadd(finlen, adxtail, bdytail, cdz, cdztail);
        if (cdytail !== 0) finlen = tailadd(finlen, -adxtail, cdytail, bdz, bdztail);
    }
    if (bdxtail !== 0) {
        if (cdytail !== 0) finlen = tailadd(finlen, bdxtail, cdytail, adz, adztail);
        if (adytail !== 0) finlen = tailadd(finlen, -bdxtail, adytail, cdz, cdztail);
    }
    if (cdxtail !== 0) {
        if (adytail !== 0) finlen = tailadd(finlen, cdxtail, adytail, bdz, bdztail);
        if (bdytail !== 0) finlen = tailadd(finlen, -cdxtail, bdytail, adz, adztail);
    }
    return fin[finlen - 1];
}
function orient3d(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz) {
    const adx = ax - dx;
    const bdx = bx - dx;
    const cdx = cx - dx;
    const ady = ay - dy;
    const bdy = by - dy;
    const cdy = cy - dy;
    const adz = az - dz;
    const bdz = bz - dz;
    const cdz = cz - dz;
    const bdxcdy = bdx * cdy;
    const cdxbdy = cdx * bdy;
    const cdxady = cdx * ady;
    const adxcdy = adx * cdy;
    const adxbdy = adx * bdy;
    const bdxady = bdx * ady;
    const det = adz * (bdxcdy - cdxbdy) + bdz * (cdxady - adxcdy) + cdz * (adxbdy - bdxady);
    const permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz) + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz) + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz);
    const errbound = o3derrboundA * permanent;
    if (det > errbound || -det > errbound) return det;
    return orient3dadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, permanent);
}
function orient3dfast(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz) {
    const adx = ax - dx;
    const bdx = bx - dx;
    const cdx = cx - dx;
    const ady = ay - dy;
    const bdy = by - dy;
    const cdy = cy - dy;
    const adz = az - dz;
    const bdz = bz - dz;
    const cdz = cz - dz;
    return adx * (bdy * cdz - bdz * cdy) + bdx * (cdy * adz - cdz * ady) + cdx * (ady * bdz - adz * bdy);
}

},{"./util.js":"3OxkP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6yBsv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "incircle", ()=>incircle
);
parcelHelpers.export(exports, "incirclefast", ()=>incirclefast
);
var _utilJs = require("./util.js");
const iccerrboundA = (10 + 96 * _utilJs.epsilon) * _utilJs.epsilon;
const iccerrboundB = (4 + 48 * _utilJs.epsilon) * _utilJs.epsilon;
const iccerrboundC = (44 + 576 * _utilJs.epsilon) * _utilJs.epsilon * _utilJs.epsilon;
const bc = _utilJs.vec(4);
const ca = _utilJs.vec(4);
const ab = _utilJs.vec(4);
const aa = _utilJs.vec(4);
const bb = _utilJs.vec(4);
const cc = _utilJs.vec(4);
const u = _utilJs.vec(4);
const v = _utilJs.vec(4);
const axtbc = _utilJs.vec(8);
const aytbc = _utilJs.vec(8);
const bxtca = _utilJs.vec(8);
const bytca = _utilJs.vec(8);
const cxtab = _utilJs.vec(8);
const cytab = _utilJs.vec(8);
const abt = _utilJs.vec(8);
const bct = _utilJs.vec(8);
const cat = _utilJs.vec(8);
const abtt = _utilJs.vec(4);
const bctt = _utilJs.vec(4);
const catt = _utilJs.vec(4);
const _8 = _utilJs.vec(8);
const _16 = _utilJs.vec(16);
const _16b = _utilJs.vec(16);
const _16c = _utilJs.vec(16);
const _32 = _utilJs.vec(32);
const _32b = _utilJs.vec(32);
const _48 = _utilJs.vec(48);
const _64 = _utilJs.vec(64);
let fin = _utilJs.vec(1152);
let fin2 = _utilJs.vec(1152);
function finadd(finlen, a, alen) {
    finlen = _utilJs.sum(finlen, fin, a, alen, fin2);
    const tmp = fin;
    fin = fin2;
    fin2 = tmp;
    return finlen;
}
function incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent) {
    let finlen;
    let adxtail, bdxtail, cdxtail, adytail, bdytail, cdytail;
    let axtbclen, aytbclen, bxtcalen, bytcalen, cxtablen, cytablen;
    let abtlen, bctlen, catlen;
    let abttlen, bcttlen, cattlen;
    let n1, n0;
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;
    const adx = ax - dx;
    const bdx = bx - dx;
    const cdx = cx - dx;
    const ady = ay - dy;
    const bdy = by - dy;
    const cdy = cy - dy;
    s1 = bdx * cdy;
    c = _utilJs.splitter * bdx;
    ahi = c - (c - bdx);
    alo = bdx - ahi;
    c = _utilJs.splitter * cdy;
    bhi = c - (c - cdy);
    blo = cdy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = cdx * bdy;
    c = _utilJs.splitter * cdx;
    ahi = c - (c - cdx);
    alo = cdx - ahi;
    c = _utilJs.splitter * bdy;
    bhi = c - (c - bdy);
    blo = bdy - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    bc[2] = _j - (u3 - bvirt) + (_i - bvirt);
    bc[3] = u3;
    s1 = cdx * ady;
    c = _utilJs.splitter * cdx;
    ahi = c - (c - cdx);
    alo = cdx - ahi;
    c = _utilJs.splitter * ady;
    bhi = c - (c - ady);
    blo = ady - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = adx * cdy;
    c = _utilJs.splitter * adx;
    ahi = c - (c - adx);
    alo = adx - ahi;
    c = _utilJs.splitter * cdy;
    bhi = c - (c - cdy);
    blo = cdy - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ca[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ca[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    ca[2] = _j - (u3 - bvirt) + (_i - bvirt);
    ca[3] = u3;
    s1 = adx * bdy;
    c = _utilJs.splitter * adx;
    ahi = c - (c - adx);
    alo = adx - ahi;
    c = _utilJs.splitter * bdy;
    bhi = c - (c - bdy);
    blo = bdy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = bdx * ady;
    c = _utilJs.splitter * bdx;
    ahi = c - (c - bdx);
    alo = bdx - ahi;
    c = _utilJs.splitter * ady;
    bhi = c - (c - ady);
    blo = ady - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    ab[2] = _j - (u3 - bvirt) + (_i - bvirt);
    ab[3] = u3;
    finlen = _utilJs.sum(_utilJs.sum(_utilJs.sum(_utilJs.scale(_utilJs.scale(4, bc, adx, _8), _8, adx, _16), _16, _utilJs.scale(_utilJs.scale(4, bc, ady, _8), _8, ady, _16b), _16b, _32), _32, _utilJs.sum(_utilJs.scale(_utilJs.scale(4, ca, bdx, _8), _8, bdx, _16), _16, _utilJs.scale(_utilJs.scale(4, ca, bdy, _8), _8, bdy, _16b), _16b, _32b), _32b, _64), _64, _utilJs.sum(_utilJs.scale(_utilJs.scale(4, ab, cdx, _8), _8, cdx, _16), _16, _utilJs.scale(_utilJs.scale(4, ab, cdy, _8), _8, cdy, _16b), _16b, _32), _32, fin);
    let det = _utilJs.estimate(finlen, fin);
    let errbound = iccerrboundB * permanent;
    if (det >= errbound || -det >= errbound) return det;
    bvirt = ax - adx;
    adxtail = ax - (adx + bvirt) + (bvirt - dx);
    bvirt = ay - ady;
    adytail = ay - (ady + bvirt) + (bvirt - dy);
    bvirt = bx - bdx;
    bdxtail = bx - (bdx + bvirt) + (bvirt - dx);
    bvirt = by - bdy;
    bdytail = by - (bdy + bvirt) + (bvirt - dy);
    bvirt = cx - cdx;
    cdxtail = cx - (cdx + bvirt) + (bvirt - dx);
    bvirt = cy - cdy;
    cdytail = cy - (cdy + bvirt) + (bvirt - dy);
    if (adxtail === 0 && bdxtail === 0 && cdxtail === 0 && adytail === 0 && bdytail === 0 && cdytail === 0) return det;
    errbound = iccerrboundC * permanent + _utilJs.resulterrbound * Math.abs(det);
    det += (adx * adx + ady * ady) * (bdx * cdytail + cdy * bdxtail - (bdy * cdxtail + cdx * bdytail)) + 2 * (adx * adxtail + ady * adytail) * (bdx * cdy - bdy * cdx) + ((bdx * bdx + bdy * bdy) * (cdx * adytail + ady * cdxtail - (cdy * adxtail + adx * cdytail)) + 2 * (bdx * bdxtail + bdy * bdytail) * (cdx * ady - cdy * adx)) + ((cdx * cdx + cdy * cdy) * (adx * bdytail + bdy * adxtail - (ady * bdxtail + bdx * adytail)) + 2 * (cdx * cdxtail + cdy * cdytail) * (adx * bdy - ady * bdx));
    if (det >= errbound || -det >= errbound) return det;
    if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {
        s1 = adx * adx;
        c = _utilJs.splitter * adx;
        ahi = c - (c - adx);
        alo = adx - ahi;
        s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
        t1 = ady * ady;
        c = _utilJs.splitter * ady;
        ahi = c - (c - ady);
        alo = ady - ahi;
        t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
        _i = s0 + t0;
        bvirt = _i - s0;
        aa[0] = s0 - (_i - bvirt) + (t0 - bvirt);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 + t1;
        bvirt = _i - _0;
        aa[1] = _0 - (_i - bvirt) + (t1 - bvirt);
        u3 = _j + _i;
        bvirt = u3 - _j;
        aa[2] = _j - (u3 - bvirt) + (_i - bvirt);
        aa[3] = u3;
    }
    if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {
        s1 = bdx * bdx;
        c = _utilJs.splitter * bdx;
        ahi = c - (c - bdx);
        alo = bdx - ahi;
        s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
        t1 = bdy * bdy;
        c = _utilJs.splitter * bdy;
        ahi = c - (c - bdy);
        alo = bdy - ahi;
        t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
        _i = s0 + t0;
        bvirt = _i - s0;
        bb[0] = s0 - (_i - bvirt) + (t0 - bvirt);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 + t1;
        bvirt = _i - _0;
        bb[1] = _0 - (_i - bvirt) + (t1 - bvirt);
        u3 = _j + _i;
        bvirt = u3 - _j;
        bb[2] = _j - (u3 - bvirt) + (_i - bvirt);
        bb[3] = u3;
    }
    if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {
        s1 = cdx * cdx;
        c = _utilJs.splitter * cdx;
        ahi = c - (c - cdx);
        alo = cdx - ahi;
        s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
        t1 = cdy * cdy;
        c = _utilJs.splitter * cdy;
        ahi = c - (c - cdy);
        alo = cdy - ahi;
        t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
        _i = s0 + t0;
        bvirt = _i - s0;
        cc[0] = s0 - (_i - bvirt) + (t0 - bvirt);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 + t1;
        bvirt = _i - _0;
        cc[1] = _0 - (_i - bvirt) + (t1 - bvirt);
        u3 = _j + _i;
        bvirt = u3 - _j;
        cc[2] = _j - (u3 - bvirt) + (_i - bvirt);
        cc[3] = u3;
    }
    if (adxtail !== 0) {
        axtbclen = _utilJs.scale(4, bc, adxtail, axtbc);
        finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(axtbclen, axtbc, 2 * adx, _16), _16, _utilJs.scale(_utilJs.scale(4, cc, adxtail, _8), _8, bdy, _16b), _16b, _utilJs.scale(_utilJs.scale(4, bb, adxtail, _8), _8, -cdy, _16c), _16c, _32, _48), _48);
    }
    if (adytail !== 0) {
        aytbclen = _utilJs.scale(4, bc, adytail, aytbc);
        finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(aytbclen, aytbc, 2 * ady, _16), _16, _utilJs.scale(_utilJs.scale(4, bb, adytail, _8), _8, cdx, _16b), _16b, _utilJs.scale(_utilJs.scale(4, cc, adytail, _8), _8, -bdx, _16c), _16c, _32, _48), _48);
    }
    if (bdxtail !== 0) {
        bxtcalen = _utilJs.scale(4, ca, bdxtail, bxtca);
        finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(bxtcalen, bxtca, 2 * bdx, _16), _16, _utilJs.scale(_utilJs.scale(4, aa, bdxtail, _8), _8, cdy, _16b), _16b, _utilJs.scale(_utilJs.scale(4, cc, bdxtail, _8), _8, -ady, _16c), _16c, _32, _48), _48);
    }
    if (bdytail !== 0) {
        bytcalen = _utilJs.scale(4, ca, bdytail, bytca);
        finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(bytcalen, bytca, 2 * bdy, _16), _16, _utilJs.scale(_utilJs.scale(4, cc, bdytail, _8), _8, adx, _16b), _16b, _utilJs.scale(_utilJs.scale(4, aa, bdytail, _8), _8, -cdx, _16c), _16c, _32, _48), _48);
    }
    if (cdxtail !== 0) {
        cxtablen = _utilJs.scale(4, ab, cdxtail, cxtab);
        finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(cxtablen, cxtab, 2 * cdx, _16), _16, _utilJs.scale(_utilJs.scale(4, bb, cdxtail, _8), _8, ady, _16b), _16b, _utilJs.scale(_utilJs.scale(4, aa, cdxtail, _8), _8, -bdy, _16c), _16c, _32, _48), _48);
    }
    if (cdytail !== 0) {
        cytablen = _utilJs.scale(4, ab, cdytail, cytab);
        finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(cytablen, cytab, 2 * cdy, _16), _16, _utilJs.scale(_utilJs.scale(4, aa, cdytail, _8), _8, bdx, _16b), _16b, _utilJs.scale(_utilJs.scale(4, bb, cdytail, _8), _8, -adx, _16c), _16c, _32, _48), _48);
    }
    if (adxtail !== 0 || adytail !== 0) {
        if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {
            s1 = bdxtail * cdy;
            c = _utilJs.splitter * bdxtail;
            ahi = c - (c - bdxtail);
            alo = bdxtail - ahi;
            c = _utilJs.splitter * cdy;
            bhi = c - (c - cdy);
            blo = cdy - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = bdx * cdytail;
            c = _utilJs.splitter * bdx;
            ahi = c - (c - bdx);
            alo = bdx - ahi;
            c = _utilJs.splitter * cdytail;
            bhi = c - (c - cdytail);
            blo = cdytail - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 + t0;
            bvirt = _i - s0;
            u[0] = s0 - (_i - bvirt) + (t0 - bvirt);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 + t1;
            bvirt = _i - _0;
            u[1] = _0 - (_i - bvirt) + (t1 - bvirt);
            u3 = _j + _i;
            bvirt = u3 - _j;
            u[2] = _j - (u3 - bvirt) + (_i - bvirt);
            u[3] = u3;
            s1 = cdxtail * -bdy;
            c = _utilJs.splitter * cdxtail;
            ahi = c - (c - cdxtail);
            alo = cdxtail - ahi;
            c = _utilJs.splitter * -bdy;
            bhi = c - (c - -bdy);
            blo = -bdy - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = cdx * -bdytail;
            c = _utilJs.splitter * cdx;
            ahi = c - (c - cdx);
            alo = cdx - ahi;
            c = _utilJs.splitter * -bdytail;
            bhi = c - (c - -bdytail);
            blo = -bdytail - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 + t0;
            bvirt = _i - s0;
            v[0] = s0 - (_i - bvirt) + (t0 - bvirt);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 + t1;
            bvirt = _i - _0;
            v[1] = _0 - (_i - bvirt) + (t1 - bvirt);
            u3 = _j + _i;
            bvirt = u3 - _j;
            v[2] = _j - (u3 - bvirt) + (_i - bvirt);
            v[3] = u3;
            bctlen = _utilJs.sum(4, u, 4, v, bct);
            s1 = bdxtail * cdytail;
            c = _utilJs.splitter * bdxtail;
            ahi = c - (c - bdxtail);
            alo = bdxtail - ahi;
            c = _utilJs.splitter * cdytail;
            bhi = c - (c - cdytail);
            blo = cdytail - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = cdxtail * bdytail;
            c = _utilJs.splitter * cdxtail;
            ahi = c - (c - cdxtail);
            alo = cdxtail - ahi;
            c = _utilJs.splitter * bdytail;
            bhi = c - (c - bdytail);
            blo = bdytail - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 - t0;
            bvirt = s0 - _i;
            bctt[0] = s0 - (_i + bvirt) + (bvirt - t0);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 - t1;
            bvirt = _0 - _i;
            bctt[1] = _0 - (_i + bvirt) + (bvirt - t1);
            u3 = _j + _i;
            bvirt = u3 - _j;
            bctt[2] = _j - (u3 - bvirt) + (_i - bvirt);
            bctt[3] = u3;
            bcttlen = 4;
        } else {
            bct[0] = 0;
            bctlen = 1;
            bctt[0] = 0;
            bcttlen = 1;
        }
        if (adxtail !== 0) {
            const len = _utilJs.scale(bctlen, bct, adxtail, _16c);
            finlen = finadd(finlen, _utilJs.sum(_utilJs.scale(axtbclen, axtbc, adxtail, _16), _16, _utilJs.scale(len, _16c, 2 * adx, _32), _32, _48), _48);
            const len2 = _utilJs.scale(bcttlen, bctt, adxtail, _8);
            finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(len2, _8, 2 * adx, _16), _16, _utilJs.scale(len2, _8, adxtail, _16b), _16b, _utilJs.scale(len, _16c, adxtail, _32), _32, _32b, _64), _64);
            if (bdytail !== 0) finlen = finadd(finlen, _utilJs.scale(_utilJs.scale(4, cc, adxtail, _8), _8, bdytail, _16), _16);
            if (cdytail !== 0) finlen = finadd(finlen, _utilJs.scale(_utilJs.scale(4, bb, -adxtail, _8), _8, cdytail, _16), _16);
        }
        if (adytail !== 0) {
            const len = _utilJs.scale(bctlen, bct, adytail, _16c);
            finlen = finadd(finlen, _utilJs.sum(_utilJs.scale(aytbclen, aytbc, adytail, _16), _16, _utilJs.scale(len, _16c, 2 * ady, _32), _32, _48), _48);
            const len2 = _utilJs.scale(bcttlen, bctt, adytail, _8);
            finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(len2, _8, 2 * ady, _16), _16, _utilJs.scale(len2, _8, adytail, _16b), _16b, _utilJs.scale(len, _16c, adytail, _32), _32, _32b, _64), _64);
        }
    }
    if (bdxtail !== 0 || bdytail !== 0) {
        if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {
            s1 = cdxtail * ady;
            c = _utilJs.splitter * cdxtail;
            ahi = c - (c - cdxtail);
            alo = cdxtail - ahi;
            c = _utilJs.splitter * ady;
            bhi = c - (c - ady);
            blo = ady - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = cdx * adytail;
            c = _utilJs.splitter * cdx;
            ahi = c - (c - cdx);
            alo = cdx - ahi;
            c = _utilJs.splitter * adytail;
            bhi = c - (c - adytail);
            blo = adytail - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 + t0;
            bvirt = _i - s0;
            u[0] = s0 - (_i - bvirt) + (t0 - bvirt);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 + t1;
            bvirt = _i - _0;
            u[1] = _0 - (_i - bvirt) + (t1 - bvirt);
            u3 = _j + _i;
            bvirt = u3 - _j;
            u[2] = _j - (u3 - bvirt) + (_i - bvirt);
            u[3] = u3;
            n1 = -cdy;
            n0 = -cdytail;
            s1 = adxtail * n1;
            c = _utilJs.splitter * adxtail;
            ahi = c - (c - adxtail);
            alo = adxtail - ahi;
            c = _utilJs.splitter * n1;
            bhi = c - (c - n1);
            blo = n1 - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = adx * n0;
            c = _utilJs.splitter * adx;
            ahi = c - (c - adx);
            alo = adx - ahi;
            c = _utilJs.splitter * n0;
            bhi = c - (c - n0);
            blo = n0 - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 + t0;
            bvirt = _i - s0;
            v[0] = s0 - (_i - bvirt) + (t0 - bvirt);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 + t1;
            bvirt = _i - _0;
            v[1] = _0 - (_i - bvirt) + (t1 - bvirt);
            u3 = _j + _i;
            bvirt = u3 - _j;
            v[2] = _j - (u3 - bvirt) + (_i - bvirt);
            v[3] = u3;
            catlen = _utilJs.sum(4, u, 4, v, cat);
            s1 = cdxtail * adytail;
            c = _utilJs.splitter * cdxtail;
            ahi = c - (c - cdxtail);
            alo = cdxtail - ahi;
            c = _utilJs.splitter * adytail;
            bhi = c - (c - adytail);
            blo = adytail - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = adxtail * cdytail;
            c = _utilJs.splitter * adxtail;
            ahi = c - (c - adxtail);
            alo = adxtail - ahi;
            c = _utilJs.splitter * cdytail;
            bhi = c - (c - cdytail);
            blo = cdytail - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 - t0;
            bvirt = s0 - _i;
            catt[0] = s0 - (_i + bvirt) + (bvirt - t0);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 - t1;
            bvirt = _0 - _i;
            catt[1] = _0 - (_i + bvirt) + (bvirt - t1);
            u3 = _j + _i;
            bvirt = u3 - _j;
            catt[2] = _j - (u3 - bvirt) + (_i - bvirt);
            catt[3] = u3;
            cattlen = 4;
        } else {
            cat[0] = 0;
            catlen = 1;
            catt[0] = 0;
            cattlen = 1;
        }
        if (bdxtail !== 0) {
            const len = _utilJs.scale(catlen, cat, bdxtail, _16c);
            finlen = finadd(finlen, _utilJs.sum(_utilJs.scale(bxtcalen, bxtca, bdxtail, _16), _16, _utilJs.scale(len, _16c, 2 * bdx, _32), _32, _48), _48);
            const len2 = _utilJs.scale(cattlen, catt, bdxtail, _8);
            finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(len2, _8, 2 * bdx, _16), _16, _utilJs.scale(len2, _8, bdxtail, _16b), _16b, _utilJs.scale(len, _16c, bdxtail, _32), _32, _32b, _64), _64);
            if (cdytail !== 0) finlen = finadd(finlen, _utilJs.scale(_utilJs.scale(4, aa, bdxtail, _8), _8, cdytail, _16), _16);
            if (adytail !== 0) finlen = finadd(finlen, _utilJs.scale(_utilJs.scale(4, cc, -bdxtail, _8), _8, adytail, _16), _16);
        }
        if (bdytail !== 0) {
            const len = _utilJs.scale(catlen, cat, bdytail, _16c);
            finlen = finadd(finlen, _utilJs.sum(_utilJs.scale(bytcalen, bytca, bdytail, _16), _16, _utilJs.scale(len, _16c, 2 * bdy, _32), _32, _48), _48);
            const len2 = _utilJs.scale(cattlen, catt, bdytail, _8);
            finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(len2, _8, 2 * bdy, _16), _16, _utilJs.scale(len2, _8, bdytail, _16b), _16b, _utilJs.scale(len, _16c, bdytail, _32), _32, _32b, _64), _64);
        }
    }
    if (cdxtail !== 0 || cdytail !== 0) {
        if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {
            s1 = adxtail * bdy;
            c = _utilJs.splitter * adxtail;
            ahi = c - (c - adxtail);
            alo = adxtail - ahi;
            c = _utilJs.splitter * bdy;
            bhi = c - (c - bdy);
            blo = bdy - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = adx * bdytail;
            c = _utilJs.splitter * adx;
            ahi = c - (c - adx);
            alo = adx - ahi;
            c = _utilJs.splitter * bdytail;
            bhi = c - (c - bdytail);
            blo = bdytail - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 + t0;
            bvirt = _i - s0;
            u[0] = s0 - (_i - bvirt) + (t0 - bvirt);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 + t1;
            bvirt = _i - _0;
            u[1] = _0 - (_i - bvirt) + (t1 - bvirt);
            u3 = _j + _i;
            bvirt = u3 - _j;
            u[2] = _j - (u3 - bvirt) + (_i - bvirt);
            u[3] = u3;
            n1 = -ady;
            n0 = -adytail;
            s1 = bdxtail * n1;
            c = _utilJs.splitter * bdxtail;
            ahi = c - (c - bdxtail);
            alo = bdxtail - ahi;
            c = _utilJs.splitter * n1;
            bhi = c - (c - n1);
            blo = n1 - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = bdx * n0;
            c = _utilJs.splitter * bdx;
            ahi = c - (c - bdx);
            alo = bdx - ahi;
            c = _utilJs.splitter * n0;
            bhi = c - (c - n0);
            blo = n0 - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 + t0;
            bvirt = _i - s0;
            v[0] = s0 - (_i - bvirt) + (t0 - bvirt);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 + t1;
            bvirt = _i - _0;
            v[1] = _0 - (_i - bvirt) + (t1 - bvirt);
            u3 = _j + _i;
            bvirt = u3 - _j;
            v[2] = _j - (u3 - bvirt) + (_i - bvirt);
            v[3] = u3;
            abtlen = _utilJs.sum(4, u, 4, v, abt);
            s1 = adxtail * bdytail;
            c = _utilJs.splitter * adxtail;
            ahi = c - (c - adxtail);
            alo = adxtail - ahi;
            c = _utilJs.splitter * bdytail;
            bhi = c - (c - bdytail);
            blo = bdytail - bhi;
            s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
            t1 = bdxtail * adytail;
            c = _utilJs.splitter * bdxtail;
            ahi = c - (c - bdxtail);
            alo = bdxtail - ahi;
            c = _utilJs.splitter * adytail;
            bhi = c - (c - adytail);
            blo = adytail - bhi;
            t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
            _i = s0 - t0;
            bvirt = s0 - _i;
            abtt[0] = s0 - (_i + bvirt) + (bvirt - t0);
            _j = s1 + _i;
            bvirt = _j - s1;
            _0 = s1 - (_j - bvirt) + (_i - bvirt);
            _i = _0 - t1;
            bvirt = _0 - _i;
            abtt[1] = _0 - (_i + bvirt) + (bvirt - t1);
            u3 = _j + _i;
            bvirt = u3 - _j;
            abtt[2] = _j - (u3 - bvirt) + (_i - bvirt);
            abtt[3] = u3;
            abttlen = 4;
        } else {
            abt[0] = 0;
            abtlen = 1;
            abtt[0] = 0;
            abttlen = 1;
        }
        if (cdxtail !== 0) {
            const len = _utilJs.scale(abtlen, abt, cdxtail, _16c);
            finlen = finadd(finlen, _utilJs.sum(_utilJs.scale(cxtablen, cxtab, cdxtail, _16), _16, _utilJs.scale(len, _16c, 2 * cdx, _32), _32, _48), _48);
            const len2 = _utilJs.scale(abttlen, abtt, cdxtail, _8);
            finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(len2, _8, 2 * cdx, _16), _16, _utilJs.scale(len2, _8, cdxtail, _16b), _16b, _utilJs.scale(len, _16c, cdxtail, _32), _32, _32b, _64), _64);
            if (adytail !== 0) finlen = finadd(finlen, _utilJs.scale(_utilJs.scale(4, bb, cdxtail, _8), _8, adytail, _16), _16);
            if (bdytail !== 0) finlen = finadd(finlen, _utilJs.scale(_utilJs.scale(4, aa, -cdxtail, _8), _8, bdytail, _16), _16);
        }
        if (cdytail !== 0) {
            const len = _utilJs.scale(abtlen, abt, cdytail, _16c);
            finlen = finadd(finlen, _utilJs.sum(_utilJs.scale(cytablen, cytab, cdytail, _16), _16, _utilJs.scale(len, _16c, 2 * cdy, _32), _32, _48), _48);
            const len2 = _utilJs.scale(abttlen, abtt, cdytail, _8);
            finlen = finadd(finlen, _utilJs.sum_three(_utilJs.scale(len2, _8, 2 * cdy, _16), _16, _utilJs.scale(len2, _8, cdytail, _16b), _16b, _utilJs.scale(len, _16c, cdytail, _32), _32, _32b, _64), _64);
        }
    }
    return fin[finlen - 1];
}
function incircle(ax, ay, bx, by, cx, cy, dx, dy) {
    const adx = ax - dx;
    const bdx = bx - dx;
    const cdx = cx - dx;
    const ady = ay - dy;
    const bdy = by - dy;
    const cdy = cy - dy;
    const bdxcdy = bdx * cdy;
    const cdxbdy = cdx * bdy;
    const alift = adx * adx + ady * ady;
    const cdxady = cdx * ady;
    const adxcdy = adx * cdy;
    const blift = bdx * bdx + bdy * bdy;
    const adxbdy = adx * bdy;
    const bdxady = bdx * ady;
    const clift = cdx * cdx + cdy * cdy;
    const det = alift * (bdxcdy - cdxbdy) + blift * (cdxady - adxcdy) + clift * (adxbdy - bdxady);
    const permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * alift + (Math.abs(cdxady) + Math.abs(adxcdy)) * blift + (Math.abs(adxbdy) + Math.abs(bdxady)) * clift;
    const errbound = iccerrboundA * permanent;
    if (det > errbound || -det > errbound) return det;
    return incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent);
}
function incirclefast(ax, ay, bx, by, cx, cy, dx, dy) {
    const adx = ax - dx;
    const ady = ay - dy;
    const bdx = bx - dx;
    const bdy = by - dy;
    const cdx = cx - dx;
    const cdy = cy - dy;
    const abdet = adx * bdy - bdx * ady;
    const bcdet = bdx * cdy - cdx * bdy;
    const cadet = cdx * ady - adx * cdy;
    const alift = adx * adx + ady * ady;
    const blift = bdx * bdx + bdy * bdy;
    const clift = cdx * cdx + cdy * cdy;
    return alift * bcdet + blift * cadet + clift * abdet;
}

},{"./util.js":"3OxkP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6qjhA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "insphere", ()=>insphere
);
parcelHelpers.export(exports, "inspherefast", ()=>inspherefast
);
var _utilJs = require("./util.js");
const isperrboundA = (16 + 224 * _utilJs.epsilon) * _utilJs.epsilon;
const isperrboundB = (5 + 72 * _utilJs.epsilon) * _utilJs.epsilon;
const isperrboundC = (71 + 1408 * _utilJs.epsilon) * _utilJs.epsilon * _utilJs.epsilon;
const ab = _utilJs.vec(4);
const bc = _utilJs.vec(4);
const cd = _utilJs.vec(4);
const de = _utilJs.vec(4);
const ea = _utilJs.vec(4);
const ac = _utilJs.vec(4);
const bd = _utilJs.vec(4);
const ce = _utilJs.vec(4);
const da = _utilJs.vec(4);
const eb = _utilJs.vec(4);
const abc = _utilJs.vec(24);
const bcd = _utilJs.vec(24);
const cde = _utilJs.vec(24);
const dea = _utilJs.vec(24);
const eab = _utilJs.vec(24);
const abd = _utilJs.vec(24);
const bce = _utilJs.vec(24);
const cda = _utilJs.vec(24);
const deb = _utilJs.vec(24);
const eac = _utilJs.vec(24);
const adet = _utilJs.vec(1152);
const bdet = _utilJs.vec(1152);
const cdet = _utilJs.vec(1152);
const ddet = _utilJs.vec(1152);
const edet = _utilJs.vec(1152);
const abdet = _utilJs.vec(2304);
const cddet = _utilJs.vec(2304);
const cdedet = _utilJs.vec(3456);
const deter = _utilJs.vec(5760);
const _8 = _utilJs.vec(8);
const _8b = _utilJs.vec(8);
const _8c = _utilJs.vec(8);
const _16 = _utilJs.vec(16);
const _24 = _utilJs.vec(24);
const _48 = _utilJs.vec(48);
const _48b = _utilJs.vec(48);
const _96 = _utilJs.vec(96);
const _192 = _utilJs.vec(192);
const _384x = _utilJs.vec(384);
const _384y = _utilJs.vec(384);
const _384z = _utilJs.vec(384);
const _768 = _utilJs.vec(768);
function sum_three_scale(a, b, c, az, bz, cz, out) {
    return _utilJs.sum_three(_utilJs.scale(4, a, az, _8), _8, _utilJs.scale(4, b, bz, _8b), _8b, _utilJs.scale(4, c, cz, _8c), _8c, _16, out);
}
function liftexact(alen, a, blen, b, clen, c, dlen, d, x, y, z, out) {
    const len = _utilJs.sum(_utilJs.sum(alen, a, blen, b, _48), _48, _utilJs.negate(_utilJs.sum(clen, c, dlen, d, _48b), _48b), _48b, _96);
    return _utilJs.sum_three(_utilJs.scale(_utilJs.scale(len, _96, x, _192), _192, x, _384x), _384x, _utilJs.scale(_utilJs.scale(len, _96, y, _192), _192, y, _384y), _384y, _utilJs.scale(_utilJs.scale(len, _96, z, _192), _192, z, _384z), _384z, _768, out);
}
function insphereexact(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez) {
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;
    s1 = ax * by;
    c = _utilJs.splitter * ax;
    ahi = c - (c - ax);
    alo = ax - ahi;
    c = _utilJs.splitter * by;
    bhi = c - (c - by);
    blo = by - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = bx * ay;
    c = _utilJs.splitter * bx;
    ahi = c - (c - bx);
    alo = bx - ahi;
    c = _utilJs.splitter * ay;
    bhi = c - (c - ay);
    blo = ay - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    ab[2] = _j - (u3 - bvirt) + (_i - bvirt);
    ab[3] = u3;
    s1 = bx * cy;
    c = _utilJs.splitter * bx;
    ahi = c - (c - bx);
    alo = bx - ahi;
    c = _utilJs.splitter * cy;
    bhi = c - (c - cy);
    blo = cy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = cx * by;
    c = _utilJs.splitter * cx;
    ahi = c - (c - cx);
    alo = cx - ahi;
    c = _utilJs.splitter * by;
    bhi = c - (c - by);
    blo = by - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    bc[2] = _j - (u3 - bvirt) + (_i - bvirt);
    bc[3] = u3;
    s1 = cx * dy;
    c = _utilJs.splitter * cx;
    ahi = c - (c - cx);
    alo = cx - ahi;
    c = _utilJs.splitter * dy;
    bhi = c - (c - dy);
    blo = dy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = dx * cy;
    c = _utilJs.splitter * dx;
    ahi = c - (c - dx);
    alo = dx - ahi;
    c = _utilJs.splitter * cy;
    bhi = c - (c - cy);
    blo = cy - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    cd[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    cd[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    cd[2] = _j - (u3 - bvirt) + (_i - bvirt);
    cd[3] = u3;
    s1 = dx * ey;
    c = _utilJs.splitter * dx;
    ahi = c - (c - dx);
    alo = dx - ahi;
    c = _utilJs.splitter * ey;
    bhi = c - (c - ey);
    blo = ey - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = ex * dy;
    c = _utilJs.splitter * ex;
    ahi = c - (c - ex);
    alo = ex - ahi;
    c = _utilJs.splitter * dy;
    bhi = c - (c - dy);
    blo = dy - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    de[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    de[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    de[2] = _j - (u3 - bvirt) + (_i - bvirt);
    de[3] = u3;
    s1 = ex * ay;
    c = _utilJs.splitter * ex;
    ahi = c - (c - ex);
    alo = ex - ahi;
    c = _utilJs.splitter * ay;
    bhi = c - (c - ay);
    blo = ay - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = ax * ey;
    c = _utilJs.splitter * ax;
    ahi = c - (c - ax);
    alo = ax - ahi;
    c = _utilJs.splitter * ey;
    bhi = c - (c - ey);
    blo = ey - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ea[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ea[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    ea[2] = _j - (u3 - bvirt) + (_i - bvirt);
    ea[3] = u3;
    s1 = ax * cy;
    c = _utilJs.splitter * ax;
    ahi = c - (c - ax);
    alo = ax - ahi;
    c = _utilJs.splitter * cy;
    bhi = c - (c - cy);
    blo = cy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = cx * ay;
    c = _utilJs.splitter * cx;
    ahi = c - (c - cx);
    alo = cx - ahi;
    c = _utilJs.splitter * ay;
    bhi = c - (c - ay);
    blo = ay - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ac[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ac[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    ac[2] = _j - (u3 - bvirt) + (_i - bvirt);
    ac[3] = u3;
    s1 = bx * dy;
    c = _utilJs.splitter * bx;
    ahi = c - (c - bx);
    alo = bx - ahi;
    c = _utilJs.splitter * dy;
    bhi = c - (c - dy);
    blo = dy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = dx * by;
    c = _utilJs.splitter * dx;
    ahi = c - (c - dx);
    alo = dx - ahi;
    c = _utilJs.splitter * by;
    bhi = c - (c - by);
    blo = by - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    bd[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    bd[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    bd[2] = _j - (u3 - bvirt) + (_i - bvirt);
    bd[3] = u3;
    s1 = cx * ey;
    c = _utilJs.splitter * cx;
    ahi = c - (c - cx);
    alo = cx - ahi;
    c = _utilJs.splitter * ey;
    bhi = c - (c - ey);
    blo = ey - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = ex * cy;
    c = _utilJs.splitter * ex;
    ahi = c - (c - ex);
    alo = ex - ahi;
    c = _utilJs.splitter * cy;
    bhi = c - (c - cy);
    blo = cy - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ce[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ce[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    ce[2] = _j - (u3 - bvirt) + (_i - bvirt);
    ce[3] = u3;
    s1 = dx * ay;
    c = _utilJs.splitter * dx;
    ahi = c - (c - dx);
    alo = dx - ahi;
    c = _utilJs.splitter * ay;
    bhi = c - (c - ay);
    blo = ay - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = ax * dy;
    c = _utilJs.splitter * ax;
    ahi = c - (c - ax);
    alo = ax - ahi;
    c = _utilJs.splitter * dy;
    bhi = c - (c - dy);
    blo = dy - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    da[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    da[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    da[2] = _j - (u3 - bvirt) + (_i - bvirt);
    da[3] = u3;
    s1 = ex * by;
    c = _utilJs.splitter * ex;
    ahi = c - (c - ex);
    alo = ex - ahi;
    c = _utilJs.splitter * by;
    bhi = c - (c - by);
    blo = by - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = bx * ey;
    c = _utilJs.splitter * bx;
    ahi = c - (c - bx);
    alo = bx - ahi;
    c = _utilJs.splitter * ey;
    bhi = c - (c - ey);
    blo = ey - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    eb[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    eb[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    eb[2] = _j - (u3 - bvirt) + (_i - bvirt);
    eb[3] = u3;
    const abclen = sum_three_scale(ab, bc, ac, cz, az, -bz, abc);
    const bcdlen = sum_three_scale(bc, cd, bd, dz, bz, -cz, bcd);
    const cdelen = sum_three_scale(cd, de, ce, ez, cz, -dz, cde);
    const dealen = sum_three_scale(de, ea, da, az, dz, -ez, dea);
    const eablen = sum_three_scale(ea, ab, eb, bz, ez, -az, eab);
    const abdlen = sum_three_scale(ab, bd, da, dz, az, bz, abd);
    const bcelen = sum_three_scale(bc, ce, eb, ez, bz, cz, bce);
    const cdalen = sum_three_scale(cd, da, ac, az, cz, dz, cda);
    const deblen = sum_three_scale(de, eb, bd, bz, dz, ez, deb);
    const eaclen = sum_three_scale(ea, ac, ce, cz, ez, az, eac);
    const deterlen = _utilJs.sum_three(liftexact(cdelen, cde, bcelen, bce, deblen, deb, bcdlen, bcd, ax, ay, az, adet), adet, liftexact(dealen, dea, cdalen, cda, eaclen, eac, cdelen, cde, bx, by, bz, bdet), bdet, _utilJs.sum_three(liftexact(eablen, eab, deblen, deb, abdlen, abd, dealen, dea, cx, cy, cz, cdet), cdet, liftexact(abclen, abc, eaclen, eac, bcelen, bce, eablen, eab, dx, dy, dz, ddet), ddet, liftexact(bcdlen, bcd, abdlen, abd, cdalen, cda, abclen, abc, ex, ey, ez, edet), edet, cddet, cdedet), cdedet, abdet, deter);
    return deter[deterlen - 1];
}
const xdet = _utilJs.vec(96);
const ydet = _utilJs.vec(96);
const zdet = _utilJs.vec(96);
const fin = _utilJs.vec(1152);
function liftadapt(a, b, c, az, bz, cz, x, y, z, out) {
    const len = sum_three_scale(a, b, c, az, bz, cz, _24);
    return _utilJs.sum_three(_utilJs.scale(_utilJs.scale(len, _24, x, _48), _48, x, xdet), xdet, _utilJs.scale(_utilJs.scale(len, _24, y, _48), _48, y, ydet), ydet, _utilJs.scale(_utilJs.scale(len, _24, z, _48), _48, z, zdet), zdet, _192, out);
}
function insphereadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez, permanent) {
    let ab3, bc3, cd3, da3, ac3, bd3;
    let aextail, bextail, cextail, dextail;
    let aeytail, beytail, ceytail, deytail;
    let aeztail, beztail, ceztail, deztail;
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0;
    const aex = ax - ex;
    const bex = bx - ex;
    const cex = cx - ex;
    const dex = dx - ex;
    const aey = ay - ey;
    const bey = by - ey;
    const cey = cy - ey;
    const dey = dy - ey;
    const aez = az - ez;
    const bez = bz - ez;
    const cez = cz - ez;
    const dez = dz - ez;
    s1 = aex * bey;
    c = _utilJs.splitter * aex;
    ahi = c - (c - aex);
    alo = aex - ahi;
    c = _utilJs.splitter * bey;
    bhi = c - (c - bey);
    blo = bey - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = bex * aey;
    c = _utilJs.splitter * bex;
    ahi = c - (c - bex);
    alo = bex - ahi;
    c = _utilJs.splitter * aey;
    bhi = c - (c - aey);
    blo = aey - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ab[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ab[1] = _0 - (_i + bvirt) + (bvirt - t1);
    ab3 = _j + _i;
    bvirt = ab3 - _j;
    ab[2] = _j - (ab3 - bvirt) + (_i - bvirt);
    ab[3] = ab3;
    s1 = bex * cey;
    c = _utilJs.splitter * bex;
    ahi = c - (c - bex);
    alo = bex - ahi;
    c = _utilJs.splitter * cey;
    bhi = c - (c - cey);
    blo = cey - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = cex * bey;
    c = _utilJs.splitter * cex;
    ahi = c - (c - cex);
    alo = cex - ahi;
    c = _utilJs.splitter * bey;
    bhi = c - (c - bey);
    blo = bey - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    bc[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    bc[1] = _0 - (_i + bvirt) + (bvirt - t1);
    bc3 = _j + _i;
    bvirt = bc3 - _j;
    bc[2] = _j - (bc3 - bvirt) + (_i - bvirt);
    bc[3] = bc3;
    s1 = cex * dey;
    c = _utilJs.splitter * cex;
    ahi = c - (c - cex);
    alo = cex - ahi;
    c = _utilJs.splitter * dey;
    bhi = c - (c - dey);
    blo = dey - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = dex * cey;
    c = _utilJs.splitter * dex;
    ahi = c - (c - dex);
    alo = dex - ahi;
    c = _utilJs.splitter * cey;
    bhi = c - (c - cey);
    blo = cey - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    cd[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    cd[1] = _0 - (_i + bvirt) + (bvirt - t1);
    cd3 = _j + _i;
    bvirt = cd3 - _j;
    cd[2] = _j - (cd3 - bvirt) + (_i - bvirt);
    cd[3] = cd3;
    s1 = dex * aey;
    c = _utilJs.splitter * dex;
    ahi = c - (c - dex);
    alo = dex - ahi;
    c = _utilJs.splitter * aey;
    bhi = c - (c - aey);
    blo = aey - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = aex * dey;
    c = _utilJs.splitter * aex;
    ahi = c - (c - aex);
    alo = aex - ahi;
    c = _utilJs.splitter * dey;
    bhi = c - (c - dey);
    blo = dey - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    da[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    da[1] = _0 - (_i + bvirt) + (bvirt - t1);
    da3 = _j + _i;
    bvirt = da3 - _j;
    da[2] = _j - (da3 - bvirt) + (_i - bvirt);
    da[3] = da3;
    s1 = aex * cey;
    c = _utilJs.splitter * aex;
    ahi = c - (c - aex);
    alo = aex - ahi;
    c = _utilJs.splitter * cey;
    bhi = c - (c - cey);
    blo = cey - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = cex * aey;
    c = _utilJs.splitter * cex;
    ahi = c - (c - cex);
    alo = cex - ahi;
    c = _utilJs.splitter * aey;
    bhi = c - (c - aey);
    blo = aey - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    ac[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    ac[1] = _0 - (_i + bvirt) + (bvirt - t1);
    ac3 = _j + _i;
    bvirt = ac3 - _j;
    ac[2] = _j - (ac3 - bvirt) + (_i - bvirt);
    ac[3] = ac3;
    s1 = bex * dey;
    c = _utilJs.splitter * bex;
    ahi = c - (c - bex);
    alo = bex - ahi;
    c = _utilJs.splitter * dey;
    bhi = c - (c - dey);
    blo = dey - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = dex * bey;
    c = _utilJs.splitter * dex;
    ahi = c - (c - dex);
    alo = dex - ahi;
    c = _utilJs.splitter * bey;
    bhi = c - (c - bey);
    blo = bey - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    bd[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    bd[1] = _0 - (_i + bvirt) + (bvirt - t1);
    bd3 = _j + _i;
    bvirt = bd3 - _j;
    bd[2] = _j - (bd3 - bvirt) + (_i - bvirt);
    bd[3] = bd3;
    const finlen = _utilJs.sum(_utilJs.sum(_utilJs.negate(liftadapt(bc, cd, bd, dez, bez, -cez, aex, aey, aez, adet), adet), adet, liftadapt(cd, da, ac, aez, cez, dez, bex, bey, bez, bdet), bdet, abdet), abdet, _utilJs.sum(_utilJs.negate(liftadapt(da, ab, bd, bez, dez, aez, cex, cey, cez, cdet), cdet), cdet, liftadapt(ab, bc, ac, cez, aez, -bez, dex, dey, dez, ddet), ddet, cddet), cddet, fin);
    let det = _utilJs.estimate(finlen, fin);
    let errbound = isperrboundB * permanent;
    if (det >= errbound || -det >= errbound) return det;
    bvirt = ax - aex;
    aextail = ax - (aex + bvirt) + (bvirt - ex);
    bvirt = ay - aey;
    aeytail = ay - (aey + bvirt) + (bvirt - ey);
    bvirt = az - aez;
    aeztail = az - (aez + bvirt) + (bvirt - ez);
    bvirt = bx - bex;
    bextail = bx - (bex + bvirt) + (bvirt - ex);
    bvirt = by - bey;
    beytail = by - (bey + bvirt) + (bvirt - ey);
    bvirt = bz - bez;
    beztail = bz - (bez + bvirt) + (bvirt - ez);
    bvirt = cx - cex;
    cextail = cx - (cex + bvirt) + (bvirt - ex);
    bvirt = cy - cey;
    ceytail = cy - (cey + bvirt) + (bvirt - ey);
    bvirt = cz - cez;
    ceztail = cz - (cez + bvirt) + (bvirt - ez);
    bvirt = dx - dex;
    dextail = dx - (dex + bvirt) + (bvirt - ex);
    bvirt = dy - dey;
    deytail = dy - (dey + bvirt) + (bvirt - ey);
    bvirt = dz - dez;
    deztail = dz - (dez + bvirt) + (bvirt - ez);
    if (aextail === 0 && aeytail === 0 && aeztail === 0 && bextail === 0 && beytail === 0 && beztail === 0 && cextail === 0 && ceytail === 0 && ceztail === 0 && dextail === 0 && deytail === 0 && deztail === 0) return det;
    errbound = isperrboundC * permanent + _utilJs.resulterrbound * Math.abs(det);
    const abeps = aex * beytail + bey * aextail - (aey * bextail + bex * aeytail);
    const bceps = bex * ceytail + cey * bextail - (bey * cextail + cex * beytail);
    const cdeps = cex * deytail + dey * cextail - (cey * dextail + dex * ceytail);
    const daeps = dex * aeytail + aey * dextail - (dey * aextail + aex * deytail);
    const aceps = aex * ceytail + cey * aextail - (aey * cextail + cex * aeytail);
    const bdeps = bex * deytail + dey * bextail - (bey * dextail + dex * beytail);
    det += (bex * bex + bey * bey + bez * bez) * (cez * daeps + dez * aceps + aez * cdeps + (ceztail * da3 + deztail * ac3 + aeztail * cd3)) + (dex * dex + dey * dey + dez * dez) * (aez * bceps - bez * aceps + cez * abeps + (aeztail * bc3 - beztail * ac3 + ceztail * ab3)) - ((aex * aex + aey * aey + aez * aez) * (bez * cdeps - cez * bdeps + dez * bceps + (beztail * cd3 - ceztail * bd3 + deztail * bc3)) + (cex * cex + cey * cey + cez * cez) * (dez * abeps + aez * bdeps + bez * daeps + (deztail * ab3 + aeztail * bd3 + beztail * da3))) + 2 * ((bex * bextail + bey * beytail + bez * beztail) * (cez * da3 + dez * ac3 + aez * cd3) + (dex * dextail + dey * deytail + dez * deztail) * (aez * bc3 - bez * ac3 + cez * ab3) - ((aex * aextail + aey * aeytail + aez * aeztail) * (bez * cd3 - cez * bd3 + dez * bc3) + (cex * cextail + cey * ceytail + cez * ceztail) * (dez * ab3 + aez * bd3 + bez * da3)));
    if (det >= errbound || -det >= errbound) return det;
    return insphereexact(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez);
}
function insphere(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez) {
    const aex = ax - ex;
    const bex = bx - ex;
    const cex = cx - ex;
    const dex = dx - ex;
    const aey = ay - ey;
    const bey = by - ey;
    const cey = cy - ey;
    const dey = dy - ey;
    const aez = az - ez;
    const bez = bz - ez;
    const cez = cz - ez;
    const dez = dz - ez;
    const aexbey = aex * bey;
    const bexaey = bex * aey;
    const ab1 = aexbey - bexaey;
    const bexcey = bex * cey;
    const cexbey = cex * bey;
    const bc1 = bexcey - cexbey;
    const cexdey = cex * dey;
    const dexcey = dex * cey;
    const cd1 = cexdey - dexcey;
    const dexaey = dex * aey;
    const aexdey = aex * dey;
    const da1 = dexaey - aexdey;
    const aexcey = aex * cey;
    const cexaey = cex * aey;
    const ac1 = aexcey - cexaey;
    const bexdey = bex * dey;
    const dexbey = dex * bey;
    const bd1 = bexdey - dexbey;
    const abc1 = aez * bc1 - bez * ac1 + cez * ab1;
    const bcd1 = bez * cd1 - cez * bd1 + dez * bc1;
    const cda1 = cez * da1 + dez * ac1 + aez * cd1;
    const dab = dez * ab1 + aez * bd1 + bez * da1;
    const alift = aex * aex + aey * aey + aez * aez;
    const blift = bex * bex + bey * bey + bez * bez;
    const clift = cex * cex + cey * cey + cez * cez;
    const dlift = dex * dex + dey * dey + dez * dez;
    const det = clift * dab - dlift * abc1 + (alift * bcd1 - blift * cda1);
    const aezplus = Math.abs(aez);
    const bezplus = Math.abs(bez);
    const cezplus = Math.abs(cez);
    const dezplus = Math.abs(dez);
    const aexbeyplus = Math.abs(aexbey);
    const bexaeyplus = Math.abs(bexaey);
    const bexceyplus = Math.abs(bexcey);
    const cexbeyplus = Math.abs(cexbey);
    const cexdeyplus = Math.abs(cexdey);
    const dexceyplus = Math.abs(dexcey);
    const dexaeyplus = Math.abs(dexaey);
    const aexdeyplus = Math.abs(aexdey);
    const aexceyplus = Math.abs(aexcey);
    const cexaeyplus = Math.abs(cexaey);
    const bexdeyplus = Math.abs(bexdey);
    const dexbeyplus = Math.abs(dexbey);
    const permanent = ((cexdeyplus + dexceyplus) * bezplus + (dexbeyplus + bexdeyplus) * cezplus + (bexceyplus + cexbeyplus) * dezplus) * alift + ((dexaeyplus + aexdeyplus) * cezplus + (aexceyplus + cexaeyplus) * dezplus + (cexdeyplus + dexceyplus) * aezplus) * blift + ((aexbeyplus + bexaeyplus) * dezplus + (bexdeyplus + dexbeyplus) * aezplus + (dexaeyplus + aexdeyplus) * bezplus) * clift + ((bexceyplus + cexbeyplus) * aezplus + (cexaeyplus + aexceyplus) * bezplus + (aexbeyplus + bexaeyplus) * cezplus) * dlift;
    const errbound = isperrboundA * permanent;
    if (det > errbound || -det > errbound) return det;
    return -insphereadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez, permanent);
}
function inspherefast(pax, pay, paz, pbx, pby, pbz, pcx, pcy, pcz, pdx, pdy, pdz, pex, pey, pez) {
    const aex = pax - pex;
    const bex = pbx - pex;
    const cex = pcx - pex;
    const dex = pdx - pex;
    const aey = pay - pey;
    const bey = pby - pey;
    const cey = pcy - pey;
    const dey = pdy - pey;
    const aez = paz - pez;
    const bez = pbz - pez;
    const cez = pcz - pez;
    const dez = pdz - pez;
    const ab2 = aex * bey - bex * aey;
    const bc2 = bex * cey - cex * bey;
    const cd2 = cex * dey - dex * cey;
    const da2 = dex * aey - aex * dey;
    const ac2 = aex * cey - cex * aey;
    const bd2 = bex * dey - dex * bey;
    const abc2 = aez * bc2 - bez * ac2 + cez * ab2;
    const bcd2 = bez * cd2 - cez * bd2 + dez * bc2;
    const cda2 = cez * da2 + dez * ac2 + aez * cd2;
    const dab = dez * ab2 + aez * bd2 + bez * da2;
    const alift = aex * aex + aey * aey + aez * aez;
    const blift = bex * bex + bey * bey + bez * bez;
    const clift = cex * cex + cey * cey + cez * cez;
    const dlift = dex * dex + dey * dey + dez * dez;
    return clift * dab - dlift * abc2 + (alift * bcd2 - blift * cda2);
}

},{"./util.js":"3OxkP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"0FAPM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uvGrid", ()=>uvGrid
);
parcelHelpers.export(exports, "quadEdgeWeightInterpolator", ()=>quadEdgeWeightInterpolator
);
parcelHelpers.export(exports, "triEdgeWeightInterpolator", ()=>triEdgeWeightInterpolator
);
parcelHelpers.export(exports, "quadPatch", ()=>quadPatch
);
parcelHelpers.export(exports, "triPatch", ()=>triPatch
);
parcelHelpers.export(exports, "tessellation", ()=>tessellation
);
parcelHelpers.export(exports, "prepareMesh", ()=>prepareMesh
);
parcelHelpers.export(exports, "tessellationMesh", ()=>tessellationMesh
);
var _geomAccel = require("@thi.ng/geom-accel");
var _poisson = require("@thi.ng/poisson");
var _vectors = require("@thi.ng/vectors");
// @ts-ignore
var _barycentric = require("barycentric");
var _barycentricDefault = parcelHelpers.interopDefault(_barycentric);
var _delaunator = require("delaunator");
var _delaunatorDefault = parcelHelpers.interopDefault(_delaunator);
var _lodashEs = require("lodash-es");
// @ts-ignore
var _angleNormals = require("angle-normals");
var _angleNormalsDefault = parcelHelpers.interopDefault(_angleNormals);
// @ts-ignore
var _mda = require("mda");
var _mdaDefault = parcelHelpers.interopDefault(_mda);
/* Generate a function that interpolates between edge weights of a UV square.

  v
  ^
  | D
  |              
  | A             C
  |              
  | B
 -|------------------> u

 * @param {number} A - edge A weight.
 * @param {number} B - edge B weight.
 * @param {number} C - edge C weight.
 * @param {number} D - edge D weight.
 * @return {function: } an interpolation function.
 */ const product = (...a1)=>a1.reduce((a, b)=>a.flatMap((d)=>b.map((e)=>[
                    d,
                    e
                ].flat()
            )
        )
    )
;
const uvGrid = (uResolution, vResolution = null)=>product([
        ..._lodashEs.range(0, 1, 1 / uResolution),
        1
    ], [
        ..._lodashEs.range(0, 1, 1 / (vResolution || uResolution)),
        1
    ])
;
const quadEdgeWeightInterpolator = (A, B, C, D, n = 1)=>([x, y])=>{
        const z = 1 - x;
        const w = 1 - y;
        const e0 = y * z * w;
        const e1 = x * z * w;
        const e2 = x * y * w;
        const e3 = x * y * z;
        const sum = e0 + e1 + e2 + e3;
        const c0 = A;
        const c1 = B;
        const c2 = C;
        const c3 = D;
        return ((e0 * c0) ** n + (e1 * c1) ** n + (e2 * c2) ** n + e3 * c3) / sum ** n;
    }
;
const triEdgeWeightInterpolator = (A, B, C, n = 1)=>([x, y, z])=>{
        const e0 = y * z;
        const e1 = x * z;
        const e2 = x * y;
        const sum = e0 + e1 + e2;
        const c0 = A;
        const c1 = B;
        const c2 = C;
        return ((e0 * c0) ** n + (e1 * c1) ** n + (e2 * c2) ** n) / sum ** n;
    }
;
const cartesian = (bary, corners)=>[
        bary[0] * corners[0][0] + bary[1] * corners[1][0] + bary[2] * corners[2][0],
        bary[0] * corners[0][1] + bary[1] * corners[1][1] + bary[2] * corners[2][1], 
    ]
;
const sampleTriangle = (corners)=>()=>{
        const u = [
            Math.random(),
            Math.random()
        ];
        const su0 = Math.sqrt(u[0]);
        const b0 = 1 - su0;
        const b1 = u[1] * su0;
        const pt = cartesian([
            b0,
            b1,
            1 - b0 - b1
        ], corners);
        return pt;
    }
;
const getRadiusTri = (triangle, weights)=>(pt)=>{
        let bary = _barycentricDefault.default(triangle, pt);
        const D = _vectors.dist([
            0,
            0
        ], [
            0.5,
            0.5
        ]);
        bary = [
            _vectors.divN2(null, bary[0], 1),
            _vectors.divN2(null, bary[1], D),
            _vectors.divN2(null, bary[2], D), 
        ];
        const x = triEdgeWeightInterpolator(weights[0], weights[1], weights[2])(bary);
        // console.log(x, bary, pt, triangle, weights)
        return 1 / x;
    }
;
const defaultOptions = {
    iter: 1,
    jitter: 0.00001,
    max: 3000000,
    quality: 150
};
const quadPatch = (resA, resB, resC, resD, opts = null)=>{
    opts = {
        ...defaultOptions,
        ...opts || {
        }
    };
    const index = new _geomAccel.KdTreeSet(2);
    const addPoint = (radius)=>(x1)=>index.add(x1.map((x)=>x * 1000
            ), radius)
    ;
    // add stitching points
    for(let a = 0; a <= 1; a += 1 / resA)index.add([
        0,
        a
    ]);
    for(let b = 0; b <= 1; b += 1 / resB)index.add([
        b,
        0
    ]);
    for(let c = 0; c <= 1; c += 1 / resC)index.add([
        1,
        c
    ]);
    for(let d = 0; d <= 1; d += 1 / resD)index.add([
        d,
        1
    ]);
    const interpolation = (x)=>1 / quadEdgeWeightInterpolator(resA, resB, resC, resD)(x)
    ;
    const sample = ()=>{
        const points = ()=>[
                Math.random(),
                Math.random()
            ]
        ;
        const density = interpolation;
        return _poisson.samplePoisson({
            index,
            points,
            density,
            max: 0,
            ...opts
        });
    };
    const boundaryPoints = index.keys();
    const points1 = [
        ...boundaryPoints,
        ...sample(), 
    ];
    return {
        points: points1,
        index
    };
};
const triPatch = (resA, resB, resC, opts = null)=>{
    opts = {
        ...defaultOptions,
        ...opts || {
        }
    };
    const corners1 = [
        [
            0,
            1
        ],
        [
            1,
            0
        ],
        [
            0,
            0
        ], 
    ];
    const index = new _geomAccel.KdTreeSet(2);
    const addPoint = (radius)=>(x2)=>index.add(x2.map((x)=>x * 1000
            ), radius)
    ;
    // add stitching points
    for(let a = 0; a <= 1; a += 1 / resA)index.add([
        a,
        0
    ]);
    for(let b = 0; b <= 1; b += 1 / resB)index.add([
        0,
        b
    ]);
    for(let c = 0; c <= 1; c += 1 / resC)index.add([
        1 - c,
        c
    ]);
    const interpolation = getRadiusTri(corners1, [
        resA,
        resB,
        resC
    ]);
    const sampleTri = (corners, weights)=>{
        const points = sampleTriangle(corners);
        const density = interpolation;
        return _poisson.samplePoisson({
            index,
            points,
            density,
            max: 0,
            ...opts
        });
    };
    const boundaryPoints = index.keys();
    const points2 = [
        ...boundaryPoints,
        ...sampleTri(corners1, [
            resA,
            resB,
            resC
        ]), 
    ];
    return {
        points: points2,
        index
    };
};
const tessellation = (sideLODs = 8)=>{
    let points;
    if (Array.isArray(sideLODs)) points = (sideLODs.length === 4 ? quadPatch(...sideLODs) : triPatch(...sideLODs)).points; // uvGrid(resolution)
    else points = triPatch(sideLODs, sideLODs, sideLODs).points;
    return _delaunatorDefault.default.from(points);
};
const prepareMesh = (grid, includeMda = true)=>{
    let mesh = {
    };
    const cells = _lodashEs.chunk(grid.triangles, 3);
    const positions = _lodashEs.chunk(grid.coords, 2).map(([u, v])=>[
            u,
            v,
            0, 
        ]
    );
    // mesh = mergeVertices(mesh.cells, mesh.positions)
    // top.normalize(mesh.cells)
    // mesh.incidence = top.incidence(mesh.cells, mesh.cells)
    const M = new _mdaDefault.default.Mesh();
    M.setPositions(positions);
    M.setCells(cells);
    M.process();
    mesh.cells = M.getCells();
    mesh.positions = M.getPositions();
    mesh.normals = _angleNormalsDefault.default(mesh.cells, mesh.positions);
    mesh.cellPositions = mesh.cells.map((indices)=>indices.map((i)=>mesh.positions[i]
        )
    );
    mesh.cellNormals = mesh.cells.map((indices)=>indices.map((i)=>mesh.normals[i]
        )
    );
    if (includeMda) mesh.mda = M;
    // console.log('mesh', mesh)
    return mesh;
};
function tessellationMesh(sideLODs) {
    const mesh = prepareMesh(tessellation(sideLODs), false);
    return mesh;
}

},{"@thi.ng/geom-accel":"eyFxq","@thi.ng/poisson":"hTYUR","@thi.ng/vectors":"gLU21","barycentric":"cdKXu","delaunator":"1U5NA","lodash-es":"bXNwz","angle-normals":"3WkEt","mda":"9J7Dv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eyFxq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _kdTreeMapJs = require("./kd-tree-map.js");
parcelHelpers.exportAll(_kdTreeMapJs, exports);
var _kdTreeSetJs = require("./kd-tree-set.js");
parcelHelpers.exportAll(_kdTreeSetJs, exports);
var _ndQuadtreeMapJs = require("./nd-quadtree-map.js");
parcelHelpers.exportAll(_ndQuadtreeMapJs, exports);
var _ndQuadtreeSetJs = require("./nd-quadtree-set.js");
parcelHelpers.exportAll(_ndQuadtreeSetJs, exports);
var _spatialGrid2Js = require("./spatial-grid2.js");
parcelHelpers.exportAll(_spatialGrid2Js, exports);
var _spatialGrid3Js = require("./spatial-grid3.js");
parcelHelpers.exportAll(_spatialGrid3Js, exports);

},{"./kd-tree-map.js":"7aH1S","./kd-tree-set.js":"5eyOc","./nd-quadtree-map.js":"5mrju","./nd-quadtree-set.js":"6tjbR","./spatial-grid2.js":"b6jlb","./spatial-grid3.js":"epsDv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7aH1S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KdNode", ()=>KdNode
);
/**
 * {@link https://en.wikipedia.org/wiki/K-d_tree}
 *
 * Partially based on:
 * {@link https://github.com/ubilabs/kd-tree-javascript}
 *
 */ parcelHelpers.export(exports, "KdTreeMap", ()=>KdTreeMap
);
var _ensureArray = require("@thi.ng/arrays/ensure-array");
var _heap = require("@thi.ng/heaps/heap");
var _api = require("@thi.ng/math/api");
var _map = require("@thi.ng/transducers/map");
var _distsq = require("@thi.ng/vectors/distsq");
var _utilsJs = require("./utils.js");
class KdNode {
    constructor(parent, dim, key, val){
        this.parent = parent;
        this.d = dim;
        this.k = key;
        this.v = val;
    }
    get height() {
        return 1 + Math.max(this.l ? this.l.height : 0, this.r ? this.r.height : 0);
    }
}
class KdTreeMap {
    constructor(dim, pairs){
        this.dim = dim;
        this._size = 0;
        this.root = pairs ? this.buildTree(_ensureArray.ensureArray(pairs), 0) : undefined;
    }
    *[Symbol.iterator]() {
        let queue = this.root ? [
            this.root
        ] : [];
        while(queue.length){
            const n = queue.pop();
            if (n) {
                yield [
                    n.k,
                    n.v
                ];
                queue.push(n.r, n.l);
            }
        }
    }
    *keys() {
        let queue = this.root ? [
            this.root
        ] : [];
        while(queue.length){
            const n = queue.pop();
            if (n) {
                yield n.k;
                queue.push(n.r, n.l);
            }
        }
    }
    values() {
        return _map.map((p)=>p[1]
        , this);
    }
    get size() {
        return this._size;
    }
    get height() {
        return this.root ? this.root.height : 0;
    }
    get ratio() {
        return this._size ? this.height / Math.log2(this._size) : 0;
    }
    copy() {
        return new KdTreeMap(this.dim, this);
    }
    clear() {
        delete this.root;
        this._size = 0;
    }
    empty() {
        return new KdTreeMap(this.dim);
    }
    set(key, val, eps = _api.EPS) {
        eps = Math.max(0, eps);
        eps *= eps;
        const search = (node, parent)=>node ? search(key[node.d] < node.k[node.d] ? node.l : node.r, node) : parent
        ;
        let parent1;
        if (this.root) {
            parent1 = nearest1(key, [
                eps,
                undefined
            ], this.dim, this.root)[1];
            if (parent1) {
                parent1.v = val;
                return false;
            }
            parent1 = search(this.root, undefined);
            const dim = parent1.d;
            parent1[key[dim] < parent1.k[dim] ? "l" : "r"] = new KdNode(parent1, (dim + 1) % this.dim, key, val);
        } else this.root = new KdNode(undefined, 0, key, val);
        this._size++;
        return true;
    }
    into(pairs, eps = _api.EPS) {
        return _utilsJs.into(this, pairs, eps);
    }
    remove(key) {
        const node = find(key, this.root, 0);
        if (node) {
            remove(node) && (this.root = undefined);
            this._size--;
            return true;
        }
        return false;
    }
    has(key, eps = _api.EPS) {
        return !!this.root && !!nearest1(key, [
            eps * eps,
            undefined
        ], this.dim, this.root)[1];
    }
    get(key, eps = _api.EPS) {
        if (this.root) {
            const node = nearest1(key, [
                eps * eps,
                undefined
            ], this.dim, this.root)[1];
            return node ? node.v : undefined;
        }
    }
    query(q, maxDist, limit, acc) {
        return this.doSelect(q, (x)=>[
                x.k,
                x.v
            ]
        , maxDist, limit, acc);
    }
    queryKeys(q, maxDist, limit, acc) {
        return this.doSelect(q, (x)=>x.k
        , maxDist, limit, acc);
    }
    queryValues(q, maxDist, limit, acc) {
        return this.doSelect(q, (x)=>x.v
        , maxDist, limit, acc);
    }
    doSelect(q, f, maxDist, maxNum = 1, acc = []) {
        if (!this.root) return [];
        maxDist *= maxDist;
        if (maxNum === 1) {
            const sel = nearest1(q, [
                maxDist,
                undefined
            ], this.dim, this.root)[1];
            sel && acc.push(f(sel));
        } else {
            const nodes = new _heap.Heap([
                [
                    maxDist,
                    undefined
                ]
            ], {
                compare: _utilsJs.CMP
            });
            nearest(q, nodes, this.dim, maxNum, this.root);
            return _utilsJs.addResults(f, nodes.values, acc);
        }
        return acc;
    }
    buildTree(points, depth, parent) {
        const n = points.length;
        if (n === 0) return;
        this._size++;
        let dim = depth % this.dim;
        if (n === 1) return new KdNode(parent, dim, ...points[0]);
        points.sort((a, b)=>a[0][dim] - b[0][dim]
        );
        const med = n >>> 1;
        const node = new KdNode(parent, dim, ...points[med]);
        node.l = this.buildTree(points.slice(0, med), depth + 1, node);
        node.r = this.buildTree(points.slice(med + 1), depth + 1, node);
        return node;
    }
}
/**
 * Returns node for point or `undefined` if none found.
 *
 * @param p - point
 * @param node - tree node
 * @param epsSq - squared epsilon / tolerance
 */ const find = (p, node, epsSq)=>{
    if (!node) return;
    return _distsq.distSq(p, node.k) <= epsSq ? node : find(p, p[node.d] < node.k[node.d] ? node.l : node.r, epsSq);
};
const findMin = (node, dim)=>{
    if (!node) return;
    if (node.d === dim) return node.l ? findMin(node.l, dim) : node;
    const q = node.k[dim];
    const l = findMin(node.l, dim);
    const r = findMin(node.r, dim);
    let min = node;
    if (l && l.k[dim] < q) min = l;
    if (r && r.k[dim] < min.k[dim]) min = r;
    return min;
};
/**
 * Returns true if root is to be deleted.
 *
 * @param node - tree node
 */ const remove = (node)=>{
    if (!node.l && !node.r) {
        if (!node.parent) return true;
        const parent = node.parent;
        const pdim = parent.d;
        parent[node.k[pdim] < parent.k[pdim] ? "l" : "r"] = undefined;
        return;
    }
    let next;
    let nextP;
    if (node.r) {
        next = findMin(node.r, node.d);
        nextP = next.k;
        remove(next);
        node.k = nextP;
    } else {
        next = findMin(node.l, node.d);
        nextP = next.k;
        remove(next);
        node.r = node.l;
        node.l = undefined;
        node.k = nextP;
    }
};
const nearest = (q, acc, dims, maxNum, node)=>{
    const p = node.k;
    const ndist = _distsq.distSq(p, q);
    if (!node.l && !node.r) {
        collect(acc, maxNum, node, ndist);
        return;
    }
    const tdist = nodeDist(node, dims, q, p);
    let best = bestChild(node, q);
    nearest(q, acc, dims, maxNum, best);
    collect(acc, maxNum, node, ndist);
    if (tdist < acc.values[0][0]) {
        best = best === node.l ? node.r : node.l;
        best && nearest(q, acc, dims, maxNum, best);
    }
};
/**
 * Optimized version of {@link nearest} for single closest point search.
 *
 * @param q - search point
 * @param acc - accumulator
 * @param dims - dimensions
 * @param node - tree node
 */ const nearest1 = (q, acc, dims, node)=>{
    const p = node.k;
    const ndist = _distsq.distSq(p, q);
    if (!node.l && !node.r) {
        collect1(acc, node, ndist);
        return acc;
    }
    const tdist = nodeDist(node, dims, q, p);
    let best = bestChild(node, q);
    nearest1(q, acc, dims, best);
    collect1(acc, node, ndist);
    if (tdist < acc[0]) {
        best = best === node.l ? node.r : node.l;
        best && nearest1(q, acc, dims, best);
    }
    return acc;
};
const bestChild = (node, q)=>{
    const d = node.d;
    return !node.r ? node.l : !node.l ? node.r : q[d] < node.k[d] ? node.l : node.r;
};
const collect = (acc, maxNum, node, ndist)=>(!acc.length || ndist < acc.peek()[0]) && (acc.length >= maxNum ? acc.pushPop([
        ndist,
        node
    ]) : acc.push([
        ndist,
        node
    ]))
;
const collect1 = (acc, node, ndist)=>ndist < acc[0] && (acc[0] = ndist, acc[1] = node)
;
const TMP = [];
const nodeDist = (node, dims, q, p)=>{
    for(let i = dims, d = node.d; i-- > 0;)TMP[i] = i === d ? q[i] : p[i];
    return _distsq.distSq(TMP, p);
};

},{"@thi.ng/arrays/ensure-array":"6Tcdc","@thi.ng/heaps/heap":"18spH","@thi.ng/math/api":"4a98p","@thi.ng/transducers/map":"fW6Xn","@thi.ng/vectors/distsq":"8XCdB","./utils.js":"9RX5K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Tcdc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ensureArray", ()=>ensureArray
);
parcelHelpers.export(exports, "ensureArrayLike", ()=>ensureArrayLike
);
var _isArray = require("@thi.ng/checks/is-array");
var _isArraylike = require("@thi.ng/checks/is-arraylike");
var _ensureIterableJs = require("./ensure-iterable.js");
const ensureArray = (x)=>_isArray.isArray(x) ? x : [
        ..._ensureIterableJs.ensureIterable(x)
    ]
;
const ensureArrayLike = (x)=>_isArraylike.isArrayLike(x) ? x : [
        ..._ensureIterableJs.ensureIterable(x)
    ]
;

},{"@thi.ng/checks/is-array":"cOR5q","@thi.ng/checks/is-arraylike":"8nYo2","./ensure-iterable.js":"cXcgx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cOR5q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isArray", ()=>isArray
);
const isArray = Array.isArray;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8nYo2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isArrayLike", ()=>isArrayLike
);
const isArrayLike = (x)=>x != null && typeof x !== "function" && x.length !== undefined
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cXcgx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ensureIterable", ()=>ensureIterable
);
var _illegalArguments = require("@thi.ng/errors/illegal-arguments");
const ensureIterable = (x)=>{
    (x == null || !x[Symbol.iterator]) && _illegalArguments.illegalArgs(`value is not iterable: ${x}`);
    return x;
};

},{"@thi.ng/errors/illegal-arguments":"co01S","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"co01S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IllegalArgumentError", ()=>IllegalArgumentError
);
parcelHelpers.export(exports, "illegalArgs", ()=>illegalArgs
);
var _deferrorJs = require("./deferror.js");
const IllegalArgumentError = _deferrorJs.defError(()=>"illegal argument(s)"
);
const illegalArgs = (msg)=>{
    throw new IllegalArgumentError(msg);
};

},{"./deferror.js":"l9nQt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l9nQt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defError", ()=>defError
);
const defError = (prefix, suffix = (msg)=>msg !== undefined ? ": " + msg : ""
)=>class extends Error {
        constructor(msg){
            super(prefix(msg) + suffix(msg));
        }
    }
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"18spH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defHeap", ()=>defHeap
);
/**
 * Generic binary heap / priority queue with customizable ordering via
 * user-supplied comparator. By default, implements min-heap ordering
 * and uses @thi.ng/compare.
 *
 * @example
 * ```ts
 * h = new Heap([20, 5, 10]);
 * h.push(15);
 *
 * h.pop(); // 5
 * h.pop(); // 10
 * h.pop(); // 15
 * h.pop(); // 20
 * h.pop(); // undefined
 * ```
 */ parcelHelpers.export(exports, "Heap", ()=>Heap
);
var _compare = require("@thi.ng/compare/compare");
var _equiv = require("@thi.ng/equiv");
const defHeap = (values, opts)=>new Heap(values, opts)
;
class Heap {
    constructor(values, opts){
        opts = {
            compare: _compare.compare,
            equiv: _equiv.equiv,
            ...opts
        };
        this.compare = opts.compare;
        this.equiv = opts.equiv;
        this.values = [];
        if (values) this.into(values);
    }
    static parentIndex(idx) {
        return idx > 0 ? idx - 1 >> 1 : -1;
    }
    static childIndex(idx) {
        return idx >= 0 ? (idx << 1) + 1 : -1;
    }
    *[Symbol.iterator]() {
        yield* this.min();
    }
    get length() {
        return this.values.length;
    }
    copy() {
        const h = this.empty();
        h.values = this.values.slice();
        return h;
    }
    clear() {
        this.values.length = 0;
    }
    empty() {
        return new Heap(null, {
            compare: this.compare
        });
    }
    peek() {
        return this.values[0];
    }
    push(val) {
        this.values.push(val);
        this.percolateUp(this.values.length - 1);
        return this;
    }
    pop() {
        const vals = this.values;
        const tail = vals.pop();
        let res;
        if (vals.length > 0) {
            res = vals[0];
            vals[0] = tail;
            this.percolateDown(0);
        } else res = tail;
        return res;
    }
    pushPop(val, vals = this.values) {
        const head = vals[0];
        if (vals.length > 0 && this.compare(head, val) <= 0) {
            vals[0] = val;
            val = head;
            this.percolateDown(0, vals);
        }
        return val;
    }
    into(vals) {
        for (let v of vals)this.push(v);
        return this;
    }
    /**
     * Calls {@link Heap.pushPop} for each given value in `vals` and
     * returns last result (i.e. the smallest value in heap after
     * processing all `vals`).
     *
     * @param vals - values to insert
     */ pushPopAll(vals) {
        let res;
        for (let v of vals)res = this.pushPop(v);
        return res;
    }
    replaceHead(val) {
        const res = this.values[0];
        this.values[0] = val;
        this.percolateDown(0);
        return res;
    }
    remove(val) {
        const { values , equiv  } = this;
        for(let i = values.length; i-- > 0;)if (equiv(values[i], val)) {
            this.values.splice(i, 1);
            this.heapify();
            return true;
        }
        return false;
    }
    find(val) {
        const { values , equiv  } = this;
        for(let i = values.length; i-- > 0;){
            if (equiv(values[i], val)) return values[i];
        }
    }
    findWith(pred) {
        const values = this.values;
        for(let i = values.length; i-- > 0;){
            if (pred(values[i])) return values[i];
        }
    }
    has(val) {
        return this.find(val) !== undefined;
    }
    heapify(vals = this.values) {
        for(let i = vals.length - 1 >> 1; i >= 0; i--)this.percolateDown(i, vals);
    }
    /**
     * Returns the largest `n` values (or less) in heap, based on
     * comparator ordering.
     *
     * @param n - number of values
     */ max(n = this.values.length) {
        const { compare , values  } = this;
        const res = values.slice(0, n);
        if (!n) return res;
        this.heapify(res);
        for(let m = values.length; n < m; n++)this.pushPop(values[n], res);
        return res.sort((a, b)=>compare(b, a)
        );
    }
    /**
     * Returns the smallest `n` values (or less) in heap, based on
     * comparator ordering.
     *
     * @param n - number of values
     */ min(n = this.values.length) {
        const { compare , values  } = this;
        const res = values.slice(0, n).sort(compare);
        if (!n) return res;
        let x = res[n - 1], y;
        for(let i = n, m = values.length; i < m; i++){
            y = values[i];
            if (compare(y, x) < 0) {
                res.splice(binarySearch(y, res, 0, n, compare), 0, y);
                res.pop();
                x = res[n - 1];
            }
        }
        return res;
    }
    parent(n) {
        n = Heap.parentIndex(n);
        return n >= 0 ? this.values[n] : undefined;
    }
    children(n) {
        n = Heap.childIndex(n);
        const vals = this.values;
        const m = vals.length;
        if (n >= m) return;
        if (n === m - 1) return [
            vals[n]
        ];
        return [
            vals[n],
            vals[n + 1]
        ];
    }
    leaves() {
        const vals = this.values;
        if (!vals.length) return [];
        return vals.slice(Heap.parentIndex(vals.length - 1) + 1);
    }
    percolateUp(i, vals = this.values) {
        const node = vals[i];
        const cmp = this.compare;
        while(i > 0){
            const pi = i - 1 >> 1;
            const parent = vals[pi];
            if (cmp(node, parent) >= 0) break;
            vals[pi] = node;
            vals[i] = parent;
            i = pi;
        }
    }
    percolateDown(i, vals = this.values) {
        const n = vals.length;
        const node = vals[i];
        const cmp = this.compare;
        let child = (i << 1) + 1;
        while(child < n){
            const next = child + 1;
            if (next < n && cmp(vals[child], vals[next]) >= 0) child = next;
            if (cmp(vals[child], node) < 0) vals[i] = vals[child];
            else break;
            i = child;
            child = (i << 1) + 1;
        }
        vals[i] = node;
    }
}
const binarySearch = (x, vals, lo, hi, cmp)=>{
    let m;
    while(lo < hi){
        m = lo + hi >>> 1;
        if (cmp(x, vals[m]) < 0) hi = m;
        else lo = m + 1;
    }
    return lo;
};

},{"@thi.ng/compare/compare":"5WIs8","@thi.ng/equiv":"e2rLA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5WIs8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compare", ()=>compare
);
const compare = (a, b)=>{
    if (a === b) return 0;
    if (a == null) return b == null ? 0 : -1;
    if (b == null) return a == null ? 0 : 1;
    if (typeof a.compare === "function") return a.compare(b);
    if (typeof b.compare === "function") return -b.compare(a);
    return a < b ? -1 : a > b ? 1 : 0;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e2rLA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "equiv", ()=>equiv
);
parcelHelpers.export(exports, "equivArrayLike", ()=>equivArrayLike
);
parcelHelpers.export(exports, "equivSet", ()=>equivSet
);
parcelHelpers.export(exports, "equivMap", ()=>equivMap
);
parcelHelpers.export(exports, "equivObject", ()=>equivObject
);
const OBJP = Object.getPrototypeOf({
});
const FN = "function";
const STR = "string";
const equiv = (a, b)=>{
    let proto;
    if (a === b) return true;
    if (a != null) {
        if (typeof a.equiv === FN) return a.equiv(b);
    } else return a == b;
    if (b != null) {
        if (typeof b.equiv === FN) return b.equiv(a);
    } else return a == b;
    if (typeof a === STR || typeof b === STR) return false;
    if ((proto = Object.getPrototypeOf(a), proto == null || proto === OBJP) && (proto = Object.getPrototypeOf(b), proto == null || proto === OBJP)) return equivObject(a, b);
    if (typeof a !== FN && a.length !== undefined && typeof b !== FN && b.length !== undefined) return equivArrayLike(a, b);
    if (a instanceof Set && b instanceof Set) return equivSet(a, b);
    if (a instanceof Map && b instanceof Map) return equivMap(a, b);
    if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();
    if (a instanceof RegExp && b instanceof RegExp) return a.toString() === b.toString();
    // NaN
    return a !== a && b !== b;
};
const equivArrayLike = (a, b, _equiv = equiv)=>{
    let l = a.length;
    if (l === b.length) {
        while(l-- > 0 && _equiv(a[l], b[l]));
    }
    return l < 0;
};
const equivSet = (a, b, _equiv = equiv)=>a.size === b.size && _equiv([
        ...a.keys()
    ].sort(), [
        ...b.keys()
    ].sort())
;
const equivMap = (a, b, _equiv = equiv)=>a.size === b.size && _equiv([
        ...a
    ].sort(), [
        ...b
    ].sort())
;
const equivObject = (a, b, _equiv = equiv)=>{
    if (Object.keys(a).length !== Object.keys(b).length) return false;
    for(let k in a){
        if (!b.hasOwnProperty(k) || !_equiv(a[k], b[k])) return false;
    }
    return true;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4a98p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PI", ()=>PI
);
parcelHelpers.export(exports, "TAU", ()=>TAU
);
parcelHelpers.export(exports, "HALF_PI", ()=>HALF_PI
);
parcelHelpers.export(exports, "THIRD_PI", ()=>THIRD_PI
);
parcelHelpers.export(exports, "QUARTER_PI", ()=>QUARTER_PI
);
parcelHelpers.export(exports, "SIXTH_PI", ()=>SIXTH_PI
);
parcelHelpers.export(exports, "INV_PI", ()=>INV_PI
);
parcelHelpers.export(exports, "INV_TAU", ()=>INV_TAU
);
parcelHelpers.export(exports, "INV_HALF_PI", ()=>INV_HALF_PI
);
parcelHelpers.export(exports, "DEG2RAD", ()=>DEG2RAD
);
parcelHelpers.export(exports, "RAD2DEG", ()=>RAD2DEG
);
parcelHelpers.export(exports, "PHI", ()=>PHI
);
parcelHelpers.export(exports, "SQRT2", ()=>SQRT2
);
parcelHelpers.export(exports, "SQRT3", ()=>SQRT3
);
parcelHelpers.export(exports, "SQRT2_2", ()=>SQRT2_2
);
parcelHelpers.export(exports, "SQRT3_2", ()=>SQRT3_2
);
parcelHelpers.export(exports, "THIRD", ()=>THIRD
);
parcelHelpers.export(exports, "TWO_THIRD", ()=>TWO_THIRD
);
parcelHelpers.export(exports, "SIXTH", ()=>SIXTH
);
parcelHelpers.export(exports, "EPS", ()=>EPS
);
const PI = Math.PI;
const TAU = PI * 2;
const HALF_PI = PI / 2;
const THIRD_PI = PI / 3;
const QUARTER_PI = PI / 4;
const SIXTH_PI = PI / 6;
const INV_PI = 1 / PI;
const INV_TAU = 1 / TAU;
const INV_HALF_PI = 1 / HALF_PI;
const DEG2RAD = PI / 180;
const RAD2DEG = 180 / PI;
const PHI = (1 + Math.sqrt(5)) / 2;
const SQRT2 = Math.SQRT2;
const SQRT3 = Math.sqrt(3);
const SQRT2_2 = SQRT2 / 2;
const SQRT3_2 = SQRT3 / 2;
const THIRD = 1 / 3;
const TWO_THIRD = 2 / 3;
const SIXTH = 1 / 6;
let EPS = 0.000001;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fW6Xn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "map", ()=>map
);
parcelHelpers.export(exports, "mapA", ()=>mapA
);
var _isIterable = require("@thi.ng/checks/is-iterable");
var _comprJs = require("./compr.js");
var _iteratorJs = require("./iterator.js");
function map(fn, src) {
    return _isIterable.isIterable(src) ? _iteratorJs.iterator1(map(fn), src) : (rfn)=>{
        const r = rfn[2];
        return _comprJs.compR(rfn, (acc, x)=>r(acc, fn(x))
        );
    };
}
const mapA = (fn, src)=>[
        ...map(fn, src), 
    ]
;

},{"@thi.ng/checks/is-iterable":"bDbbO","./compr.js":"ePFjm","./iterator.js":"8km8L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bDbbO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isIterable", ()=>isIterable
);
const isIterable = (x)=>x != null && typeof x[Symbol.iterator] === "function"
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ePFjm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compR", ()=>compR
);
const compR = (rfn, fn)=>[
        rfn[0],
        rfn[1],
        fn
    ]
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8km8L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Takes a transducer and input iterable. Returns iterator of
 * transformed results.
 *
 * @param xform -
 * @param xs -
 */ parcelHelpers.export(exports, "iterator", ()=>iterator
);
/**
 * Optimized version of {@link iterator} for transducers which are
 * guaranteed to:
 *
 * 1) Only produce none or a single result per input
 * 2) Do not require a `completion` reduction step
 *
 * @param xform -
 * @param xs -
 */ parcelHelpers.export(exports, "iterator1", ()=>iterator1
);
parcelHelpers.export(exports, "__iter", ()=>__iter
);
var _api = require("@thi.ng/api/api");
var _isIterable = require("@thi.ng/checks/is-iterable");
var _ensureJs = require("./ensure.js");
var _pushJs = require("./push.js");
var _reducedJs = require("./reduced.js");
function* iterator(xform, xs) {
    const rfn = _ensureJs.ensureTransducer(xform)(_pushJs.push());
    const complete = rfn[1];
    const reduce = rfn[2];
    for (let x of xs){
        const y = reduce([], x);
        if (_reducedJs.isReduced(y)) {
            yield* _reducedJs.unreduced(complete(y.deref()));
            return;
        }
        if (y.length) yield* y;
    }
    yield* _reducedJs.unreduced(complete([]));
}
function* iterator1(xform, xs) {
    const reduce = _ensureJs.ensureTransducer(xform)([
        _api.NO_OP,
        _api.NO_OP,
        (_, x)=>x
    ])[2];
    for (let x1 of xs){
        let y = reduce(_api.SEMAPHORE, x1);
        if (_reducedJs.isReduced(y)) {
            y = _reducedJs.unreduced(y.deref());
            if (y !== _api.SEMAPHORE) yield y;
            return;
        }
        if (y !== _api.SEMAPHORE) yield y;
    }
}
const __iter = (xform, args, impl = iterator1)=>{
    const n = args.length - 1;
    return _isIterable.isIterable(args[n]) ? args.length > 1 ? impl(xform.apply(null, args.slice(0, n)), args[n]) : impl(xform(), args[0]) : undefined;
};

},{"@thi.ng/api/api":"efej5","@thi.ng/checks/is-iterable":"bDbbO","./ensure.js":"lSMoA","./push.js":"8Qmga","./reduced.js":"cAjrZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"efej5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_EPS", ()=>DEFAULT_EPS
);
parcelHelpers.export(exports, "SEMAPHORE", ()=>SEMAPHORE
);
parcelHelpers.export(exports, "NO_OP", ()=>NO_OP
);
parcelHelpers.export(exports, "EVENT_ALL", ()=>EVENT_ALL
);
parcelHelpers.export(exports, "EVENT_ENABLE", ()=>EVENT_ENABLE
);
parcelHelpers.export(exports, "EVENT_DISABLE", ()=>EVENT_DISABLE
);
const DEFAULT_EPS = 0.000001;
const SEMAPHORE = Symbol();
const NO_OP = ()=>{
};
const EVENT_ALL = "*";
const EVENT_ENABLE = "enable";
const EVENT_DISABLE = "disable";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lSMoA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ensureTransducer", ()=>ensureTransducer
);
var _implementsFunction = require("@thi.ng/checks/implements-function");
const ensureTransducer = (x)=>_implementsFunction.implementsFunction(x, "xform") ? x.xform() : x
;

},{"@thi.ng/checks/implements-function":"cjrzK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cjrzK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "implementsFunction", ()=>implementsFunction
);
const implementsFunction = (x, fn)=>x != null && typeof x[fn] === "function"
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Qmga":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "push", ()=>push
);
var _reduceJs = require("./reduce.js");
function push(xs) {
    return xs ? [
        ...xs
    ] : _reduceJs.reducer(()=>[]
    , (acc, x)=>(acc.push(x), acc)
    );
}

},{"./reduce.js":"hP05c","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hP05c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "reduce", ()=>reduce
);
parcelHelpers.export(exports, "reduceRight", ()=>reduceRight
);
parcelHelpers.export(exports, "reducer", ()=>reducer
);
parcelHelpers.export(exports, "$$reduce", ()=>$$reduce
);
var _implementsFunction = require("@thi.ng/checks/implements-function");
var _isArraylike = require("@thi.ng/checks/is-arraylike");
var _isIterable = require("@thi.ng/checks/is-iterable");
var _illegalArity = require("@thi.ng/errors/illegal-arity");
var _reducedJs = require("./reduced.js");
const parseArgs = (args)=>args.length === 2 ? [
        undefined,
        args[1]
    ] : args.length === 3 ? [
        args[1],
        args[2]
    ] : _illegalArity.illegalArity(args.length)
;
function reduce(...args) {
    const rfn = args[0];
    const init = rfn[0];
    const complete = rfn[1];
    const reduce1 = rfn[2];
    args = parseArgs(args);
    const acc = args[0] == null ? init() : args[0];
    const xs = args[1];
    return _reducedJs.unreduced(complete(_implementsFunction.implementsFunction(xs, "$reduce") ? xs.$reduce(reduce1, acc) : _isArraylike.isArrayLike(xs) ? reduceArray(reduce1, acc, xs) : reduceIterable(reduce1, acc, xs)));
}
function reduceRight(...args) {
    const rfn = args[0];
    const init = rfn[0];
    const complete = rfn[1];
    const reduce2 = rfn[2];
    args = parseArgs(args);
    let acc = args[0] == null ? init() : args[0];
    const xs = args[1];
    for(let i = xs.length; i-- > 0;){
        acc = reduce2(acc, xs[i]);
        if (_reducedJs.isReduced(acc)) {
            acc = acc.deref();
            break;
        }
    }
    return _reducedJs.unreduced(complete(acc));
}
const reduceArray = (rfn, acc, xs)=>{
    for(let i = 0, n = xs.length; i < n; i++){
        acc = rfn(acc, xs[i]);
        if (_reducedJs.isReduced(acc)) {
            acc = acc.deref();
            break;
        }
    }
    return acc;
};
const reduceIterable = (rfn, acc, xs)=>{
    for (let x of xs){
        acc = rfn(acc, x);
        if (_reducedJs.isReduced(acc)) {
            acc = acc.deref();
            break;
        }
    }
    return acc;
};
const reducer = (init, rfn)=>[
        init,
        (acc)=>acc
        ,
        rfn
    ]
;
const $$reduce = (rfn, args)=>{
    const n = args.length - 1;
    return _isIterable.isIterable(args[n]) ? args.length > 1 ? reduce(rfn.apply(null, args.slice(0, n)), args[n]) : reduce(rfn(), args[0]) : undefined;
};

},{"@thi.ng/checks/implements-function":"cjrzK","@thi.ng/checks/is-arraylike":"8nYo2","@thi.ng/checks/is-iterable":"bDbbO","@thi.ng/errors/illegal-arity":"fOKRC","./reduced.js":"cAjrZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fOKRC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IllegalArityError", ()=>IllegalArityError
);
parcelHelpers.export(exports, "illegalArity", ()=>illegalArity
);
var _deferrorJs = require("./deferror.js");
const IllegalArityError = _deferrorJs.defError(()=>"illegal arity"
);
const illegalArity = (n)=>{
    throw new IllegalArityError(n);
};

},{"./deferror.js":"l9nQt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cAjrZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Reduced", ()=>Reduced
);
parcelHelpers.export(exports, "reduced", ()=>reduced
);
parcelHelpers.export(exports, "isReduced", ()=>isReduced
);
parcelHelpers.export(exports, "ensureReduced", ()=>ensureReduced
);
parcelHelpers.export(exports, "unreduced", ()=>unreduced
);
class Reduced {
    constructor(val){
        this.value = val;
    }
    deref() {
        return this.value;
    }
}
const reduced = (x)=>new Reduced(x)
;
const isReduced = (x)=>x instanceof Reduced
;
const ensureReduced = (x)=>x instanceof Reduced ? x : new Reduced(x)
;
const unreduced = (x)=>x instanceof Reduced ? x.deref() : x
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8XCdB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distSq", ()=>distSq
);
parcelHelpers.export(exports, "distSq2", ()=>distSq2
);
parcelHelpers.export(exports, "distSq3", ()=>distSq3
);
parcelHelpers.export(exports, "distSq4", ()=>distSq4
);
var _emitJs = require("./compile/emit.js");
var _vopJs = require("./vop.js");
const tpl = ([a, b])=>`t=${a}-${b};s+=t*t;`
;
const pre = "let t,s=0;";
const $ = (dim)=>distSq.add(dim, _emitJs.compile(dim, tpl, "a,b", undefined, "s", "", pre))
;
const distSq = _vopJs.vop();
distSq.default(_emitJs.compileG(tpl, "a,b", undefined, "s", pre));
const distSq2 = $(2);
const distSq3 = $(3);
const distSq4 = $(4);

},{"./compile/emit.js":"hpIek","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hpIek":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultOut", ()=>defaultOut
);
parcelHelpers.export(exports, "compile", ()=>compile
);
parcelHelpers.export(exports, "compileHOF", ()=>compileHOF
);
parcelHelpers.export(exports, "compileG", ()=>compileG
);
parcelHelpers.export(exports, "compileS", ()=>compileS
);
parcelHelpers.export(exports, "compileGHOF", ()=>compileGHOF
);
parcelHelpers.export(exports, "defOp", ()=>defOp
);
parcelHelpers.export(exports, "defFnOp", ()=>defFnOp
);
parcelHelpers.export(exports, "defHofOp", ()=>defHofOp
);
parcelHelpers.export(exports, "defOpS", ()=>defOpS
);
parcelHelpers.export(exports, "defHofOpS", ()=>defHofOpS
);
parcelHelpers.export(exports, "defMathOp", ()=>defMathOp
);
parcelHelpers.export(exports, "defMathOpN", ()=>defMathOpN
);
parcelHelpers.export(exports, "defBitOp", ()=>defBitOp
);
parcelHelpers.export(exports, "defBitOpN", ()=>defBitOpN
);
var _comp = require("@thi.ng/transducers/comp");
var _map = require("@thi.ng/transducers/map");
var _mapIndexed = require("@thi.ng/transducers/map-indexed");
var _range = require("@thi.ng/transducers/range");
var _str = require("@thi.ng/transducers/str");
var _take = require("@thi.ng/transducers/take");
var _transduce = require("@thi.ng/transducers/transduce");
var _zip = require("@thi.ng/transducers/zip");
var _vopJs = require("../vop.js");
var _templatesJs = require("./templates.js");
/**
 * HOF array index lookup gen to provide optimized versions of:
 *
 * @example
 * ```ts
 * lookup("a")(0) // a[ia]
 * lookup("a")(1) // a[ia * sa]
 * lookup("a")(2) // a[ia + 2 * sa]
 * ```
 *
 * @param sym -
 */ const lookup = (sym)=>(i)=>i > 1 ? `${sym}[i${sym}+${i}*s${sym}]` : i == 1 ? `${sym}[i${sym}+s${sym}]` : `${sym}[i${sym}]`
;
/**
 * Infinite iterator of strided index lookups for `sym`.
 *
 * @param sym -
 */ const indicesStrided = (sym)=>_map.map(lookup(sym), _range.range())
;
/**
 * Infinite iterator of simple (non-strided) index lookups for `sym`.
 *
 * @param sym -
 */ const indices = (sym)=>_map.map((i)=>`${sym}[${i}]`
    , _range.range())
;
/**
 * Code generator for loop-unrolled vector operations. Takes a vector
 * size `dim`, a code template function `tpl` and an array of symbol
 * names participating in the template. For each symbol, creates
 * iterator of index lookups (e.g. `a[0]` or `a[ia+k*sa]`), forms them
 * into tuples and passes them to template to generate code and joins
 * generated result with `opJoin` separator (default:
 * `""`).
 *
 * If the optional `ret` arg is not `null` (default `"a"`), appends a
 * `return` statement to the result array, using `ret` as return value.
 * Returns array of source code lines.
 *
 * The optional `pre` and `post` strings can be used to wrap the
 * generated code. `post` will be injected **before** the generated
 * return statement (if not suppressed).
 *
 * @param dim -
 * @param tpl -
 * @param syms -
 * @param ret -
 * @param opJoin -
 * @param pre -
 * @param post -
 * @param strided -
 */ const assemble = (dim, tpl, syms, ret = "a", opJoin = "", pre = "", post = "", strided = false)=>[
        pre,
        _transduce.transduce(_comp.comp(_take.take(dim), _mapIndexed.mapIndexed((i, x)=>tpl(x, i)
        )), _str.str(opJoin), _zip.zip.apply(null, syms.split(",").map(strided ? indicesStrided : indices))),
        post,
        ret !== "" ? `return ${ret};` : "", 
    ]
;
const assembleG = (tpl, syms, ret = "a", pre, post, strided = false)=>[
        pre,
        "for(let i=a.length;--i>=0;) {",
        tpl(syms.split(",").map(strided ? (x)=>`${x}[i${x}+i*s${x}]`
         : (x)=>`${x}[i]`
        )),
        "}",
        post,
        ret !== null ? `return ${ret};` : "", 
    ]
;
const assembleS = (tpl, syms = _templatesJs.ARGS_VV, ret = "o", pre = _templatesJs.DEFAULT_OUT, post)=>[
        pre,
        "while(k-->0) {",
        tpl(syms.split(",").map((x)=>`${x}[i${x}+k*s${x}]`
        )),
        "}",
        post,
        ret !== null ? `return ${ret};` : "", 
    ]
;
const defaultOut = (o, args)=>`!${o} && (${o}=${args.split(",")[1]});`
;
const compile = (dim, tpl, args, syms = args, ret = "a", opJoin, pre, post, strided = false)=>new Function(args, assemble(dim, tpl, syms, ret, opJoin, pre, post, strided).join(""))
;
const compileHOF = (dim, fns, tpl, hofArgs, args, syms = args, ret = "a", opJoin = "", pre, post, strided = false)=>{
    return new Function(hofArgs, `return (${args})=>{${assemble(dim, tpl, syms, ret, opJoin, pre, post, strided).join("")}}`)(...fns);
};
const compileG = (tpl, args, syms = args, ret = "a", pre, post, strided = false)=>new Function(args, assembleG(tpl, syms, ret, pre, post, strided).join(""))
;
const compileS = (tpl, args, syms = args, ret, pre, post)=>new Function(args, assembleS(tpl, syms, ret, pre, post).join(""))
;
const compileGHOF = (fns, tpl, hofArgs, args, syms = args, ret = "a", pre, post, strided = false)=>new Function(hofArgs, `return (${args})=>{${assembleG(tpl, syms, ret, pre, post, strided).join("")}}`)(...fns)
;
const defOp = (tpl, args = _templatesJs.ARGS_VV, syms, ret = "o", dispatch = 1, pre)=>{
    syms = syms || args;
    pre = pre != null ? pre : defaultOut(ret, args);
    const fn = _vopJs.vop(dispatch);
    const $ = (dim)=>fn.add(dim, compile(dim, tpl, args, syms, ret, "", pre))
    ;
    fn.default(compileG(tpl, args, syms, ret, pre));
    return [
        fn,
        $(2),
        $(3),
        $(4)
    ];
};
const defFnOp = (op)=>defOp(_templatesJs.FN(op), _templatesJs.ARGS_V)
;
const defHofOp = (op, tpl, args = _templatesJs.ARGS_V, syms, ret = "o", dispatch = 1, pre)=>{
    const _tpl = tpl || _templatesJs.FN("op");
    syms = syms || args;
    pre = pre != null ? pre : defaultOut(ret, args);
    const fn = _vopJs.vop(dispatch);
    const $ = (dim)=>fn.add(dim, compileHOF(dim, [
            op
        ], _tpl, "op", args, syms, ret, "", pre))
    ;
    fn.default(compileGHOF([
        op
    ], _tpl, "op", args, syms, ret, pre));
    return [
        fn,
        $(2),
        $(3),
        $(4)
    ];
};
const defOpS = (tpl, args = _templatesJs.ARGS_VV, idxArgs = _templatesJs.SARGS_VV, syms = _templatesJs.ARGS_VV, ret = "o", pre, sizes = [
    2,
    3,
    4
])=>[
        compileS(tpl, `${args},k,${idxArgs}`, syms, ret, pre),
        ...sizes.map((dim)=>compile(dim, tpl, `${args},${idxArgs}`, syms, ret, "", pre != null ? pre : defaultOut(ret, args), "", true)
        ), 
    ]
;
const defHofOpS = (op, tpl, args = _templatesJs.ARGS_VV, idxArgs = _templatesJs.SARGS_VV, syms = _templatesJs.ARGS_VV, ret = "o", pre, sizes = [
    2,
    3,
    4
])=>[
        new Function("op", `return (${args},k,${idxArgs})=>{${assembleS(tpl, syms, ret, pre).join("")}}`)(op),
        ...sizes.map((dim)=>compileHOF(dim, [
                op
            ], tpl, "op", `${args},${idxArgs}`, syms, ret, "", pre != null ? pre : defaultOut(ret, args), "", true)
        ), 
    ]
;
const defMathOp = (op)=>defOp(_templatesJs.MATH(op))
;
const defMathOpN = (op)=>defOp(_templatesJs.MATH_N(op), _templatesJs.ARGS_VN)
;
const defBitOp = (op, signed = false)=>defOp((signed ? _templatesJs.SIGNED : _templatesJs.UNSIGNED)(op))
;
const defBitOpN = (op, signed = false)=>defOp((signed ? _templatesJs.SIGNED_N : _templatesJs.UNSIGNED_N)(op), _templatesJs.ARGS_VN)
;

},{"@thi.ng/transducers/comp":"7g4yM","@thi.ng/transducers/map":"fW6Xn","@thi.ng/transducers/map-indexed":"feveV","@thi.ng/transducers/range":"lUHc9","@thi.ng/transducers/str":"9x5I6","@thi.ng/transducers/take":"cr3ZD","@thi.ng/transducers/transduce":"1Ttho","@thi.ng/transducers/zip":"ithYS","../vop.js":"4v2k5","./templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7g4yM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "comp", ()=>comp
);
var _comp = require("@thi.ng/compose/comp");
var _ensureJs = require("./ensure.js");
function comp(...fns) {
    fns = fns.map(_ensureJs.ensureTransducer);
    return _comp.comp.apply(null, fns);
}

},{"@thi.ng/compose/comp":"87ham","./ensure.js":"lSMoA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"87ham":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "comp", ()=>comp
);
parcelHelpers.export(exports, "compL", ()=>compL
);
parcelHelpers.export(exports, "compI", ()=>compI
);
var _illegalArity = require("@thi.ng/errors/illegal-arity");
function comp(...fns) {
    let [a, b, c, d, e, f, g, h, i, j] = fns;
    switch(fns.length){
        case 0:
            _illegalArity.illegalArity(0);
        case 1:
            return a;
        case 2:
            return (...xs)=>a(b(...xs))
            ;
        case 3:
            return (...xs)=>a(b(c(...xs)))
            ;
        case 4:
            return (...xs)=>a(b(c(d(...xs))))
            ;
        case 5:
            return (...xs)=>a(b(c(d(e(...xs)))))
            ;
        case 6:
            return (...xs)=>a(b(c(d(e(f(...xs))))))
            ;
        case 7:
            return (...xs)=>a(b(c(d(e(f(g(...xs)))))))
            ;
        case 8:
            return (...xs)=>a(b(c(d(e(f(g(h(...xs))))))))
            ;
        case 9:
            return (...xs)=>a(b(c(d(e(f(g(h(i(...xs)))))))))
            ;
        case 10:
        default:
            const fn = (...xs)=>a(b(c(d(e(f(g(h(i(j(...xs))))))))))
            ;
            return fns.length === 10 ? fn : comp(fn, ...fns.slice(10));
    }
}
function compL(...fns) {
    return comp.apply(null, fns.reverse());
}
const compI = compL;

},{"@thi.ng/errors/illegal-arity":"fOKRC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"feveV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapIndexed", ()=>mapIndexed
);
var _comprJs = require("./compr.js");
var _iteratorJs = require("./iterator.js");
function mapIndexed(...args) {
    return _iteratorJs.__iter(mapIndexed, args) || ((rfn)=>{
        const r = rfn[2];
        const fn = args[0];
        let i = args[1] || 0;
        return _comprJs.compR(rfn, (acc, x)=>r(acc, fn(i++, x))
        );
    });
}

},{"./compr.js":"ePFjm","./iterator.js":"8km8L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lUHc9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "range", ()=>range
);
/**
 * Simple class wrapper around given range interval and implementing
 * `Iterable` and {@link IReducible} interfaces, the latter is used to
 * accelerate use with {@link (reduce:1)}.
 */ parcelHelpers.export(exports, "Range", ()=>Range
);
var _reducedJs = require("./reduced.js");
function range(from, to, step) {
    return new Range(from, to, step);
}
class Range {
    constructor(from, to, step){
        if (from === undefined) {
            from = 0;
            to = Infinity;
        } else if (to === undefined) {
            to = from;
            from = 0;
        }
        step = step === undefined ? from < to ? 1 : -1 : step;
        this.from = from;
        this.to = to;
        this.step = step;
    }
    *[Symbol.iterator]() {
        let { from , to , step  } = this;
        if (step > 0) while(from < to){
            yield from;
            from += step;
        }
        else if (step < 0) while(from > to){
            yield from;
            from += step;
        }
    }
    $reduce(rfn, acc) {
        const step = this.step;
        if (step > 0) for(let i = this.from, n = this.to; i < n && !_reducedJs.isReduced(acc); i += step)acc = rfn(acc, i);
        else for(let i1 = this.from, n1 = this.to; i1 > n1 && !_reducedJs.isReduced(acc); i1 += step)acc = rfn(acc, i1);
        return acc;
    }
}

},{"./reduced.js":"cAjrZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9x5I6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "str", ()=>str
);
var _reduceJs = require("./reduce.js");
function str(sep, xs) {
    sep = sep || "";
    let first = true;
    return xs ? [
        ...xs
    ].join(sep) : _reduceJs.reducer(()=>""
    , (acc, x)=>(acc = first ? acc + x : acc + sep + x, first = false, acc)
    );
}

},{"./reduce.js":"hP05c","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cr3ZD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "take", ()=>take
);
var _isIterable = require("@thi.ng/checks/is-iterable");
var _comprJs = require("./compr.js");
var _iteratorJs = require("./iterator.js");
var _reducedJs = require("./reduced.js");
function take(n, src) {
    return _isIterable.isIterable(src) ? _iteratorJs.iterator(take(n), src) : (rfn)=>{
        const r = rfn[2];
        let m = n;
        return _comprJs.compR(rfn, (acc, x)=>--m > 0 ? r(acc, x) : m === 0 ? _reducedJs.ensureReduced(r(acc, x)) : _reducedJs.reduced(acc)
        );
    };
}

},{"@thi.ng/checks/is-iterable":"bDbbO","./compr.js":"ePFjm","./iterator.js":"8km8L","./reduced.js":"cAjrZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Ttho":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transduce", ()=>transduce
);
parcelHelpers.export(exports, "transduceRight", ()=>transduceRight
);
var _illegalArity = require("@thi.ng/errors/illegal-arity");
var _ensureJs = require("./ensure.js");
var _mapJs = require("./map.js");
var _reduceJs = require("./reduce.js");
function transduce(...args) {
    return $transduce(transduce, _reduceJs.reduce, args);
}
function transduceRight(...args) {
    return $transduce(transduceRight, _reduceJs.reduceRight, args);
}
const $transduce = (tfn, rfn, args)=>{
    let acc, xs;
    switch(args.length){
        case 4:
            xs = args[3];
            acc = args[2];
            break;
        case 3:
            xs = args[2];
            break;
        case 2:
            return _mapJs.map((x)=>tfn(args[0], args[1], x)
            );
        default:
            _illegalArity.illegalArity(args.length);
    }
    return rfn(_ensureJs.ensureTransducer(args[0])(args[1]), acc, xs);
};

},{"@thi.ng/errors/illegal-arity":"fOKRC","./ensure.js":"lSMoA","./map.js":"fW6Xn","./reduce.js":"hP05c","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ithYS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "zip", ()=>zip
);
function* zip(...src) {
    const iters = src.map((s)=>s[Symbol.iterator]()
    );
    while(true){
        const tuple = [];
        for (let i of iters){
            let v = i.next();
            if (v.done) return;
            tuple.push(v.value);
        }
        yield tuple;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4v2k5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "vop", ()=>vop
);
var _unsupported = require("@thi.ng/errors/unsupported");
const vop = (dispatch = 0)=>{
    const impls = new Array(5);
    let fallback;
    const fn1 = (...args)=>{
        const g = impls[args[dispatch].length] || fallback;
        return g ? g(...args) : _unsupported.unsupported(`no impl for vec size ${args[dispatch].length}`);
    };
    fn1.add = (dim, fn)=>impls[dim] = fn
    ;
    fn1.default = (fn)=>fallback = fn
    ;
    fn1.impl = (dim)=>impls[dim] || fallback
    ;
    // fn.impls = impls;
    return fn1;
};

},{"@thi.ng/errors/unsupported":"dDHMM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dDHMM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnsupportedOperationError", ()=>UnsupportedOperationError
);
parcelHelpers.export(exports, "unsupported", ()=>unsupported
);
var _deferrorJs = require("./deferror.js");
const UnsupportedOperationError = _deferrorJs.defError(()=>"unsupported operation"
);
const unsupported = (msg)=>{
    throw new UnsupportedOperationError(msg);
};

},{"./deferror.js":"l9nQt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1B2Pe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ARGS_V", ()=>ARGS_V
);
parcelHelpers.export(exports, "ARGS_VV", ()=>ARGS_VV
);
parcelHelpers.export(exports, "ARGS_VVV", ()=>ARGS_VVV
);
parcelHelpers.export(exports, "ARGS_VN", ()=>ARGS_VN
);
parcelHelpers.export(exports, "ARGS_VNV", ()=>ARGS_VNV
);
parcelHelpers.export(exports, "ARGS_VVN", ()=>ARGS_VVN
);
parcelHelpers.export(exports, "SARGS_V", ()=>SARGS_V
);
parcelHelpers.export(exports, "SARGS_VV", ()=>SARGS_VV
);
parcelHelpers.export(exports, "SARGS_VVV", ()=>SARGS_VVV
);
parcelHelpers.export(exports, "DEFAULT_OUT", ()=>DEFAULT_OUT
);
parcelHelpers.export(exports, "NEW_OUT", ()=>NEW_OUT
);
parcelHelpers.export(exports, "NEW_OUT_A", ()=>NEW_OUT_A
);
parcelHelpers.export(exports, "MATH", ()=>MATH
);
parcelHelpers.export(exports, "MATH_N", ()=>MATH_N
);
parcelHelpers.export(exports, "MATH2", ()=>MATH2
);
parcelHelpers.export(exports, "MATH2_N", ()=>MATH2_N
);
parcelHelpers.export(exports, "MATH2A_N", ()=>MATH2A_N
);
parcelHelpers.export(exports, "SIGNED", ()=>SIGNED
);
parcelHelpers.export(exports, "UNSIGNED", ()=>UNSIGNED
);
parcelHelpers.export(exports, "SIGNED_N", ()=>SIGNED_N
);
parcelHelpers.export(exports, "UNSIGNED_N", ()=>UNSIGNED_N
);
parcelHelpers.export(exports, "FN", ()=>FN
);
parcelHelpers.export(exports, "FN2", ()=>FN2
);
parcelHelpers.export(exports, "FN3", ()=>FN3
);
parcelHelpers.export(exports, "FN5", ()=>FN5
);
parcelHelpers.export(exports, "FN_N", ()=>FN_N
);
parcelHelpers.export(exports, "DOT", ()=>DOT
);
parcelHelpers.export(exports, "DOT_G", ()=>DOT_G
);
parcelHelpers.export(exports, "SET", ()=>SET
);
parcelHelpers.export(exports, "SET_N", ()=>SET_N
);
parcelHelpers.export(exports, "MIX", ()=>MIX
);
parcelHelpers.export(exports, "MIX_N", ()=>MIX_N
);
const ARGS_V = "o,a";
const ARGS_VV = "o,a,b";
const ARGS_VVV = "o,a,b,c";
const ARGS_VN = "o,a,n";
const ARGS_VNV = "o,a,n,b";
const ARGS_VVN = "o,a,b,n";
const SARGS_V = "io=0,ia=0,so=1,sa=1";
const SARGS_VV = "io=0,ia=0,ib=0,so=1,sa=1,sb=1";
const SARGS_VVV = "io=0,ia=0,ib=0,ic=0,so=1,sa=1,sb=1,sc=1";
const DEFAULT_OUT = "!o&&(o=a);";
const NEW_OUT = "!o&&(o=[]);";
const NEW_OUT_A = "!a&&(a=[]);";
const MATH = (op)=>([o, a, b])=>`${o}=${a}${op}${b};`
;
const MATH_N = (op)=>([o, a])=>`${o}=${a}${op}n;`
;
const MATH2 = (op1, op2)=>([o, a, b, c])=>`${o}=(${a}${op1}${b})${op2}${c};`
;
const MATH2_N = (op1, op2)=>([o, a, b])=>`${o}=(${a}${op1}${b})${op2}n;`
;
const MATH2A_N = (op1, op2)=>([o, a, b])=>`${o}=(${a}${op1}n)${op2}${b};`
;
const SIGNED = (op)=>([o, a, b])=>`${o}=(${a}${op}${b})|0;`
;
const UNSIGNED = (op)=>([o, a, b])=>`${o}=(${a}${op}${b})>>>0;`
;
const SIGNED_N = (op)=>([o, a])=>`${o}=(${a}${op}n)|0;`
;
const UNSIGNED_N = (op)=>([o, a])=>`${o}=(${a}${op}n)>>>0;`
;
const FN = (op = "op")=>([o, a])=>`${o}=${op}(${a});`
;
const FN2 = (op = "op")=>([o, a, b])=>`${o}=${op}(${a},${b});`
;
const FN3 = (op = "op")=>([o, a, b, c])=>`${o}=${op}(${a},${b},${c});`
;
const FN5 = (op = "op")=>([o, a, b, c, d, e])=>`${o}=${op}(${a},${b},${c},${d},${e});`
;
const FN_N = (op = "op")=>([o, a])=>`${o}=${op}(${a},n);`
;
const DOT = ([a, b])=>`${a}*${b}`
;
const DOT_G = ([a, b])=>`s+=${a}*${b};`
;
const SET = ([o, a])=>`${o}=${a};`
;
const SET_N = ([a])=>`${a}=n;`
;
const MIX = ([o, a, b, c])=>`${o}=${a}+(${b}-${a})*${c};`
;
const MIX_N = ([o, a, b])=>`${o}=${a}+(${b}-${a})*n;`
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9RX5K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CMP", ()=>CMP
);
parcelHelpers.export(exports, "addResults", ()=>addResults
);
parcelHelpers.export(exports, "into", ()=>into
);
const CMP = (a, b)=>b[0] - a[0]
;
const addResults = (fn, sel, acc)=>{
    for(let n = sel.sort(CMP).length; n-- > 0;){
        const s = sel[n][1];
        s && acc.push(fn(s));
    }
    return acc;
};
const into = (map, pairs, eps)=>{
    let ok = true;
    for (let p of pairs)ok = map.set(p[0], p[1], eps) && ok;
    return ok;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5eyOc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KdTreeSet", ()=>KdTreeSet
);
var _kdTreeMapJs = require("./kd-tree-map.js");
class KdTreeSet {
    constructor(dim, keys){
        this.tree = new _kdTreeMapJs.KdTreeMap(dim);
        keys && this.into(keys);
    }
    [Symbol.iterator]() {
        return this.tree.keys();
    }
    keys() {
        return this.tree.keys();
    }
    values() {
        return this.tree.keys();
    }
    get size() {
        return this.tree.size;
    }
    get height() {
        return this.tree.height;
    }
    get ratio() {
        return this.tree.ratio;
    }
    copy() {
        return new KdTreeSet(this.tree.dim, this);
    }
    clear() {
        this.tree.clear();
    }
    empty() {
        return new KdTreeSet(this.tree.dim);
    }
    add(key, eps) {
        return this.tree.set(key, key, eps);
    }
    into(ks, eps) {
        let ok = true;
        for (let k of ks)ok = this.tree.set(k, k, eps) && ok;
        return ok;
    }
    remove(key) {
        return this.tree.remove(key);
    }
    has(key, eps) {
        return this.tree.has(key, eps);
    }
    get(key, eps) {
        return this.tree.get(key, eps);
    }
    query(q, maxDist, limit, acc) {
        return this.tree.query(q, maxDist, limit, acc);
    }
    queryKeys(q, maxDist, limit, acc) {
        return this.tree.queryKeys(q, maxDist, limit, acc);
    }
    queryValues(q, maxDist, limit, acc) {
        return this.tree.queryKeys(q, maxDist, limit, acc);
    }
}

},{"./kd-tree-map.js":"7aH1S","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5mrju":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NdQtNode", ()=>NdQtNode
);
/**
 * Point-based quadtree for nD keys and optional value association.
 * Supports radial range queries and key removal with tree pruning. See
 * {@link ndQuadtreeFromMinMax}.
 *
 * @remarks
 * Partially ported from Clojure version of {@link http://thi.ng/geom}.
 */ parcelHelpers.export(exports, "NdQuadtreeMap", ()=>NdQuadtreeMap
);
var _equiv = require("@thi.ng/equiv");
var _assert = require("@thi.ng/errors/assert");
var _point = require("@thi.ng/geom-isec/point");
var _rectCircle = require("@thi.ng/geom-isec/rect-circle");
var _heap = require("@thi.ng/heaps/heap");
var _api = require("@thi.ng/math/api");
var _iterate = require("@thi.ng/transducers/iterate");
var _map = require("@thi.ng/transducers/map");
var _permutations = require("@thi.ng/transducers/permutations");
var _repeat = require("@thi.ng/transducers/repeat");
var _take = require("@thi.ng/transducers/take");
var _addmn = require("@thi.ng/vectors/addmn");
var _distsq = require("@thi.ng/vectors/distsq");
var _madd = require("@thi.ng/vectors/madd");
var _muln = require("@thi.ng/vectors/muln");
var _submn = require("@thi.ng/vectors/submn");
var _vop = require("@thi.ng/vectors/vop");
var _utilsJs = require("./utils.js");
class NdQtNode {
    constructor(parent, pos, ext){
        this.parent = parent;
        this.pos = pos;
        this.ext = ext;
        this.numC = 0;
    }
    clear() {
        delete this.children;
        delete this.k;
        delete this.v;
        this.numC = 0;
    }
    set(p, val, eps) {
        return (eps <= 0 || !this.queryKeys(p, eps, 1, []).length) && this.containsPoint(p) && this.setUnsafe(p, val);
    }
    setUnsafe(p, val) {
        if (this.k) {
            if (_equiv.equivArrayLike(this.k, p)) {
                this.v = val;
                return false;
            }
            this.ensureChild(childID(this.k, this.pos)).setUnsafe(this.k, this.v);
            delete this.k;
            delete this.v;
        }
        if (this.children) return this.ensureChild(childID(p, this.pos)).setUnsafe(p, val);
        else {
            this.k = p;
            this.v = val;
        }
        return true;
    }
    query(fn, p, r, max, acc) {
        return _utilsJs.addResults(fn, this.doQuery(p, r, max, new _heap.Heap([
            [
                r * r
            ]
        ], {
            compare: _utilsJs.CMP
        })).values, acc);
    }
    queryKeys(p, r, max, acc) {
        return this.query((n)=>n.k
        , p, r, max, acc);
    }
    queryValues(p, r, max, acc) {
        return this.query((n)=>n.v
        , p, r, max, acc);
    }
    containsPoint(p) {
        return _point.pointInCenteredBox(p, this.pos, this.ext);
    }
    nodeForPoint(p) {
        if (this.k && _equiv.equivArrayLike(this.k, p)) return this;
        if (this.children) {
            const child = this.children[childID(p, this.pos)];
            return child ? child.nodeForPoint(p) : undefined;
        }
    }
    doQuery(p, r, max, acc) {
        if (_rectCircle.testCenteredBoxSphere(this.pos, this.ext, p, r)) {
            if (this.k) {
                const d = _distsq.distSq(this.k, p);
                if (d <= acc.values[0][0]) acc.length >= max ? acc.pushPop([
                    d,
                    this
                ]) : acc.push([
                    d,
                    this
                ]);
            } else if (this.children) {
                for(let i = MAX_CHILDREN[this.pos.length], j = this.numC; i-- > 0 && j > 0;)if (this.children[i]) {
                    this.children[i].doQuery(p, r, max, acc);
                    j--;
                }
            }
        }
        return acc;
    }
    ensureChild(id) {
        !this.children && (this.children = []);
        let c = this.children[id];
        if (!c) {
            const csize = _muln.mulN([], this.ext, 0.5);
            this.children[id] = c = new NdQtNode(this, _madd.madd([], csize, CHILD_OFFSETS[csize.length][id], this.pos), csize);
            this.numC++;
        }
        return c;
    }
}
class NdQuadtreeMap {
    constructor(pos, ext, pairs){
        const dim = pos.length;
        _assert.assert(dim > 0 && dim <= NdQuadtreeMap.MAX_DIM, `illegal dimension: ${dim}`);
        _assert.assert(ext.length === dim, `pos/ext dimensions must be equal`);
        initChildOffsets(dim);
        this.root = new NdQtNode(undefined, pos, ext);
        this._size = 0;
        pairs && this.into(pairs, -1);
    }
    /**
     * Returns a new point-based `NdQuadtreeMap` for nD keys in given
     * region defined by `min` / `max` coordinates. The dimensionality
     * of the tree is implicitly defined by the provided coordinates.
     * Only points within that region can be indexed.
     *
     * @remarks
     * Due to exponentially growing lookup tables, currently only
     * supports up to 16 dimensions.
     */ static fromMinMax(min, max) {
        return new NdQuadtreeMap(_addmn.addmN([], min, max, 0.5), _submn.submN([], max, min, 0.5));
    }
    get size() {
        return this._size;
    }
    [Symbol.iterator]() {
        return _map.map((n)=>[
                n.k,
                n.v
            ]
        , this.nodes());
    }
    keys() {
        return _map.map((n)=>n.k
        , this.nodes());
    }
    values() {
        return _map.map((n)=>n.v
        , this.nodes());
    }
    *nodes(all = false) {
        let queue = [
            this.root
        ];
        while(queue.length){
            const n = queue.pop();
            if (n) {
                if (all || n.k) yield n;
                if (n.children) queue = queue.concat(n.children);
            }
        }
    }
    copy() {
        const tree = new NdQuadtreeMap(this.root.pos, this.root.ext, this);
        return tree;
    }
    clear() {
        this.root.clear();
        this._size = 0;
    }
    empty() {
        return new NdQuadtreeMap(this.root.pos, this.root.ext);
    }
    set(key, val, eps = _api.EPS) {
        if (this.root.set(key, val, eps)) {
            this._size++;
            return true;
        }
        return false;
    }
    into(pairs, eps = _api.EPS) {
        return _utilsJs.into(this, pairs, eps);
    }
    remove(p) {
        let node = this.root.nodeForPoint(p);
        if (!node) return false;
        this._size--;
        delete node.k;
        delete node.v;
        let doPrune = true;
        while(node.parent){
            node = node.parent;
            delete node.children[childID(p, node.pos)];
            doPrune = --node.numC === 0;
            if (doPrune) delete node.children;
            else break;
        }
        return true;
    }
    has(p, eps = _api.EPS) {
        return !!(eps <= 0 ? this.root.nodeForPoint(p) : this.root.queryKeys(p, eps, 1, []).length);
    }
    get(p, eps = _api.EPS) {
        if (eps <= 0) {
            const node = this.root.nodeForPoint(p);
            return node ? node.v : undefined;
        }
        return this.root.queryValues(p, eps, 1, [])[0];
    }
    query(p, r, max = 1, acc = []) {
        return this.root.query((n)=>[
                n.k,
                n.v
            ]
        , p, r, max, acc);
    }
    queryKeys(p, r, max = 1, acc = []) {
        return this.root.queryKeys(p, r, max, acc);
    }
    queryValues(p, r, max = 1, acc = []) {
        return this.root.queryValues(p, r, max, acc);
    }
    containsPoint(p) {
        return this.root.containsPoint(p);
    }
    nodeForPoint(p) {
        return this.root.nodeForPoint(p);
    }
}
NdQuadtreeMap.MAX_DIM = 16;
const MAX_CHILDREN = [
    ..._take.take(NdQuadtreeMap.MAX_DIM + 1, _iterate.iterate((x)=>x * 2
    , 1)), 
];
const CHILD_OFFSETS = [];
const initChildOffsets = (dim)=>CHILD_OFFSETS[dim] || (CHILD_OFFSETS[dim] = [
        ..._permutations.permutations(..._repeat.repeat([
            -1,
            1
        ], dim))
    ])
;
const childID = _vop.vop(0);
childID.add(1, (p, q)=>p[0] >= q[0] ? 1 : 0
);
childID.add(2, (p, q)=>(p[0] >= q[0] ? 2 : 0) | (p[1] >= q[1] ? 1 : 0)
);
childID.add(3, (p, q)=>(p[0] >= q[0] ? 4 : 0) | (p[1] >= q[1] ? 2 : 0) | (p[2] >= q[2] ? 1 : 0)
);
childID.add(4, (p, q)=>(p[0] >= q[0] ? 8 : 0) | (p[1] >= q[1] ? 4 : 0) | (p[2] >= q[2] ? 2 : 0) | (p[3] >= q[3] ? 1 : 0)
);
childID.default((p, q)=>{
    let id = 0;
    for(let i = 0, n = p.length - 1, bit = 1 << n; i <= n; i++, bit >>>= 1)p[i] >= q[i] && (id += bit);
    return id;
});

},{"@thi.ng/equiv":"e2rLA","@thi.ng/errors/assert":"zM8kA","@thi.ng/geom-isec/point":"f9zjT","@thi.ng/geom-isec/rect-circle":"318Sg","@thi.ng/heaps/heap":"18spH","@thi.ng/math/api":"4a98p","@thi.ng/transducers/iterate":"l9qxc","@thi.ng/transducers/map":"fW6Xn","@thi.ng/transducers/permutations":"jj5MK","@thi.ng/transducers/repeat":"afG7n","@thi.ng/transducers/take":"cr3ZD","@thi.ng/vectors/addmn":"9C52h","@thi.ng/vectors/distsq":"8XCdB","@thi.ng/vectors/madd":"8NYtQ","@thi.ng/vectors/muln":"1TKlE","@thi.ng/vectors/submn":"aIPIo","@thi.ng/vectors/vop":"4v2k5","./utils.js":"9RX5K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"zM8kA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AssertionError", ()=>AssertionError
);
parcelHelpers.export(exports, "assert", ()=>assert
);
var _deferrorJs = require("./deferror.js");
var process = require("process");
const AssertionError = _deferrorJs.defError(()=>"Assertion failed"
);
const assert = (()=>typeof process !== "undefined" && typeof process.env !== "undefined" ? true : typeof __SNOWPACK_ENV__ !== "undefined" ? __SNOWPACK_ENV__.MODE !== "production" || !!__SNOWPACK_ENV__.UMBRELLA_ASSERTS || !!__SNOWPACK_ENV__.SNOWPACK_PUBLIC_UMBRELLA_ASSERTS : true
)() ? (test, msg)=>{
    if (typeof test === "function" && !test() || !test) throw new AssertionError(typeof msg === "function" ? msg() : msg);
} : ()=>{
};

},{"./deferror.js":"l9nQt","process":"jhUEF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f9zjT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pointInSegment", ()=>pointInSegment
);
parcelHelpers.export(exports, "pointInCircle", ()=>pointInCircle
);
parcelHelpers.export(exports, "pointInSphere", ()=>pointInSphere
);
parcelHelpers.export(exports, "classifyPointInCircle", ()=>classifyPointInCircle
);
parcelHelpers.export(exports, "pointIn3Circle", ()=>pointIn3Circle
);
parcelHelpers.export(exports, "pointIn4Sphere", ()=>pointIn4Sphere
);
parcelHelpers.export(exports, "pointInCircumCircle", ()=>pointInCircumCircle
);
parcelHelpers.export(exports, "pointInTriangle2", ()=>pointInTriangle2
);
parcelHelpers.export(exports, "classifyPointInTriangle2", ()=>classifyPointInTriangle2
);
parcelHelpers.export(exports, "pointInPolygon2", ()=>pointInPolygon2
);
parcelHelpers.export(exports, "classifyPointPolyPair", ()=>classifyPointPolyPair
);
parcelHelpers.export(exports, "pointInBox", ()=>pointInBox
);
parcelHelpers.export(exports, "pointInRect", ()=>pointInRect
);
parcelHelpers.export(exports, "pointInAABB", ()=>pointInAABB
);
parcelHelpers.export(exports, "pointInCenteredBox", ()=>pointInCenteredBox
);
parcelHelpers.export(exports, "pointInCenteredRect", ()=>pointInCenteredRect
);
parcelHelpers.export(exports, "pointInCenteredAABB", ()=>pointInCenteredAABB
);
var _line = require("@thi.ng/geom-closest-point/line");
var _abs = require("@thi.ng/math/abs");
var _api = require("@thi.ng/math/api");
var _interval = require("@thi.ng/math/interval");
var _clockwise = require("@thi.ng/vectors/clockwise");
var _distsq = require("@thi.ng/vectors/distsq");
var _magsq = require("@thi.ng/vectors/magsq");
var _mixn = require("@thi.ng/vectors/mixn");
var _signedArea = require("@thi.ng/vectors/signed-area");
var _vop = require("@thi.ng/vectors/vop");
const pointInSegment = (p, a, b, eps = _api.EPS)=>{
    const t = _line.closestT(p, a, b);
    return t !== undefined ? _distsq.distSq(p, _mixn.mixN([], a, b, _interval.clamp01(t))) < eps * eps : false;
};
const pointInCircle = (p, pos, r)=>_distsq.distSq(pos, p) <= r * r
;
const pointInSphere = pointInCircle;
const classifyPointInCircle = (p, pos, r, eps = _api.EPS)=>_abs.sign(r * r - _distsq.distSq(pos, p), eps)
;
const pointIn3Circle = ([px, py], a, b, c)=>{
    const apx = a[0] - px;
    const apy = a[1] - py;
    const bpx = b[0] - px;
    const bpy = b[1] - py;
    const cpx = c[0] - px;
    const cpy = c[1] - py;
    const abdet = apx * bpy - bpx * apy;
    const bcdet = bpx * cpy - cpx * bpy;
    const cadet = cpx * apy - apx * cpy;
    const alift = apx * apx + apy * apy;
    const blift = bpx * bpx + bpy * bpy;
    const clift = cpx * cpx + cpy * cpy;
    return alift * bcdet + blift * cadet + clift * abdet;
};
const pointIn4Sphere = ([px, py, pz], a, b, c, d)=>{
    const apx = a[0] - px;
    const bpx = b[0] - px;
    const cpx = c[0] - px;
    const dpx = d[0] - px;
    const apy = a[1] - py;
    const bpy = b[1] - py;
    const cpy = c[1] - py;
    const dpy = d[1] - py;
    const apz = a[2] - pz;
    const bpz = b[2] - pz;
    const cpz = c[2] - pz;
    const dpz = d[2] - pz;
    const ab = apx * bpy - bpx * apy;
    const bc = bpx * cpy - cpx * bpy;
    const cd = cpx * dpy - dpx * cpy;
    const da = dpx * apy - apx * dpy;
    const ac = apx * cpy - cpx * apy;
    const bd = bpx * dpy - dpx * bpy;
    const abc = apz * bc - bpz * ac + cpz * ab;
    const bcd = bpz * cd - cpz * bd + dpz * bc;
    const cda = cpz * da + dpz * ac + apz * cd;
    const dab = dpz * ab + apz * bd + bpz * da;
    const alift = apx * apx + apy * apy + apz * apz;
    const blift = bpx * bpx + bpy * bpy + bpz * bpz;
    const clift = cpx * cpx + cpy * cpy + cpz * cpz;
    const dlift = dpx * dpx + dpy * dpy + dpz * dpz;
    return dlift * abc - clift * dab + (blift * cda - alift * bcd);
};
const pointInCircumCircle = (a, b, c, d)=>_magsq.magSq(a) * _signedArea.signedArea2(b, c, d) - _magsq.magSq(b) * _signedArea.signedArea2(a, c, d) + _magsq.magSq(c) * _signedArea.signedArea2(a, b, d) - _magsq.magSq(d) * _signedArea.signedArea2(a, b, c) > 0
;
const pointInTriangle2 = (p, a, b, c)=>{
    const s = _clockwise.clockwise2(a, b, c) ? 1 : -1;
    return s * _signedArea.signedArea2(a, c, p) >= 0 && s * _signedArea.signedArea2(b, a, p) >= 0 && s * _signedArea.signedArea2(c, b, p) >= 0;
};
const classifyPointInTriangle2 = (p, a, b, c, eps = _api.EPS)=>{
    const s = _clockwise.clockwise2(a, b, c) ? 1 : -1;
    return _abs.sign(Math.min(s * _signedArea.signedArea2(a, c, p), s * _signedArea.signedArea2(b, a, p), s * _signedArea.signedArea2(c, b, p)), eps);
};
const pointInPolygon2 = (p, pts)=>{
    const n = pts.length - 1;
    const px = p[0];
    const py = p[1];
    let a = pts[n];
    let b = pts[0];
    let inside = 0;
    for(let i = 0; i <= n; a = b, b = pts[++i])inside = classifyPointPolyPair(px, py, a[0], a[1], b[0], b[1], inside);
    return inside;
};
const classifyPointPolyPair = (px, py, ax, ay, bx, by, inside)=>(ay < py && by >= py || by < py && ay >= py) && (ax <= px || bx <= px) ? inside ^ ~~(ax + (py - ay) / (by - ay) * (bx - ax) < px) : inside
;
const pointInBox = _vop.vop(0);
const pointInRect = pointInBox.add(2, ([x, y], pos, size)=>x >= pos[0] && x <= pos[0] + size[0] && y >= pos[1] && y <= pos[1] + size[1]
);
const pointInAABB = pointInBox.add(3, ([x, y, z], pos, size)=>x >= pos[0] && x <= pos[0] + size[0] && y >= pos[1] && y <= pos[1] + size[1] && z >= pos[2] && z <= pos[2] + size[2]
);
pointInBox.default((p, boxMin, boxSize)=>{
    for(let i = p.length; i-- > 0;){
        const x = p[i];
        const y = boxMin[i];
        if (x < y || x > y + boxSize[i]) return false;
    }
    return true;
});
const pointInCenteredBox = _vop.vop(0);
const pointInCenteredRect = pointInCenteredBox.add(2, ([x, y], pos, size)=>x >= pos[0] - size[0] && x <= pos[0] + size[0] && y >= pos[1] - size[1] && y <= pos[1] + size[1]
);
const pointInCenteredAABB = pointInCenteredBox.add(3, ([x, y, z], pos, size)=>x >= pos[0] - size[0] && x <= pos[0] + size[0] && y >= pos[1] - size[1] && y <= pos[1] + size[1] && z >= pos[2] - size[2] && z <= pos[2] + size[2]
);
pointInCenteredBox.default((p, boxCenter, boxExtent)=>{
    for(let i = p.length; i-- > 0;){
        const x = p[i];
        const y = boxCenter[i];
        const z = boxExtent[i];
        if (x < y - z || x > y + z) return false;
    }
    return true;
});

},{"@thi.ng/geom-closest-point/line":"71qLb","@thi.ng/math/abs":"he08U","@thi.ng/math/api":"4a98p","@thi.ng/math/interval":"1TDWA","@thi.ng/vectors/clockwise":"hd0jc","@thi.ng/vectors/distsq":"8XCdB","@thi.ng/vectors/magsq":"bsMC4","@thi.ng/vectors/mixn":"jolPM","@thi.ng/vectors/signed-area":"2iZFe","@thi.ng/vectors/vop":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"71qLb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "closestT", ()=>closestT
);
parcelHelpers.export(exports, "closestPointLine", ()=>closestPointLine
);
parcelHelpers.export(exports, "distToLine", ()=>distToLine
);
parcelHelpers.export(exports, "closestPointSegment", ()=>closestPointSegment
);
parcelHelpers.export(exports, "distToSegment", ()=>distToSegment
);
parcelHelpers.export(exports, "closestPointPolyline", ()=>closestPointPolyline
);
parcelHelpers.export(exports, "farthestPointSegment", ()=>farthestPointSegment
);
var _dist = require("@thi.ng/vectors/dist");
var _distsq = require("@thi.ng/vectors/distsq");
var _dot = require("@thi.ng/vectors/dot");
var _empty = require("@thi.ng/vectors/empty");
var _magsq = require("@thi.ng/vectors/magsq");
var _mixn = require("@thi.ng/vectors/mixn");
var _set = require("@thi.ng/vectors/set");
var _sub = require("@thi.ng/vectors/sub");
const closestT = (p, a, b)=>{
    const d = _sub.sub([], b, a);
    const l = _magsq.magSq(d);
    return l > 0.000001 ? _dot.dot(_sub.sub([], p, a), d) / l : undefined;
};
const closestPointLine = (p, a, b)=>_mixn.mixN([], a, b, closestT(p, a, b) || 0)
;
const distToLine = (p, a, b)=>_dist.dist(p, closestPointLine(p, a, b) || a)
;
const closestPointSegment = (p, a, b, out, insideOnly = false, eps = 0)=>{
    const t = closestT(p, a, b);
    if (t !== undefined && (!insideOnly || t >= eps && t <= 1 - eps)) {
        out = out || _empty.empty(p);
        return t <= 0 ? _set.set(out, a) : t >= 1 ? _set.set(out, b) : _mixn.mixN(out, a, b, t);
    }
};
const distToSegment = (p, a, b)=>_dist.dist(p, closestPointSegment(p, a, b) || a)
;
const closestPointPolyline = (p, pts, closed = false, out = [])=>{
    if (!pts.length) return;
    const tmp = [];
    const n = pts.length - 1;
    let minD = Infinity, i, j;
    if (closed) {
        i = n;
        j = 0;
    } else {
        i = 0;
        j = 1;
    }
    for(; j <= n; i = j, j++)if (closestPointSegment(p, pts[i], pts[j], tmp)) {
        const d = _distsq.distSq(p, tmp);
        if (d < minD) {
            minD = d;
            _set.set(out, tmp);
        }
    }
    return minD < Infinity ? out : undefined;
};
const farthestPointSegment = (a, b, points, from = 0, to = points.length)=>{
    let maxD = -1;
    let maxIdx = -1;
    const tmp = _empty.empty(a);
    for(let i = from; i < to; i++){
        const p = points[i];
        const d = _distsq.distSq(p, closestPointSegment(p, a, b, tmp) || a);
        if (d > maxD) {
            maxD = d;
            maxIdx = i;
        }
    }
    return [
        maxIdx,
        Math.sqrt(maxD)
    ];
};

},{"@thi.ng/vectors/dist":"kIwBu","@thi.ng/vectors/distsq":"8XCdB","@thi.ng/vectors/dot":"9vV5N","@thi.ng/vectors/empty":"5JVqG","@thi.ng/vectors/magsq":"bsMC4","@thi.ng/vectors/mixn":"jolPM","@thi.ng/vectors/set":"bSUB8","@thi.ng/vectors/sub":"fzaw7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kIwBu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dist", ()=>dist
);
parcelHelpers.export(exports, "dist2", ()=>dist2
);
parcelHelpers.export(exports, "dist3", ()=>dist3
);
parcelHelpers.export(exports, "dist4", ()=>dist4
);
var _distsqJs = require("./distsq.js");
const dist = (a, b)=>Math.sqrt(_distsqJs.distSq(a, b))
;
const dist2 = (a, b)=>Math.sqrt(_distsqJs.distSq2(a, b))
;
const dist3 = (a, b)=>Math.sqrt(_distsqJs.distSq3(a, b))
;
const dist4 = (a, b)=>Math.sqrt(_distsqJs.distSq4(a, b))
;

},{"./distsq.js":"8XCdB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9vV5N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dot", ()=>dot
);
parcelHelpers.export(exports, "dot2", ()=>dot2
);
parcelHelpers.export(exports, "dot3", ()=>dot3
);
parcelHelpers.export(exports, "dot4", ()=>dot4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
var _vopJs = require("./vop.js");
const $ = (dim)=>dot.add(dim, _emitJs.compile(dim, _templatesJs.DOT, "a,b", undefined, "", "+", "return ", ";"))
;
const dot = _vopJs.vop();
dot.default(_emitJs.compileG(_templatesJs.DOT_G, "a,b", undefined, "s", "let s=0;"));
const dot2 = $(2);
const dot3 = $(3);
const dot4 = $(4);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5JVqG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "empty", ()=>empty
);
var _implementsFunction = require("@thi.ng/checks/implements-function");
var _setnJs = require("./setn.js");
const empty = (v)=>_implementsFunction.implementsFunction(v, "empty") ? v.empty() : _setnJs.zeroes(v.length)
;

},{"@thi.ng/checks/implements-function":"cjrzK","./setn.js":"2M6y1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2M6y1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setN", ()=>setN
);
parcelHelpers.export(exports, "setN2", ()=>setN2
);
parcelHelpers.export(exports, "setN3", ()=>setN3
);
parcelHelpers.export(exports, "setN4", ()=>setN4
);
parcelHelpers.export(exports, "zero", ()=>zero
);
parcelHelpers.export(exports, "one", ()=>one
);
parcelHelpers.export(exports, "zeroes", ()=>zeroes
);
parcelHelpers.export(exports, "ones", ()=>ones
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [setN, setN2, setN3, setN4] = _emitJs.defOp(_templatesJs.SET_N, "a,n", "a", "a", 0, "");
const zero = (a)=>setN(a, 0)
;
const one = (a)=>setN(a, 1)
;
const zeroes = (n)=>new Array(n).fill(0)
;
const ones = (n)=>new Array(n).fill(1)
;

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bsMC4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "magSq", ()=>magSq
);
parcelHelpers.export(exports, "magSq2", ()=>magSq2
);
parcelHelpers.export(exports, "magSq3", ()=>magSq3
);
parcelHelpers.export(exports, "magSq4", ()=>magSq4
);
var _emitJs = require("./compile/emit.js");
var _vopJs = require("./vop.js");
const $ = (dim)=>magSq.add(dim, _emitJs.compile(dim, ([a])=>`${a}*${a}`
    , "a", "a", "", "+", "return ", ";"))
;
const magSq = _vopJs.vop();
magSq.default(_emitJs.compileG(([a])=>`sum+=${a}*${a};`
, "a", undefined, "sum", "let sum=0;"));
const magSq2 = $(2);
const magSq3 = $(3);
const magSq4 = $(4);

},{"./compile/emit.js":"hpIek","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jolPM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mixN", ()=>mixN
);
parcelHelpers.export(exports, "mixN2", ()=>mixN2
);
parcelHelpers.export(exports, "mixN3", ()=>mixN3
);
parcelHelpers.export(exports, "mixN4", ()=>mixN4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [mixN, mixN2, mixN3, mixN4] = _emitJs.defOp(_templatesJs.MIX_N, _templatesJs.ARGS_VVN);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bSUB8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "set", ()=>set
);
parcelHelpers.export(exports, "set2", ()=>set2
);
parcelHelpers.export(exports, "set3", ()=>set3
);
parcelHelpers.export(exports, "set4", ()=>set4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [set, set2, set3, set4] = _emitJs.defOp(_templatesJs.SET, "o,a", undefined, "o", 1, _templatesJs.NEW_OUT);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fzaw7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sub", ()=>sub
);
parcelHelpers.export(exports, "sub2", ()=>sub2
);
parcelHelpers.export(exports, "sub3", ()=>sub3
);
parcelHelpers.export(exports, "sub4", ()=>sub4
);
var _emitJs = require("./compile/emit.js");
const [sub, sub2, sub3, sub4] = _emitJs.defMathOp("-");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"he08U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "absDiff", ()=>absDiff
);
parcelHelpers.export(exports, "sign", ()=>sign
);
var _apiJs = require("./api.js");
const absDiff = (x, y)=>Math.abs(x - y)
;
const sign = (x, eps = _apiJs.EPS)=>x > eps ? 1 : x < -eps ? -1 : 0
;

},{"./api.js":"4a98p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1TDWA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "clamp", ()=>clamp
);
parcelHelpers.export(exports, "clamp0", ()=>clamp0
);
parcelHelpers.export(exports, "clamp01", ()=>clamp01
);
parcelHelpers.export(exports, "clamp11", ()=>clamp11
);
parcelHelpers.export(exports, "clamp05", ()=>clamp05
);
parcelHelpers.export(exports, "wrap", ()=>wrap
);
parcelHelpers.export(exports, "wrapOnce", ()=>wrapOnce
);
parcelHelpers.export(exports, "wrap01", ()=>wrap01
);
parcelHelpers.export(exports, "wrap11", ()=>wrap11
);
parcelHelpers.export(exports, "min2id", ()=>min2id
);
parcelHelpers.export(exports, "min3id", ()=>min3id
);
parcelHelpers.export(exports, "min4id", ()=>min4id
);
parcelHelpers.export(exports, "max2id", ()=>max2id
);
parcelHelpers.export(exports, "max3id", ()=>max3id
);
parcelHelpers.export(exports, "max4id", ()=>max4id
);
parcelHelpers.export(exports, "minNonZero2", ()=>minNonZero2
);
parcelHelpers.export(exports, "minNonZero3", ()=>minNonZero3
);
parcelHelpers.export(exports, "smin", ()=>smin
);
parcelHelpers.export(exports, "smax", ()=>smax
);
parcelHelpers.export(exports, "sclamp", ()=>sclamp
);
parcelHelpers.export(exports, "absMin", ()=>absMin
);
parcelHelpers.export(exports, "absMax", ()=>absMax
);
parcelHelpers.export(exports, "foldback", ()=>foldback
);
parcelHelpers.export(exports, "inRange", ()=>inRange
);
parcelHelpers.export(exports, "inOpenRange", ()=>inOpenRange
);
const clamp = (x, min, max)=>x < min ? min : x > max ? max : x
;
const clamp0 = (x)=>x > 0 ? x : 0
;
const clamp01 = (x)=>x < 0 ? 0 : x > 1 ? 1 : x
;
const clamp11 = (x)=>x < -1 ? -1 : x > 1 ? 1 : x
;
const clamp05 = (x)=>x < 0 ? 0 : x > 0.5 ? 0.5 : x
;
const wrap = (x, min, max)=>{
    if (min === max) return min;
    if (x > max) {
        const d = max - min;
        x -= d;
        if (x > max) x -= d * ((x - min) / d | 0);
    } else if (x < min) {
        const d = max - min;
        x += d;
        if (x < min) x += d * ((min - x) / d + 1 | 0);
    }
    return x;
};
const wrapOnce = (x, min, max)=>x < min ? x - min + max : x > max ? x - max + min : x
;
const wrap01 = (x)=>x < 0 ? x + 1 : x > 1 ? x - 1 : x
;
const wrap11 = (x)=>x < -1 ? x + 2 : x > 1 ? x - 2 : x
;
const min2id = (a, b)=>a <= b ? 0 : 1
;
const min3id = (a, b, c)=>a <= b ? a <= c ? 0 : 2 : b <= c ? 1 : 2
;
const min4id = (a, b, c, d)=>a <= b ? a <= c ? a <= d ? 0 : 3 : c <= d ? 2 : 3 : b <= c ? b <= d ? 1 : 3 : c <= d ? 2 : 3
;
const max2id = (a, b)=>a >= b ? 0 : 1
;
const max3id = (a, b, c)=>a >= b ? a >= c ? 0 : 2 : b >= c ? 1 : 2
;
const max4id = (a, b, c, d)=>a >= b ? a >= c ? a >= d ? 0 : 3 : c >= d ? 2 : 3 : b >= c ? b >= d ? 1 : 3 : c >= d ? 2 : 3
;
const minNonZero2 = (a, b)=>a !== 0 ? b !== 0 ? Math.min(a, b) : a : b
;
const minNonZero3 = (a, b, c)=>minNonZero2(minNonZero2(a, b), c)
;
const smin = (a, b, k)=>smax(a, b, -k)
;
const smax = (a, b, k)=>{
    const ea = Math.exp(a * k);
    const eb = Math.exp(b * k);
    return (a * ea + b * eb) / (ea + eb);
};
const sclamp = (x, min, max, k)=>smin(smax(x, min, k), max, k)
;
const absMin = (a, b)=>Math.abs(a) < Math.abs(b) ? a : b
;
const absMax = (a, b)=>Math.abs(a) > Math.abs(b) ? a : b
;
const foldback = (e, x)=>x < -e || x > e ? Math.abs(Math.abs((x - e) % (4 * e)) - 2 * e) - e : x
;
const inRange = (x, min, max)=>x >= min && x <= max
;
const inOpenRange = (x, min, max)=>x > min && x < max
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hd0jc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "corner2", ()=>corner2
);
parcelHelpers.export(exports, "clockwise2", ()=>clockwise2
);
var _abs = require("@thi.ng/math/abs");
var _api = require("@thi.ng/math/api");
var _signedAreaJs = require("./signed-area.js");
const corner2 = (a, b, c, eps = _api.EPS)=>_abs.sign(_signedAreaJs.signedArea2(a, b, c), eps)
;
const clockwise2 = (a, b, c, eps = _api.EPS)=>corner2(a, b, c, eps) < 0
;

},{"@thi.ng/math/abs":"he08U","@thi.ng/math/api":"4a98p","./signed-area.js":"2iZFe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2iZFe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "signedArea2", ()=>signedArea2
);
parcelHelpers.export(exports, "signedAreaC2", ()=>signedAreaC2
);
const signedArea2 = (a, b, c)=>{
    const ax = a[0];
    const ay = a[1];
    return (b[0] - ax) * (c[1] - ay) - (c[0] - ax) * (b[1] - ay);
};
const signedAreaC2 = (ax, ay, bx, by, cx, cy)=>(bx - ax) * (cy - ay) - (cx - ax) * (by - ay)
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"318Sg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "testBoxSphere", ()=>testBoxSphere
);
parcelHelpers.export(exports, "testRectCircle", ()=>testRectCircle
);
parcelHelpers.export(exports, "testAABBSphere", ()=>testAABBSphere
);
parcelHelpers.export(exports, "testCenteredBoxSphere", ()=>testCenteredBoxSphere
);
parcelHelpers.export(exports, "testCenteredRectCircle", ()=>testCenteredRectCircle
);
parcelHelpers.export(exports, "testCenteredAABBSphere", ()=>testCenteredAABBSphere
);
var _vop = require("@thi.ng/vectors/vop");
const testBoxSphere = _vop.vop(0);
const testRectCircle = testBoxSphere.add(2, (boxMinPos, boxSize, circlePos, r)=>axis(circlePos[0], boxMinPos[0], boxSize[0]) + axis(circlePos[1], boxMinPos[1], boxSize[1]) <= r * r
);
const testAABBSphere = testBoxSphere.add(3, (boxMinPos, boxSize, spherePos, r)=>axis(spherePos[0], boxMinPos[0], boxSize[0]) + axis(spherePos[1], boxMinPos[1], boxSize[1]) + axis(spherePos[2], boxMinPos[2], boxSize[2]) <= r * r
);
testBoxSphere.default((boxPos, boxSize, spherePos, r)=>{
    let sum = 0;
    for(let i = boxPos.length; i-- > 0;)sum += axis(spherePos[i], boxPos[i], boxSize[i]);
    return sum <= r * r;
});
const testCenteredBoxSphere = _vop.vop(0);
const testCenteredRectCircle = testCenteredBoxSphere.add(2, (boxPos, { 0: w , 1: h  }, circlePos, r)=>axis(circlePos[0], boxPos[0] - w, w * 2) + axis(circlePos[1], boxPos[1] - h, h * 2) <= r * r
);
const testCenteredAABBSphere = testCenteredBoxSphere.add(3, (boxPos, { 0: w , 1: h , 2: d  }, spherePos, r)=>axis(spherePos[0], boxPos[0] - w, w * 2) + axis(spherePos[1], boxPos[1] - h, h * 2) + axis(spherePos[2], boxPos[2] - d, d * 2) <= r * r
);
testCenteredBoxSphere.default((boxPos, boxExtent, spherePos, r)=>{
    let sum = 0;
    for(let i = boxPos.length; i-- > 0;)sum += axis(spherePos[i], boxPos[i] - boxExtent[i], boxExtent[i] * 2);
    return sum <= r * r;
});
const axis = (a, b, c)=>(a < b ? a - b : a > b + c ? a - b - c : 0) ** 2
;

},{"@thi.ng/vectors/vop":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l9qxc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Yields an infinite iterator of the inductive sequence:
 *
 * `f(x+1) = f(f(x))`
 *
 * @remarks
 * The first value emitted always is `seed` itself, then f(seed),
 * f(f(seed, i)) etc. The given function is called with the current
 * iteration counter as 2nd arg (starting w/ i=1).
 *
 * @example
 * ```ts
 * [...iterate((x) => x * 2, 1, 5)]
 * // [ 1, 2, 4, 8, 16 ]
 *
 * [...iterate((x, i) => x * 10 + i, 0, 8)]
 * // [ 0, 1, 12, 123, 1234, 12345, 123456, 1234567 ]
 * ```
 *
 * @param fn -
 * @param seed -
 * @param num -
 */ parcelHelpers.export(exports, "iterate", ()=>iterate
);
function* iterate(fn, seed, num = Infinity) {
    for(let i = 1; i <= num; i++){
        yield seed;
        seed = fn(seed, i);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jj5MK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "permutations", ()=>permutations
);
parcelHelpers.export(exports, "permutationsN", ()=>permutationsN
);
var _ensureArray = require("@thi.ng/arrays/ensure-array");
var _illegalArguments = require("@thi.ng/errors/illegal-arguments");
var _rangeJs = require("./range.js");
function* permutations(...src) {
    const n = src.length - 1;
    if (n < 0) return;
    const step = new Array(n + 1).fill(0);
    const realized = src.map(_ensureArray.ensureArrayLike);
    const total = realized.reduce((acc, x)=>acc * x.length
    , 1);
    for(let i = 0; i < total; i++){
        const tuple = [];
        for(let j = n; j >= 0; j--){
            const r = realized[j];
            let s = step[j];
            if (s === r.length) {
                step[j] = s = 0;
                j > 0 && step[j - 1]++;
            }
            tuple[j] = r[s];
        }
        step[n]++;
        yield tuple;
    }
}
const permutationsN = (n, m = n, offsets)=>{
    if (offsets && offsets.length < n) _illegalArguments.illegalArgs(`insufficient offsets, got ${offsets.length}, needed ${n}`);
    const seqs = [];
    while(n-- > 0){
        const o = offsets ? offsets[n] : 0;
        seqs[n] = _rangeJs.range(o, o + m);
    }
    return permutations.apply(null, seqs);
};

},{"@thi.ng/arrays/ensure-array":"6Tcdc","@thi.ng/errors/illegal-arguments":"co01S","./range.js":"lUHc9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"afG7n":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Iterator yielding an infinite (by default) repetition of given value
 * `x`. If `n` is given, only produces that many values.
 *
 * See also: {@link repeatedly}
 *
 * @example
 * ```ts
 * [...repeat(42, 5)]
 * // [42, 42, 42, 42, 42]
 * ```
 *
 * @param x - value to repeat
 * @param n - num values (default: )
 */ parcelHelpers.export(exports, "repeat", ()=>repeat
);
function* repeat(x, n = Infinity) {
    while(n-- > 0)yield x;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9C52h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addmN", ()=>addmN
);
parcelHelpers.export(exports, "addmN2", ()=>addmN2
);
parcelHelpers.export(exports, "addmN3", ()=>addmN3
);
parcelHelpers.export(exports, "addmN4", ()=>addmN4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [addmN, addmN2, addmN3, addmN4] = _emitJs.defOp(_templatesJs.MATH2_N("+", "*"), _templatesJs.ARGS_VVN);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8NYtQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "madd", ()=>madd
);
parcelHelpers.export(exports, "madd2", ()=>madd2
);
parcelHelpers.export(exports, "madd3", ()=>madd3
);
parcelHelpers.export(exports, "madd4", ()=>madd4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [madd, madd2, madd3, madd4] = _emitJs.defOp(_templatesJs.MATH2("*", "+"), _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1TKlE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mulN", ()=>mulN
);
parcelHelpers.export(exports, "mulN2", ()=>mulN2
);
parcelHelpers.export(exports, "mulN3", ()=>mulN3
);
parcelHelpers.export(exports, "mulN4", ()=>mulN4
);
var _emitJs = require("./compile/emit.js");
const [mulN, mulN2, mulN3, mulN4] = _emitJs.defMathOpN("*");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aIPIo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "submN", ()=>submN
);
parcelHelpers.export(exports, "submN2", ()=>submN2
);
parcelHelpers.export(exports, "submN3", ()=>submN3
);
parcelHelpers.export(exports, "submN4", ()=>submN4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [submN, submN2, submN3, submN4] = _emitJs.defOp(_templatesJs.MATH2_N("-", "*"), _templatesJs.ARGS_VVN);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6tjbR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NdQuadtreeSet", ()=>NdQuadtreeSet
);
var _api = require("@thi.ng/math/api");
var _addmn = require("@thi.ng/vectors/addmn");
var _submn = require("@thi.ng/vectors/submn");
var _ndQuadtreeMapJs = require("./nd-quadtree-map.js");
class NdQuadtreeSet {
    constructor(pos, ext, keys){
        this.tree = new _ndQuadtreeMapJs.NdQuadtreeMap(pos, ext);
        this._size = 0;
        keys && this.into(keys);
    }
    /**
     * Returns a new point-based `NdQuadtreeSet` for nD keys in given
     * region defined by `min` / `max` coordinates. The dimensionality
     * of the tree is implicitly defined by the provided coordinates.
     * Only points within that region can be indexed.
     *
     * @remarks
     * Due to exponentially growing lookup tables, currently only
     * supports up to 16 dimensions.
     */ static fromMinMax(min, max) {
        return new NdQuadtreeSet(_addmn.addmN([], min, max, 0.5), _submn.submN([], max, min, 0.5));
    }
    [Symbol.iterator]() {
        return this.tree.keys();
    }
    keys() {
        return this.tree.keys();
    }
    values() {
        return this.tree.values();
    }
    get size() {
        return this._size;
    }
    copy() {
        return new NdQuadtreeSet(this.tree.root.pos, this.tree.root.ext, this);
    }
    clear() {
        this.tree.clear();
    }
    empty() {
        return new NdQuadtreeSet(this.tree.root.pos, this.tree.root.ext);
    }
    add(key, eps = _api.EPS) {
        return this.tree.set(key, key, eps);
    }
    into(keys, eps = _api.EPS) {
        let ok = true;
        const tree = this.tree;
        for (let k of keys)ok = tree.set(k, k, eps) && ok;
        return ok;
    }
    remove(key) {
        return this.tree.remove(key);
    }
    has(key, eps = _api.EPS) {
        return this.tree.has(key, eps);
    }
    get(key, eps) {
        return this.tree.get(key, eps);
    }
    query(q, maxDist, limit, acc) {
        return this.tree.query(q, maxDist, limit, acc);
    }
    queryKeys(q, maxDist, limit, acc) {
        return this.tree.queryKeys(q, maxDist, limit, acc);
    }
    queryValues(q, maxDist, limit, acc) {
        return this.tree.queryKeys(q, maxDist, limit, acc);
    }
}

},{"@thi.ng/math/api":"4a98p","@thi.ng/vectors/addmn":"9C52h","@thi.ng/vectors/submn":"aIPIo","./nd-quadtree-map.js":"5mrju","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b6jlb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SpatialGrid2", ()=>SpatialGrid2
);
var _isNumber = require("@thi.ng/checks/is-number");
var _heap = require("@thi.ng/heaps/heap");
var _interval = require("@thi.ng/math/interval");
var _addn = require("@thi.ng/vectors/addn");
var _distsq = require("@thi.ng/vectors/distsq");
var _subn = require("@thi.ng/vectors/subn");
var _aspatialGridJs = require("./aspatial-grid.js");
var _utilsJs = require("./utils.js");
const TMP = [];
class SpatialGrid2 extends _aspatialGridJs.ASpatialGrid {
    constructor(min, size, res){
        super(min, size, _isNumber.isNumber(res) ? [
            res,
            res
        ] : res);
        this._cells = new Array(this._res[0] * this._res[1]);
    }
    copy() {
        return super.copy();
    }
    empty() {
        return new SpatialGrid2(this._min, this._size, this._res);
    }
    doQuery(fn, k, r, limit = Infinity, acc = []) {
        const id1 = this.findIndex(_subn.subN2(TMP, k, r));
        const id2 = this.findIndex(_addn.addN2(TMP, k, r));
        const stride = this._res[0];
        const x1 = id1 % stride;
        const x2 = id2 % stride;
        const y1 = (id1 / stride | 0) * stride;
        const y2 = (id2 / stride | 0) * stride;
        const cells = this._cells;
        let c;
        let x, y;
        r *= r;
        const heap = new _heap.Heap([
            [
                r
            ]
        ], {
            compare: _utilsJs.CMP
        });
        const sel = heap.values;
        for(y = y1; y <= y2; y += stride)for(x = x1; x <= x2; x++){
            c = cells[y + x];
            c && c.length && this.queryCell(_distsq.distSq2, heap, c, k, limit);
        }
        return _utilsJs.addResults(fn, sel, acc);
    }
    findIndex(k) {
        const { _min: min , _res1: res1 , _invSize: invSize  } = this;
        const kx = _interval.clamp((k[0] - min[0]) * invSize[0], 0, res1[0]);
        const ky = _interval.clamp((k[1] - min[1]) * invSize[1], 0, res1[1]);
        return (kx | 0) + (ky | 0) * this._res[0];
    }
}

},{"@thi.ng/checks/is-number":"hNf8P","@thi.ng/heaps/heap":"18spH","@thi.ng/math/interval":"1TDWA","@thi.ng/vectors/addn":"cecib","@thi.ng/vectors/distsq":"8XCdB","@thi.ng/vectors/subn":"i3npD","./aspatial-grid.js":"hVTuS","./utils.js":"9RX5K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hNf8P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isNumber", ()=>isNumber
);
const isNumber = (x)=>typeof x === "number"
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cecib":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addN", ()=>addN
);
parcelHelpers.export(exports, "addN2", ()=>addN2
);
parcelHelpers.export(exports, "addN3", ()=>addN3
);
parcelHelpers.export(exports, "addN4", ()=>addN4
);
var _emitJs = require("./compile/emit.js");
const [addN, addN2, addN3, addN4] = _emitJs.defMathOpN("+");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i3npD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subN", ()=>subN
);
parcelHelpers.export(exports, "subN2", ()=>subN2
);
parcelHelpers.export(exports, "subN3", ()=>subN3
);
parcelHelpers.export(exports, "subN4", ()=>subN4
);
var _emitJs = require("./compile/emit.js");
const [subN, subN2, subN3, subN4] = _emitJs.defMathOpN("-");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hVTuS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Common base class for {@link SpatialGrid2} and {@link SpatialGrid3}.
 *
 * @internal
 */ parcelHelpers.export(exports, "ASpatialGrid", ()=>ASpatialGrid
);
var _api = require("@thi.ng/math/api");
var _map = require("@thi.ng/transducers/map");
var _div = require("@thi.ng/vectors/div");
var _equals = require("@thi.ng/vectors/equals");
var _floor = require("@thi.ng/vectors/floor");
var _subn = require("@thi.ng/vectors/subn");
var _utilsJs = require("./utils.js");
class ASpatialGrid {
    constructor(_min, _size, _res){
        this._min = _min;
        this._size = _size;
        this._res = _res;
        _floor.floor(null, this._res);
        this._res1 = _subn.subN([], this._res, 1);
        this._invSize = _div.div([], this._res, _size);
        this._num = 0;
    }
    get size() {
        return this._num;
    }
    *[Symbol.iterator]() {
        const cells = this._cells;
        for(let i = cells.length; i-- > 0;)if (cells[i]) yield* cells[i];
    }
    keys() {
        return _map.map((p)=>p[0]
        , this);
    }
    values() {
        return _map.map((p)=>p[1]
        , this);
    }
    copy() {
        const copy = this.empty();
        copy._num = this._num;
        const src = this._cells;
        const dest = copy._cells;
        for(let i = src.length; i-- > 0;)dest[i] = src[i] ? src[i].slice() : null;
        return copy;
    }
    clear() {
        this._cells.fill(null);
        this._num = 0;
    }
    has(k, eps = _api.EPS) {
        return !!this.find(k, eps);
    }
    get(k, eps = _api.EPS) {
        const pair = this.find(k, eps);
        return pair ? pair[1] : undefined;
    }
    set(k, v, eps = _api.EPS) {
        if (eps >= 0 && this.query(k, eps, 1).length) return false;
        const id = this.findIndex(k);
        const cell = this._cells[id];
        if (!cell) this._cells[id] = [
            [
                k,
                v
            ]
        ];
        else cell.push([
            k,
            v
        ]);
        this._num++;
        return true;
    }
    into(pairs, eps = _api.EPS) {
        return _utilsJs.into(this, pairs, eps);
    }
    remove(k) {
        const id = this.findIndex(k);
        const cell = this._cells[id];
        if (!cell) return false;
        for(let i = cell.length; i-- > 0;)if (_equals.equals(cell[i][0], k)) {
            cell.splice(i, 1);
            this._num--;
            return true;
        }
        return false;
    }
    query(q, radius, limit, acc) {
        return this.doQuery((p)=>p
        , q, radius, limit, acc);
    }
    queryKeys(q, radius, limit, acc) {
        return this.doQuery((p)=>p[0]
        , q, radius, limit, acc);
    }
    queryValues(q, radius, limit, acc) {
        return this.doQuery((p)=>p[1]
        , q, radius, limit, acc);
    }
    queryCell(dist, heap, c, k, limit) {
        for(let i = c.length; i-- > 0;){
            const d = dist(c[i][0], k);
            if (d <= heap.values[0][0]) heap.length >= limit ? heap.pushPop([
                d,
                c[i]
            ]) : heap.push([
                d,
                c[i]
            ]);
        }
    }
    find(k, eps) {
        if (eps > 0) {
            const res = this.query(k, _api.EPS, 1);
            return res.length ? res[0] : undefined;
        }
        const cell = this._cells[this.findIndex(k)];
        if (cell) for(let i = cell.length; i-- > 0;){
            if (_equals.equals(cell[i][0], k)) return cell[i];
        }
    }
}

},{"@thi.ng/math/api":"4a98p","@thi.ng/transducers/map":"fW6Xn","@thi.ng/vectors/div":"5inb4","@thi.ng/vectors/equals":"kCRCM","@thi.ng/vectors/floor":"8Bam4","@thi.ng/vectors/subn":"i3npD","./utils.js":"9RX5K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5inb4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "div", ()=>div
);
parcelHelpers.export(exports, "div2", ()=>div2
);
parcelHelpers.export(exports, "div3", ()=>div3
);
parcelHelpers.export(exports, "div4", ()=>div4
);
var _emitJs = require("./compile/emit.js");
const [div, div2, div3, div4] = _emitJs.defMathOp("/");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kCRCM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "equals2", ()=>equals2
);
parcelHelpers.export(exports, "equals3", ()=>equals3
);
parcelHelpers.export(exports, "equals4", ()=>equals4
);
var _equiv = require("@thi.ng/equiv");
var _vopJs = require("./vop.js");
const equals = _vopJs.vop(0);
const equals2 = equals.add(2, (a, b)=>a[0] === b[0] && a[1] === b[1]
);
const equals3 = equals.add(3, (a, b)=>a[0] === b[0] && a[1] === b[1] && a[2] === b[2]
);
const equals4 = equals.add(4, (a, b)=>a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3]
);
equals.default(_equiv.equivArrayLike);

},{"@thi.ng/equiv":"e2rLA","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Bam4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "floor", ()=>floor
);
parcelHelpers.export(exports, "floor2", ()=>floor2
);
parcelHelpers.export(exports, "floor3", ()=>floor3
);
parcelHelpers.export(exports, "floor4", ()=>floor4
);
var _emitJs = require("./compile/emit.js");
const [floor, floor2, floor3, floor4] = _emitJs.defFnOp("Math.floor");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"epsDv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SpatialGrid3", ()=>SpatialGrid3
);
var _isNumber = require("@thi.ng/checks/is-number");
var _heap = require("@thi.ng/heaps/heap");
var _interval = require("@thi.ng/math/interval");
var _addn = require("@thi.ng/vectors/addn");
var _distsq = require("@thi.ng/vectors/distsq");
var _subn = require("@thi.ng/vectors/subn");
var _aspatialGridJs = require("./aspatial-grid.js");
var _utilsJs = require("./utils.js");
const TMP = [];
class SpatialGrid3 extends _aspatialGridJs.ASpatialGrid {
    constructor(min, size, res){
        super(min, size, _isNumber.isNumber(res) ? [
            res,
            res,
            res
        ] : res);
        this._cells = new Array(this._res[0] * this._res[1] * this._res[2]);
        this._stride = [
            this._res[0],
            this._res[0] * this._res[1]
        ];
    }
    copy() {
        return super.copy();
    }
    empty() {
        return new SpatialGrid3(this._min, this._size, this._res);
    }
    doQuery(fn, k, r, limit = Infinity, acc = []) {
        const id1 = this.findIndex(_subn.subN3(TMP, k, r));
        const id2 = this.findIndex(_addn.addN3(TMP, k, r));
        const [width, slice] = this._stride;
        const x1 = id1 % width;
        const x2 = id2 % width;
        const y1 = (id1 / width | 0) * width;
        const y2 = (id2 / width | 0) * width;
        const z1 = (id1 / slice | 0) * slice;
        const z2 = (id2 / slice | 0) * slice;
        const cells = this._cells;
        let c;
        let x, y, z;
        r *= r;
        const heap = new _heap.Heap([
            [
                r
            ]
        ], {
            compare: _utilsJs.CMP
        });
        const sel = heap.values;
        for(z = z1; z <= z2; z += slice){
            for(y = y1; y <= y2; y += width)for(x = x1; x <= x2; x++){
                c = cells[z + y + x];
                c && c.length && this.queryCell(_distsq.distSq3, heap, c, k, limit);
            }
        }
        return _utilsJs.addResults(fn, sel, acc);
    }
    findIndex(k) {
        const { _min: min , _res1: res1 , _invSize: invSize  } = this;
        const kx = _interval.clamp((k[0] - min[0]) * invSize[0], 0, res1[0]);
        const ky = _interval.clamp((k[1] - min[1]) * invSize[1], 0, res1[1]);
        const kz = _interval.clamp((k[2] - min[2]) * invSize[2], 0, res1[2]);
        return (kx | 0) + (ky | 0) * this._stride[0] + (kz | 0) * this._stride[1];
    }
}

},{"@thi.ng/checks/is-number":"hNf8P","@thi.ng/heaps/heap":"18spH","@thi.ng/math/interval":"1TDWA","@thi.ng/vectors/addn":"cecib","@thi.ng/vectors/distsq":"8XCdB","@thi.ng/vectors/subn":"i3npD","./aspatial-grid.js":"hVTuS","./utils.js":"9RX5K","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hTYUR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _apiJs = require("./api.js");
parcelHelpers.exportAll(_apiJs, exports);
var _poissonJs = require("./poisson.js");
parcelHelpers.exportAll(_poissonJs, exports);
var _stratifiedJs = require("./stratified.js");
parcelHelpers.exportAll(_stratifiedJs, exports);

},{"./api.js":"5xKqf","./poisson.js":"7FWpL","./stratified.js":"lBUk4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5xKqf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7FWpL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "samplePoisson", ()=>samplePoisson
);
var _isNumber = require("@thi.ng/checks/is-number");
var _system = require("@thi.ng/random/system");
var _jitter = require("@thi.ng/vectors/jitter");
const samplePoisson = (_opts)=>{
    const opts = {
        rnd: _system.SYSTEM,
        iter: 1,
        jitter: 1,
        quality: 500,
        ..._opts
    };
    const { points , index , rnd , jitter , quality , density: _d  } = opts;
    const density = _isNumber.isNumber(_d) ? ()=>_d
     : _d;
    const iter = Math.max(opts.iter, 1);
    const samples = [];
    let failed = 0;
    let pos;
    let d;
    let i;
    outer: for(let num = opts.max; num > 0;){
        pos = points(rnd);
        d = density(pos);
        i = iter;
        while(i-- > 0){
            if (!index.has(pos, d)) {
                index.add(pos, 0);
                samples.push(pos);
                failed = 0;
                num--;
                continue outer;
            }
            _jitter.jitter(null, pos, jitter, rnd);
        }
        if (++failed > quality) break;
    }
    return samples;
};

},{"@thi.ng/checks/is-number":"hNf8P","@thi.ng/random/system":"bSLzr","@thi.ng/vectors/jitter":"aBPSB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bSLzr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A `Math.random()` based {@link IRandom} implementation. Also @see
 * {@link SYSTEM}.
 */ parcelHelpers.export(exports, "SystemRandom", ()=>SystemRandom
);
parcelHelpers.export(exports, "SYSTEM", ()=>SYSTEM
);
var _arandomJs = require("./arandom.js");
const random = Math.random;
class SystemRandom extends _arandomJs.ARandom {
    int() {
        return random() * 4294967296 >>> 0;
    }
    float(norm = 1) {
        return random() * norm;
    }
    norm(norm = 1) {
        return (random() - 0.5) * 2 * norm;
    }
}
const SYSTEM = new SystemRandom();

},{"./arandom.js":"hEnTe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hEnTe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ARandom", ()=>ARandom
);
const INV_MAX = 1 / 2 ** 32;
class ARandom {
    float(norm = 1) {
        return this.int() * INV_MAX * norm;
    }
    norm(norm = 1) {
        return (this.int() * INV_MAX - 0.5) * 2 * norm;
    }
    minmax(min, max) {
        return this.float() * (max - min) + min;
    }
    minmaxInt(min, max) {
        min |= 0;
        max |= 0;
        return min + (this.float() * (max - min) | 0);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aBPSB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "jitter", ()=>jitter
);
var _system = require("@thi.ng/random/system");
var _addJs = require("./add.js");
var _randomJs = require("./random.js");
const jitter = (out, a, n = 1, rnd = _system.SYSTEM)=>_addJs.add(out, a, _randomJs.randNorm(new Array(a.length), n, rnd))
;

},{"@thi.ng/random/system":"bSLzr","./add.js":"6HmvS","./random.js":"8bjGw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6HmvS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "add", ()=>add
);
parcelHelpers.export(exports, "add2", ()=>add2
);
parcelHelpers.export(exports, "add3", ()=>add3
);
parcelHelpers.export(exports, "add4", ()=>add4
);
var _emitJs = require("./compile/emit.js");
const [add, add2, add3, add4] = _emitJs.defMathOp("+");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8bjGw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "random", ()=>random
);
parcelHelpers.export(exports, "random2", ()=>random2
);
parcelHelpers.export(exports, "random3", ()=>random3
);
parcelHelpers.export(exports, "random4", ()=>random4
);
parcelHelpers.export(exports, "randomDistrib", ()=>randomDistrib
);
parcelHelpers.export(exports, "randomDistrib2", ()=>randomDistrib2
);
parcelHelpers.export(exports, "randomDistrib3", ()=>randomDistrib3
);
parcelHelpers.export(exports, "randomDistrib4", ()=>randomDistrib4
);
parcelHelpers.export(exports, "randNorm", ()=>randNorm
);
parcelHelpers.export(exports, "randNorm2", ()=>randNorm2
);
parcelHelpers.export(exports, "randNorm3", ()=>randNorm3
);
parcelHelpers.export(exports, "randNorm4", ()=>randNorm4
);
parcelHelpers.export(exports, "randNormDistrib", ()=>randNormDistrib
);
parcelHelpers.export(exports, "randNormDistrib2", ()=>randNormDistrib2
);
parcelHelpers.export(exports, "randNormDistrib3", ()=>randNormDistrib3
);
parcelHelpers.export(exports, "randNormDistrib4", ()=>randNormDistrib4
);
parcelHelpers.export(exports, "randMinMax", ()=>randMinMax
);
parcelHelpers.export(exports, "randMinMax2", ()=>randMinMax2
);
parcelHelpers.export(exports, "randMinMax3", ()=>randMinMax3
);
parcelHelpers.export(exports, "randMinMax4", ()=>randMinMax4
);
var _normal = require("@thi.ng/random/distributions/normal");
var _system = require("@thi.ng/random/system");
var _emitJs = require("./compile/emit.js");
var _indexJs = require("./index.js");
var _normalizeJs = require("./normalize.js");
const [random, random2, random3, random4] = _emitJs.defHofOp(_system.SYSTEM, ([a])=>`${a}=rnd.minmax(n,m);`
, "a,n=-1,m=1,rnd=op", "a", "a", 0, _indexJs.NEW_OUT_A);
const [randomDistrib, randomDistrib2, randomDistrib3, randomDistrib4] = _emitJs.defHofOp(_normal.normal, ([a])=>`${a}=rnd()*n;`
, "a,rnd=op(),n=1", "a", "a", 0, _indexJs.NEW_OUT_A);
const $norm = (random1)=>(v, n = 1, rnd = _system.SYSTEM)=>_normalizeJs.normalize(null, random1(v, -1, 1, rnd), n)
;
const $normDist = (random5)=>(v, rnd, n = 1)=>_normalizeJs.normalize(null, random5(v, rnd), n)
;
const randNorm = $norm(random);
const randNorm2 = $norm(random2);
const randNorm3 = $norm(random3);
const randNorm4 = $norm(random4);
const randNormDistrib = $normDist(randomDistrib);
const randNormDistrib2 = $normDist(randomDistrib2);
const randNormDistrib3 = $normDist(randomDistrib3);
const randNormDistrib4 = $normDist(randomDistrib4);
const [randMinMax, randMinMax2, randMinMax3, randMinMax4] = _emitJs.defHofOp(_system.SYSTEM, ([o, a, b])=>`${o}=rnd.minmax(${a},${b});`
, "o,a,b,rnd=op", "o,a,b");

},{"@thi.ng/random/distributions/normal":"eJF5A","@thi.ng/random/system":"bSLzr","./compile/emit.js":"hpIek","./index.js":"gLU21","./normalize.js":"9ex3j","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eJF5A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "normal", ()=>normal
);
var _systemJs = require("../system.js");
const normal = (rnd = _systemJs.SYSTEM, bias = 0, sigma = 1)=>{
    let a;
    let b;
    let r;
    return ()=>{
        if (a != null) {
            b = a;
            a = null;
        } else do {
            a = rnd.norm();
            b = rnd.norm();
            r = a * a + b * b;
        }while (r > 1 || r === 0)
        return bias + sigma * b * Math.sqrt(-2 * Math.log(r) / r);
    };
};

},{"../system.js":"bSLzr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gLU21":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _apiJs = require("./api.js");
parcelHelpers.exportAll(_apiJs, exports);
var _iteratorJs = require("./iterator.js");
parcelHelpers.exportAll(_iteratorJs, exports);
var _accessorsJs = require("./compile/accessors.js");
parcelHelpers.exportAll(_accessorsJs, exports);
var _emitJs = require("./compile/emit.js");
parcelHelpers.exportAll(_emitJs, exports);
var _templatesJs = require("./compile/templates.js");
parcelHelpers.exportAll(_templatesJs, exports);
var _avecJs = require("./avec.js");
parcelHelpers.exportAll(_avecJs, exports);
var _vec2Js = require("./vec2.js");
parcelHelpers.exportAll(_vec2Js, exports);
var _vec3Js = require("./vec3.js");
parcelHelpers.exportAll(_vec3Js, exports);
var _vec4Js = require("./vec4.js");
parcelHelpers.exportAll(_vec4Js, exports);
var _vopJs = require("./vop.js");
parcelHelpers.exportAll(_vopJs, exports);
var _absJs = require("./abs.js");
parcelHelpers.exportAll(_absJs, exports);
var _acosJs = require("./acos.js");
parcelHelpers.exportAll(_acosJs, exports);
var _addwJs = require("./addw.js");
parcelHelpers.exportAll(_addwJs, exports);
var _addJs = require("./add.js");
parcelHelpers.exportAll(_addJs, exports);
var _addiJs = require("./addi.js");
parcelHelpers.exportAll(_addiJs, exports);
var _addmJs = require("./addm.js");
parcelHelpers.exportAll(_addmJs, exports);
var _addmnJs = require("./addmn.js");
parcelHelpers.exportAll(_addmnJs, exports);
var _addmsJs = require("./addms.js");
parcelHelpers.exportAll(_addmsJs, exports);
var _addmnsJs = require("./addmns.js");
parcelHelpers.exportAll(_addmnsJs, exports);
var _addnJs = require("./addn.js");
parcelHelpers.exportAll(_addnJs, exports);
var _addsJs = require("./adds.js");
parcelHelpers.exportAll(_addsJs, exports);
var _addnsJs = require("./addns.js");
parcelHelpers.exportAll(_addnsJs, exports);
var _angleBetweenJs = require("./angle-between.js");
parcelHelpers.exportAll(_angleBetweenJs, exports);
var _asinJs = require("./asin.js");
parcelHelpers.exportAll(_asinJs, exports);
var _atanJs = require("./atan.js");
parcelHelpers.exportAll(_atanJs, exports);
var _bisectJs = require("./bisect.js");
parcelHelpers.exportAll(_bisectJs, exports);
var _bitAndJs = require("./bit-and.js");
parcelHelpers.exportAll(_bitAndJs, exports);
var _bitNotJs = require("./bit-not.js");
parcelHelpers.exportAll(_bitNotJs, exports);
var _bitOrJs = require("./bit-or.js");
parcelHelpers.exportAll(_bitOrJs, exports);
var _bitXorJs = require("./bit-xor.js");
parcelHelpers.exportAll(_bitXorJs, exports);
var _bufferJs = require("./buffer.js");
parcelHelpers.exportAll(_bufferJs, exports);
var _cartesianJs = require("./cartesian.js");
parcelHelpers.exportAll(_cartesianJs, exports);
var _ceilJs = require("./ceil.js");
parcelHelpers.exportAll(_ceilJs, exports);
var _centerJs = require("./center.js");
parcelHelpers.exportAll(_centerJs, exports);
var _clampJs = require("./clamp.js");
parcelHelpers.exportAll(_clampJs, exports);
var _clampnJs = require("./clampn.js");
parcelHelpers.exportAll(_clampnJs, exports);
var _clockwiseJs = require("./clockwise.js");
parcelHelpers.exportAll(_clockwiseJs, exports);
var _compareJs = require("./compare.js");
parcelHelpers.exportAll(_compareJs, exports);
var _convertJs = require("./convert.js");
parcelHelpers.exportAll(_convertJs, exports);
var _copyJs = require("./copy.js");
parcelHelpers.exportAll(_copyJs, exports);
var _correlationJs = require("./correlation.js");
parcelHelpers.exportAll(_correlationJs, exports);
var _cosJs = require("./cos.js");
parcelHelpers.exportAll(_cosJs, exports);
var _coshJs = require("./cosh.js");
parcelHelpers.exportAll(_coshJs, exports);
var _covarianceJs = require("./covariance.js");
parcelHelpers.exportAll(_covarianceJs, exports);
var _crossJs = require("./cross.js");
parcelHelpers.exportAll(_crossJs, exports);
var _crosssJs = require("./crosss.js");
parcelHelpers.exportAll(_crosssJs, exports);
var _degreesJs = require("./degrees.js");
parcelHelpers.exportAll(_degreesJs, exports);
var _directionJs = require("./direction.js");
parcelHelpers.exportAll(_directionJs, exports);
var _distJs = require("./dist.js");
parcelHelpers.exportAll(_distJs, exports);
var _distBraycurtisJs = require("./dist-braycurtis.js");
parcelHelpers.exportAll(_distBraycurtisJs, exports);
var _distCanberraJs = require("./dist-canberra.js");
parcelHelpers.exportAll(_distCanberraJs, exports);
var _distChebyshevJs = require("./dist-chebyshev.js");
parcelHelpers.exportAll(_distChebyshevJs, exports);
var _distHammingJs = require("./dist-hamming.js");
parcelHelpers.exportAll(_distHammingJs, exports);
var _distHaversineJs = require("./dist-haversine.js");
parcelHelpers.exportAll(_distHaversineJs, exports);
var _distJaccardJs = require("./dist-jaccard.js");
parcelHelpers.exportAll(_distJaccardJs, exports);
var _distManhattanJs = require("./dist-manhattan.js");
parcelHelpers.exportAll(_distManhattanJs, exports);
var _distMinkowskiJs = require("./dist-minkowski.js");
parcelHelpers.exportAll(_distMinkowskiJs, exports);
var _distSorensendiceJs = require("./dist-sorensendice.js");
parcelHelpers.exportAll(_distSorensendiceJs, exports);
var _distWeightedJs = require("./dist-weighted.js");
parcelHelpers.exportAll(_distWeightedJs, exports);
var _distsqJs = require("./distsq.js");
parcelHelpers.exportAll(_distsqJs, exports);
var _divJs = require("./div.js");
parcelHelpers.exportAll(_divJs, exports);
var _diviJs = require("./divi.js");
parcelHelpers.exportAll(_diviJs, exports);
var _divnJs = require("./divn.js");
parcelHelpers.exportAll(_divnJs, exports);
var _divsJs = require("./divs.js");
parcelHelpers.exportAll(_divsJs, exports);
var _divnsJs = require("./divns.js");
parcelHelpers.exportAll(_divnsJs, exports);
var _dotJs = require("./dot.js");
parcelHelpers.exportAll(_dotJs, exports);
var _dotcJs = require("./dotc.js");
parcelHelpers.exportAll(_dotcJs, exports);
var _dotsJs = require("./dots.js");
parcelHelpers.exportAll(_dotsJs, exports);
var _emptyJs = require("./empty.js");
parcelHelpers.exportAll(_emptyJs, exports);
var _eqdeltaJs = require("./eqdelta.js");
parcelHelpers.exportAll(_eqdeltaJs, exports);
var _equalsJs = require("./equals.js");
parcelHelpers.exportAll(_equalsJs, exports);
var _everyJs = require("./every.js");
parcelHelpers.exportAll(_everyJs, exports);
var _expJs = require("./exp.js");
parcelHelpers.exportAll(_expJs, exports);
var _exp2Js = require("./exp_2.js");
parcelHelpers.exportAll(_exp2Js, exports);
var _faceForwardJs = require("./face-forward.js");
parcelHelpers.exportAll(_faceForwardJs, exports);
var _fillJs = require("./fill.js");
parcelHelpers.exportAll(_fillJs, exports);
var _fitJs = require("./fit.js");
parcelHelpers.exportAll(_fitJs, exports);
var _floorJs = require("./floor.js");
parcelHelpers.exportAll(_floorJs, exports);
var _fmodJs = require("./fmod.js");
parcelHelpers.exportAll(_fmodJs, exports);
var _fmodnJs = require("./fmodn.js");
parcelHelpers.exportAll(_fmodnJs, exports);
var _fractJs = require("./fract.js");
parcelHelpers.exportAll(_fractJs, exports);
var _gvecJs = require("./gvec.js");
parcelHelpers.exportAll(_gvecJs, exports);
var _hashJs = require("./hash.js");
parcelHelpers.exportAll(_hashJs, exports);
var _headingJs = require("./heading.js");
parcelHelpers.exportAll(_headingJs, exports);
var _headingSegmentJs = require("./heading-segment.js");
parcelHelpers.exportAll(_headingSegmentJs, exports);
var _homogeneousJs = require("./homogeneous.js");
parcelHelpers.exportAll(_homogeneousJs, exports);
var _invertJs = require("./invert.js");
parcelHelpers.exportAll(_invertJs, exports);
var _invsqrtJs = require("./invsqrt.js");
parcelHelpers.exportAll(_invsqrtJs, exports);
var _isInfJs = require("./is-inf.js");
parcelHelpers.exportAll(_isInfJs, exports);
var _isNanJs = require("./is-nan.js");
parcelHelpers.exportAll(_isNanJs, exports);
var _jitterJs = require("./jitter.js");
parcelHelpers.exportAll(_jitterJs, exports);
var _limitJs = require("./limit.js");
parcelHelpers.exportAll(_limitJs, exports);
var _logJs = require("./log.js");
parcelHelpers.exportAll(_logJs, exports);
var _log2Js = require("./log_2.js");
parcelHelpers.exportAll(_log2Js, exports);
var _logicAndJs = require("./logic-and.js");
parcelHelpers.exportAll(_logicAndJs, exports);
var _logicNotJs = require("./logic-not.js");
parcelHelpers.exportAll(_logicNotJs, exports);
var _logicOrJs = require("./logic-or.js");
parcelHelpers.exportAll(_logicOrJs, exports);
var _lshiftJs = require("./lshift.js");
parcelHelpers.exportAll(_lshiftJs, exports);
var _maddJs = require("./madd.js");
parcelHelpers.exportAll(_maddJs, exports);
var _maddnJs = require("./maddn.js");
parcelHelpers.exportAll(_maddnJs, exports);
var _maddsJs = require("./madds.js");
parcelHelpers.exportAll(_maddsJs, exports);
var _maddnsJs = require("./maddns.js");
parcelHelpers.exportAll(_maddnsJs, exports);
var _magJs = require("./mag.js");
parcelHelpers.exportAll(_magJs, exports);
var _magsJs = require("./mags.js");
parcelHelpers.exportAll(_magsJs, exports);
var _magsqJs = require("./magsq.js");
parcelHelpers.exportAll(_magsqJs, exports);
var _magsqsJs = require("./magsqs.js");
parcelHelpers.exportAll(_magsqsJs, exports);
var _majorJs = require("./major.js");
parcelHelpers.exportAll(_majorJs, exports);
var _mapJs = require("./map.js");
parcelHelpers.exportAll(_mapJs, exports);
var _mapVectorsJs = require("./map-vectors.js");
parcelHelpers.exportAll(_mapVectorsJs, exports);
var _maxJs = require("./max.js");
parcelHelpers.exportAll(_maxJs, exports);
var _maxBoundsJs = require("./max-bounds.js");
parcelHelpers.exportAll(_maxBoundsJs, exports);
var _meanJs = require("./mean.js");
parcelHelpers.exportAll(_meanJs, exports);
var _medianJs = require("./median.js");
parcelHelpers.exportAll(_medianJs, exports);
var _minJs = require("./min.js");
parcelHelpers.exportAll(_minJs, exports);
var _minBoundsJs = require("./min-bounds.js");
parcelHelpers.exportAll(_minBoundsJs, exports);
var _minorJs = require("./minor.js");
parcelHelpers.exportAll(_minorJs, exports);
var _mixBilinearJs = require("./mix-bilinear.js");
parcelHelpers.exportAll(_mixBilinearJs, exports);
var _mixCubicJs = require("./mix-cubic.js");
parcelHelpers.exportAll(_mixCubicJs, exports);
var _mixHermiteJs = require("./mix-hermite.js");
parcelHelpers.exportAll(_mixHermiteJs, exports);
var _mixQuadraticJs = require("./mix-quadratic.js");
parcelHelpers.exportAll(_mixQuadraticJs, exports);
var _mixJs = require("./mix.js");
parcelHelpers.exportAll(_mixJs, exports);
var _mixnJs = require("./mixn.js");
parcelHelpers.exportAll(_mixnJs, exports);
var _mixsJs = require("./mixs.js");
parcelHelpers.exportAll(_mixsJs, exports);
var _mixnsJs = require("./mixns.js");
parcelHelpers.exportAll(_mixnsJs, exports);
var _modJs = require("./mod.js");
parcelHelpers.exportAll(_modJs, exports);
var _modnJs = require("./modn.js");
parcelHelpers.exportAll(_modnJs, exports);
var _msubJs = require("./msub.js");
parcelHelpers.exportAll(_msubJs, exports);
var _msubnJs = require("./msubn.js");
parcelHelpers.exportAll(_msubnJs, exports);
var _msubsJs = require("./msubs.js");
parcelHelpers.exportAll(_msubsJs, exports);
var _msubnsJs = require("./msubns.js");
parcelHelpers.exportAll(_msubnsJs, exports);
var _mulJs = require("./mul.js");
parcelHelpers.exportAll(_mulJs, exports);
var _muliJs = require("./muli.js");
parcelHelpers.exportAll(_muliJs, exports);
var _mulnJs = require("./muln.js");
parcelHelpers.exportAll(_mulnJs, exports);
var _mulsJs = require("./muls.js");
parcelHelpers.exportAll(_mulsJs, exports);
var _mulnsJs = require("./mulns.js");
parcelHelpers.exportAll(_mulnsJs, exports);
var _negJs = require("./neg.js");
parcelHelpers.exportAll(_negJs, exports);
var _normalJs = require("./normal.js");
parcelHelpers.exportAll(_normalJs, exports);
var _normalizeJs = require("./normalize.js");
parcelHelpers.exportAll(_normalizeJs, exports);
var _normalizesJs = require("./normalizes.js");
parcelHelpers.exportAll(_normalizesJs, exports);
var _notJs = require("./not.js");
parcelHelpers.exportAll(_notJs, exports);
var _orthoNormalJs = require("./ortho-normal.js");
parcelHelpers.exportAll(_orthoNormalJs, exports);
var _perpendicularJs = require("./perpendicular.js");
parcelHelpers.exportAll(_perpendicularJs, exports);
var _pointOnRayJs = require("./point-on-ray.js");
parcelHelpers.exportAll(_pointOnRayJs, exports);
var _polarJs = require("./polar.js");
parcelHelpers.exportAll(_polarJs, exports);
var _powJs = require("./pow.js");
parcelHelpers.exportAll(_powJs, exports);
var _pownJs = require("./pown.js");
parcelHelpers.exportAll(_pownJs, exports);
var _projectJs = require("./project.js");
parcelHelpers.exportAll(_projectJs, exports);
var _radiansJs = require("./radians.js");
parcelHelpers.exportAll(_radiansJs, exports);
var _randomJs = require("./random.js");
parcelHelpers.exportAll(_randomJs, exports);
var _randomsJs = require("./randoms.js");
parcelHelpers.exportAll(_randomsJs, exports);
var _reflectJs = require("./reflect.js");
parcelHelpers.exportAll(_reflectJs, exports);
var _refractJs = require("./refract.js");
parcelHelpers.exportAll(_refractJs, exports);
var _remainderJs = require("./remainder.js");
parcelHelpers.exportAll(_remainderJs, exports);
var _remaindernJs = require("./remaindern.js");
parcelHelpers.exportAll(_remaindernJs, exports);
var _rotateAroundAxisJs = require("./rotate-around-axis.js");
parcelHelpers.exportAll(_rotateAroundAxisJs, exports);
var _rotateAroundPointJs = require("./rotate-around-point.js");
parcelHelpers.exportAll(_rotateAroundPointJs, exports);
var _rotateJs = require("./rotate.js");
parcelHelpers.exportAll(_rotateJs, exports);
var _rotatesJs = require("./rotates.js");
parcelHelpers.exportAll(_rotatesJs, exports);
var _roundJs = require("./round.js");
parcelHelpers.exportAll(_roundJs, exports);
var _rshiftJs = require("./rshift.js");
parcelHelpers.exportAll(_rshiftJs, exports);
var _safeDivJs = require("./safe-div.js");
parcelHelpers.exportAll(_safeDivJs, exports);
var _selectJs = require("./select.js");
parcelHelpers.exportAll(_selectJs, exports);
var _setJs = require("./set.js");
parcelHelpers.exportAll(_setJs, exports);
var _setcJs = require("./setc.js");
parcelHelpers.exportAll(_setcJs, exports);
var _setnJs = require("./setn.js");
parcelHelpers.exportAll(_setnJs, exports);
var _setsJs = require("./sets.js");
parcelHelpers.exportAll(_setsJs, exports);
var _setcsJs = require("./setcs.js");
parcelHelpers.exportAll(_setcsJs, exports);
var _setnsJs = require("./setns.js");
parcelHelpers.exportAll(_setnsJs, exports);
var _setvnJs = require("./setvn.js");
parcelHelpers.exportAll(_setvnJs, exports);
var _setvvJs = require("./setvv.js");
parcelHelpers.exportAll(_setvvJs, exports);
var _signJs = require("./sign.js");
parcelHelpers.exportAll(_signJs, exports);
var _signedAreaJs = require("./signed-area.js");
parcelHelpers.exportAll(_signedAreaJs, exports);
var _signedVolumeJs = require("./signed-volume.js");
parcelHelpers.exportAll(_signedVolumeJs, exports);
var _sinJs = require("./sin.js");
parcelHelpers.exportAll(_sinJs, exports);
var _sinhJs = require("./sinh.js");
parcelHelpers.exportAll(_sinhJs, exports);
var _softmaxJs = require("./softmax.js");
parcelHelpers.exportAll(_softmaxJs, exports);
var _someJs = require("./some.js");
parcelHelpers.exportAll(_someJs, exports);
var _sqrtJs = require("./sqrt.js");
parcelHelpers.exportAll(_sqrtJs, exports);
var _stepJs = require("./step.js");
parcelHelpers.exportAll(_stepJs, exports);
var _smoothstepJs = require("./smoothstep.js");
parcelHelpers.exportAll(_smoothstepJs, exports);
var _standardizeJs = require("./standardize.js");
parcelHelpers.exportAll(_standardizeJs, exports);
var _stringJs = require("./string.js");
parcelHelpers.exportAll(_stringJs, exports);
var _subJs = require("./sub.js");
parcelHelpers.exportAll(_subJs, exports);
var _subiJs = require("./subi.js");
parcelHelpers.exportAll(_subiJs, exports);
var _submJs = require("./subm.js");
parcelHelpers.exportAll(_submJs, exports);
var _submnJs = require("./submn.js");
parcelHelpers.exportAll(_submnJs, exports);
var _submsJs = require("./subms.js");
parcelHelpers.exportAll(_submsJs, exports);
var _submnsJs = require("./submns.js");
parcelHelpers.exportAll(_submnsJs, exports);
var _subnJs = require("./subn.js");
parcelHelpers.exportAll(_subnJs, exports);
var _subsJs = require("./subs.js");
parcelHelpers.exportAll(_subsJs, exports);
var _subnsJs = require("./subns.js");
parcelHelpers.exportAll(_subnsJs, exports);
var _sumJs = require("./sum.js");
parcelHelpers.exportAll(_sumJs, exports);
var _swizzleJs = require("./swizzle.js");
parcelHelpers.exportAll(_swizzleJs, exports);
var _tanJs = require("./tan.js");
parcelHelpers.exportAll(_tanJs, exports);
var _tanhJs = require("./tanh.js");
parcelHelpers.exportAll(_tanhJs, exports);
var _tensorJs = require("./tensor.js");
parcelHelpers.exportAll(_tensorJs, exports);
var _truncJs = require("./trunc.js");
parcelHelpers.exportAll(_truncJs, exports);
var _varianceJs = require("./variance.js");
parcelHelpers.exportAll(_varianceJs, exports);
var _vecOfJs = require("./vec-of.js");
parcelHelpers.exportAll(_vecOfJs, exports);
var _wrapJs = require("./wrap.js");
parcelHelpers.exportAll(_wrapJs, exports);
var _eqJs = require("./eq.js");
parcelHelpers.exportAll(_eqJs, exports);
var _neqJs = require("./neq.js");
parcelHelpers.exportAll(_neqJs, exports);
var _gtJs = require("./gt.js");
parcelHelpers.exportAll(_gtJs, exports);
var _gteJs = require("./gte.js");
parcelHelpers.exportAll(_gteJs, exports);
var _ltJs = require("./lt.js");
parcelHelpers.exportAll(_ltJs, exports);
var _lteJs = require("./lte.js");
parcelHelpers.exportAll(_lteJs, exports);

},{"./api.js":"60HDf","./iterator.js":"dnjxi","./compile/accessors.js":"5h29N","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","./avec.js":"czAXr","./vec2.js":"2P1xq","./vec3.js":"65hPu","./vec4.js":"iQG7M","./vop.js":"4v2k5","./abs.js":"ivhHk","./acos.js":"kPmuu","./addw.js":"cFpxt","./add.js":"6HmvS","./addi.js":"5JekR","./addm.js":"7tmcI","./addmn.js":"9C52h","./addms.js":"cfDqf","./addmns.js":"jvybo","./addn.js":"cecib","./adds.js":"cZbCm","./addns.js":"cDsWw","./angle-between.js":"8OhzV","./asin.js":"fm4pB","./atan.js":"aiYhv","./bisect.js":"bXCEG","./bit-and.js":"ihEMJ","./bit-not.js":"5kBRM","./bit-or.js":"8o6Ie","./bit-xor.js":"7BWzt","./buffer.js":"ecaja","./cartesian.js":"g2NFB","./ceil.js":"2tmeM","./center.js":"2MkSv","./clamp.js":"k99Yr","./clampn.js":"4kXdw","./clockwise.js":"hd0jc","./compare.js":"b5iVX","./convert.js":"hGWRF","./copy.js":"4RdrM","./correlation.js":"5oxGU","./cos.js":"kXrcE","./cosh.js":"O9xPf","./covariance.js":"alatG","./cross.js":"a6Q1x","./crosss.js":"2Nw0k","./degrees.js":"8oHW5","./direction.js":"g7PP7","./dist.js":"kIwBu","./dist-braycurtis.js":"8W4oS","./dist-canberra.js":"bsKNq","./dist-chebyshev.js":"kKt2g","./dist-hamming.js":"gmYUE","./dist-haversine.js":"c8sP5","./dist-jaccard.js":"8rqoi","./dist-manhattan.js":"dV6Jy","./dist-minkowski.js":"85fil","./dist-sorensendice.js":"eyp87","./dist-weighted.js":"btBuC","./distsq.js":"8XCdB","./div.js":"5inb4","./divi.js":"hac1Q","./divn.js":"8VZzE","./divs.js":"c7wQo","./divns.js":"afuXO","./dot.js":"9vV5N","./dotc.js":"cU5Pz","./dots.js":"3KJkk","./empty.js":"5JVqG","./eqdelta.js":"eBVIX","./equals.js":"kCRCM","./every.js":"kHThs","./exp.js":"5Qp2H","./exp_2.js":"9UjlL","./face-forward.js":"iuxjX","./fill.js":"klykq","./fit.js":"dCUuP","./floor.js":"8Bam4","./fmod.js":"5TOiT","./fmodn.js":"bYnoA","./fract.js":"4fVSV","./gvec.js":"1cUXh","./hash.js":"e4rRM","./heading.js":"jM0y9","./heading-segment.js":"a3Qmf","./homogeneous.js":"a3DYy","./invert.js":"hJpMW","./invsqrt.js":"bHU8F","./is-inf.js":"hVJ5w","./is-nan.js":"lmjNR","./jitter.js":"aBPSB","./limit.js":"ceTNs","./log.js":"zFq2X","./log_2.js":"1fpEn","./logic-and.js":"b5AQh","./logic-not.js":"eDW8G","./logic-or.js":"3aaGQ","./lshift.js":"46YJu","./madd.js":"8NYtQ","./maddn.js":"bTkou","./madds.js":"iDF9M","./maddns.js":"iOnQH","./mag.js":"70TCJ","./mags.js":"h4CFH","./magsq.js":"bsMC4","./magsqs.js":"b5N6p","./major.js":"hqWnf","./map.js":"7CzQk","./map-vectors.js":"8KUWS","./max.js":"7CH4J","./max-bounds.js":"l64lm","./mean.js":"7w5sd","./median.js":"k1qXc","./min.js":"gWOyO","./min-bounds.js":"kPgsx","./minor.js":"9omJw","./mix-bilinear.js":"baPCK","./mix-cubic.js":"5OlFY","./mix-hermite.js":"114q9","./mix-quadratic.js":"6mY6C","./mix.js":"hb219","./mixn.js":"jolPM","./mixs.js":"gLg2m","./mixns.js":"glIAb","./mod.js":"fNrmT","./modn.js":"YyBoO","./msub.js":"8UZie","./msubn.js":"9zPln","./msubs.js":"ke6Rd","./msubns.js":"6JEEE","./mul.js":"bTRb3","./muli.js":"aJFBK","./muln.js":"1TKlE","./muls.js":"01xwB","./mulns.js":"b3IkY","./neg.js":"gnwVs","./normal.js":"8RAVI","./normalize.js":"9ex3j","./normalizes.js":"lD3Rj","./not.js":"u5ZXS","./ortho-normal.js":"h0jz9","./perpendicular.js":"dnMKL","./point-on-ray.js":"lDaDN","./polar.js":"hjxag","./pow.js":"ek3Z1","./pown.js":"e4E3E","./project.js":"3Ztzw","./radians.js":"4f5wk","./random.js":"8bjGw","./randoms.js":"jp9qg","./reflect.js":"d5xc2","./refract.js":"1FHgE","./remainder.js":"8QlLp","./remaindern.js":"6YhVp","./rotate-around-axis.js":"bnMmK","./rotate-around-point.js":"fTth1","./rotate.js":"756IA","./rotates.js":"f8Qd6","./round.js":"k0lRR","./rshift.js":"5ezs6","./safe-div.js":"iquHD","./select.js":"e9RWo","./set.js":"bSUB8","./setc.js":"jST0o","./setn.js":"2M6y1","./sets.js":"3jBTJ","./setcs.js":"35qNU","./setns.js":"fEREX","./setvn.js":"8Xxwm","./setvv.js":"bgsN2","./sign.js":"deOCU","./signed-area.js":"2iZFe","./signed-volume.js":"kWxbb","./sin.js":"eQFJ3","./sinh.js":"4FADI","./softmax.js":"awIye","./some.js":"kVDnA","./sqrt.js":"adalI","./step.js":"1iWKd","./smoothstep.js":"95Lq7","./standardize.js":"dbQSi","./string.js":"iiJ6W","./sub.js":"fzaw7","./subi.js":"csHlx","./subm.js":"92Lej","./submn.js":"aIPIo","./subms.js":"1EUBR","./submns.js":"co6Wj","./subn.js":"i3npD","./subs.js":"h2qQr","./subns.js":"hfisH","./sum.js":"2gBvR","./swizzle.js":"8JoUk","./tan.js":"9mqB8","./tanh.js":"cIJ1g","./tensor.js":"coH0v","./trunc.js":"1UHBI","./variance.js":"5Fsvh","./vec-of.js":"1dJsE","./wrap.js":"7bcGS","./eq.js":"XkoMe","./neq.js":"1PSgL","./gt.js":"c6eU8","./gte.js":"h9jv8","./lt.js":"8IIjy","./lte.js":"7gcE2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"60HDf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MIN2", ()=>MIN2
);
parcelHelpers.export(exports, "MAX2", ()=>MAX2
);
parcelHelpers.export(exports, "ONE2", ()=>ONE2
);
parcelHelpers.export(exports, "ZERO2", ()=>ZERO2
);
parcelHelpers.export(exports, "X2", ()=>X2
);
parcelHelpers.export(exports, "Y2", ()=>Y2
);
parcelHelpers.export(exports, "MIN3", ()=>MIN3
);
parcelHelpers.export(exports, "MAX3", ()=>MAX3
);
parcelHelpers.export(exports, "ONE3", ()=>ONE3
);
parcelHelpers.export(exports, "ZERO3", ()=>ZERO3
);
parcelHelpers.export(exports, "X3", ()=>X3
);
parcelHelpers.export(exports, "Y3", ()=>Y3
);
parcelHelpers.export(exports, "Z3", ()=>Z3
);
parcelHelpers.export(exports, "MIN4", ()=>MIN4
);
parcelHelpers.export(exports, "MAX4", ()=>MAX4
);
parcelHelpers.export(exports, "ONE4", ()=>ONE4
);
parcelHelpers.export(exports, "ZERO4", ()=>ZERO4
);
parcelHelpers.export(exports, "X4", ()=>X4
);
parcelHelpers.export(exports, "Y4", ()=>Y4
);
parcelHelpers.export(exports, "Z4", ()=>Z4
);
parcelHelpers.export(exports, "W4", ()=>W4
);
const mi = -Infinity;
const mx = Infinity;
const MIN2 = Object.freeze([
    mi,
    mi
]);
const MAX2 = Object.freeze([
    mx,
    mx
]);
const ONE2 = Object.freeze([
    1,
    1
]);
const ZERO2 = Object.freeze([
    0,
    0
]);
const X2 = Object.freeze([
    1,
    0
]);
const Y2 = Object.freeze([
    0,
    1
]);
const MIN3 = Object.freeze([
    mi,
    mi,
    mi
]);
const MAX3 = Object.freeze([
    mx,
    mx,
    mx
]);
const ONE3 = Object.freeze([
    1,
    1,
    1
]);
const ZERO3 = Object.freeze([
    0,
    0,
    0
]);
const X3 = Object.freeze([
    1,
    0,
    0
]);
const Y3 = Object.freeze([
    0,
    1,
    0
]);
const Z3 = Object.freeze([
    0,
    0,
    1
]);
const MIN4 = Object.freeze([
    mi,
    mi,
    mi,
    mi
]);
const MAX4 = Object.freeze([
    mx,
    mx,
    mx,
    mx
]);
const ONE4 = Object.freeze([
    1,
    1,
    1,
    1
]);
const ZERO4 = Object.freeze([
    0,
    0,
    0,
    0
]);
const X4 = Object.freeze([
    1,
    0,
    0,
    0
]);
const Y4 = Object.freeze([
    0,
    1,
    0,
    0
]);
const Z4 = Object.freeze([
    0,
    0,
    1,
    0
]);
const W4 = Object.freeze([
    0,
    0,
    0,
    1
]);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dnjxi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "vecIterator", ()=>vecIterator
);
parcelHelpers.export(exports, "stridedValues", ()=>stridedValues
);
function* vecIterator(ctor, buf, num, start, cstride, estride) {
    while(num-- > 0){
        yield new ctor(buf, start, cstride);
        start += estride;
    }
}
function* stridedValues(buf, num, start, stride) {
    while(num-- > 0){
        yield buf[start];
        start += stride;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5h29N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "declareIndex", ()=>declareIndex
);
parcelHelpers.export(exports, "declareIndices", ()=>declareIndices
);
const declareIndex = (proto, id, idx, strided = true, defNumeric = true)=>{
    const get = idx > 0 ? strided ? function() {
        return this.buf[this.offset + idx * this.stride];
    } : function() {
        return this.buf[this.offset + idx];
    } : function() {
        return this.buf[this.offset];
    };
    const set = idx > 0 ? strided ? function(n) {
        this.buf[this.offset + idx * this.stride] = n;
    } : function(n) {
        this.buf[this.offset + idx] = n;
    } : function(n) {
        this.buf[this.offset] = n;
    };
    defNumeric && Object.defineProperty(proto, idx, {
        get,
        set,
        enumerable: true
    });
    Object.defineProperty(proto, id, {
        get,
        set,
        enumerable: true
    });
};
const declareIndices = (proto, props, strided, defNumeric)=>props.forEach((id, i)=>declareIndex(proto, id, i, strided, defNumeric)
    )
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"czAXr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AVec", ()=>AVec
);
var _stringJs = require("./string.js");
class AVec {
    constructor(buf, offset = 0, stride = 1){
        this.buf = buf;
        this.offset = offset;
        this.stride = stride;
    }
    toString() {
        return _stringJs.FORMATTER(this);
    }
}

},{"./string.js":"iiJ6W","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iiJ6W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defFormat", ()=>defFormat
);
parcelHelpers.export(exports, "setFormat", ()=>setFormat
);
parcelHelpers.export(exports, "FORMATTER", ()=>FORMATTER
);
var _isFunction = require("@thi.ng/checks/is-function");
var _float = require("@thi.ng/strings/float");
const defFormat = (opts)=>{
    const { prec , width , delim , wrap  } = {
        prec: 3,
        delim: ", ",
        wrap: "[]",
        ...opts
    };
    const fmt = width ? _float.floatFixedWidth(width, prec) : _float.float(prec);
    return (src)=>{
        let res = [];
        for (let x of src)res.push(fmt(x));
        return `${wrap[0]}${res.join(delim)}${wrap[1]}`;
    };
};
const setFormat = (fmt)=>{
    FORMATTER = _isFunction.isFunction(fmt) ? fmt : defFormat(fmt);
};
let FORMATTER = defFormat();

},{"@thi.ng/checks/is-function":"4VSWl","@thi.ng/strings/float":"8t0B1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4VSWl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isFunction", ()=>isFunction
);
const isFunction = (x)=>typeof x === "function"
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8t0B1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "float", ()=>float
);
parcelHelpers.export(exports, "floatFixedWidth", ()=>floatFixedWidth
);
var _memoizej = require("@thi.ng/memoize/memoizej");
var _padLeftJs = require("./pad-left.js");
const float = _memoizej.memoizeJ((prec, special = false)=>special ? (x)=>nanOrInf(x) || x.toFixed(prec)
     : (x)=>x.toFixed(prec)
);
const floatFixedWidth = _memoizej.memoizeJ((width, prec = 3)=>{
    const l = width - prec - 1;
    const pl = Math.pow(10, l);
    const pln = -Math.pow(10, l - 1);
    const pr = Math.pow(10, -(prec - 1));
    const pad = _padLeftJs.padLeft(width);
    return (x)=>{
        const ax = Math.abs(x);
        return pad(nanOrInf(x) || (x === 0 ? "0" : ax < pr || ax >= pl ? exp(x, width) : x.toFixed(prec - (x < pln ? 1 : 0))));
    };
});
const exp = (x, w)=>x.toExponential(Math.max(w - 4 - (Math.log(Math.abs(x)) / Math.LN10 >= 10 ? 2 : 1) - (x < 0 ? 1 : 0), 0))
;
const nanOrInf = (x)=>isNaN(x) ? "NaN" : x === Infinity ? "+" : x === -Infinity ? "-" : undefined
;

},{"@thi.ng/memoize/memoizej":"kpZq7","./pad-left.js":"jyWQa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kpZq7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "memoizeJ", ()=>memoizeJ
);
function memoizeJ(fn, cache) {
    !cache && (cache = {
    });
    return (...args)=>{
        const key = JSON.stringify(args);
        if (key !== undefined) return key in cache ? cache[key] : cache[key] = fn.apply(null, args);
        return fn.apply(null, args);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jyWQa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "padLeft", ()=>padLeft
);
parcelHelpers.export(exports, "Z2", ()=>Z2
);
parcelHelpers.export(exports, "Z3", ()=>Z3
);
parcelHelpers.export(exports, "Z4", ()=>Z4
);
var _memoizej = require("@thi.ng/memoize/memoizej");
var _repeatJs = require("./repeat.js");
const padLeft = _memoizej.memoizeJ((n, ch = " ")=>{
    const buf = _repeatJs.repeat(String(ch), n);
    return (x, len)=>{
        if (x == null) return buf;
        x = x.toString();
        len = len !== undefined ? len : x.length;
        return len < n ? buf.substring(len) + x : x;
    };
});
const Z2 = padLeft(2, "0");
const Z3 = padLeft(3, "0");
const Z4 = padLeft(4, "0");

},{"@thi.ng/memoize/memoizej":"kpZq7","./repeat.js":"jrSWh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jrSWh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "repeat", ()=>repeat
);
var _memoizej = require("@thi.ng/memoize/memoizej");
const repeat = _memoizej.memoizeJ((ch, n)=>ch.repeat(n)
);

},{"@thi.ng/memoize/memoizej":"kpZq7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2P1xq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Vec2", ()=>Vec2
);
parcelHelpers.export(exports, "vec2", ()=>vec2
);
parcelHelpers.export(exports, "vec2n", ()=>vec2n
);
parcelHelpers.export(exports, "asVec2", ()=>asVec2
);
var _api = require("@thi.ng/math/api");
var _accessorsJs = require("./compile/accessors.js");
var _apiJs = require("./api.js");
var _avecJs = require("./avec.js");
var _bufferJs = require("./buffer.js");
var _eqdeltaJs = require("./eqdelta.js");
var _hashJs = require("./hash.js");
var _iteratorJs = require("./iterator.js");
var _setsJs = require("./sets.js");
class Vec2 extends _avecJs.AVec {
    constructor(buf, offset = 0, stride = 1){
        super(buf || [
            0,
            0
        ], offset, stride);
    }
    /**
     * Returns array of memory mapped {@link Vec2} instances using given
     * backing array and stride settings: The `cstride` is the step size
     * between individual XY vector components. `estride` is the step
     * size between successive vectors. This arrangement allows for
     * different storage approaches, incl. SOA, AOS, striped /
     * interleaved etc.
     *
     * @param buf - backing array
     * @param num - num vectors
     * @param start -  start index
     * @param cstride - component stride
     * @param estride - element stride
     */ static mapBuffer(buf, num = buf.length >> 1, start = 0, cstride = 1, estride = 2) {
        return _bufferJs.mapStridedBuffer(Vec2, buf, num, start, cstride, estride);
    }
    /**
     * Merges given `src` iterable of {@link Vec2}s into single array `buf`.
     * Vectors will be arranged according to given component and element
     * strides, starting at `start` index. It's the user's
     * responsibility to ensure the target buffer has sufficient
     * capacity to hold the input vectors. See `Vec2.mapBuffer` for the
     * inverse operation. Returns `buf`.
     *
     * @param buf -
     * @param src -
     * @param start -
     * @param cstride -
     * @param estride -
     */ static intoBuffer(buf, src, start = 0, cstride = 1, estride = 2) {
        return _bufferJs.intoStridedBuffer(_setsJs.setS2, buf, src, start, cstride, estride);
    }
    static iterator(buf, num, start = 0, cstride = 1, estride = 2) {
        return _iteratorJs.vecIterator(Vec2, buf, num, start, cstride, estride);
    }
    [Symbol.iterator]() {
        return _iteratorJs.stridedValues(this.buf, 2, this.offset, this.stride);
    }
    get length() {
        return 2;
    }
    copy() {
        return new Vec2([
            this.x,
            this.y
        ]);
    }
    copyView() {
        return new Vec2(this.buf, this.offset, this.stride);
    }
    empty() {
        return new Vec2();
    }
    eqDelta(v, eps = _api.EPS) {
        return _eqdeltaJs.eqDelta2(this, v, eps);
    }
    hash() {
        return _hashJs.hash(this);
    }
    toJSON() {
        return [
            this.x,
            this.y
        ];
    }
}
Vec2.X_AXIS = new Vec2(_apiJs.X2);
Vec2.Y_AXIS = new Vec2(_apiJs.Y2);
Vec2.MIN = new Vec2(_apiJs.MIN2);
Vec2.MAX = new Vec2(_apiJs.MAX2);
Vec2.ZERO = new Vec2(_apiJs.ZERO2);
Vec2.ONE = new Vec2(_apiJs.ONE2);
_accessorsJs.declareIndices(Vec2.prototype, [
    "x",
    "y"
]);
const vec2 = (x = 0, y = 0)=>new Vec2([
        x,
        y
    ])
;
const vec2n = (n)=>new Vec2([
        n,
        n
    ])
;
const asVec2 = (x)=>x instanceof Vec2 ? x : new Vec2(x.length >= 2 ? x : [
        x[0] || 0,
        x[1] || 0
    ])
;

},{"@thi.ng/math/api":"4a98p","./compile/accessors.js":"5h29N","./api.js":"60HDf","./avec.js":"czAXr","./buffer.js":"ecaja","./eqdelta.js":"eBVIX","./hash.js":"e4rRM","./iterator.js":"dnjxi","./sets.js":"3jBTJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ecaja":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapBuffer", ()=>mapBuffer
);
parcelHelpers.export(exports, "intoBuffer", ()=>intoBuffer
);
parcelHelpers.export(exports, "mapStridedBuffer", ()=>mapStridedBuffer
);
parcelHelpers.export(exports, "intoStridedBuffer", ()=>intoStridedBuffer
);
var _typedarray = require("@thi.ng/api/typedarray");
const mapBuffer = (type, buf, num, size, byteOffset = 0, byteStride = size * _typedarray.SIZEOF[type])=>{
    const res = [];
    for(; num-- > 0; byteOffset += byteStride)res.push(_typedarray.typedArray(type, buf, byteOffset, size));
    return res;
};
const intoBuffer = (type, buf, src, byteOffset, byteStride)=>{
    const view = _typedarray.typedArray(type, buf);
    const size = _typedarray.SIZEOF[type];
    byteOffset /= size;
    byteStride /= size;
    for (let x of src){
        view.set(x, byteOffset);
        byteOffset += byteStride;
    }
};
const mapStridedBuffer = (ctor, buf, num, start, cstride, estride)=>{
    const res = [];
    while(num-- > 0){
        res.push(new ctor(buf, start, cstride));
        start += estride;
    }
    return res;
};
const intoStridedBuffer = (set, buf, src, start, cstride, estride)=>{
    for (let v of src){
        set(buf, v, start, 0, cstride, 1);
        start += estride;
    }
    return buf;
};

},{"@thi.ng/api/typedarray":"aGQJc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aGQJc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GLType", ()=>GLType
);
parcelHelpers.export(exports, "GL2TYPE", ()=>GL2TYPE
);
parcelHelpers.export(exports, "TYPE2GL", ()=>TYPE2GL
);
parcelHelpers.export(exports, "SIZEOF", ()=>SIZEOF
);
parcelHelpers.export(exports, "FLOAT_ARRAY_CTORS", ()=>FLOAT_ARRAY_CTORS
);
parcelHelpers.export(exports, "INT_ARRAY_CTORS", ()=>INT_ARRAY_CTORS
);
parcelHelpers.export(exports, "UINT_ARRAY_CTORS", ()=>UINT_ARRAY_CTORS
);
parcelHelpers.export(exports, "TYPEDARRAY_CTORS", ()=>TYPEDARRAY_CTORS
);
parcelHelpers.export(exports, "asNativeType", ()=>asNativeType
);
parcelHelpers.export(exports, "asGLType", ()=>asGLType
);
parcelHelpers.export(exports, "asInt", ()=>asInt
);
parcelHelpers.export(exports, "sizeOf", ()=>sizeOf
);
parcelHelpers.export(exports, "typedArray", ()=>typedArray
);
parcelHelpers.export(exports, "typedArrayType", ()=>typedArrayType
);
parcelHelpers.export(exports, "uintTypeForSize", ()=>uintTypeForSize
);
parcelHelpers.export(exports, "intTypeForSize", ()=>intTypeForSize
);
parcelHelpers.export(exports, "uintTypeForBits", ()=>uintTypeForBits
);
parcelHelpers.export(exports, "intTypeForBits", ()=>intTypeForBits
);
var GLType;
(function(GLType1) {
    GLType1[GLType1["I8"] = 5120] = "I8";
    GLType1[GLType1["U8"] = 5121] = "U8";
    GLType1[GLType1["I16"] = 5122] = "I16";
    GLType1[GLType1["U16"] = 5123] = "U16";
    GLType1[GLType1["I32"] = 5124] = "I32";
    GLType1[GLType1["U32"] = 5125] = "U32";
    GLType1[GLType1["F32"] = 5126] = "F32";
})(GLType || (GLType = {
}));
const GL2TYPE = {
    [GLType.I8]: "i8",
    [GLType.U8]: "u8",
    [GLType.I16]: "i16",
    [GLType.U16]: "u16",
    [GLType.I32]: "i32",
    [GLType.U32]: "u32",
    [GLType.F32]: "f32"
};
const TYPE2GL = {
    i8: GLType.I8,
    u8: GLType.U8,
    u8c: GLType.U8,
    i16: GLType.I16,
    u16: GLType.U16,
    i32: GLType.I32,
    u32: GLType.U32,
    f32: GLType.F32,
    f64: undefined
};
const SIZEOF = {
    u8: 1,
    u8c: 1,
    i8: 1,
    u16: 2,
    i16: 2,
    u32: 4,
    i32: 4,
    f32: 4,
    f64: 8
};
const FLOAT_ARRAY_CTORS = {
    f32: Float32Array,
    f64: Float64Array
};
const INT_ARRAY_CTORS = {
    i8: Int8Array,
    i16: Int16Array,
    i32: Int32Array
};
const UINT_ARRAY_CTORS = {
    u8: Uint8Array,
    u8c: Uint8ClampedArray,
    u16: Uint16Array,
    u32: Uint32Array
};
const TYPEDARRAY_CTORS = {
    ...FLOAT_ARRAY_CTORS,
    ...INT_ARRAY_CTORS,
    ...UINT_ARRAY_CTORS
};
const asNativeType = (type)=>{
    const t = GL2TYPE[type];
    return t !== undefined ? t : type;
};
const asGLType = (type)=>{
    const t = TYPE2GL[type];
    return t !== undefined ? t : type;
};
const asInt = (...args)=>args.map((x)=>x | 0
    )
;
const sizeOf = (type)=>SIZEOF[asNativeType(type)]
;
function typedArray(type, ...xs) {
    return new TYPEDARRAY_CTORS[asNativeType(type)](...xs);
}
const typedArrayType = (x)=>{
    if (Array.isArray(x)) return "f64";
    for(let id in TYPEDARRAY_CTORS){
        if (x instanceof TYPEDARRAY_CTORS[id]) return id;
    }
    return "f64";
};
const uintTypeForSize = (x)=>x <= 256 ? "u8" : x <= 65536 ? "u16" : "u32"
;
const intTypeForSize = (x)=>x >= -128 && x < 128 ? "i8" : x >= -32768 && x < 32768 ? "i16" : "i32"
;
const uintTypeForBits = (x)=>x > 16 ? "u32" : x > 8 ? "u16" : "u8"
;
const intTypeForBits = (x)=>x > 16 ? "i32" : x > 8 ? "i16" : "i8"
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eBVIX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eqDelta", ()=>eqDelta
);
parcelHelpers.export(exports, "eqDelta2", ()=>eqDelta2
);
parcelHelpers.export(exports, "eqDelta3", ()=>eqDelta3
);
parcelHelpers.export(exports, "eqDelta4", ()=>eqDelta4
);
parcelHelpers.export(exports, "eqDeltaS", ()=>eqDeltaS
);
parcelHelpers.export(exports, "eqDeltaArray", ()=>eqDeltaArray
);
parcelHelpers.export(exports, "isInArray", ()=>isInArray
);
var _implementsFunction = require("@thi.ng/checks/implements-function");
var _api = require("@thi.ng/math/api");
var _eqdelta = require("@thi.ng/math/eqdelta");
var _emitJs = require("./compile/emit.js");
var _vopJs = require("./vop.js");
const $ = (dim)=>eqDelta.add(dim, _emitJs.compileHOF(dim, [
        _eqdelta.eqDelta,
        _api.EPS
    ], ([a, b])=>`eq(${a},${b},eps)`
    , "eq,_eps", "a,b,eps=_eps", "a,b", "", "&&", "return a.length === b.length && ", ";"))
;
const eqDelta = _vopJs.vop();
eqDelta.default((v1, v2, eps = _api.EPS)=>{
    if (_implementsFunction.implementsFunction(v1, "eqDelta")) return v1.eqDelta(v2, eps);
    if (_implementsFunction.implementsFunction(v2, "eqDelta")) return v2.eqDelta(v1, eps);
    return eqDeltaS(v1, v2, v1.length, eps);
});
const eqDelta2 = $(2);
const eqDelta3 = $(3);
const eqDelta4 = $(4);
const eqDeltaS = (a, b, n, eps = _api.EPS, ia = 0, ib = 0, sa = 1, sb = 1)=>{
    for(; n > 0; n--, ia += sa, ib += sb){
        if (!_eqdelta.eqDelta(a[ia], b[ib], eps)) return false;
    }
    return true;
};
const eqDeltaArray = (a, b, eps = _api.EPS)=>{
    if (a === b) return true;
    if (a.length !== b.length) return false;
    for(let i = a.length; i-- > 0;){
        if (!eqDelta(a[i], b[i], eps)) return false;
    }
    return true;
};
const isInArray = (p, pts, eps = _api.EPS)=>{
    for(let i = pts.length; i-- > 0;){
        if (eqDelta(p, pts[i], eps)) return true;
    }
    return false;
};

},{"@thi.ng/checks/implements-function":"cjrzK","@thi.ng/math/api":"4a98p","@thi.ng/math/eqdelta":"cmNLt","./compile/emit.js":"hpIek","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cmNLt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eqDelta", ()=>eqDelta
);
parcelHelpers.export(exports, "eqDeltaScaled", ()=>eqDeltaScaled
);
var _apiJs = require("./api.js");
const abs = Math.abs;
const max = Math.max;
const eqDelta = (a, b, eps = _apiJs.EPS)=>abs(a - b) <= eps
;
const eqDeltaScaled = (a, b, eps = _apiJs.EPS)=>abs(a - b) <= eps * max(1, abs(a), abs(b))
;

},{"./api.js":"4a98p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e4rRM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hash", ()=>hash
);
var _float = require("@thi.ng/binary/float");
var _rotate = require("@thi.ng/binary/rotate");
const hash = (v, H = 2654435761)=>{
    let hash1 = -1;
    for(let i = v.length; i-- > 0;)hash1 = Math.imul(H, hash1) + mix(hash1, _float.floatToUintBits(v[i])) >>> 0;
    return hash1;
};
const M1 = 3432918353;
const M2 = 461845907;
const M3 = 3864292196;
const mix = (h, k)=>{
    k = Math.imul(_rotate.rotateLeft(Math.imul(k, M1) >>> 0, 15), M2) >>> 0;
    return (Math.imul(_rotate.rotateLeft(h ^ k, 13), 5) >>> 0) + M3 >>> 0;
};

},{"@thi.ng/binary/float":"4OyLt","@thi.ng/binary/rotate":"9tmG6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4OyLt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IS_LE", ()=>IS_LE
);
parcelHelpers.export(exports, "floatToIntBits", ()=>floatToIntBits
);
parcelHelpers.export(exports, "floatToUintBits", ()=>floatToUintBits
);
parcelHelpers.export(exports, "intBitsToFloat", ()=>intBitsToFloat
);
parcelHelpers.export(exports, "uintBitsToFloat", ()=>uintBitsToFloat
);
parcelHelpers.export(exports, "floatToIntBits64", ()=>floatToIntBits64
);
parcelHelpers.export(exports, "floatToUintBits64", ()=>floatToUintBits64
);
parcelHelpers.export(exports, "intBitsToFloat64", ()=>intBitsToFloat64
);
parcelHelpers.export(exports, "uintBitsToFloat64", ()=>uintBitsToFloat64
);
parcelHelpers.export(exports, "floatToSortableInt", ()=>floatToSortableInt
);
parcelHelpers.export(exports, "f32u8", ()=>f32u8
);
parcelHelpers.export(exports, "f32u16", ()=>f32u16
);
parcelHelpers.export(exports, "f32u24", ()=>f32u24
);
parcelHelpers.export(exports, "f32u32", ()=>f32u32
);
parcelHelpers.export(exports, "u8f32", ()=>u8f32
);
parcelHelpers.export(exports, "u16f32", ()=>u16f32
);
parcelHelpers.export(exports, "u24f32", ()=>u24f32
);
parcelHelpers.export(exports, "u32f32", ()=>u32f32
);
const F64 = new Float64Array(1);
const F32 = new Float32Array(F64.buffer);
const I32 = new Int32Array(F64.buffer);
const U32 = new Uint32Array(F64.buffer);
const IS_LE = (F64[0] = 2, U32[1] === 1073741824);
const floatToIntBits = (x)=>(F32[0] = x, I32[0])
;
const floatToUintBits = (x)=>(F32[0] = x, U32[0])
;
const intBitsToFloat = (x)=>(I32[0] = x, F32[0])
;
const uintBitsToFloat = (x)=>(U32[0] = x, F32[0])
;
const floatToIntBits64 = (x)=>(F64[0] = x, IS_LE ? [
        I32[1],
        I32[0]
    ] : [
        I32[0],
        I32[1]
    ])
;
const floatToUintBits64 = (x)=>(F64[0] = x, IS_LE ? [
        U32[1],
        U32[0]
    ] : [
        U32[0],
        U32[1]
    ])
;
const intBitsToFloat64 = (hi, lo)=>{
    IS_LE ? (I32[1] = hi, I32[0] = lo) : (I32[0] = hi, I32[1] = lo);
    return F64[0];
};
const uintBitsToFloat64 = (hi, lo)=>{
    IS_LE ? (U32[1] = hi, U32[0] = lo) : (U32[0] = hi, U32[1] = lo);
    return F64[0];
};
const floatToSortableInt = (x)=>{
    if (x === -0) x = 0;
    const i = floatToIntBits(x);
    return x < 0 ? ~i | -2147483648 : i;
};
const clamp11 = (x)=>x < -1 ? -1 : x > 1 ? 1 : x
;
const f32u8 = (x)=>clamp11(x) * 127 & 255
;
const f32u16 = (x)=>clamp11(x) * 32767 & 65535
;
const f32u24 = (x)=>clamp11(x) * 8388607 & 16777215
;
const f32u32 = (x)=>clamp11(x) * 2147483647 >>> 0
;
const u8f32 = (x)=>(x &= 255, (x | (x >> 7) * 4294967040) / 127)
;
const u16f32 = (x)=>(x &= 65535, (x | (x >> 15) * 4294901760) / 32767)
;
const u24f32 = (x)=>(x &= 16777215, (x | (x >> 23) * 4278190080) / 8388607)
;
const u32f32 = (x)=>(x | 0) / 2147483647
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9tmG6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rotateLeft", ()=>rotateLeft
);
parcelHelpers.export(exports, "rotateRight", ()=>rotateRight
);
parcelHelpers.export(exports, "shiftRL", ()=>shiftRL
);
const rotateLeft = (x, n)=>(x << n | x >>> 32 - n) >>> 0
;
const rotateRight = (x, n)=>(x >>> n | x << 32 - n) >>> 0
;
const shiftRL = (x, n)=>n < 0 ? x << -n : x >>> n
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3jBTJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setS", ()=>setS
);
parcelHelpers.export(exports, "setS2", ()=>setS2
);
parcelHelpers.export(exports, "setS3", ()=>setS3
);
parcelHelpers.export(exports, "setS4", ()=>setS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [setS, setS2, setS3, setS4] = _emitJs.defOpS(_templatesJs.SET, "o,a", _templatesJs.SARGS_V, "o,a", "o", _templatesJs.NEW_OUT);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"65hPu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Vec3", ()=>Vec3
);
parcelHelpers.export(exports, "vec3", ()=>vec3
);
parcelHelpers.export(exports, "vec3n", ()=>vec3n
);
parcelHelpers.export(exports, "asVec3", ()=>asVec3
);
var _api = require("@thi.ng/math/api");
var _accessorsJs = require("./compile/accessors.js");
var _apiJs = require("./api.js");
var _avecJs = require("./avec.js");
var _bufferJs = require("./buffer.js");
var _eqdeltaJs = require("./eqdelta.js");
var _hashJs = require("./hash.js");
var _iteratorJs = require("./iterator.js");
var _setsJs = require("./sets.js");
class Vec3 extends _avecJs.AVec {
    constructor(buf, offset = 0, stride = 1){
        super(buf || [
            0,
            0,
            0
        ], offset, stride);
    }
    /**
     * Returns array of memory mapped {@link Vec3} instances using given
     * backing array and stride settings: The `cstride` is the step size
     * between individual XYZ vector components. `estride` is the step
     * size between successive vectors. This arrangement allows for
     * different storage approaches, incl. SOA, AOS, striped /
     * interleaved etc.
     *
     * @param buf - backing array
     * @param num - num vectors
     * @param start -  start index
     * @param cstride - component stride
     * @param estride - element stride
     */ static mapBuffer(buf, num = buf.length / 3 | 0, start = 0, cstride = 1, estride = 3) {
        return _bufferJs.mapStridedBuffer(Vec3, buf, num, start, cstride, estride);
    }
    /**
     * Merges given `src` iterable of {@link Vec3}s into single array `buf`.
     * Vectors will be arranged according to given component and element
     * strides, starting at `start` index. It's the user's
     * responsibility to ensure the target buffer has sufficient
     * capacity to hold the input vectors. See `Vec3.mapBuffer` for the
     * inverse operation. Returns `buf`.
     *
     * @param buf -
     * @param src -
     * @param start -
     * @param cstride -
     * @param estride -
     */ static intoBuffer(buf, src, start = 0, cstride = 1, estride = 3) {
        return _bufferJs.intoStridedBuffer(_setsJs.setS3, buf, src, start, cstride, estride);
    }
    static iterator(buf, num, start = 0, cstride = 1, estride = 3) {
        return _iteratorJs.vecIterator(Vec3, buf, num, start, cstride, estride);
    }
    [Symbol.iterator]() {
        return _iteratorJs.stridedValues(this.buf, 3, this.offset, this.stride);
    }
    get length() {
        return 3;
    }
    copy() {
        return new Vec3([
            this.x,
            this.y,
            this.z
        ]);
    }
    copyView() {
        return new Vec3(this.buf, this.offset, this.stride);
    }
    empty() {
        return new Vec3();
    }
    eqDelta(v, eps = _api.EPS) {
        return _eqdeltaJs.eqDelta3(this, v, eps);
    }
    hash() {
        return _hashJs.hash(this);
    }
    toJSON() {
        return [
            this.x,
            this.y,
            this.z
        ];
    }
}
Vec3.X_AXIS = new Vec3(_apiJs.X3);
Vec3.Y_AXIS = new Vec3(_apiJs.Y3);
Vec3.Z_AXIS = new Vec3(_apiJs.Z3);
Vec3.MIN = new Vec3(_apiJs.MIN3);
Vec3.MAX = new Vec3(_apiJs.MAX3);
Vec3.ZERO = new Vec3(_apiJs.ZERO3);
Vec3.ONE = new Vec3(_apiJs.ONE3);
_accessorsJs.declareIndices(Vec3.prototype, [
    "x",
    "y",
    "z"
]);
const vec3 = (x = 0, y = 0, z = 0)=>new Vec3([
        x,
        y,
        z
    ])
;
const vec3n = (n)=>new Vec3([
        n,
        n,
        n
    ])
;
const asVec3 = (x)=>x instanceof Vec3 ? x : new Vec3(x.length >= 3 ? x : [
        x[0] || 0,
        x[1] || 0,
        x[2] || 0
    ])
;

},{"@thi.ng/math/api":"4a98p","./compile/accessors.js":"5h29N","./api.js":"60HDf","./avec.js":"czAXr","./buffer.js":"ecaja","./eqdelta.js":"eBVIX","./hash.js":"e4rRM","./iterator.js":"dnjxi","./sets.js":"3jBTJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iQG7M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Vec4", ()=>Vec4
);
parcelHelpers.export(exports, "vec4", ()=>vec4
);
parcelHelpers.export(exports, "vec4n", ()=>vec4n
);
parcelHelpers.export(exports, "asVec4", ()=>asVec4
);
var _api = require("@thi.ng/math/api");
var _accessorsJs = require("./compile/accessors.js");
var _apiJs = require("./api.js");
var _avecJs = require("./avec.js");
var _bufferJs = require("./buffer.js");
var _eqdeltaJs = require("./eqdelta.js");
var _hashJs = require("./hash.js");
var _iteratorJs = require("./iterator.js");
var _setsJs = require("./sets.js");
class Vec4 extends _avecJs.AVec {
    constructor(buf, offset = 0, stride = 1){
        super(buf || [
            0,
            0,
            0,
            0
        ], offset, stride);
    }
    /**
     * Returns array of memory mapped {@link Vec4} instances using given
     * backing array and stride settings: The `cstride` is the step size
     * between individual XYZ vector components. `estride` is the step
     * size between successive vectors. This arrangement allows for
     * different storage approaches, incl. SOA, AOS, striped /
     * interleaved etc.
     *
     * @param buf - backing array
     * @param num - num vectors
     * @param start -  start index
     * @param cstride - component stride
     * @param estride - element stride
     */ static mapBuffer(buf, num = buf.length >> 2, start = 0, cstride = 1, estride = 4) {
        return _bufferJs.mapStridedBuffer(Vec4, buf, num, start, cstride, estride);
    }
    /**
     * Merges given `src` iterable of {@link Vec4}s into single array `buf`.
     * Vectors will be arranged according to given component and element
     * strides, starting at `start` index. It's the user's
     * responsibility to ensure the target buffer has sufficient
     * capacity to hold the input vectors. See `Vec4.mapBuffer` for the
     * inverse operation. Returns `buf`.
     *
     * @param buf -
     * @param src -
     * @param start -
     * @param cstride -
     * @param estride -
     */ static intoBuffer(buf, src, start = 0, cstride = 1, estride = 4) {
        return _bufferJs.intoStridedBuffer(_setsJs.setS4, buf, src, start, cstride, estride);
    }
    static *iterator(buf, num, start = 0, cstride = 1, estride = 4) {
        return _iteratorJs.vecIterator(Vec4, buf, num, start, cstride, estride);
    }
    [Symbol.iterator]() {
        return _iteratorJs.stridedValues(this.buf, 4, this.offset, this.stride);
    }
    get length() {
        return 4;
    }
    copy() {
        return new Vec4([
            this.x,
            this.y,
            this.z,
            this.w
        ]);
    }
    copyView() {
        return new Vec4(this.buf, this.offset, this.stride);
    }
    empty() {
        return new Vec4();
    }
    eqDelta(v, eps = _api.EPS) {
        return _eqdeltaJs.eqDelta4(this, v, eps);
    }
    hash() {
        return _hashJs.hash(this);
    }
    toJSON() {
        return [
            this.x,
            this.y,
            this.z,
            this.w
        ];
    }
}
Vec4.X_AXIS = new Vec4(_apiJs.X4);
Vec4.Y_AXIS = new Vec4(_apiJs.Y4);
Vec4.Z_AXIS = new Vec4(_apiJs.Z4);
Vec4.MIN = new Vec4(_apiJs.MIN4);
Vec4.MAX = new Vec4(_apiJs.MAX4);
Vec4.ZERO = new Vec4(_apiJs.ZERO4);
Vec4.ONE = new Vec4(_apiJs.ONE4);
_accessorsJs.declareIndices(Vec4.prototype, [
    "x",
    "y",
    "z",
    "w"
]);
const vec4 = (x = 0, y = 0, z = 0, w = 0)=>new Vec4([
        x,
        y,
        z,
        w
    ])
;
const vec4n = (n)=>new Vec4([
        n,
        n,
        n,
        n
    ])
;
const asVec4 = (x)=>x instanceof Vec4 ? x : new Vec4(x.length >= 4 ? x : [
        x[0] || 0,
        x[1] || 0,
        x[2] || 0,
        x[3] || 0
    ])
;

},{"@thi.ng/math/api":"4a98p","./compile/accessors.js":"5h29N","./api.js":"60HDf","./avec.js":"czAXr","./buffer.js":"ecaja","./eqdelta.js":"eBVIX","./hash.js":"e4rRM","./iterator.js":"dnjxi","./sets.js":"3jBTJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ivhHk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "abs", ()=>abs
);
parcelHelpers.export(exports, "abs2", ()=>abs2
);
parcelHelpers.export(exports, "abs3", ()=>abs3
);
parcelHelpers.export(exports, "abs4", ()=>abs4
);
var _emitJs = require("./compile/emit.js");
const [abs, abs2, abs3, abs4] = _emitJs.defFnOp("Math.abs");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kPmuu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "acos", ()=>acos
);
parcelHelpers.export(exports, "acos2", ()=>acos2
);
parcelHelpers.export(exports, "acos3", ()=>acos3
);
parcelHelpers.export(exports, "acos4", ()=>acos4
);
var _emitJs = require("./compile/emit.js");
const [acos, acos2, acos3, acos4] = _emitJs.defFnOp("Math.acos");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cFpxt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addW2", ()=>addW2
);
parcelHelpers.export(exports, "addW3", ()=>addW3
);
parcelHelpers.export(exports, "addW4", ()=>addW4
);
parcelHelpers.export(exports, "addW5", ()=>addW5
);
var _maddnJs = require("./maddn.js");
var _mulnJs = require("./muln.js");
const addW2 = (out, a, b, wa, wb)=>(!out && (out = a), _maddnJs.maddN(out, b, wb, _mulnJs.mulN(out, a, wa)))
;
const addW3 = (out, a, b, c, wa, wb, wc)=>(!out && (out = a), _maddnJs.maddN(out, c, wc, _maddnJs.maddN(out, b, wb, _mulnJs.mulN(out, a, wa))))
;
const addW4 = (out, a, b, c, d, wa, wb, wc, wd)=>(!out && (out = a), _maddnJs.maddN(out, d, wd, _maddnJs.maddN(out, c, wc, _maddnJs.maddN(out, b, wb, _mulnJs.mulN(out, a, wa)))))
;
const addW5 = (out, a, b, c, d, e, wa, wb, wc, wd, we)=>(!out && (out = a), _maddnJs.maddN(out, e, we, _maddnJs.maddN(out, d, wd, _maddnJs.maddN(out, c, wc, _maddnJs.maddN(out, b, wb, _mulnJs.mulN(out, a, wa))))))
;

},{"./maddn.js":"bTkou","./muln.js":"1TKlE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bTkou":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "maddN", ()=>maddN
);
parcelHelpers.export(exports, "maddN2", ()=>maddN2
);
parcelHelpers.export(exports, "maddN3", ()=>maddN3
);
parcelHelpers.export(exports, "maddN4", ()=>maddN4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [maddN, maddN2, maddN3, maddN4] = _emitJs.defOp(_templatesJs.MATH2A_N("*", "+"), _templatesJs.ARGS_VNV, _templatesJs.ARGS_VV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5JekR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addI", ()=>addI
);
parcelHelpers.export(exports, "addI2", ()=>addI2
);
parcelHelpers.export(exports, "addI3", ()=>addI3
);
parcelHelpers.export(exports, "addI4", ()=>addI4
);
parcelHelpers.export(exports, "addU", ()=>addU
);
parcelHelpers.export(exports, "addU2", ()=>addU2
);
parcelHelpers.export(exports, "addU3", ()=>addU3
);
parcelHelpers.export(exports, "addU4", ()=>addU4
);
parcelHelpers.export(exports, "addNI", ()=>addNI
);
parcelHelpers.export(exports, "addNI2", ()=>addNI2
);
parcelHelpers.export(exports, "addNI3", ()=>addNI3
);
parcelHelpers.export(exports, "addNI4", ()=>addNI4
);
parcelHelpers.export(exports, "addNU", ()=>addNU
);
parcelHelpers.export(exports, "addNU2", ()=>addNU2
);
parcelHelpers.export(exports, "addNU3", ()=>addNU3
);
parcelHelpers.export(exports, "addNU4", ()=>addNU4
);
var _emitJs = require("./compile/emit.js");
const [addI, addI2, addI3, addI4] = _emitJs.defBitOp("+", true);
const [addU, addU2, addU3, addU4] = _emitJs.defBitOp("+");
const [addNI, addNI2, addNI3, addNI4] = _emitJs.defBitOpN("+", true);
const [addNU, addNU2, addNU3, addNU4] = _emitJs.defBitOpN("+");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7tmcI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addm", ()=>addm
);
parcelHelpers.export(exports, "addm2", ()=>addm2
);
parcelHelpers.export(exports, "addm3", ()=>addm3
);
parcelHelpers.export(exports, "addm4", ()=>addm4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [addm, addm2, addm3, addm4] = _emitJs.defOp(_templatesJs.MATH2("+", "*"), _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cfDqf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addmS", ()=>addmS
);
parcelHelpers.export(exports, "addmS2", ()=>addmS2
);
parcelHelpers.export(exports, "addmS3", ()=>addmS3
);
parcelHelpers.export(exports, "addmS4", ()=>addmS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [addmS, addmS2, addmS3, addmS4] = _emitJs.defOpS(_templatesJs.MATH2("+", "*"), _templatesJs.ARGS_VVV, _templatesJs.SARGS_VVV, _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jvybo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addmNS", ()=>addmNS
);
parcelHelpers.export(exports, "addmNS2", ()=>addmNS2
);
parcelHelpers.export(exports, "addmNS3", ()=>addmNS3
);
parcelHelpers.export(exports, "addmNS4", ()=>addmNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [addmNS, addmNS2, addmNS3, addmNS4] = _emitJs.defOpS(_templatesJs.MATH2_N("+", "*"), _templatesJs.ARGS_VVN, _templatesJs.SARGS_VV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cZbCm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addS", ()=>addS
);
parcelHelpers.export(exports, "addS2", ()=>addS2
);
parcelHelpers.export(exports, "addS3", ()=>addS3
);
parcelHelpers.export(exports, "addS4", ()=>addS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [addS, addS2, addS3, addS4] = _emitJs.defOpS(_templatesJs.MATH("+"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cDsWw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addNS", ()=>addNS
);
parcelHelpers.export(exports, "addNS2", ()=>addNS2
);
parcelHelpers.export(exports, "addNS3", ()=>addNS3
);
parcelHelpers.export(exports, "addNS4", ()=>addNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [addNS, addNS2, addNS3, addNS4] = _emitJs.defOpS(_templatesJs.MATH_N("+"), _templatesJs.ARGS_VN, _templatesJs.SARGS_V, _templatesJs.ARGS_V);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8OhzV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "angleRatio", ()=>angleRatio
);
parcelHelpers.export(exports, "angleBetween2", ()=>angleBetween2
);
parcelHelpers.export(exports, "angleBetween3", ()=>angleBetween3
);
var _angle = require("@thi.ng/math/angle");
var _crossJs = require("./cross.js");
var _dotJs = require("./dot.js");
var _magJs = require("./mag.js");
const angleRatio = (a, b)=>_dotJs.dot(a, b) / (_magJs.mag(a) * _magJs.mag(b))
;
const angleBetween2 = (a, b, absInner = false)=>{
    const t = Math.atan2(_crossJs.cross2(a, b), _dotJs.dot(a, b));
    return absInner ? _angle.absInnerAngle(t) : t;
};
const angleBetween3 = (a, b, normalize = true, absInner = false)=>{
    const t = normalize ? Math.acos(angleRatio(a, b)) : Math.acos(_dotJs.dot(a, b));
    return absInner ? _angle.absInnerAngle(t) : t;
};

},{"@thi.ng/math/angle":"el41q","./cross.js":"a6Q1x","./dot.js":"9vV5N","./mag.js":"70TCJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"el41q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sincos", ()=>sincos
);
parcelHelpers.export(exports, "cossin", ()=>cossin
);
parcelHelpers.export(exports, "absTheta", ()=>absTheta
);
parcelHelpers.export(exports, "absInnerAngle", ()=>absInnerAngle
);
parcelHelpers.export(exports, "angleDist", ()=>angleDist
);
parcelHelpers.export(exports, "atan2Abs", ()=>atan2Abs
);
parcelHelpers.export(exports, "quadrant", ()=>quadrant
);
parcelHelpers.export(exports, "deg", ()=>deg
);
parcelHelpers.export(exports, "rad", ()=>rad
);
parcelHelpers.export(exports, "csc", ()=>csc
);
parcelHelpers.export(exports, "sec", ()=>sec
);
parcelHelpers.export(exports, "cot", ()=>cot
);
parcelHelpers.export(exports, "loc", ()=>loc
);
parcelHelpers.export(exports, "normCos", ()=>normCos
);
parcelHelpers.export(exports, "fastCos", ()=>fastCos
);
parcelHelpers.export(exports, "fastSin", ()=>fastSin
);
var _apiJs = require("./api.js");
const sincos = (theta, n = 1)=>[
        Math.sin(theta) * n,
        Math.cos(theta) * n, 
    ]
;
const cossin = (theta, n = 1)=>[
        Math.cos(theta) * n,
        Math.sin(theta) * n, 
    ]
;
const absTheta = (theta)=>(theta %= _apiJs.TAU, theta < 0 ? _apiJs.TAU + theta : theta)
;
const absInnerAngle = (theta)=>(theta = Math.abs(theta), theta > _apiJs.PI ? _apiJs.TAU - theta : theta)
;
const angleDist = (a, b)=>absInnerAngle(absTheta(b % _apiJs.TAU - a % _apiJs.TAU))
;
const atan2Abs = (y, x)=>absTheta(Math.atan2(y, x))
;
const quadrant = (theta)=>absTheta(theta) * _apiJs.INV_HALF_PI | 0
;
const deg = (theta)=>theta * _apiJs.RAD2DEG
;
const rad = (theta)=>theta * _apiJs.DEG2RAD
;
const csc = (theta)=>1 / Math.sin(theta)
;
const sec = (theta)=>1 / Math.cos(theta)
;
const cot = (theta)=>1 / Math.tan(theta)
;
const loc = (a, b, gamma)=>Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(gamma))
;
const normCos = (x)=>{
    const x2 = x * x;
    return 1 + x2 * (-4 + 2 * x2);
};
const __fastCos = (x)=>{
    const x2 = x * x;
    return 0.99940307 + x2 * (-0.49558072 + 0.03679168 * x2);
};
const fastCos = (theta)=>{
    theta %= _apiJs.TAU;
    theta < 0 && (theta = -theta);
    switch(theta * _apiJs.INV_HALF_PI | 0){
        case 0:
            return __fastCos(theta);
        case 1:
            return -__fastCos(_apiJs.PI - theta);
        case 2:
            return -__fastCos(theta - _apiJs.PI);
        default:
            return __fastCos(_apiJs.TAU - theta);
    }
};
const fastSin = (theta)=>fastCos(_apiJs.HALF_PI - theta)
;

},{"./api.js":"4a98p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a6Q1x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cross2", ()=>cross2
);
parcelHelpers.export(exports, "cross3", ()=>cross3
);
var _setcJs = require("./setc.js");
const cross2 = (a, b)=>a[0] * b[1] - a[1] * b[0]
;
const cross3 = (out, a, b)=>_setcJs.setC3(out || a, a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0])
;

},{"./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jST0o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setC2", ()=>setC2
);
parcelHelpers.export(exports, "setC3", ()=>setC3
);
parcelHelpers.export(exports, "setC4", ()=>setC4
);
parcelHelpers.export(exports, "setC6", ()=>setC6
);
parcelHelpers.export(exports, "setC", ()=>setC
);
const setC2 = (out, x, y)=>(!out && (out = []), out[0] = x, out[1] = y, out)
;
const setC3 = (out, x, y, z)=>(!out && (out = []), out[0] = x, out[1] = y, out[2] = z, out)
;
const setC4 = (out, x, y, z, w)=>(!out && (out = []), out[0] = x, out[1] = y, out[2] = z, out[3] = w, out)
;
const setC6 = (out, a, b, c, d, e, f)=>(!out && (out = []), out[0] = a, out[1] = b, out[2] = c, out[3] = d, out[4] = e, out[5] = f, out)
;
const setC = (out, ...xs)=>{
    !out && (out = []);
    for(let i = 0, n = xs.length; i < n; i++)out[i] = xs[i];
    return out;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"70TCJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mag", ()=>mag
);
var _magsqJs = require("./magsq.js");
const mag = (v)=>Math.sqrt(_magsqJs.magSq(v))
;

},{"./magsq.js":"bsMC4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fm4pB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "asin", ()=>asin
);
parcelHelpers.export(exports, "asin2", ()=>asin2
);
parcelHelpers.export(exports, "asin3", ()=>asin3
);
parcelHelpers.export(exports, "asin4", ()=>asin4
);
var _emitJs = require("./compile/emit.js");
const [asin, asin2, asin3, asin4] = _emitJs.defFnOp("Math.asin");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aiYhv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "atan", ()=>atan
);
parcelHelpers.export(exports, "atan2", ()=>atan2
);
parcelHelpers.export(exports, "atan3", ()=>atan3
);
parcelHelpers.export(exports, "atan4", ()=>atan4
);
parcelHelpers.export(exports, "atan_2", ()=>atan_2
);
parcelHelpers.export(exports, "atan_22", ()=>atan_22
);
parcelHelpers.export(exports, "atan_23", ()=>atan_23
);
parcelHelpers.export(exports, "atan_24", ()=>atan_24
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [atan, atan2, atan3, atan4] = _emitJs.defFnOp("Math.atan");
const [atan_2, atan_22, atan_23, atan_24] = _emitJs.defOp(_templatesJs.FN2("Math.atan2"), _templatesJs.ARGS_VV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bXCEG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bisect2", ()=>bisect2
);
parcelHelpers.export(exports, "cornerBisector", ()=>cornerBisector
);
parcelHelpers.export(exports, "cornerBisector2", ()=>cornerBisector2
);
var _api = require("@thi.ng/math/api");
var _addmnJs = require("./addmn.js");
var _directionJs = require("./direction.js");
var _headingJs = require("./heading.js");
var _mixnJs = require("./mixn.js");
var _normalizeJs = require("./normalize.js");
var _perpendicularJs = require("./perpendicular.js");
var _subJs = require("./sub.js");
const bisect2 = (a, b)=>{
    const theta = (_headingJs.headingXY(a) + _headingJs.headingXY(b)) / 2;
    return theta <= _api.HALF_PI ? theta : _api.PI - theta;
};
const cornerBisector = (out, a, b, c, n = 1)=>(!out && (out = []), _normalizeJs.normalize(out, _addmnJs.addmN(out, _normalizeJs.normalize(out, _subJs.sub(out, a, b)), _normalizeJs.normalize(null, _subJs.sub([], c, b)), 0.5), n))
;
const cornerBisector2 = (out, a, b, c, n = 1)=>(!out && (out = []), _perpendicularJs.perpendicularCCW(out, _normalizeJs.normalize(out, _mixnJs.mixN2(out, _directionJs.direction(out, a, b), _directionJs.direction([], b, c), 0.5), n)))
;

},{"@thi.ng/math/api":"4a98p","./addmn.js":"9C52h","./direction.js":"g7PP7","./heading.js":"jM0y9","./mixn.js":"jolPM","./normalize.js":"9ex3j","./perpendicular.js":"dnMKL","./sub.js":"fzaw7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g7PP7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "direction", ()=>direction
);
var _normalizeJs = require("./normalize.js");
var _subJs = require("./sub.js");
const direction = (out, a, b, n = 1)=>_normalizeJs.normalize(null, _subJs.sub(out || a, b, a), n)
;

},{"./normalize.js":"9ex3j","./sub.js":"fzaw7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9ex3j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "normalize", ()=>normalize
);
var _api = require("@thi.ng/math/api");
var _magJs = require("./mag.js");
var _mulnJs = require("./muln.js");
var _setJs = require("./set.js");
const normalize = (out, v, n = 1)=>{
    !out && (out = v);
    const m = _magJs.mag(v);
    return m >= _api.EPS ? _mulnJs.mulN(out, v, n / m) : out !== v ? _setJs.set(out, v) : out;
};

},{"@thi.ng/math/api":"4a98p","./mag.js":"70TCJ","./muln.js":"1TKlE","./set.js":"bSUB8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jM0y9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "headingXY", ()=>headingXY
);
parcelHelpers.export(exports, "headingXZ", ()=>headingXZ
);
parcelHelpers.export(exports, "headingYZ", ()=>headingYZ
);
parcelHelpers.export(exports, "heading", ()=>heading
);
var _angle = require("@thi.ng/math/angle");
const headingXY = (a)=>_angle.atan2Abs(a[1], a[0])
;
const headingXZ = (a)=>_angle.atan2Abs(a[2], a[0])
;
const headingYZ = (a)=>_angle.atan2Abs(a[2], a[1])
;
const heading = headingXY;

},{"@thi.ng/math/angle":"el41q","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dnMKL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "perpendicularCCW", ()=>perpendicularCCW
);
parcelHelpers.export(exports, "perpendicularCW", ()=>perpendicularCW
);
var _setcJs = require("./setc.js");
const perpendicularCCW = (out, a)=>_setcJs.setC2(out || a, -a[1], a[0])
;
const perpendicularCW = (out, a)=>_setcJs.setC2(out || a, a[1], -a[0])
;

},{"./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ihEMJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bitAndI", ()=>bitAndI
);
parcelHelpers.export(exports, "bitAndI2", ()=>bitAndI2
);
parcelHelpers.export(exports, "bitAndI3", ()=>bitAndI3
);
parcelHelpers.export(exports, "bitAndI4", ()=>bitAndI4
);
parcelHelpers.export(exports, "bitAndU", ()=>bitAndU
);
parcelHelpers.export(exports, "bitAndU2", ()=>bitAndU2
);
parcelHelpers.export(exports, "bitAndU3", ()=>bitAndU3
);
parcelHelpers.export(exports, "bitAndU4", ()=>bitAndU4
);
parcelHelpers.export(exports, "bitAndNI", ()=>bitAndNI
);
parcelHelpers.export(exports, "bitAndNI2", ()=>bitAndNI2
);
parcelHelpers.export(exports, "bitAndNI3", ()=>bitAndNI3
);
parcelHelpers.export(exports, "bitAndNI4", ()=>bitAndNI4
);
parcelHelpers.export(exports, "bitAndNU", ()=>bitAndNU
);
parcelHelpers.export(exports, "bitAndNU2", ()=>bitAndNU2
);
parcelHelpers.export(exports, "bitAndNU3", ()=>bitAndNU3
);
parcelHelpers.export(exports, "bitAndNU4", ()=>bitAndNU4
);
var _emitJs = require("./compile/emit.js");
const [bitAndI, bitAndI2, bitAndI3, bitAndI4] = _emitJs.defBitOp("&", true);
const [bitAndU, bitAndU2, bitAndU3, bitAndU4] = _emitJs.defBitOp("&");
const [bitAndNI, bitAndNI2, bitAndNI3, bitAndNI4] = _emitJs.defBitOpN("&", true);
const [bitAndNU, bitAndNU2, bitAndNU3, bitAndNU4] = _emitJs.defBitOpN("&");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5kBRM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bitNotI", ()=>bitNotI
);
parcelHelpers.export(exports, "bitNotI2", ()=>bitNotI2
);
parcelHelpers.export(exports, "bitNotI3", ()=>bitNotI3
);
parcelHelpers.export(exports, "bitNotI4", ()=>bitNotI4
);
parcelHelpers.export(exports, "bitNotU", ()=>bitNotU
);
parcelHelpers.export(exports, "bitNotU2", ()=>bitNotU2
);
parcelHelpers.export(exports, "bitNotU3", ()=>bitNotU3
);
parcelHelpers.export(exports, "bitNotU4", ()=>bitNotU4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [bitNotI, bitNotI2, bitNotI3, bitNotI4] = _emitJs.defOp(([o, a])=>`${o}=(~${a})|0;`
, _templatesJs.ARGS_V);
const [bitNotU, bitNotU2, bitNotU3, bitNotU4] = _emitJs.defOp(([o, a])=>`${o}=(~${a})>>>0;`
, _templatesJs.ARGS_V);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8o6Ie":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bitOrI", ()=>bitOrI
);
parcelHelpers.export(exports, "bitOrI2", ()=>bitOrI2
);
parcelHelpers.export(exports, "bitOrI3", ()=>bitOrI3
);
parcelHelpers.export(exports, "bitOrI4", ()=>bitOrI4
);
parcelHelpers.export(exports, "bitOrU", ()=>bitOrU
);
parcelHelpers.export(exports, "bitOrU2", ()=>bitOrU2
);
parcelHelpers.export(exports, "bitOrU3", ()=>bitOrU3
);
parcelHelpers.export(exports, "bitOrU4", ()=>bitOrU4
);
parcelHelpers.export(exports, "bitOrNI", ()=>bitOrNI
);
parcelHelpers.export(exports, "bitOrNI2", ()=>bitOrNI2
);
parcelHelpers.export(exports, "bitOrNI3", ()=>bitOrNI3
);
parcelHelpers.export(exports, "bitOrNI4", ()=>bitOrNI4
);
parcelHelpers.export(exports, "bitOrNU", ()=>bitOrNU
);
parcelHelpers.export(exports, "bitOrNU2", ()=>bitOrNU2
);
parcelHelpers.export(exports, "bitOrNU3", ()=>bitOrNU3
);
parcelHelpers.export(exports, "bitOrNU4", ()=>bitOrNU4
);
var _emitJs = require("./compile/emit.js");
const [bitOrI, bitOrI2, bitOrI3, bitOrI4] = _emitJs.defBitOp("|", true);
const [bitOrU, bitOrU2, bitOrU3, bitOrU4] = _emitJs.defBitOp("|");
const [bitOrNI, bitOrNI2, bitOrNI3, bitOrNI4] = _emitJs.defBitOpN("|", true);
const [bitOrNU, bitOrNU2, bitOrNU3, bitOrNU4] = _emitJs.defBitOpN("|");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7BWzt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bitXorI", ()=>bitXorI
);
parcelHelpers.export(exports, "bitXorI2", ()=>bitXorI2
);
parcelHelpers.export(exports, "bitXorI3", ()=>bitXorI3
);
parcelHelpers.export(exports, "bitXorI4", ()=>bitXorI4
);
parcelHelpers.export(exports, "bitXorU", ()=>bitXorU
);
parcelHelpers.export(exports, "bitXorU2", ()=>bitXorU2
);
parcelHelpers.export(exports, "bitXorU3", ()=>bitXorU3
);
parcelHelpers.export(exports, "bitXorU4", ()=>bitXorU4
);
parcelHelpers.export(exports, "bitXorNI", ()=>bitXorNI
);
parcelHelpers.export(exports, "bitXorNI2", ()=>bitXorNI2
);
parcelHelpers.export(exports, "bitXorNI3", ()=>bitXorNI3
);
parcelHelpers.export(exports, "bitXorNI4", ()=>bitXorNI4
);
parcelHelpers.export(exports, "bitXorNU", ()=>bitXorNU
);
parcelHelpers.export(exports, "bitXorNU2", ()=>bitXorNU2
);
parcelHelpers.export(exports, "bitXorNU3", ()=>bitXorNU3
);
parcelHelpers.export(exports, "bitXorNU4", ()=>bitXorNU4
);
var _emitJs = require("./compile/emit.js");
const [bitXorI, bitXorI2, bitXorI3, bitXorI4] = _emitJs.defBitOp("^", true);
const [bitXorU, bitXorU2, bitXorU3, bitXorU4] = _emitJs.defBitOp("^");
const [bitXorNI, bitXorNI2, bitXorNI3, bitXorNI4] = _emitJs.defBitOpN("^", true);
const [bitXorNU, bitXorNU2, bitXorNU3, bitXorNU4] = _emitJs.defBitOpN("^");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g2NFB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cartesian", ()=>cartesian
);
parcelHelpers.export(exports, "cartesian2", ()=>cartesian2
);
parcelHelpers.export(exports, "cartesian3", ()=>cartesian3
);
var _angle = require("@thi.ng/math/angle");
var _addJs = require("./add.js");
var _apiJs = require("./api.js");
var _setcJs = require("./setc.js");
var _vopJs = require("./vop.js");
const cos = Math.cos;
const sin = Math.sin;
const cartesian = _vopJs.vop(1);
const cartesian2 = cartesian.add(2, (out, a, b = _apiJs.ZERO2)=>_addJs.add2(out || a, _angle.cossin(a[1], a[0]), b)
);
const cartesian3 = cartesian.add(3, (out, a, b = _apiJs.ZERO3)=>{
    const r = a[0];
    const theta = a[1];
    const phi = a[2];
    const ct = cos(theta);
    return _setcJs.setC3(out || a, r * ct * cos(phi) + b[0], r * ct * sin(phi) + b[1], r * sin(theta) + b[2]);
});

},{"@thi.ng/math/angle":"el41q","./add.js":"6HmvS","./api.js":"60HDf","./setc.js":"jST0o","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2tmeM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ceil", ()=>ceil
);
parcelHelpers.export(exports, "ceil2", ()=>ceil2
);
parcelHelpers.export(exports, "ceil3", ()=>ceil3
);
parcelHelpers.export(exports, "ceil4", ()=>ceil4
);
var _emitJs = require("./compile/emit.js");
const [ceil, ceil2, ceil3, ceil4] = _emitJs.defFnOp("Math.ceil");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2MkSv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "center", ()=>center
);
var _meanJs = require("./mean.js");
var _subnJs = require("./subn.js");
const center = (out, a)=>_subnJs.subN(out, a, _meanJs.vmean(a))
;

},{"./mean.js":"7w5sd","./subn.js":"i3npD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7w5sd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mean", ()=>mean
);
parcelHelpers.export(exports, "vmean", ()=>vmean
);
var _addJs = require("./add.js");
var _ensureJs = require("./internal/ensure.js");
var _mulnJs = require("./muln.js");
var _setJs = require("./set.js");
var _sumJs = require("./sum.js");
const mean = (out, src)=>{
    _ensureJs.__ensureInputs(src);
    out = _setJs.set(out || [], src[0]);
    for(let i = src.length; i-- > 1;)_addJs.add(out, out, src[i]);
    return _mulnJs.mulN(out, out, 1 / src.length);
};
const vmean = (a)=>a.length > 0 ? _sumJs.sum(a) / a.length : 0
;

},{"./add.js":"6HmvS","./internal/ensure.js":"dq2YU","./muln.js":"1TKlE","./set.js":"bSUB8","./sum.js":"2gBvR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dq2YU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__ensureInputs", ()=>__ensureInputs
);
var _assert = require("@thi.ng/errors/assert");
const __ensureInputs = (src)=>_assert.assert(src.length > 0, `no inputs given`)
;

},{"@thi.ng/errors/assert":"zM8kA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2gBvR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sum", ()=>sum
);
parcelHelpers.export(exports, "sum2", ()=>sum2
);
parcelHelpers.export(exports, "sum3", ()=>sum3
);
parcelHelpers.export(exports, "sum4", ()=>sum4
);
var _add = require("@thi.ng/transducers/add");
var _reduce = require("@thi.ng/transducers/reduce");
var _vopJs = require("./vop.js");
const sum = _vopJs.vop();
sum.default((v)=>_reduce.reduce(_add.add(), v)
);
const sum2 = sum.add(2, (a)=>a[0] + a[1]
);
const sum3 = sum.add(3, (a)=>a[0] + a[1] + a[2]
);
const sum4 = sum.add(4, (a)=>a[0] + a[1] + a[2] + a[3]
);

},{"@thi.ng/transducers/add":"92liA","@thi.ng/transducers/reduce":"hP05c","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"92liA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "add", ()=>add
);
var _mathopJs = require("./internal/mathop.js");
function add(...args) {
    return _mathopJs.__mathop(add, (acc, x)=>acc + x
    , 0, args);
}

},{"./internal/mathop.js":"2ModK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2ModK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__mathop", ()=>__mathop
);
var _reduceJs = require("../reduce.js");
const __mathop = (rfn, fn, initDefault, args)=>{
    const res = _reduceJs.$$reduce(rfn, args);
    if (res !== undefined) return res;
    const init = args[0] || initDefault;
    return _reduceJs.reducer(()=>init
    , fn);
};

},{"../reduce.js":"hP05c","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k99Yr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "clamp", ()=>clamp
);
parcelHelpers.export(exports, "clamp2", ()=>clamp2
);
parcelHelpers.export(exports, "clamp3", ()=>clamp3
);
parcelHelpers.export(exports, "clamp4", ()=>clamp4
);
parcelHelpers.export(exports, "clamp01", ()=>clamp01
);
parcelHelpers.export(exports, "clamp01_2", ()=>clamp01_2
);
parcelHelpers.export(exports, "clamp01_3", ()=>clamp01_3
);
parcelHelpers.export(exports, "clamp01_4", ()=>clamp01_4
);
parcelHelpers.export(exports, "clamp11", ()=>clamp11
);
parcelHelpers.export(exports, "clamp11_2", ()=>clamp11_2
);
parcelHelpers.export(exports, "clamp11_3", ()=>clamp11_3
);
parcelHelpers.export(exports, "clamp11_4", ()=>clamp11_4
);
var _interval = require("@thi.ng/math/interval");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [clamp, clamp2, clamp3, clamp4] = _emitJs.defHofOp(_interval.clamp, _templatesJs.FN3(), _templatesJs.ARGS_VVV);
const [clamp01, clamp01_2, clamp01_3, clamp01_4] = _emitJs.defHofOp(_interval.clamp01, _templatesJs.FN(), _templatesJs.ARGS_V);
const [clamp11, clamp11_2, clamp11_3, clamp11_4] = _emitJs.defHofOp(_interval.clamp11, _templatesJs.FN(), _templatesJs.ARGS_V);

},{"@thi.ng/math/interval":"1TDWA","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4kXdw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "clampN", ()=>clampN
);
parcelHelpers.export(exports, "clampN2", ()=>clampN2
);
parcelHelpers.export(exports, "clampN3", ()=>clampN3
);
parcelHelpers.export(exports, "clampN4", ()=>clampN4
);
var _interval = require("@thi.ng/math/interval");
var _emitJs = require("./compile/emit.js");
const [clampN, clampN2, clampN3, clampN4] = _emitJs.defHofOp(_interval.clamp, ([o, a])=>`${o}=op(${a},n,m);`
, "o,a,n,m", "o,a");

},{"@thi.ng/math/interval":"1TDWA","./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b5iVX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "comparator2", ()=>comparator2
);
parcelHelpers.export(exports, "comparator3", ()=>comparator3
);
parcelHelpers.export(exports, "comparator4", ()=>comparator4
);
const comparator2 = (o1, o2)=>(a, b)=>{
        const ax = a[o1];
        const ay = a[o2];
        const bx = b[o1];
        const by = b[o2];
        return ax === bx ? ay === by ? 0 : ay < by ? -2 : 2 : ax < bx ? -1 : 1;
    }
;
const comparator3 = (o1, o2, o3)=>(a, b)=>{
        const ax = a[o1];
        const ay = a[o2];
        const az = a[o3];
        const bx = b[o1];
        const by = b[o2];
        const bz = b[o3];
        return ax === bx ? ay === by ? az === bz ? 0 : az < bz ? -3 : 3 : ay < by ? -2 : 2 : ax < bx ? -1 : 1;
    }
;
const comparator4 = (o1, o2, o3, o4)=>(a, b)=>{
        const ax = a[o1];
        const ay = a[o2];
        const az = a[o3];
        const aw = b[o4];
        const bx = b[o1];
        const by = b[o2];
        const bz = b[o3];
        const bw = b[o4];
        return ax === bx ? ay === by ? az === bz ? aw === bw ? 0 : aw < bw ? -4 : 4 : az < bz ? -3 : 3 : ay < by ? -2 : 2 : ax < bx ? -1 : 1;
    }
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hGWRF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "asIVec", ()=>asIVec
);
parcelHelpers.export(exports, "asIVec2", ()=>asIVec2
);
parcelHelpers.export(exports, "asIVec3", ()=>asIVec3
);
parcelHelpers.export(exports, "asIVec4", ()=>asIVec4
);
parcelHelpers.export(exports, "asUVec", ()=>asUVec
);
parcelHelpers.export(exports, "asUVec2", ()=>asUVec2
);
parcelHelpers.export(exports, "asUVec3", ()=>asUVec3
);
parcelHelpers.export(exports, "asUVec4", ()=>asUVec4
);
parcelHelpers.export(exports, "asBVec", ()=>asBVec
);
parcelHelpers.export(exports, "asBVec2", ()=>asBVec2
);
parcelHelpers.export(exports, "asBVec3", ()=>asBVec3
);
parcelHelpers.export(exports, "asBVec4", ()=>asBVec4
);
parcelHelpers.export(exports, "fromBVec", ()=>fromBVec
);
parcelHelpers.export(exports, "fromBVec2", ()=>fromBVec2
);
parcelHelpers.export(exports, "fromBVec3", ()=>fromBVec3
);
parcelHelpers.export(exports, "fromBVec4", ()=>fromBVec4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const $ = (tpl, pre = _templatesJs.NEW_OUT)=>_emitJs.defOp(tpl, _templatesJs.ARGS_V, _templatesJs.ARGS_V, "o", 1, pre)
;
const [asIVec, asIVec2, asIVec3, asIVec4] = $(([o, a])=>`${o}=${a}|0;`
);
const [asUVec, asUVec2, asUVec3, asUVec4] = $(([o, a])=>`${o}=${a}>>>0;`
);
const [asBVec, asBVec2, asBVec3, asBVec4] = $(([o, a])=>`${o}=!!${a};`
);
const [fromBVec, fromBVec2, fromBVec3, fromBVec4] = $(([o, a])=>`${o}=~~${a};`
);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4RdrM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "copy", ()=>copy
);
parcelHelpers.export(exports, "copyVectors", ()=>copyVectors
);
var _implementsFunction = require("@thi.ng/checks/implements-function");
var _setJs = require("./set.js");
const copy = (v)=>_implementsFunction.implementsFunction(v, "copy") ? v.copy() : _setJs.set([], v)
;
const copyVectors = (pts)=>pts.map(copy)
;

},{"@thi.ng/checks/implements-function":"cjrzK","./set.js":"bSUB8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5oxGU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "correlation", ()=>correlation
);
var _centerJs = require("./center.js");
var _magJs = require("./mag.js");
var _mulJs = require("./mul.js");
var _sumJs = require("./sum.js");
const correlation = (a, b)=>{
    a = _centerJs.center([], a);
    b = _centerJs.center([], b);
    const m = _magJs.mag(a) * _magJs.mag(b);
    return m !== 0 ? _sumJs.sum(_mulJs.mul(null, a, b)) / m : undefined;
};

},{"./center.js":"2MkSv","./mag.js":"70TCJ","./mul.js":"bTRb3","./sum.js":"2gBvR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bTRb3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "mul2", ()=>mul2
);
parcelHelpers.export(exports, "mul3", ()=>mul3
);
parcelHelpers.export(exports, "mul4", ()=>mul4
);
var _emitJs = require("./compile/emit.js");
const [mul, mul2, mul3, mul4] = _emitJs.defMathOp("*");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kXrcE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cos", ()=>cos
);
parcelHelpers.export(exports, "cos2", ()=>cos2
);
parcelHelpers.export(exports, "cos3", ()=>cos3
);
parcelHelpers.export(exports, "cos4", ()=>cos4
);
var _emitJs = require("./compile/emit.js");
const [cos, cos2, cos3, cos4] = _emitJs.defFnOp("Math.cos");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"O9xPf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cosh", ()=>cosh
);
parcelHelpers.export(exports, "cosh2", ()=>cosh2
);
parcelHelpers.export(exports, "cosh3", ()=>cosh3
);
parcelHelpers.export(exports, "cosh4", ()=>cosh4
);
var _emitJs = require("./compile/emit.js");
const [cosh, cosh2, cosh3, cosh4] = _emitJs.defFnOp("Math.cosh");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"alatG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "covariance", ()=>covariance
);
var _centerJs = require("./center.js");
var _mulJs = require("./mul.js");
var _sumJs = require("./sum.js");
const covariance = (a, b)=>_sumJs.sum(_mulJs.mul(null, _centerJs.center([], a), _centerJs.center([], b))) / (a.length - 1)
;

},{"./center.js":"2MkSv","./mul.js":"bTRb3","./sum.js":"2gBvR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2Nw0k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "crossS2", ()=>crossS2
);
parcelHelpers.export(exports, "crossS3", ()=>crossS3
);
var _setcsJs = require("./setcs.js");
const crossS2 = (a, b, ia = 0, ib = 0, sa = 1, sb = 1)=>a[ia] * b[ib + sb] - a[ia + sa] * b[ib]
;
const crossS3 = (out, a, b, io = 0, ia = 0, ib = 0, so = 1, sa = 1, sb = 1)=>_setcsJs.setCS3(out || a, a[ia + sa] * b[ib + 2 * sb] - a[ia + 2 * sa] * b[ib + sb], a[ia + 2 * sa] * b[ib] - a[ia] * b[ib + 2 * sb], a[ia] * b[ib + sb] - a[ia + sa] * b[ib], io, so)
;

},{"./setcs.js":"35qNU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"35qNU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setCS2", ()=>setCS2
);
parcelHelpers.export(exports, "setCS3", ()=>setCS3
);
parcelHelpers.export(exports, "setCS4", ()=>setCS4
);
const setCS2 = (out, x, y, io = 0, so = 1)=>(!out && (out = []), out[io] = x, out[io + so] = y, out)
;
const setCS3 = (out, x, y, z, io = 0, so = 1)=>(!out && (out = []), out[io] = x, out[io + so] = y, out[io + 2 * so] = z, out)
;
const setCS4 = (out, x, y, z, w, io = 0, so = 1)=>(!out && (out = []), out[io] = x, out[io + so] = y, out[io + 2 * so] = z, out[io + 3 * so] = w, out)
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8oHW5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "degrees", ()=>degrees
);
parcelHelpers.export(exports, "degrees2", ()=>degrees2
);
parcelHelpers.export(exports, "degrees3", ()=>degrees3
);
parcelHelpers.export(exports, "degrees4", ()=>degrees4
);
var _angle = require("@thi.ng/math/angle");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [degrees, degrees2, degrees3, degrees4] = _emitJs.defHofOp(_angle.deg, _templatesJs.FN("op"));

},{"@thi.ng/math/angle":"el41q","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8W4oS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distBrayCurtis", ()=>distBrayCurtis
);
const distBrayCurtis = (a, b)=>{
    let c = 0;
    let s = 0;
    for(let i = a.length; i-- > 0;){
        c += Math.abs(a[i] - b[i]);
        s += Math.abs(a[i] + b[i]);
    }
    return s > 0 ? c / s : 0;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bsKNq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distCanberra", ()=>distCanberra
);
const distCanberra = (a, b)=>{
    let delta = 0;
    for(let i = a.length; i-- > 0;){
        const aa = a[i];
        const bb = b[i];
        const d = Math.abs(aa) + Math.abs(bb);
        d > 0 && (delta += Math.abs(aa - bb) / d);
    }
    return delta;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kKt2g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distChebyshev", ()=>distChebyshev
);
parcelHelpers.export(exports, "distChebyshev2", ()=>distChebyshev2
);
parcelHelpers.export(exports, "distChebyshev3", ()=>distChebyshev3
);
parcelHelpers.export(exports, "distChebyshev4", ()=>distChebyshev4
);
var _emitJs = require("./compile/emit.js");
var _vopJs = require("./vop.js");
const $ = (dim)=>distChebyshev.add(dim, _emitJs.compile(dim, ([a, b])=>`Math.abs(${a}-${b})`
    , "a,b", undefined, "", ",", "return Math.max(", ");"))
;
const distChebyshev = _vopJs.vop();
distChebyshev.default((a, b)=>{
    let max = 0;
    for(let i = a.length; i-- > 0;)max = Math.max(max, Math.abs(a[i] - b[i]));
    return max;
});
const distChebyshev2 = $(2);
const distChebyshev3 = $(3);
const distChebyshev4 = $(4);

},{"./compile/emit.js":"hpIek","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gmYUE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distHamming", ()=>distHamming
);
const distHamming = (a, b)=>{
    let delta = 0;
    for(let i = a.length; i-- > 0;)a[i] !== b[i] && delta++;
    return delta / a.length;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c8sP5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distHaversineLatLon", ()=>distHaversineLatLon
);
parcelHelpers.export(exports, "distHaversineLonLat", ()=>distHaversineLonLat
);
parcelHelpers.export(exports, "distHaversine", ()=>distHaversine
);
var _radiansJs = require("./radians.js");
const distHaversineLatLon = (a, b, r = 6371)=>{
    a = _radiansJs.radians2([], a);
    b = _radiansJs.radians2([], b);
    return dist(a[0], a[1], b[0], b[1], r);
};
const distHaversineLonLat = (a, b, r = 6371)=>{
    a = _radiansJs.radians2([], a);
    b = _radiansJs.radians2([], b);
    return dist(a[1], a[0], b[1], b[0], r);
};
const distHaversine = distHaversineLonLat;
const dist = (lat1, lon1, lat2, lon2, r)=>{
    const dlat = 0.5 - Math.cos(lat2 - lat1) * 0.5;
    const dlon = (1 - Math.cos(lon2 - lon1)) * 0.5;
    const combined = dlat + Math.cos(lat1) * Math.cos(lat2) * dlon;
    return 2 * r * Math.asin(Math.sqrt(combined));
};

},{"./radians.js":"4f5wk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4f5wk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "radians", ()=>radians
);
parcelHelpers.export(exports, "radians2", ()=>radians2
);
parcelHelpers.export(exports, "radians3", ()=>radians3
);
parcelHelpers.export(exports, "radians4", ()=>radians4
);
var _angle = require("@thi.ng/math/angle");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [radians, radians2, radians3, radians4] = _emitJs.defHofOp(_angle.rad, _templatesJs.FN("op"));

},{"@thi.ng/math/angle":"el41q","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8rqoi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distJaccard", ()=>distJaccard
);
const distJaccard = (a, b)=>{
    let numNZ = 0;
    let numEQ = 0;
    for(let i = a.length; i-- > 0;){
        const aa = a[i] !== 0;
        const bb = b[i] !== 0;
        numNZ += ~~(aa || bb);
        numEQ += ~~(aa && bb);
    }
    return numNZ ? (numNZ - numEQ) / numNZ : 0;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dV6Jy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distManhattan", ()=>distManhattan
);
parcelHelpers.export(exports, "distManhattan2", ()=>distManhattan2
);
parcelHelpers.export(exports, "distManhattan3", ()=>distManhattan3
);
parcelHelpers.export(exports, "distManhattan4", ()=>distManhattan4
);
var _emitJs = require("./compile/emit.js");
var _vopJs = require("./vop.js");
const $ = (dim)=>distManhattan.add(dim, _emitJs.compile(dim, ([a, b])=>`Math.abs(${a}-${b})`
    , "a,b", undefined, "", "+", "return ", ";"))
;
const distManhattan = _vopJs.vop();
distManhattan.default(_emitJs.compileG(([a, b])=>`sum+=Math.abs(${a}-${b});`
, "a,b", undefined, "sum", "let sum=0;"));
const distManhattan2 = $(2);
const distManhattan3 = $(3);
const distManhattan4 = $(4);

},{"./compile/emit.js":"hpIek","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"85fil":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distMinkowski", ()=>distMinkowski
);
const distMinkowski = (a, b, p)=>{
    let delta = 0;
    for(let i = a.length; i-- > 0;)delta += Math.abs(a[i] - b[i]) ** p;
    return delta ** (1 / p);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eyp87":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distSorensenDice", ()=>distSorensenDice
);
const distSorensenDice = (a, b)=>{
    let numTP = 0;
    let numFP = 0;
    for(let i = a.length; i-- > 0;){
        const aa = a[i] !== 0;
        const bb = b[i] !== 0;
        numTP += ~~(aa && bb);
        numFP += ~~(aa !== bb);
    }
    return numFP ? numFP / (2 * numTP + numFP) : 0;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"btBuC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "weightedDistance", ()=>weightedDistance
);
var _mulJs = require("./mul.js");
const weightedDistance = (fn, weights)=>(a, b)=>fn(_mulJs.mul([], a, weights), _mulJs.mul([], b, weights))
;

},{"./mul.js":"bTRb3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hac1Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "divI", ()=>divI
);
parcelHelpers.export(exports, "divI2", ()=>divI2
);
parcelHelpers.export(exports, "divI3", ()=>divI3
);
parcelHelpers.export(exports, "divI4", ()=>divI4
);
parcelHelpers.export(exports, "divU", ()=>divU
);
parcelHelpers.export(exports, "divU2", ()=>divU2
);
parcelHelpers.export(exports, "divU3", ()=>divU3
);
parcelHelpers.export(exports, "divU4", ()=>divU4
);
parcelHelpers.export(exports, "divNI", ()=>divNI
);
parcelHelpers.export(exports, "divNI2", ()=>divNI2
);
parcelHelpers.export(exports, "divNI3", ()=>divNI3
);
parcelHelpers.export(exports, "divNI4", ()=>divNI4
);
parcelHelpers.export(exports, "divNU", ()=>divNU
);
parcelHelpers.export(exports, "divNU2", ()=>divNU2
);
parcelHelpers.export(exports, "divNU3", ()=>divNU3
);
parcelHelpers.export(exports, "divNU4", ()=>divNU4
);
var _emitJs = require("./compile/emit.js");
const [divI, divI2, divI3, divI4] = _emitJs.defBitOp("/", true);
const [divU, divU2, divU3, divU4] = _emitJs.defBitOp("/");
const [divNI, divNI2, divNI3, divNI4] = _emitJs.defBitOpN("/", true);
const [divNU, divNU2, divNU3, divNU4] = _emitJs.defBitOpN("/");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8VZzE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "divN", ()=>divN
);
parcelHelpers.export(exports, "divN2", ()=>divN2
);
parcelHelpers.export(exports, "divN3", ()=>divN3
);
parcelHelpers.export(exports, "divN4", ()=>divN4
);
var _emitJs = require("./compile/emit.js");
const [divN, divN2, divN3, divN4] = _emitJs.defMathOpN("/");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c7wQo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "divS", ()=>divS
);
parcelHelpers.export(exports, "divS2", ()=>divS2
);
parcelHelpers.export(exports, "divS3", ()=>divS3
);
parcelHelpers.export(exports, "divS4", ()=>divS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [divS, divS2, divS3, divS4] = _emitJs.defOpS(_templatesJs.MATH("/"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"afuXO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "divNS", ()=>divNS
);
parcelHelpers.export(exports, "divNS2", ()=>divNS2
);
parcelHelpers.export(exports, "divNS3", ()=>divNS3
);
parcelHelpers.export(exports, "divNS4", ()=>divNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [divNS, divNS2, divNS3, divNS4] = _emitJs.defOpS(_templatesJs.MATH_N("/"), _templatesJs.ARGS_VN, _templatesJs.SARGS_V, _templatesJs.ARGS_V);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cU5Pz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dotC4", ()=>dotC4
);
parcelHelpers.export(exports, "dotC6", ()=>dotC6
);
parcelHelpers.export(exports, "dotC8", ()=>dotC8
);
const dotC4 = (a, b, c, d)=>a * b + c * d
;
const dotC6 = (a, b, c, d, e, f)=>a * b + c * d + e * f
;
const dotC8 = (a, b, c, d, e, f, g, h)=>a * b + c * d + e * f + g * h
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3KJkk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dotS", ()=>dotS
);
parcelHelpers.export(exports, "dotS2", ()=>dotS2
);
parcelHelpers.export(exports, "dotS3", ()=>dotS3
);
parcelHelpers.export(exports, "dotS4", ()=>dotS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const dotS = (a, b, n, ia = 0, ib = 0, sa = 1, sb = 1)=>{
    let sum = 0;
    for(; n-- > 0; ia += sa, ib += sb)sum += a[ia] * b[ib];
    return sum;
};
const $ = (dim)=>_emitJs.compile(dim, _templatesJs.DOT, `o,a,${_templatesJs.SARGS_V}`, "o,a", "", "+", "return ", ";", true)
;
const dotS2 = $(2);
const dotS3 = $(3);
const dotS4 = $(4);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kHThs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "every", ()=>every
);
parcelHelpers.export(exports, "every2", ()=>every2
);
parcelHelpers.export(exports, "every3", ()=>every3
);
parcelHelpers.export(exports, "every4", ()=>every4
);
var _vopJs = require("./vop.js");
const every = _vopJs.vop();
every.default((v)=>{
    for(let i = v.length; i-- > 0;){
        if (!v[i]) return false;
    }
    return true;
});
const every2 = every.add(2, (a)=>a[0] && a[1]
);
const every3 = every.add(3, (a)=>a[0] && a[1] && a[2]
);
const every4 = every.add(4, (a)=>a[0] && a[1] && a[2] && a[3]
);

},{"./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Qp2H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "exp", ()=>exp
);
parcelHelpers.export(exports, "exp2", ()=>exp2
);
parcelHelpers.export(exports, "exp3", ()=>exp3
);
parcelHelpers.export(exports, "exp4", ()=>exp4
);
var _emitJs = require("./compile/emit.js");
const [exp, exp2, exp3, exp4] = _emitJs.defFnOp("Math.exp");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9UjlL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "exp_2", ()=>exp_2
);
parcelHelpers.export(exports, "exp_22", ()=>exp_22
);
parcelHelpers.export(exports, "exp_23", ()=>exp_23
);
parcelHelpers.export(exports, "exp_24", ()=>exp_24
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [exp_2, exp_22, exp_23, exp_24] = _emitJs.defOp(([o, a])=>`${o}=Math.pow(2,${a});`
, _templatesJs.ARGS_V);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iuxjX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "faceForward", ()=>faceForward
);
var _dotJs = require("./dot.js");
var _mulnJs = require("./muln.js");
var _setJs = require("./set.js");
const faceForward = (out, n, i, nref)=>{
    !out && (out = n);
    return _dotJs.dot(nref, i) < 0 ? out !== n ? _setJs.set(out, n) : out : _mulnJs.mulN(out, n, -1);
};

},{"./dot.js":"9vV5N","./muln.js":"1TKlE","./set.js":"bSUB8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"klykq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fill", ()=>fill
);
var _mapJs = require("./map.js");
var _setJs = require("./set.js");
const fill = (out, v, num, so = out.length * out.stride)=>_mapJs.mapV(_setJs.set.impl(v.length), out, v, num, so, 0)
;

},{"./map.js":"7CzQk","./set.js":"bSUB8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7CzQk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapVV", ()=>mapVV
);
parcelHelpers.export(exports, "mapV", ()=>mapV
);
parcelHelpers.export(exports, "mapVN", ()=>mapVN
);
parcelHelpers.export(exports, "mapVVV", ()=>mapVVV
);
parcelHelpers.export(exports, "mapVVN", ()=>mapVVN
);
const mapVV = (op, out, a, b, num, so = out.length * out.stride, sa = a.length * a.stride, sb = b.length * b.stride)=>{
    while(num-- > 0){
        op(out, a, b);
        out.offset += so;
        a.offset += sa;
        b.offset += sb;
    }
    return out.buf;
};
const mapV = (op, out, a, num, so = out.length * out.stride, sa = a.length * a.stride)=>{
    while(num-- > 0){
        op(out, a);
        out.offset += so;
        a.offset += sa;
    }
    return out.buf;
};
const mapVN = (op, out, a, n, num, so = out.length * out.stride, sa = a.length * a.stride)=>{
    while(num-- > 0){
        op(out, a, n);
        out.offset += so;
        a.offset += sa;
    }
    return out.buf;
};
const mapVVV = (op, out, a, b, c, num, so = out.length * out.stride, sa = a.length * a.stride, sb = b.length * b.stride, sc = c.length * c.stride)=>{
    while(num-- > 0){
        op(out, a, b, c);
        out.offset += so;
        a.offset += sa;
        b.offset += sb;
        c.offset += sc;
    }
    return out.buf;
};
const mapVVN = (op, out, a, b, n, num, so = out.length * out.stride, sa = a.length * a.stride, sb = b.length * b.stride)=>{
    while(num-- > 0){
        op(out, a, b, n);
        out.offset += so;
        a.offset += sa;
        b.offset += sb;
    }
    return out.buf;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dCUuP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fit", ()=>fit
);
parcelHelpers.export(exports, "fit2", ()=>fit2
);
parcelHelpers.export(exports, "fit3", ()=>fit3
);
parcelHelpers.export(exports, "fit4", ()=>fit4
);
parcelHelpers.export(exports, "fit01", ()=>fit01
);
parcelHelpers.export(exports, "fit01_2", ()=>fit01_2
);
parcelHelpers.export(exports, "fit01_3", ()=>fit01_3
);
parcelHelpers.export(exports, "fit01_4", ()=>fit01_4
);
parcelHelpers.export(exports, "fit11", ()=>fit11
);
parcelHelpers.export(exports, "fit11_2", ()=>fit11_2
);
parcelHelpers.export(exports, "fit11_3", ()=>fit11_3
);
parcelHelpers.export(exports, "fit11_4", ()=>fit11_4
);
var _fit = require("@thi.ng/math/fit");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [fit, fit2, fit3, fit4] = _emitJs.defHofOp(_fit.fit, _templatesJs.FN5(), "o,a,b,c,d,e");
const [fit01, fit01_2, fit01_3, fit01_4] = _emitJs.defHofOp(_fit.fit01, _templatesJs.FN3(), _templatesJs.ARGS_VVV);
const [fit11, fit11_2, fit11_3, fit11_4] = _emitJs.defHofOp(_fit.fit11, _templatesJs.FN3(), _templatesJs.ARGS_VVV);

},{"@thi.ng/math/fit":"8JCov","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8JCov":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "norm", ()=>norm
);
parcelHelpers.export(exports, "fit", ()=>fit
);
parcelHelpers.export(exports, "fitClamped", ()=>fitClamped
);
parcelHelpers.export(exports, "fit01", ()=>fit01
);
parcelHelpers.export(exports, "fit10", ()=>fit10
);
parcelHelpers.export(exports, "fit11", ()=>fit11
);
var _intervalJs = require("./interval.js");
const norm = (x, a, b)=>b !== a ? (x - a) / (b - a) : 0
;
const fit = (x, a, b, c, d)=>c + (d - c) * norm(x, a, b)
;
const fitClamped = (x, a, b, c, d)=>c + (d - c) * _intervalJs.clamp01(norm(x, a, b))
;
const fit01 = (x, a, b)=>a + (b - a) * _intervalJs.clamp01(x)
;
const fit10 = (x, a, b)=>b + (a - b) * _intervalJs.clamp01(x)
;
const fit11 = (x, a, b)=>a + (b - a) * (0.5 + 0.5 * _intervalJs.clamp11(x))
;

},{"./interval.js":"1TDWA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5TOiT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fmod", ()=>fmod
);
parcelHelpers.export(exports, "fmod2", ()=>fmod2
);
parcelHelpers.export(exports, "fmod3", ()=>fmod3
);
parcelHelpers.export(exports, "fmod4", ()=>fmod4
);
var _emitJs = require("./compile/emit.js");
const [fmod, fmod2, fmod3, fmod4] = _emitJs.defMathOp("%");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bYnoA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fmodN", ()=>fmodN
);
parcelHelpers.export(exports, "fmodN2", ()=>fmodN2
);
parcelHelpers.export(exports, "fmodN3", ()=>fmodN3
);
parcelHelpers.export(exports, "fmodN4", ()=>fmodN4
);
var _emitJs = require("./compile/emit.js");
const [fmodN, fmodN2, fmodN3, fmodN4] = _emitJs.defMathOpN("%");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4fVSV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fract", ()=>fract
);
parcelHelpers.export(exports, "fract2", ()=>fract2
);
parcelHelpers.export(exports, "fract3", ()=>fract3
);
parcelHelpers.export(exports, "fract4", ()=>fract4
);
var _prec = require("@thi.ng/math/prec");
var _emitJs = require("./compile/emit.js");
const [fract, fract2, fract3, fract4] = _emitJs.defHofOp(_prec.fract);

},{"@thi.ng/math/prec":"7e7rg","./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7e7rg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mod", ()=>mod
);
parcelHelpers.export(exports, "fract", ()=>fract
);
parcelHelpers.export(exports, "trunc", ()=>trunc
);
parcelHelpers.export(exports, "roundTo", ()=>roundTo
);
parcelHelpers.export(exports, "floorTo", ()=>floorTo
);
parcelHelpers.export(exports, "ceilTo", ()=>ceilTo
);
parcelHelpers.export(exports, "roundEps", ()=>roundEps
);
var _apiJs = require("./api.js");
const mod = (a, b)=>a - b * Math.floor(a / b)
;
const fract = (x)=>x - Math.floor(x)
;
const trunc = (x)=>x < 0 ? Math.ceil(x) : Math.floor(x)
;
const roundTo = (x, prec = 1)=>Math.round(x / prec) * prec
;
const floorTo = (x, prec = 1)=>Math.floor(x / prec) * prec
;
const ceilTo = (x, prec = 1)=>Math.ceil(x / prec) * prec
;
const roundEps = (x, eps = _apiJs.EPS)=>{
    const f = fract(x);
    return f <= eps || f >= 1 - eps ? Math.round(x) : x;
};

},{"./api.js":"4a98p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1cUXh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "gvec", ()=>gvec
);
var _api = require("@thi.ng/math/api");
var _memoize1 = require("@thi.ng/memoize/memoize1");
var _map = require("@thi.ng/transducers/map");
var _range = require("@thi.ng/transducers/range");
var _eqdeltaJs = require("./eqdelta.js");
var _iteratorJs = require("./iterator.js");
var _setnJs = require("./setn.js");
var _setsJs = require("./sets.js");
var _stringJs = require("./string.js");
const SYM_B = "buf";
const SYM_L = "length";
const SYM_O = "offset";
const SYM_S = "stride";
const SYM_C = "copy";
const SYM_CV = "copyView";
const SYM_EMPTY = "empty";
const SYM_EQD = "eqDelta";
const SYM_STR = "toString";
const PROPS = new Set([
    SYM_B,
    SYM_C,
    SYM_CV,
    SYM_EMPTY,
    SYM_EQD,
    SYM_L,
    SYM_O,
    SYM_S,
    SYM_STR,
    Symbol.iterator, 
]);
const keys = _memoize1.memoize1((size)=>[
        ..._map.map(String, _range.range(size)),
        ...PROPS, 
    ]
);
const gvec = (buf, size, offset = 0, stride = 1)=>new Proxy(buf, {
        get (obj, id) {
            switch(id){
                case Symbol.iterator:
                    return ()=>_iteratorJs.stridedValues(obj, size, offset, stride)
                    ;
                case SYM_L:
                    return size;
                case SYM_B:
                    return buf;
                case SYM_O:
                    return offset;
                case SYM_S:
                    return stride;
                case SYM_C:
                    return ()=>_setsJs.setS([], obj, size, 0, offset, 1, stride)
                    ;
                case SYM_CV:
                    return ()=>gvec(obj, size, offset, stride)
                    ;
                case SYM_EMPTY:
                    return ()=>_setnJs.zeroes(size)
                    ;
                case SYM_EQD:
                    return (o, eps = _api.EPS)=>_eqdeltaJs.eqDeltaS(buf, o, size, eps, offset, 0, stride, 1)
                    ;
                case SYM_STR:
                    return ()=>_stringJs.FORMATTER(_iteratorJs.stridedValues(obj, size, offset, stride))
                    ;
                default:
                    const j = parseInt(id);
                    return !isNaN(j) && j >= 0 && j < size ? obj[offset + j * stride] : undefined;
            }
        },
        set (obj, id, value) {
            const j = parseInt(id);
            if (!isNaN(j) && j >= 0 && j < size) obj[offset + (id | 0) * stride] = value;
            else switch(id){
                case SYM_O:
                    offset = value;
                    break;
                case SYM_S:
                    stride = value;
                    break;
                case SYM_L:
                    size = value;
                    break;
                default:
                    return false;
            }
            return true;
        },
        has (_, id) {
            return id >= 0 && id < size || PROPS.has(id);
        },
        ownKeys () {
            return keys(size);
        }
    })
;

},{"@thi.ng/math/api":"4a98p","@thi.ng/memoize/memoize1":"2HM4Q","@thi.ng/transducers/map":"fW6Xn","@thi.ng/transducers/range":"lUHc9","./eqdelta.js":"eBVIX","./iterator.js":"dnjxi","./setn.js":"2M6y1","./sets.js":"3jBTJ","./string.js":"iiJ6W","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2HM4Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "memoize1", ()=>memoize1
);
const memoize1 = (fn, cache)=>{
    !cache && (cache = new Map());
    return (x)=>{
        let res;
        return cache.has(x) ? cache.get(x) : (cache.set(x, res = fn(x)), res);
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a3Qmf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "headingSegmentXY", ()=>headingSegmentXY
);
parcelHelpers.export(exports, "headingSegmentXZ", ()=>headingSegmentXZ
);
parcelHelpers.export(exports, "headingSegmentYZ", ()=>headingSegmentYZ
);
parcelHelpers.export(exports, "headingSegment", ()=>headingSegment
);
var _angle = require("@thi.ng/math/angle");
const $ = (u, v)=>(a, b)=>_angle.atan2Abs(b[u] - a[u], b[v] - a[v])
;
const headingSegmentXY = $(1, 0);
const headingSegmentXZ = $(2, 0);
const headingSegmentYZ = $(2, 1);
const headingSegment = headingSegmentXY;

},{"@thi.ng/math/angle":"el41q","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a3DYy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromHomogeneous", ()=>fromHomogeneous
);
parcelHelpers.export(exports, "fromHomogeneous3", ()=>fromHomogeneous3
);
parcelHelpers.export(exports, "fromHomogeneous4", ()=>fromHomogeneous4
);
var _vopJs = require("./vop.js");
var _setcJs = require("./setc.js");
const fromHomogeneous = _vopJs.vop(1);
const fromHomogeneous3 = fromHomogeneous.add(3, (out, [x, y, w])=>_setcJs.setC2(out || [], x / w, y / w)
);
const fromHomogeneous4 = fromHomogeneous.add(4, (out, [x, y, z, w])=>_setcJs.setC3(out || [], x / w, y / w, z / w)
);

},{"./vop.js":"4v2k5","./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hJpMW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "invert", ()=>invert
);
parcelHelpers.export(exports, "invert2", ()=>invert2
);
parcelHelpers.export(exports, "invert3", ()=>invert3
);
parcelHelpers.export(exports, "invert4", ()=>invert4
);
var _emitJs = require("./compile/emit.js");
const [invert, invert2, invert3, invert4] = _emitJs.defOp(([o, a])=>`${o}=1/${a};`
);

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bHU8F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "invSqrt", ()=>invSqrt
);
parcelHelpers.export(exports, "invSqrt2", ()=>invSqrt2
);
parcelHelpers.export(exports, "invSqrt3", ()=>invSqrt3
);
parcelHelpers.export(exports, "invSqrt4", ()=>invSqrt4
);
var _emitJs = require("./compile/emit.js");
const [invSqrt, invSqrt2, invSqrt3, invSqrt4] = _emitJs.defOp(([o, a])=>`${o}=1/Math.sqrt(${a});`
);

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hVJ5w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isInf", ()=>isInf
);
parcelHelpers.export(exports, "isInf2", ()=>isInf2
);
parcelHelpers.export(exports, "isInf3", ()=>isInf3
);
parcelHelpers.export(exports, "isInf4", ()=>isInf4
);
var _emitJs = require("./compile/emit.js");
const [isInf, isInf2, isInf3, isInf4] = _emitJs.defFnOp("!isFinite");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lmjNR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isNaN", ()=>isNaN
);
parcelHelpers.export(exports, "isNaN2", ()=>isNaN2
);
parcelHelpers.export(exports, "isNaN3", ()=>isNaN3
);
parcelHelpers.export(exports, "isNaN4", ()=>isNaN4
);
var _emitJs = require("./compile/emit.js");
const [isNaN, isNaN2, isNaN3, isNaN4] = _emitJs.defFnOp("isNaN");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ceTNs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "limit", ()=>limit
);
var _magJs = require("./mag.js");
var _mulnJs = require("./muln.js");
var _setJs = require("./set.js");
const limit = (out, v, n)=>{
    !out && (out = v);
    const m = _magJs.mag(v);
    return m > n ? _mulnJs.mulN(out, v, n / m) : out !== v ? _setJs.set(out, v) : out;
};

},{"./mag.js":"70TCJ","./muln.js":"1TKlE","./set.js":"bSUB8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"zFq2X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "log", ()=>log
);
parcelHelpers.export(exports, "log2", ()=>log2
);
parcelHelpers.export(exports, "log3", ()=>log3
);
parcelHelpers.export(exports, "log4", ()=>log4
);
var _emitJs = require("./compile/emit.js");
const [log, log2, log3, log4] = _emitJs.defFnOp("Math.log");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1fpEn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "log_2", ()=>log_2
);
parcelHelpers.export(exports, "log_22", ()=>log_22
);
parcelHelpers.export(exports, "log_23", ()=>log_23
);
parcelHelpers.export(exports, "log_24", ()=>log_24
);
var _emitJs = require("./compile/emit.js");
const [log_2, log_22, log_23, log_24] = _emitJs.defFnOp("Math.log2");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b5AQh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "logicAnd", ()=>logicAnd
);
parcelHelpers.export(exports, "logicAnd2", ()=>logicAnd2
);
parcelHelpers.export(exports, "logicAnd3", ()=>logicAnd3
);
parcelHelpers.export(exports, "logicAnd4", ()=>logicAnd4
);
parcelHelpers.export(exports, "logicAndN", ()=>logicAndN
);
parcelHelpers.export(exports, "logicAndN2", ()=>logicAndN2
);
parcelHelpers.export(exports, "logicAndN3", ()=>logicAndN3
);
parcelHelpers.export(exports, "logicAndN4", ()=>logicAndN4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [logicAnd, logicAnd2, logicAnd3, logicAnd4] = _emitJs.defOp(_templatesJs.MATH("&&"));
const [logicAndN, logicAndN2, logicAndN3, logicAndN4] = _emitJs.defOp(_templatesJs.MATH_N("&&"), _templatesJs.ARGS_VN);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eDW8G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "logicNot", ()=>logicNot
);
parcelHelpers.export(exports, "logicNot2", ()=>logicNot2
);
parcelHelpers.export(exports, "logicNot3", ()=>logicNot3
);
parcelHelpers.export(exports, "logicNot4", ()=>logicNot4
);
var _emitJs = require("./compile/emit.js");
const [logicNot, logicNot2, logicNot3, logicNot4] = _emitJs.defFnOp("!");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3aaGQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "logicOr", ()=>logicOr
);
parcelHelpers.export(exports, "logicOr2", ()=>logicOr2
);
parcelHelpers.export(exports, "logicOr3", ()=>logicOr3
);
parcelHelpers.export(exports, "logicOr4", ()=>logicOr4
);
parcelHelpers.export(exports, "logicOrN", ()=>logicOrN
);
parcelHelpers.export(exports, "logicOrN2", ()=>logicOrN2
);
parcelHelpers.export(exports, "logicOrN3", ()=>logicOrN3
);
parcelHelpers.export(exports, "logicOrN4", ()=>logicOrN4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [logicOr, logicOr2, logicOr3, logicOr4] = _emitJs.defOp(_templatesJs.MATH("||"));
const [logicOrN, logicOrN2, logicOrN3, logicOrN4] = _emitJs.defOp(_templatesJs.MATH_N("||"), _templatesJs.ARGS_VN);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"46YJu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lshiftI", ()=>lshiftI
);
parcelHelpers.export(exports, "lshiftI2", ()=>lshiftI2
);
parcelHelpers.export(exports, "lshiftI3", ()=>lshiftI3
);
parcelHelpers.export(exports, "lshiftI4", ()=>lshiftI4
);
parcelHelpers.export(exports, "lshiftU", ()=>lshiftU
);
parcelHelpers.export(exports, "lshiftU2", ()=>lshiftU2
);
parcelHelpers.export(exports, "lshiftU3", ()=>lshiftU3
);
parcelHelpers.export(exports, "lshiftU4", ()=>lshiftU4
);
parcelHelpers.export(exports, "lshiftNI", ()=>lshiftNI
);
parcelHelpers.export(exports, "lshiftNI2", ()=>lshiftNI2
);
parcelHelpers.export(exports, "lshiftNI3", ()=>lshiftNI3
);
parcelHelpers.export(exports, "lshiftNI4", ()=>lshiftNI4
);
parcelHelpers.export(exports, "lshiftNU", ()=>lshiftNU
);
parcelHelpers.export(exports, "lshiftNU2", ()=>lshiftNU2
);
parcelHelpers.export(exports, "lshiftNU3", ()=>lshiftNU3
);
parcelHelpers.export(exports, "lshiftNU4", ()=>lshiftNU4
);
var _emitJs = require("./compile/emit.js");
const [lshiftI, lshiftI2, lshiftI3, lshiftI4] = _emitJs.defBitOp("<<", true);
const [lshiftU, lshiftU2, lshiftU3, lshiftU4] = _emitJs.defBitOp("<<");
const [lshiftNI, lshiftNI2, lshiftNI3, lshiftNI4] = _emitJs.defBitOpN("<<", true);
const [lshiftNU, lshiftNU2, lshiftNU3, lshiftNU4] = _emitJs.defBitOpN("<<");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iDF9M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "maddS", ()=>maddS
);
parcelHelpers.export(exports, "maddS2", ()=>maddS2
);
parcelHelpers.export(exports, "maddS3", ()=>maddS3
);
parcelHelpers.export(exports, "maddS4", ()=>maddS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [maddS, maddS2, maddS3, maddS4] = _emitJs.defOpS(_templatesJs.MATH2("*", "+"), _templatesJs.ARGS_VVV, _templatesJs.SARGS_VVV, _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iOnQH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "maddNS", ()=>maddNS
);
parcelHelpers.export(exports, "maddNS2", ()=>maddNS2
);
parcelHelpers.export(exports, "maddNS3", ()=>maddNS3
);
parcelHelpers.export(exports, "maddNS4", ()=>maddNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [maddNS, maddNS2, maddNS3, maddNS4] = _emitJs.defOpS(_templatesJs.MATH2A_N("*", "+"), _templatesJs.ARGS_VNV, _templatesJs.SARGS_VV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h4CFH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "magS", ()=>magS
);
parcelHelpers.export(exports, "magS2", ()=>magS2
);
parcelHelpers.export(exports, "magS3", ()=>magS3
);
parcelHelpers.export(exports, "magS4", ()=>magS4
);
var _dotsJs = require("./dots.js");
const magS = (a, num, ia, sa)=>Math.sqrt(_dotsJs.dotS(a, a, num, ia, ia, sa, sa))
;
const magS2 = (a, ia, sa)=>Math.sqrt(_dotsJs.dotS2(a, a, ia, ia, sa, sa))
;
const magS3 = (a, ia, sa)=>Math.sqrt(_dotsJs.dotS3(a, a, ia, ia, sa, sa))
;
const magS4 = (a, ia, sa)=>Math.sqrt(_dotsJs.dotS4(a, a, ia, ia, sa, sa))
;

},{"./dots.js":"3KJkk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b5N6p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "magSqS2", ()=>magSqS2
);
parcelHelpers.export(exports, "magSqS3", ()=>magSqS3
);
parcelHelpers.export(exports, "magSqS4", ()=>magSqS4
);
var _dotsJs = require("./dots.js");
const magSqS2 = (a, ia, sa)=>_dotsJs.dotS2(a, a, ia, ia, sa, sa)
;
const magSqS3 = (a, ia, sa)=>_dotsJs.dotS3(a, a, ia, ia, sa, sa)
;
const magSqS4 = (a, ia, sa)=>_dotsJs.dotS4(a, a, ia, ia, sa, sa)
;

},{"./dots.js":"3KJkk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hqWnf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "major", ()=>major
);
parcelHelpers.export(exports, "major2", ()=>major2
);
parcelHelpers.export(exports, "major3", ()=>major3
);
parcelHelpers.export(exports, "major4", ()=>major4
);
var _interval = require("@thi.ng/math/interval");
var _vopJs = require("./vop.js");
const abs = Math.abs;
const major = _vopJs.vop();
major.default((a)=>{
    let id = -1;
    let max = -Infinity;
    for(let i = a.length; i-- > 0;){
        const x = abs(a[i]);
        if (x > max) {
            max = x;
            id = i;
        }
    }
    return id;
});
const major2 = major.add(2, (a)=>_interval.max2id(abs(a[0]), abs(a[1]))
);
const major3 = major.add(3, (a)=>_interval.max3id(abs(a[0]), abs(a[1]), abs(a[2]))
);
const major4 = major.add(4, (a)=>_interval.max4id(abs(a[0]), abs(a[1]), abs(a[2]), abs(a[3]))
);

},{"@thi.ng/math/interval":"1TDWA","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8KUWS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapVectors", ()=>mapVectors
);
var _isNumber = require("@thi.ng/checks/is-number");
function mapVectors(fn, out, a, b, c) {
    const num = a.length;
    !out && (out = new Array(num));
    c !== undefined ? _isNumber.isNumber(c) ? mapVVN(fn, out, a, b, c) : mapVVV(fn, out, a, b, c) : _isNumber.isNumber(b) ? mapVN(fn, out, a, b) : mapVV(fn, out, a, b);
    return out;
}
const mapVN = (fn, out, a, b)=>{
    for(let i = 0, num = a.length; i < num; i++)out[i] = fn(out[i] || [], a[i], b);
};
const mapVV = (fn, out, a, b)=>{
    for(let i = 0, num = a.length; i < num; i++)out[i] = fn(out[i] || [], a[i], b[i]);
};
const mapVVN = (fn, out, a, b, c)=>{
    for(let i = 0, num = a.length; i < num; i++)out[i] = fn(out[i] || [], a[i], b[i], c);
};
const mapVVV = (fn, out, a, b, c)=>{
    for(let i = 0, num = a.length; i < num; i++)out[i] = fn(out[i] || [], a[i], b[i], c[i]);
};

},{"@thi.ng/checks/is-number":"hNf8P","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7CH4J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "max", ()=>max
);
parcelHelpers.export(exports, "max2", ()=>max2
);
parcelHelpers.export(exports, "max3", ()=>max3
);
parcelHelpers.export(exports, "max4", ()=>max4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [max, max2, max3, max4] = _emitJs.defOp(_templatesJs.FN2("Math.max"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l64lm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "maxBounds", ()=>maxBounds
);
var _ensureJs = require("./internal/ensure.js");
var _maxJs = require("./max.js");
var _setnJs = require("./setn.js");
var _vecOfJs = require("./vec-of.js");
const maxBounds = (out, src)=>{
    _ensureJs.__ensureInputs(src);
    out = out ? _setnJs.setN(out, -Infinity) : _vecOfJs.vecOf(src[0].length, -Infinity);
    for(let i = src.length; i-- > 0;)_maxJs.max(out, out, src[i]);
    return out;
};

},{"./internal/ensure.js":"dq2YU","./max.js":"7CH4J","./setn.js":"2M6y1","./vec-of.js":"1dJsE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1dJsE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "vecOf", ()=>vecOf
);
parcelHelpers.export(exports, "oneHot", ()=>oneHot
);
const vecOf = (size, n = 0)=>new Array(size).fill(n)
;
const oneHot = (size, hot)=>{
    const res = vecOf(size);
    res[hot] = 1;
    return res;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k1qXc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "median", ()=>median
);
parcelHelpers.export(exports, "vmedian", ()=>vmedian
);
var _ensureJs = require("./internal/ensure.js");
const median = (out, src)=>{
    _ensureJs.__ensureInputs(src);
    out = out || [];
    const m = src.length >> 1;
    for(let i = src[0].length; i-- > 0;)out[i] = src.map((x)=>x[i]
    ).sort((a, b)=>a - b
    )[m];
    return out;
};
const vmedian = (a1)=>{
    if (!a1.length) return 0;
    a1 = [
        ...a1
    ].sort((a, b)=>a - b
    );
    return a1[a1.length >> 1];
};

},{"./internal/ensure.js":"dq2YU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gWOyO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "min", ()=>min
);
parcelHelpers.export(exports, "min2", ()=>min2
);
parcelHelpers.export(exports, "min3", ()=>min3
);
parcelHelpers.export(exports, "min4", ()=>min4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [min, min2, min3, min4] = _emitJs.defOp(_templatesJs.FN2("Math.min"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kPgsx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "minBounds", ()=>minBounds
);
var _ensureJs = require("./internal/ensure.js");
var _minJs = require("./min.js");
var _setnJs = require("./setn.js");
var _vecOfJs = require("./vec-of.js");
const minBounds = (out, src)=>{
    _ensureJs.__ensureInputs(src);
    out = out ? _setnJs.setN(out, Infinity) : _vecOfJs.vecOf(src[0].length, Infinity);
    for(let i = src.length; i-- > 0;)_minJs.min(out, out, src[i]);
    return out;
};

},{"./internal/ensure.js":"dq2YU","./min.js":"gWOyO","./setn.js":"2M6y1","./vec-of.js":"1dJsE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9omJw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "minor", ()=>minor
);
parcelHelpers.export(exports, "minor2", ()=>minor2
);
parcelHelpers.export(exports, "minor3", ()=>minor3
);
parcelHelpers.export(exports, "minor4", ()=>minor4
);
var _interval = require("@thi.ng/math/interval");
var _vopJs = require("./vop.js");
const abs = Math.abs;
const minor = _vopJs.vop();
minor.default((a)=>{
    let id = -1;
    let min = Infinity;
    for(let i = a.length; i-- > 0;){
        const x = abs(a[i]);
        if (x < min) {
            min = x;
            id = i;
        }
    }
    return id;
});
const minor2 = minor.add(2, (a)=>_interval.min2id(abs(a[0]), abs(a[1]))
);
const minor3 = minor.add(3, (a)=>_interval.min3id(abs(a[0]), abs(a[1]), abs(a[2]))
);
const minor4 = minor.add(4, (a)=>_interval.min4id(abs(a[0]), abs(a[1]), abs(a[2]), abs(a[3]))
);

},{"@thi.ng/math/interval":"1TDWA","./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"baPCK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mixBilinear", ()=>mixBilinear
);
parcelHelpers.export(exports, "mixBilinear2", ()=>mixBilinear2
);
parcelHelpers.export(exports, "mixBilinear3", ()=>mixBilinear3
);
parcelHelpers.export(exports, "mixBilinear4", ()=>mixBilinear4
);
var _mix = require("@thi.ng/math/mix");
var _emitJs = require("./compile/emit.js");
const [mixBilinear, mixBilinear2, mixBilinear3, mixBilinear4] = _emitJs.defHofOp(_mix.mixBilinear, ([o, a, b, c, d])=>`${o}=op(${a},${b},${c},${d},u,v);`
, "o,a,b,c,d,u,v");

},{"@thi.ng/math/mix":"cHjhA","./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cHjhA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mix", ()=>mix
);
parcelHelpers.export(exports, "mixBilinear", ()=>mixBilinear
);
parcelHelpers.export(exports, "mixQuadratic", ()=>mixQuadratic
);
parcelHelpers.export(exports, "mixCubic", ()=>mixCubic
);
parcelHelpers.export(exports, "mixHermite", ()=>mixHermite
);
parcelHelpers.export(exports, "mixCubicHermite", ()=>mixCubicHermite
);
parcelHelpers.export(exports, "mixCubicHermiteFromPoints", ()=>mixCubicHermiteFromPoints
);
parcelHelpers.export(exports, "mixBicubic", ()=>mixBicubic
);
parcelHelpers.export(exports, "tangentCardinal", ()=>tangentCardinal
);
parcelHelpers.export(exports, "tangentDiff3", ()=>tangentDiff3
);
parcelHelpers.export(exports, "tween", ()=>tween
);
parcelHelpers.export(exports, "circular", ()=>circular
);
parcelHelpers.export(exports, "invCircular", ()=>invCircular
);
parcelHelpers.export(exports, "lens", ()=>lens
);
parcelHelpers.export(exports, "cosine", ()=>cosine
);
parcelHelpers.export(exports, "decimated", ()=>decimated
);
parcelHelpers.export(exports, "bounce", ()=>bounce
);
parcelHelpers.export(exports, "ease", ()=>ease
);
parcelHelpers.export(exports, "impulse", ()=>impulse
);
parcelHelpers.export(exports, "gain", ()=>gain
);
parcelHelpers.export(exports, "parabola", ()=>parabola
);
parcelHelpers.export(exports, "cubicPulse", ()=>cubicPulse
);
parcelHelpers.export(exports, "sinc", ()=>sinc
);
parcelHelpers.export(exports, "sincNormalized", ()=>sincNormalized
);
parcelHelpers.export(exports, "lanczos", ()=>lanczos
);
parcelHelpers.export(exports, "sigmoid", ()=>sigmoid
);
parcelHelpers.export(exports, "sigmoid01", ()=>sigmoid01
);
parcelHelpers.export(exports, "sigmoid11", ()=>sigmoid11
);
parcelHelpers.export(exports, "schlick", ()=>schlick
);
parcelHelpers.export(exports, "expFactor", ()=>expFactor
);
parcelHelpers.export(exports, "gaussian", ()=>gaussian
);
var _apiJs = require("./api.js");
const mix = (a, b, t)=>a + (b - a) * t
;
const mixBilinear = (a, b, c, d, u, v)=>{
    const iu = 1 - u;
    const iv = 1 - v;
    return a * iu * iv + b * u * iv + c * iu * v + d * u * v;
};
const mixQuadratic = (a, b, c, t)=>{
    const s = 1 - t;
    return a * s * s + b * 2 * s * t + c * t * t;
};
const mixCubic = (a, b, c, d, t)=>{
    const t2 = t * t;
    const s = 1 - t;
    const s2 = s * s;
    return a * s2 * s + b * 3 * s2 * t + c * 3 * t2 * s + d * t2 * t;
};
const mixHermite = (a, b, c, d, t)=>{
    const y1 = 0.5 * (c - a);
    const y2 = 1.5 * (b - c) + 0.5 * (d - a);
    return ((y2 * t + a - b + y1 - y2) * t + y1) * t + b;
};
const mixCubicHermite = (a, ta, b, tb, t)=>{
    const s = t - 1;
    const t2 = t * t;
    const s2 = s * s;
    const h00 = (1 + 2 * t) * s2;
    const h10 = t * s2;
    const h01 = t2 * (3 - 2 * t);
    const h11 = t2 * s;
    return h00 * a + h10 * ta + h01 * b + h11 * tb;
};
const mixCubicHermiteFromPoints = (a, b, c, d, t)=>{
    d *= 0.5;
    const aa = -0.5 * a + 1.5 * b - 1.5 * c + d;
    const bb = a - 2.5 * b + 2 * c - d;
    const cc = -0.5 * a + 0.5 * c;
    const dd = b;
    const t2 = t * t;
    return t * t2 * aa + t2 * bb + t * cc + dd;
};
const mixBicubic = (s00, s01, s02, s03, s10, s11, s12, s13, s20, s21, s22, s23, s30, s31, s32, s33, u, v)=>mixCubicHermiteFromPoints(mixCubicHermiteFromPoints(s00, s01, s02, s03, u), mixCubicHermiteFromPoints(s10, s11, s12, s13, u), mixCubicHermiteFromPoints(s20, s21, s22, s23, u), mixCubicHermiteFromPoints(s30, s31, s32, s33, u), v)
;
const tangentCardinal = (prev, next, scale = 0.5, ta = 0, tc = 2)=>scale * ((next - prev) / (tc - ta))
;
const tangentDiff3 = (prev, curr, next, ta = 0, tb = 1, tc = 2)=>0.5 * ((next - curr) / (tc - tb) + (curr - prev) / (tb - ta))
;
const tween = (f, from, to)=>(t)=>mix(from, to, f(t))
;
const circular = (t)=>{
    t = 1 - t;
    return Math.sqrt(1 - t * t);
};
const invCircular = (t)=>1 - circular(1 - t)
;
const lens = (pos, strength, t)=>{
    const impl = strength > 0 ? invCircular : circular;
    const tp = 1 - pos;
    const tl = t <= pos ? impl(t / pos) * pos : 1 - impl((1 - t) / tp) * tp;
    return mix(t, tl, Math.abs(strength));
};
const cosine = (t)=>1 - (Math.cos(t * _apiJs.PI) * 0.5 + 0.5)
;
const decimated = (n, t)=>Math.floor(t * n) / n
;
const bounce = (k, amp, t)=>{
    const tk = t * k;
    return 1 - amp * Math.sin(tk) / tk * Math.cos(t * _apiJs.HALF_PI);
};
const ease = (ease1, t)=>Math.pow(t, ease1)
;
const impulse = (k, t)=>{
    const h = k * t;
    return h * Math.exp(1 - h);
};
const gain = (k, t)=>t < 0.5 ? 0.5 * Math.pow(2 * t, k) : 1 - 0.5 * Math.pow(2 - 2 * t, k)
;
const parabola = (k, t)=>Math.pow(4 * t * (1 - t), k)
;
const cubicPulse = (w, c, t)=>{
    t = Math.abs(t - c);
    return t > w ? 0 : (t /= w, 1 - t * t * (3 - 2 * t));
};
const sinc = (t)=>t !== 0 ? Math.sin(t) / t : 1
;
const sincNormalized = (k, t)=>sinc(_apiJs.PI * k * t)
;
const lanczos = (a, t)=>t !== 0 ? -a < t && t < a ? sinc(_apiJs.PI * t) * sinc(_apiJs.PI * t / a) : 0 : 1
;
const sigmoid = (bias, k, t)=>t != bias ? 1 / (1 + Math.exp(-k * (t - bias))) : 0.5
;
const sigmoid01 = (k, t)=>sigmoid(0.5, k, t)
;
const sigmoid11 = (k, t)=>sigmoid(0, k, t)
;
const schlick = (a, b, t)=>t <= b ? b * t / (t + a * (b - t) + _apiJs.EPS) : (1 - b) * (t - 1) / (1 - t - a * (b - t) + _apiJs.EPS) + 1
;
const expFactor = (a, b, num)=>(b / a) ** (1 / num)
;
const gaussian = (bias, sigma, t)=>Math.exp(-((t - bias) ** 2) / (2 * sigma * sigma))
;

},{"./api.js":"4a98p","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5OlFY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mixCubic", ()=>mixCubic
);
var _addwJs = require("./addw.js");
const mixCubic = (out, a, b, c, d, t)=>{
    const s = 1 - t;
    const s2 = s * s;
    const t2 = t * t;
    return _addwJs.addW4(out, a, b, c, d, s2 * s, 3 * s2 * t, 3 * t2 * s, t2 * t);
};

},{"./addw.js":"cFpxt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"114q9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mixCubicHermite", ()=>mixCubicHermite
);
parcelHelpers.export(exports, "mixHermiteCardinal", ()=>mixHermiteCardinal
);
parcelHelpers.export(exports, "mixHermiteDiff3", ()=>mixHermiteDiff3
);
parcelHelpers.export(exports, "tangentCardinal", ()=>tangentCardinal
);
parcelHelpers.export(exports, "tangentDiff3", ()=>tangentDiff3
);
var _addmnJs = require("./addmn.js");
var _addwJs = require("./addw.js");
var _submnJs = require("./submn.js");
const mixCubicHermite = (out, a, ta, b, tb, t)=>{
    const s = t - 1;
    const t2 = t * t;
    const s2 = s * s;
    return _addwJs.addW4(out, a, ta, b, tb, (1 + 2 * t) * s2, t * s2, t2 * (3 - 2 * t), t2 * s);
};
const mixHermiteCardinal = (out, a, b, c, d, t, scale = 0.5)=>mixCubicHermite(out, b, tangentCardinal([], a, c, scale), c, tangentCardinal([], b, d, scale), t)
;
const mixHermiteDiff3 = (out, a, b, c, d, t)=>mixCubicHermite(out, b, tangentDiff3([], a, b, c), c, tangentDiff3([], b, c, d), t)
;
const tangentCardinal = (out, prev, next, scale = 0.5, ta = 0, tc = 2)=>_submnJs.submN(out, next, prev, scale / (tc - ta))
;
const tangentDiff3 = (out, prev, curr, next, ta = 0, tb = 1, tc = 2)=>_addmnJs.addmN(out, _submnJs.submN(out, curr, prev, 1 / (tb - ta)), _submnJs.submN([], next, curr, 1 / (tc - tb)), 0.5)
;

},{"./addmn.js":"9C52h","./addw.js":"cFpxt","./submn.js":"aIPIo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6mY6C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mixQuadratic", ()=>mixQuadratic
);
var _addwJs = require("./addw.js");
const mixQuadratic = (out, a, b, c, t)=>{
    const s = 1 - t;
    return _addwJs.addW3(out, a, b, c, s * s, 2 * s * t, t * t);
};

},{"./addw.js":"cFpxt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hb219":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mix", ()=>mix
);
parcelHelpers.export(exports, "mix2", ()=>mix2
);
parcelHelpers.export(exports, "mix3", ()=>mix3
);
parcelHelpers.export(exports, "mix4", ()=>mix4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [mix, mix2, mix3, mix4] = _emitJs.defOp(_templatesJs.MIX, _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gLg2m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mixS", ()=>mixS
);
parcelHelpers.export(exports, "mixS2", ()=>mixS2
);
parcelHelpers.export(exports, "mixS3", ()=>mixS3
);
parcelHelpers.export(exports, "mixS4", ()=>mixS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [mixS, mixS2, mixS3, mixS4] = _emitJs.defOpS(_templatesJs.MIX, _templatesJs.ARGS_VVV, _templatesJs.SARGS_VVV, _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"glIAb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mixNS", ()=>mixNS
);
parcelHelpers.export(exports, "mixNS2", ()=>mixNS2
);
parcelHelpers.export(exports, "mixNS3", ()=>mixNS3
);
parcelHelpers.export(exports, "mixNS4", ()=>mixNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [mixNS, mixNS2, mixNS3, mixNS4] = _emitJs.defOpS(_templatesJs.MIX_N, _templatesJs.ARGS_VVN, _templatesJs.SARGS_VV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fNrmT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mod", ()=>mod
);
parcelHelpers.export(exports, "mod2", ()=>mod2
);
parcelHelpers.export(exports, "mod3", ()=>mod3
);
parcelHelpers.export(exports, "mod4", ()=>mod4
);
var _prec = require("@thi.ng/math/prec");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [mod, mod2, mod3, mod4] = _emitJs.defHofOp(_prec.mod, _templatesJs.FN2("op"), _templatesJs.ARGS_VV);

},{"@thi.ng/math/prec":"7e7rg","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"YyBoO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "modN", ()=>modN
);
parcelHelpers.export(exports, "modN2", ()=>modN2
);
parcelHelpers.export(exports, "modN3", ()=>modN3
);
parcelHelpers.export(exports, "modN4", ()=>modN4
);
var _prec = require("@thi.ng/math/prec");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [modN, modN2, modN3, modN4] = _emitJs.defHofOp(_prec.mod, _templatesJs.FN_N("op"), _templatesJs.ARGS_VN, _templatesJs.ARGS_V);

},{"@thi.ng/math/prec":"7e7rg","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8UZie":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "msub", ()=>msub
);
parcelHelpers.export(exports, "msub2", ()=>msub2
);
parcelHelpers.export(exports, "msub3", ()=>msub3
);
parcelHelpers.export(exports, "msub4", ()=>msub4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [msub, msub2, msub3, msub4] = _emitJs.defOp(_templatesJs.MATH2("*", "-"), _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9zPln":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "msubN", ()=>msubN
);
parcelHelpers.export(exports, "msubN2", ()=>msubN2
);
parcelHelpers.export(exports, "msubN3", ()=>msubN3
);
parcelHelpers.export(exports, "msubN4", ()=>msubN4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [msubN, msubN2, msubN3, msubN4] = _emitJs.defOp(_templatesJs.MATH2A_N("*", "-"), _templatesJs.ARGS_VNV, _templatesJs.ARGS_VV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ke6Rd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "msubS", ()=>msubS
);
parcelHelpers.export(exports, "msubS2", ()=>msubS2
);
parcelHelpers.export(exports, "msubS3", ()=>msubS3
);
parcelHelpers.export(exports, "msubS4", ()=>msubS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [msubS, msubS2, msubS3, msubS4] = _emitJs.defOpS(_templatesJs.MATH2("*", "-"), _templatesJs.ARGS_VVV, _templatesJs.SARGS_VVV, _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6JEEE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "msubNS", ()=>msubNS
);
parcelHelpers.export(exports, "msubNS2", ()=>msubNS2
);
parcelHelpers.export(exports, "msubNS3", ()=>msubNS3
);
parcelHelpers.export(exports, "msubNS4", ()=>msubNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [msubNS, msubNS2, msubNS3, msubNS4] = _emitJs.defOpS(_templatesJs.MATH2A_N("*", "-"), _templatesJs.ARGS_VNV, _templatesJs.SARGS_VV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aJFBK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mulI", ()=>mulI
);
parcelHelpers.export(exports, "mulI2", ()=>mulI2
);
parcelHelpers.export(exports, "mulI3", ()=>mulI3
);
parcelHelpers.export(exports, "mulI4", ()=>mulI4
);
parcelHelpers.export(exports, "mulU", ()=>mulU
);
parcelHelpers.export(exports, "mulU2", ()=>mulU2
);
parcelHelpers.export(exports, "mulU3", ()=>mulU3
);
parcelHelpers.export(exports, "mulU4", ()=>mulU4
);
parcelHelpers.export(exports, "mulNI", ()=>mulNI
);
parcelHelpers.export(exports, "mulNI2", ()=>mulNI2
);
parcelHelpers.export(exports, "mulNI3", ()=>mulNI3
);
parcelHelpers.export(exports, "mulNI4", ()=>mulNI4
);
parcelHelpers.export(exports, "mulNU", ()=>mulNU
);
parcelHelpers.export(exports, "mulNU2", ()=>mulNU2
);
parcelHelpers.export(exports, "mulNU3", ()=>mulNU3
);
parcelHelpers.export(exports, "mulNU4", ()=>mulNU4
);
var _emitJs = require("./compile/emit.js");
const [mulI, mulI2, mulI3, mulI4] = _emitJs.defBitOp("*", true);
const [mulU, mulU2, mulU3, mulU4] = _emitJs.defBitOp("*");
const [mulNI, mulNI2, mulNI3, mulNI4] = _emitJs.defBitOpN("*", true);
const [mulNU, mulNU2, mulNU3, mulNU4] = _emitJs.defBitOpN("*");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"01xwB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mulS", ()=>mulS
);
parcelHelpers.export(exports, "mulS2", ()=>mulS2
);
parcelHelpers.export(exports, "mulS3", ()=>mulS3
);
parcelHelpers.export(exports, "mulS4", ()=>mulS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [mulS, mulS2, mulS3, mulS4] = _emitJs.defOpS(_templatesJs.MATH("*"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b3IkY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mulNS", ()=>mulNS
);
parcelHelpers.export(exports, "mulNS2", ()=>mulNS2
);
parcelHelpers.export(exports, "mulNS3", ()=>mulNS3
);
parcelHelpers.export(exports, "mulNS4", ()=>mulNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [mulNS, mulNS2, mulNS3, mulNS4] = _emitJs.defOpS(_templatesJs.MATH_N("*"), _templatesJs.ARGS_VN, _templatesJs.SARGS_V, _templatesJs.ARGS_V);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gnwVs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "neg", ()=>neg
);
var _mulnJs = require("./muln.js");
const neg = (out, v)=>_mulnJs.mulN(out, v, -1)
;

},{"./muln.js":"1TKlE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8RAVI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "normalCCW", ()=>normalCCW
);
parcelHelpers.export(exports, "normalCW", ()=>normalCW
);
var _directionJs = require("./direction.js");
var _perpendicularJs = require("./perpendicular.js");
const normalCCW = (out, a, b, n = 1)=>_perpendicularJs.perpendicularCCW(null, _directionJs.direction(out || [], a, b, n))
;
const normalCW = (out, a, b, n = 1)=>_perpendicularJs.perpendicularCW(null, _directionJs.direction(out || [], a, b, n))
;

},{"./direction.js":"g7PP7","./perpendicular.js":"dnMKL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lD3Rj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "normalizeS", ()=>normalizeS
);
parcelHelpers.export(exports, "normalizeS2", ()=>normalizeS2
);
parcelHelpers.export(exports, "normalizeS3", ()=>normalizeS3
);
parcelHelpers.export(exports, "normalizeS4", ()=>normalizeS4
);
var _api = require("@thi.ng/math/api");
var _magsJs = require("./mags.js");
var _mulnsJs = require("./mulns.js");
var _setsJs = require("./sets.js");
const normalizeS = (out, v, num, n = 1, io = 0, ia = 0, so = 1, sa = 1)=>{
    !out && (out = v);
    const m = _magsJs.magS(v, num, ia, sa);
    return m >= _api.EPS ? _mulnsJs.mulNS(out, v, n / m, num, io, ia, so, sa) : out !== v ? _setsJs.setS(out, v, num, io, ia, so, sa) : out;
};
const normalizeS2 = (out, v, n = 1, io = 0, ia = 0, so = 1, sa = 1)=>{
    !out && (out = v);
    const m = _magsJs.magS2(v, ia, sa);
    return m >= _api.EPS ? _mulnsJs.mulNS2(out, v, n / m, io, ia, so, sa) : out !== v ? _setsJs.setS2(out, v, io, ia, so, sa) : out;
};
const normalizeS3 = (out, v, n = 1, io = 0, ia = 0, so = 1, sa = 1)=>{
    !out && (out = v);
    const m = _magsJs.magS3(v, ia, sa);
    return m >= _api.EPS ? _mulnsJs.mulNS3(out, v, n / m, io, ia, so, sa) : out !== v ? _setsJs.setS3(out, v, io, ia, so, sa) : out;
};
const normalizeS4 = (out, v, n = 1, io = 0, ia = 0, so = 1, sa = 1)=>{
    !out && (out = v);
    const m = _magsJs.magS4(v, ia, sa);
    return m >= _api.EPS ? _mulnsJs.mulNS4(out, v, n / m, io, ia, so, sa) : out !== v ? _setsJs.setS4(out, v, io, ia, so, sa) : out;
};

},{"@thi.ng/math/api":"4a98p","./mags.js":"h4CFH","./mulns.js":"b3IkY","./sets.js":"3jBTJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"u5ZXS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "not", ()=>not
);
parcelHelpers.export(exports, "not2", ()=>not2
);
parcelHelpers.export(exports, "not3", ()=>not3
);
parcelHelpers.export(exports, "not4", ()=>not4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [not, not2, not3, not4] = _emitJs.defOp(([o, a])=>`${o}=!${a};`
, _templatesJs.ARGS_V, _templatesJs.ARGS_V, "o", 1, _templatesJs.NEW_OUT);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h0jz9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "orthoNormal3", ()=>orthoNormal3
);
var _crossJs = require("./cross.js");
var _normalizeJs = require("./normalize.js");
var _subJs = require("./sub.js");
const orthoNormal3 = (out, a, b, c, doNormalize = true)=>{
    out = _crossJs.cross3(null, _subJs.sub3(out || a, b, a), _subJs.sub3([], c, a));
    return doNormalize ? _normalizeJs.normalize(out, out) : out;
};

},{"./cross.js":"a6Q1x","./normalize.js":"9ex3j","./sub.js":"fzaw7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lDaDN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pointOnRay", ()=>pointOnRay
);
parcelHelpers.export(exports, "pointOnRay2", ()=>pointOnRay2
);
parcelHelpers.export(exports, "pointOnRay3", ()=>pointOnRay3
);
var _maddnJs = require("./maddn.js");
const pointOnRay = (out, rayOrigin, rayDir, dist)=>_maddnJs.maddN(out, rayDir, dist, rayOrigin)
;
const pointOnRay2 = (out, rayOrigin, rayDir, dist)=>_maddnJs.maddN2(out, rayDir, dist, rayOrigin)
;
const pointOnRay3 = (out, rayOrigin, rayDir, dist)=>_maddnJs.maddN3(out, rayDir, dist, rayOrigin)
;

},{"./maddn.js":"bTkou","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hjxag":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "polar", ()=>polar
);
parcelHelpers.export(exports, "polar2", ()=>polar2
);
parcelHelpers.export(exports, "polar3", ()=>polar3
);
var _vopJs = require("./vop.js");
var _magJs = require("./mag.js");
var _setcJs = require("./setc.js");
const sqrt = Math.sqrt;
const asin = Math.asin;
const atan2 = Math.atan2;
const polar = _vopJs.vop(1);
const polar2 = polar.add(2, (out, a)=>_setcJs.setC2(out || a, _magJs.mag(a), atan2(a[1], a[0]))
);
const polar3 = polar.add(3, (out, a)=>{
    const x = a[0];
    const y = a[1];
    const z = a[2];
    const r = sqrt(x * x + y * y + z * z);
    return _setcJs.setC3(out || a, r, asin(z / r), atan2(y, x));
});

},{"./vop.js":"4v2k5","./mag.js":"70TCJ","./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ek3Z1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pow", ()=>pow
);
parcelHelpers.export(exports, "pow2", ()=>pow2
);
parcelHelpers.export(exports, "pow3", ()=>pow3
);
parcelHelpers.export(exports, "pow4", ()=>pow4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [pow, pow2, pow3, pow4] = _emitJs.defOp(_templatesJs.FN2("Math.pow"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e4E3E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "powN", ()=>powN
);
parcelHelpers.export(exports, "powN2", ()=>powN2
);
parcelHelpers.export(exports, "powN3", ()=>powN3
);
parcelHelpers.export(exports, "powN4", ()=>powN4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [powN, powN2, powN3, powN4] = _emitJs.defOp(_templatesJs.FN_N("Math.pow"), _templatesJs.ARGS_VN);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Ztzw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "project", ()=>project
);
var _dotJs = require("./dot.js");
var _magsqJs = require("./magsq.js");
var _mulnJs = require("./muln.js");
const project = (out, v, dir)=>_mulnJs.mulN(out || v, dir, _dotJs.dot(v, dir) / _magsqJs.magSq(dir))
;

},{"./dot.js":"9vV5N","./magsq.js":"bsMC4","./muln.js":"1TKlE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jp9qg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "randomS", ()=>randomS
);
parcelHelpers.export(exports, "randomS2", ()=>randomS2
);
parcelHelpers.export(exports, "randomS3", ()=>randomS3
);
parcelHelpers.export(exports, "randomS4", ()=>randomS4
);
parcelHelpers.export(exports, "randomDistribS", ()=>randomDistribS
);
parcelHelpers.export(exports, "randomDistribS2", ()=>randomDistribS2
);
parcelHelpers.export(exports, "randomDistribS3", ()=>randomDistribS3
);
parcelHelpers.export(exports, "randomDistribS4", ()=>randomDistribS4
);
parcelHelpers.export(exports, "randNormS", ()=>randNormS
);
parcelHelpers.export(exports, "randNormS2", ()=>randNormS2
);
parcelHelpers.export(exports, "randNormS3", ()=>randNormS3
);
parcelHelpers.export(exports, "randNormS4", ()=>randNormS4
);
parcelHelpers.export(exports, "randNormDistribS", ()=>randNormDistribS
);
parcelHelpers.export(exports, "randNormDistribS2", ()=>randNormDistribS2
);
parcelHelpers.export(exports, "randNormDistribS3", ()=>randNormDistribS3
);
parcelHelpers.export(exports, "randNormDistribS4", ()=>randNormDistribS4
);
parcelHelpers.export(exports, "randMinMaxS", ()=>randMinMaxS
);
parcelHelpers.export(exports, "randMinMaxS2", ()=>randMinMaxS2
);
parcelHelpers.export(exports, "randMinMaxS3", ()=>randMinMaxS3
);
parcelHelpers.export(exports, "randMinMaxS4", ()=>randMinMaxS4
);
var _normal = require("@thi.ng/random/distributions/normal");
var _system = require("@thi.ng/random/system");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
var _normalizesJs = require("./normalizes.js");
const [randomS, randomS2, randomS3, randomS4] = _emitJs.defHofOpS(_system.SYSTEM, ([a])=>`${a}=rnd.minmax(n,m);`
, "a", "n=-1,m=1,rnd=op,ia=0,sa=1", "a", "a", _templatesJs.NEW_OUT_A);
const [randomDistribS, randomDistribS2, randomDistribS3, randomDistribS4, ] = _emitJs.defHofOpS(_normal.normal, ([a])=>`${a}=rnd()*n;`
, "a", "rnd=op(),n=1,ia=0,sa=1", "a", "a", _templatesJs.NEW_OUT_A);
const $norm = (normalize, random)=>(a, n = 1, rnd, ia = 0, sa = 1)=>normalize(null, random(a, -1, 1, rnd, ia, sa), n, ia, ia, sa, sa)
;
const $normDist = (normalize, random)=>(a, rnd, n = 1, ia = 0, sa = 1)=>normalize(null, random(a, rnd, 1, ia, sa), n, ia, ia, sa, sa)
;
const randNormS = (a, num, n = 1, rnd, ia = 0, sa = 1)=>_normalizesJs.normalizeS(a = randomS(a, num, -1, 1, rnd, ia, sa), a, num, n, ia, ia, sa, sa)
;
const randNormS2 = $norm(_normalizesJs.normalizeS2, randomS2);
const randNormS3 = $norm(_normalizesJs.normalizeS3, randomS3);
const randNormS4 = $norm(_normalizesJs.normalizeS4, randomS4);
const randNormDistribS = (a, num, rnd, n = 1, ia = 0, sa = 1)=>_normalizesJs.normalizeS(null, randomDistribS(a, num, rnd, 1, ia, sa), num, n, ia, ia, sa, sa)
;
const randNormDistribS2 = $normDist(_normalizesJs.normalizeS2, randomDistribS2);
const randNormDistribS3 = $normDist(_normalizesJs.normalizeS3, randomDistribS3);
const randNormDistribS4 = $normDist(_normalizesJs.normalizeS4, randomDistribS4);
const [randMinMaxS, randMinMaxS2, randMinMaxS3, randMinMaxS4] = _emitJs.defHofOpS(_system.SYSTEM, ([o, a, b])=>`${o}=rnd.minmax(${a},${b});`
, "o,a,b", `rnd=op,${_templatesJs.SARGS_VV}`, "o,a,b");

},{"@thi.ng/random/distributions/normal":"eJF5A","@thi.ng/random/system":"bSLzr","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","./normalizes.js":"lD3Rj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d5xc2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "reflect", ()=>reflect
);
var _dotJs = require("./dot.js");
var _maddnJs = require("./maddn.js");
const reflect = (out, a, b)=>_maddnJs.maddN(out || a, b, -2 * _dotJs.dot(a, b), a)
;

},{"./dot.js":"9vV5N","./maddn.js":"bTkou","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1FHgE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "refract", ()=>refract
);
var _dotJs = require("./dot.js");
var _maddnJs = require("./maddn.js");
var _mulnJs = require("./muln.js");
var _setnJs = require("./setn.js");
const refract = (out, a, n, eta)=>{
    !out && (out = a);
    const d = _dotJs.dot(a, n);
    const k = 1 - eta * eta * (1 - d * d);
    return k < 0 ? _setnJs.zero(out) : _maddnJs.maddN(out, n, -(eta * d + Math.sqrt(k)), _mulnJs.mulN(out, a, eta));
};

},{"./dot.js":"9vV5N","./maddn.js":"bTkou","./muln.js":"1TKlE","./setn.js":"2M6y1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8QlLp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "remainder", ()=>remainder
);
parcelHelpers.export(exports, "remainder2", ()=>remainder2
);
parcelHelpers.export(exports, "remainder3", ()=>remainder3
);
parcelHelpers.export(exports, "remainder4", ()=>remainder4
);
var _libc = require("@thi.ng/math/libc");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [remainder, remainder2, remainder3, remainder4] = _emitJs.defHofOp(_libc.remainder, _templatesJs.FN2("op"), _templatesJs.ARGS_VV);

},{"@thi.ng/math/libc":"6VBft","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6VBft":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "copysign", ()=>copysign
);
parcelHelpers.export(exports, "exp2", ()=>exp2
);
parcelHelpers.export(exports, "fdim", ()=>fdim
);
parcelHelpers.export(exports, "fma", ()=>fma
);
parcelHelpers.export(exports, "fmod", ()=>fmod
);
parcelHelpers.export(exports, "frexp", ()=>frexp
);
parcelHelpers.export(exports, "ldexp", ()=>ldexp
);
parcelHelpers.export(exports, "remainder", ()=>remainder
);
parcelHelpers.export(exports, "ldiv", ()=>ldiv
);
const copysign = (x, y)=>Math.sign(y) * Math.abs(x)
;
const exp2 = (x)=>2 ** x
;
const fdim = (x, y)=>Math.max(x - y, 0)
;
const fma = (x, y, z)=>x * y + z
;
const fmod = (x, y)=>x % y
;
const frexp = (x)=>{
    if (x === 0 || !isFinite(x)) return [
        x,
        0
    ];
    const abs = Math.abs(x);
    let exp = Math.max(-1023, Math.floor(Math.log2(abs)) + 1);
    let y = abs * 2 ** -exp;
    while(y < 0.5){
        y *= 2;
        exp--;
    }
    while(y >= 1){
        y *= 0.5;
        exp++;
    }
    return [
        x < 0 ? -y : y,
        exp
    ];
};
const ldexp = (x, exp)=>x * 2 ** exp
;
const remainder = (x, y)=>x - y * Math.round(x / y)
;
const ldiv = (x, y)=>{
    x |= 0;
    y |= 0;
    const q = x / y | 0;
    return [
        q,
        x - q * y
    ];
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6YhVp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "remainderN", ()=>remainderN
);
parcelHelpers.export(exports, "remainderN2", ()=>remainderN2
);
parcelHelpers.export(exports, "remainderN3", ()=>remainderN3
);
parcelHelpers.export(exports, "remainderN4", ()=>remainderN4
);
var _libc = require("@thi.ng/math/libc");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [remainderN, remainderN2, remainderN3, remainderN4] = _emitJs.defHofOp(_libc.remainder, _templatesJs.FN_N("op"), _templatesJs.ARGS_VN, _templatesJs.ARGS_V);

},{"@thi.ng/math/libc":"6VBft","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bnMmK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rotateAroundAxis3", ()=>rotateAroundAxis3
);
var _setcJs = require("./setc.js");
const rotateAroundAxis3 = (out, v, axis, theta)=>{
    const x = v[0];
    const y = v[1];
    const z = v[2];
    const ax = axis[0];
    const ay = axis[1];
    const az = axis[2];
    const ux = ax * x;
    const uy = ax * y;
    const uz = ax * z;
    const vx = ay * x;
    const vy = ay * y;
    const vz = ay * z;
    const wx = az * x;
    const wy = az * y;
    const wz = az * z;
    const uvw = ux + vy + wz;
    const s = Math.sin(theta);
    const c = Math.cos(theta);
    return _setcJs.setC3(out || v, ax * uvw + (x * (ay * ay + az * az) - ax * (vy + wz)) * c + (-wy + vz) * s, ay * uvw + (y * (ax * ax + az * az) - ay * (ux + wz)) * c + (wx - uz) * s, az * uvw + (z * (ax * ax + ay * ay) - az * (ux + vy)) * c + (-vx + uy) * s);
};

},{"./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fTth1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rotateAroundPoint2", ()=>rotateAroundPoint2
);
var _setcJs = require("./setc.js");
const rotateAroundPoint2 = (out, v, p, theta)=>{
    const x = v[0] - p[0];
    const y = v[1] - p[1];
    const s = Math.sin(theta);
    const c = Math.cos(theta);
    return _setcJs.setC2(out || v, x * c - y * s + p[0], x * s + y * c + p[1]);
};

},{"./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"756IA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
parcelHelpers.export(exports, "rotate", ()=>rotate
);
var _setJs = require("./set.js");
const _rotate = (u, v)=>(out, a, theta)=>{
        out ? out !== a && _setJs.set(out, a) : out = a;
        const s = Math.sin(theta);
        const c = Math.cos(theta);
        const x = a[u];
        const y = a[v];
        out[u] = x * c - y * s;
        out[v] = x * s + y * c;
        return out;
    }
;
const rotateX = _rotate(1, 2);
const rotateY = _rotate(2, 0);
const rotateZ = _rotate(0, 1);
const rotate = rotateZ;

},{"./set.js":"bSUB8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f8Qd6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rotateS2", ()=>rotateS2
);
parcelHelpers.export(exports, "rotateXS3", ()=>rotateXS3
);
parcelHelpers.export(exports, "rotateYS3", ()=>rotateYS3
);
parcelHelpers.export(exports, "rotateZS3", ()=>rotateZS3
);
var _setsJs = require("./sets.js");
const _rotate = (set, u, v)=>(out, a, theta, io = 0, ia = 0, so = 1, sa = 1)=>{
        out ? out !== a && set(out, a, io, ia, so, sa) : out = a;
        const s = Math.sin(theta);
        const c = Math.cos(theta);
        const x = a[ia + u * sa];
        const y = a[ia + v * sa];
        out[io + u * so] = x * c - y * s;
        out[io + v * so] = x * s + y * c;
        return out;
    }
;
const rotateS2 = _rotate(_setsJs.setS2, 0, 1);
const rotateXS3 = _rotate(_setsJs.setS3, 1, 2);
const rotateYS3 = _rotate(_setsJs.setS3, 2, 0);
const rotateZS3 = _rotate(_setsJs.setS3, 0, 1);

},{"./sets.js":"3jBTJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k0lRR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "round", ()=>round
);
parcelHelpers.export(exports, "round2", ()=>round2
);
parcelHelpers.export(exports, "round3", ()=>round3
);
parcelHelpers.export(exports, "round4", ()=>round4
);
parcelHelpers.export(exports, "roundN", ()=>roundN
);
parcelHelpers.export(exports, "roundN2", ()=>roundN2
);
parcelHelpers.export(exports, "roundN3", ()=>roundN3
);
parcelHelpers.export(exports, "roundN4", ()=>roundN4
);
var _prec = require("@thi.ng/math/prec");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [round, round2, round3, round4] = _emitJs.defHofOp(_prec.roundTo, _templatesJs.FN2("op"), _templatesJs.ARGS_VV);
const [roundN, roundN2, roundN3, roundN4] = _emitJs.defHofOp(_prec.roundTo, _templatesJs.FN_N("op"), "o,a,n=1", "o,a");

},{"@thi.ng/math/prec":"7e7rg","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5ezs6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rshiftI", ()=>rshiftI
);
parcelHelpers.export(exports, "rshiftI2", ()=>rshiftI2
);
parcelHelpers.export(exports, "rshiftI3", ()=>rshiftI3
);
parcelHelpers.export(exports, "rshiftI4", ()=>rshiftI4
);
parcelHelpers.export(exports, "rshiftU", ()=>rshiftU
);
parcelHelpers.export(exports, "rshiftU2", ()=>rshiftU2
);
parcelHelpers.export(exports, "rshiftU3", ()=>rshiftU3
);
parcelHelpers.export(exports, "rshiftU4", ()=>rshiftU4
);
parcelHelpers.export(exports, "rshiftNI", ()=>rshiftNI
);
parcelHelpers.export(exports, "rshiftNI2", ()=>rshiftNI2
);
parcelHelpers.export(exports, "rshiftNI3", ()=>rshiftNI3
);
parcelHelpers.export(exports, "rshiftNI4", ()=>rshiftNI4
);
parcelHelpers.export(exports, "rshiftNU", ()=>rshiftNU
);
parcelHelpers.export(exports, "rshiftNU2", ()=>rshiftNU2
);
parcelHelpers.export(exports, "rshiftNU3", ()=>rshiftNU3
);
parcelHelpers.export(exports, "rshiftNU4", ()=>rshiftNU4
);
var _emitJs = require("./compile/emit.js");
const [rshiftI, rshiftI2, rshiftI3, rshiftI4] = _emitJs.defBitOp(">>", true);
const [rshiftU, rshiftU2, rshiftU3, rshiftU4] = _emitJs.defBitOp(">>>");
const [rshiftNI, rshiftNI2, rshiftNI3, rshiftNI4] = _emitJs.defBitOpN(">>", true);
const [rshiftNU, rshiftNU2, rshiftNU3, rshiftNU4] = _emitJs.defBitOpN(">>>");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iquHD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "safeDiv", ()=>safeDiv
);
parcelHelpers.export(exports, "safeDiv2", ()=>safeDiv2
);
parcelHelpers.export(exports, "safeDiv3", ()=>safeDiv3
);
parcelHelpers.export(exports, "safeDiv4", ()=>safeDiv4
);
var _safeDiv = require("@thi.ng/math/safe-div");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [safeDiv, safeDiv2, safeDiv3, safeDiv4] = _emitJs.defHofOp(_safeDiv.safeDiv, _templatesJs.FN2("op"), _templatesJs.ARGS_VV);

},{"@thi.ng/math/safe-div":"5Hm6P","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Hm6P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "safeDiv", ()=>safeDiv
);
const safeDiv = (a, b)=>b !== 0 ? a / b : 0
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e9RWo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "select", ()=>select
);
const select = (out, a, b, mask)=>{
    out = out || a;
    for(let i = a.length; i-- > 0;)out[i] = mask[i] ? b[i] : a[i];
    return out;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fEREX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setNS", ()=>setNS
);
parcelHelpers.export(exports, "setNS2", ()=>setNS2
);
parcelHelpers.export(exports, "setNS3", ()=>setNS3
);
parcelHelpers.export(exports, "setNS4", ()=>setNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [setNS, setNS2, setNS3, setNS4] = _emitJs.defOpS(_templatesJs.SET_N, "o,n", "io=0,so=1", "o", "o", "");

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Xxwm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setVN3", ()=>setVN3
);
parcelHelpers.export(exports, "setVN4", ()=>setVN4
);
var _setcJs = require("./setc.js");
const setVN3 = (out, a, n)=>_setcJs.setC3(out, a[0], a[1], n)
;
const setVN4 = (out, a, n)=>_setcJs.setC4(out, a[0], a[1], a[2], n)
;

},{"./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bgsN2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setVV4", ()=>setVV4
);
parcelHelpers.export(exports, "setVV6", ()=>setVV6
);
parcelHelpers.export(exports, "setVV9", ()=>setVV9
);
parcelHelpers.export(exports, "setVV16", ()=>setVV16
);
var _setcJs = require("./setc.js");
const setVV4 = (out, a, b)=>_setcJs.setC4(out, a[0], a[1], b[0], b[1])
;
const setVV6 = (out, a, b, c)=>_setcJs.setC6(out, a[0], a[1], b[0], b[1], c[0], c[1])
;
const setVV9 = (out, a, b, c)=>_setcJs.setC(out, a[0], a[1], a[2], b[0], b[1], b[2], c[0], c[1], c[2])
;
const setVV16 = (out, a, b, c, d)=>_setcJs.setC(out, a[0], a[1], a[2], a[3], b[0], b[1], b[2], b[3], c[0], c[1], c[2], c[3], d[0], d[1], d[2], d[3])
;

},{"./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"deOCU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sign", ()=>sign
);
parcelHelpers.export(exports, "sign2", ()=>sign2
);
parcelHelpers.export(exports, "sign3", ()=>sign3
);
parcelHelpers.export(exports, "sign4", ()=>sign4
);
var _emitJs = require("./compile/emit.js");
const [sign, sign2, sign3, sign4] = _emitJs.defFnOp("Math.sign");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kWxbb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "signedVolume", ()=>signedVolume
);
const signedVolume = (a, b, c, [dx, dy, dz])=>{
    const ady = a[1] - dy;
    const bdy = b[1] - dy;
    const cdy = c[1] - dy;
    const adz = a[2] - dz;
    const bdz = b[2] - dz;
    const cdz = c[2] - dz;
    return (a[0] - dx) * (bdy * cdz - bdz * cdy) + (b[0] - dx) * (cdy * adz - cdz * ady) + (c[0] - dx) * (ady * bdz - adz * bdy);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eQFJ3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sin", ()=>sin
);
parcelHelpers.export(exports, "sin2", ()=>sin2
);
parcelHelpers.export(exports, "sin3", ()=>sin3
);
parcelHelpers.export(exports, "sin4", ()=>sin4
);
var _emitJs = require("./compile/emit.js");
const [sin, sin2, sin3, sin4] = _emitJs.defFnOp("Math.sin");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4FADI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sinh", ()=>sinh
);
parcelHelpers.export(exports, "sinh2", ()=>sinh2
);
parcelHelpers.export(exports, "sinh3", ()=>sinh3
);
parcelHelpers.export(exports, "sinh4", ()=>sinh4
);
var _emitJs = require("./compile/emit.js");
const [sinh, sinh2, sinh3, sinh4] = _emitJs.defFnOp("Math.sinh");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"awIye":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "softMax", ()=>softMax
);
var _divnJs = require("./divn.js");
var _expJs = require("./exp.js");
var _sumJs = require("./sum.js");
const softMax = (out, src)=>{
    const e = _expJs.exp([], src);
    return _divnJs.divN(out || src, e, _sumJs.sum(e));
};

},{"./divn.js":"8VZzE","./exp.js":"5Qp2H","./sum.js":"2gBvR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kVDnA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "some", ()=>some
);
parcelHelpers.export(exports, "some2", ()=>some2
);
parcelHelpers.export(exports, "some3", ()=>some3
);
parcelHelpers.export(exports, "some4", ()=>some4
);
var _vopJs = require("./vop.js");
const some = _vopJs.vop();
some.default((v)=>{
    for(let i = v.length; i-- > 0;){
        if (v[i]) return true;
    }
    return false;
});
const some2 = some.add(2, (a)=>a[0] || a[1]
);
const some3 = some.add(3, (a)=>a[0] || a[1] || a[2]
);
const some4 = some.add(4, (a)=>a[0] || a[1] || a[2] || a[3]
);

},{"./vop.js":"4v2k5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"adalI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sqrt", ()=>sqrt
);
parcelHelpers.export(exports, "sqrt2", ()=>sqrt2
);
parcelHelpers.export(exports, "sqrt3", ()=>sqrt3
);
parcelHelpers.export(exports, "sqrt4", ()=>sqrt4
);
var _emitJs = require("./compile/emit.js");
const [sqrt, sqrt2, sqrt3, sqrt4] = _emitJs.defFnOp("Math.sqrt");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1iWKd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "step", ()=>step
);
parcelHelpers.export(exports, "step2", ()=>step2
);
parcelHelpers.export(exports, "step3", ()=>step3
);
parcelHelpers.export(exports, "step4", ()=>step4
);
var _step = require("@thi.ng/math/step");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [step, step2, step3, step4] = _emitJs.defHofOp(_step.step, _templatesJs.FN2("op"), "o,e,a", undefined, "o", 2, _templatesJs.DEFAULT_OUT);

},{"@thi.ng/math/step":"kmNpH","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kmNpH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "step", ()=>step
);
parcelHelpers.export(exports, "smoothStep", ()=>smoothStep
);
parcelHelpers.export(exports, "smootherStep", ()=>smootherStep
);
parcelHelpers.export(exports, "expStep", ()=>expStep
);
var _intervalJs = require("./interval.js");
const step = (edge, x)=>x < edge ? 0 : 1
;
const smoothStep = (edge, edge2, x)=>{
    x = _intervalJs.clamp01((x - edge) / (edge2 - edge));
    return (3 - 2 * x) * x * x;
};
const smootherStep = (edge, edge2, x)=>{
    x = _intervalJs.clamp01((x - edge) / (edge2 - edge));
    return x * x * x * (x * (x * 6 - 15) + 10);
};
const expStep = (k, n, x)=>1 - Math.exp(-k * Math.pow(x, n))
;

},{"./interval.js":"1TDWA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"95Lq7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "smoothStep", ()=>smoothStep
);
parcelHelpers.export(exports, "smoothStep2", ()=>smoothStep2
);
parcelHelpers.export(exports, "smoothStep3", ()=>smoothStep3
);
parcelHelpers.export(exports, "smoothStep4", ()=>smoothStep4
);
var _step = require("@thi.ng/math/step");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [smoothStep, smoothStep2, smoothStep3, smoothStep4] = _emitJs.defHofOp(_step.smoothStep, _templatesJs.FN3(), "o,e1,e2,a", undefined, "o", 3, _templatesJs.DEFAULT_OUT);

},{"@thi.ng/math/step":"kmNpH","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dbQSi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "standardize", ()=>standardize
);
var _centerJs = require("./center.js");
var _mulnJs = require("./muln.js");
var _setJs = require("./set.js");
var _varianceJs = require("./variance.js");
const standardize = (out, a, isCentered = false)=>{
    out = !isCentered ? _centerJs.center(out, a) : !out ? a : _setJs.set(out, a);
    const d = _varianceJs.sd(out, true);
    return d > 0 ? _mulnJs.mulN(null, out, 1 / d) : out;
};

},{"./center.js":"2MkSv","./muln.js":"1TKlE","./set.js":"bSUB8","./variance.js":"5Fsvh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Fsvh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "variance", ()=>variance
);
parcelHelpers.export(exports, "sd", ()=>sd
);
parcelHelpers.export(exports, "sdError", ()=>sdError
);
var _centerJs = require("./center.js");
var _magsqJs = require("./magsq.js");
const variance = (a, isCentered = false)=>a.length > 0 ? _magsqJs.magSq(isCentered ? a : _centerJs.center([], a)) / a.length : 0
;
const sd = (a, isCentered = false)=>a.length > 1 ? Math.sqrt(_magsqJs.magSq(isCentered ? a : _centerJs.center([], a)) / (a.length - 1)) : 0
;
const sdError = (a, isCentered = false)=>a.length > 1 ? sd(a, isCentered) / Math.sqrt(a.length) : 0
;

},{"./center.js":"2MkSv","./magsq.js":"bsMC4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"csHlx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subI", ()=>subI
);
parcelHelpers.export(exports, "subI2", ()=>subI2
);
parcelHelpers.export(exports, "subI3", ()=>subI3
);
parcelHelpers.export(exports, "subI4", ()=>subI4
);
parcelHelpers.export(exports, "subU", ()=>subU
);
parcelHelpers.export(exports, "subU2", ()=>subU2
);
parcelHelpers.export(exports, "subU3", ()=>subU3
);
parcelHelpers.export(exports, "subU4", ()=>subU4
);
parcelHelpers.export(exports, "subNI", ()=>subNI
);
parcelHelpers.export(exports, "subNI2", ()=>subNI2
);
parcelHelpers.export(exports, "subNI3", ()=>subNI3
);
parcelHelpers.export(exports, "subNI4", ()=>subNI4
);
parcelHelpers.export(exports, "subNU", ()=>subNU
);
parcelHelpers.export(exports, "subNU2", ()=>subNU2
);
parcelHelpers.export(exports, "subNU3", ()=>subNU3
);
parcelHelpers.export(exports, "subNU4", ()=>subNU4
);
var _emitJs = require("./compile/emit.js");
const [subI, subI2, subI3, subI4] = _emitJs.defBitOp("-", true);
const [subU, subU2, subU3, subU4] = _emitJs.defBitOp("-");
const [subNI, subNI2, subNI3, subNI4] = _emitJs.defBitOpN("-", true);
const [subNU, subNU2, subNU3, subNU4] = _emitJs.defBitOpN("-");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"92Lej":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subm", ()=>subm
);
parcelHelpers.export(exports, "subm2", ()=>subm2
);
parcelHelpers.export(exports, "subm3", ()=>subm3
);
parcelHelpers.export(exports, "subm4", ()=>subm4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [subm, subm2, subm3, subm4] = _emitJs.defOp(_templatesJs.MATH2("-", "*"), _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1EUBR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "submS", ()=>submS
);
parcelHelpers.export(exports, "submS2", ()=>submS2
);
parcelHelpers.export(exports, "submS3", ()=>submS3
);
parcelHelpers.export(exports, "submS4", ()=>submS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [submS, submS2, submS3, submS4] = _emitJs.defOpS(_templatesJs.MATH2("-", "*"), _templatesJs.ARGS_VVV, _templatesJs.SARGS_VVV, _templatesJs.ARGS_VVV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"co6Wj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "submNS", ()=>submNS
);
parcelHelpers.export(exports, "submNS2", ()=>submNS2
);
parcelHelpers.export(exports, "submNS3", ()=>submNS3
);
parcelHelpers.export(exports, "submNS4", ()=>submNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [submNS, submNS2, submNS3, submNS4] = _emitJs.defOpS(_templatesJs.MATH2_N("-", "*"), _templatesJs.ARGS_VVN, _templatesJs.SARGS_VV);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h2qQr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subS", ()=>subS
);
parcelHelpers.export(exports, "subS2", ()=>subS2
);
parcelHelpers.export(exports, "subS3", ()=>subS3
);
parcelHelpers.export(exports, "subS4", ()=>subS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [subS, subS2, subS3, subS4] = _emitJs.defOpS(_templatesJs.MATH("-"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hfisH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subNS", ()=>subNS
);
parcelHelpers.export(exports, "subNS2", ()=>subNS2
);
parcelHelpers.export(exports, "subNS3", ()=>subNS3
);
parcelHelpers.export(exports, "subNS4", ()=>subNS4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [subNS, subNS2, subNS3, subNS4] = _emitJs.defOpS(_templatesJs.MATH_N("-"), _templatesJs.ARGS_VN, _templatesJs.SARGS_V, _templatesJs.ARGS_V);

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8JoUk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "swizzle2", ()=>swizzle2
);
parcelHelpers.export(exports, "swizzle3", ()=>swizzle3
);
parcelHelpers.export(exports, "swizzle4", ()=>swizzle4
);
parcelHelpers.export(exports, "swapXY", ()=>swapXY
);
parcelHelpers.export(exports, "swapXZ", ()=>swapXZ
);
parcelHelpers.export(exports, "swapYZ", ()=>swapYZ
);
parcelHelpers.export(exports, "setSwizzle1", ()=>setSwizzle1
);
parcelHelpers.export(exports, "setSwizzle2", ()=>setSwizzle2
);
parcelHelpers.export(exports, "setSwizzle3", ()=>setSwizzle3
);
parcelHelpers.export(exports, "setSwizzle4", ()=>setSwizzle4
);
var _setcJs = require("./setc.js");
const swizzle2 = (out, a, x, y)=>_setcJs.setC2(out || a, a[x] || 0, a[y] || 0)
;
const swizzle3 = (out, a, x, y, z)=>_setcJs.setC3(out || a, a[x] || 0, a[y] || 0, a[z] || 0)
;
const swizzle4 = (out, a, x, y, z, w)=>_setcJs.setC4(out || a, a[x] || 0, a[y] || 0, a[z] || 0, a[w] || 0)
;
const swapXY = (out, v)=>swizzle3(out, v, 1, 0, 2)
;
const swapXZ = (out, v)=>swizzle3(out, v, 2, 1, 0)
;
const swapYZ = (out, v)=>swizzle3(out, v, 0, 2, 1)
;
const setSwizzle1 = (out, n, a)=>(out[a] = n, out)
;
const setSwizzle2 = (out, v, a, b)=>(out[a] = v[0], out[b] = v[1], out)
;
const setSwizzle3 = (out, v, a, b, c)=>(out[a] = v[0], out[b] = v[1], out[c] = v[2], out)
;
const setSwizzle4 = (out, v, a, b, c, d)=>(out[a] = v[0], out[b] = v[1], out[c] = v[2], out[d] = v[3], out)
;

},{"./setc.js":"jST0o","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9mqB8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tan", ()=>tan
);
parcelHelpers.export(exports, "tan2", ()=>tan2
);
parcelHelpers.export(exports, "tan3", ()=>tan3
);
parcelHelpers.export(exports, "tan4", ()=>tan4
);
var _emitJs = require("./compile/emit.js");
const [tan, tan2, tan3, tan4] = _emitJs.defFnOp("Math.tan");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cIJ1g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tanh", ()=>tanh
);
parcelHelpers.export(exports, "tanh2", ()=>tanh2
);
parcelHelpers.export(exports, "tanh3", ()=>tanh3
);
parcelHelpers.export(exports, "tanh4", ()=>tanh4
);
var _emitJs = require("./compile/emit.js");
const [tanh, tanh2, tanh3, tanh4] = _emitJs.defFnOp("Math.tanh");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"coH0v":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tensor", ()=>tensor
);
const tensor = (out, a, b)=>{
    out = out || [];
    const n = a.length;
    const m = b.length;
    for(let i = 0, k = 0; i < m; i++){
        const bb = b[i];
        for(let j = 0; j < n; j++)out[k++] = a[j] * bb;
    }
    return out;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1UHBI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "trunc", ()=>trunc
);
parcelHelpers.export(exports, "trunc2", ()=>trunc2
);
parcelHelpers.export(exports, "trunc3", ()=>trunc3
);
parcelHelpers.export(exports, "trunc4", ()=>trunc4
);
var _emitJs = require("./compile/emit.js");
const [trunc, trunc2, trunc3, trunc4] = _emitJs.defFnOp("Math.trunc");

},{"./compile/emit.js":"hpIek","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7bcGS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "wrap", ()=>wrap
);
parcelHelpers.export(exports, "wrap2", ()=>wrap2
);
parcelHelpers.export(exports, "wrap3", ()=>wrap3
);
parcelHelpers.export(exports, "wrap4", ()=>wrap4
);
var _interval = require("@thi.ng/math/interval");
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [wrap, wrap2, wrap3, wrap4] = _emitJs.defHofOp(_interval.wrap, _templatesJs.FN3(), _templatesJs.ARGS_VVV);

},{"@thi.ng/math/interval":"1TDWA","./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"XkoMe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eq", ()=>eq
);
parcelHelpers.export(exports, "eq2", ()=>eq2
);
parcelHelpers.export(exports, "eq3", ()=>eq3
);
parcelHelpers.export(exports, "eq4", ()=>eq4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [eq, eq2, eq3, eq4] = _emitJs.defOp(_templatesJs.MATH("==="));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1PSgL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "neq", ()=>neq
);
parcelHelpers.export(exports, "neq2", ()=>neq2
);
parcelHelpers.export(exports, "neq3", ()=>neq3
);
parcelHelpers.export(exports, "neq4", ()=>neq4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [neq, neq2, neq3, neq4] = _emitJs.defOp(_templatesJs.MATH("!=="));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c6eU8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "gt", ()=>gt
);
parcelHelpers.export(exports, "gt2", ()=>gt2
);
parcelHelpers.export(exports, "gt3", ()=>gt3
);
parcelHelpers.export(exports, "gt4", ()=>gt4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [gt, gt2, gt3, gt4] = _emitJs.defOp(_templatesJs.MATH(">"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h9jv8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "gte", ()=>gte
);
parcelHelpers.export(exports, "gte2", ()=>gte2
);
parcelHelpers.export(exports, "gte3", ()=>gte3
);
parcelHelpers.export(exports, "gte4", ()=>gte4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [gte, gte2, gte3, gte4] = _emitJs.defOp(_templatesJs.MATH(">="));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8IIjy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lt", ()=>lt
);
parcelHelpers.export(exports, "lt2", ()=>lt2
);
parcelHelpers.export(exports, "lt3", ()=>lt3
);
parcelHelpers.export(exports, "lt4", ()=>lt4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [lt, lt2, lt3, lt4] = _emitJs.defOp(_templatesJs.MATH("<"));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7gcE2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lte", ()=>lte
);
parcelHelpers.export(exports, "lte2", ()=>lte2
);
parcelHelpers.export(exports, "lte3", ()=>lte3
);
parcelHelpers.export(exports, "lte4", ()=>lte4
);
var _emitJs = require("./compile/emit.js");
var _templatesJs = require("./compile/templates.js");
const [lte, lte2, lte3, lte4] = _emitJs.defOp(_templatesJs.MATH("<="));

},{"./compile/emit.js":"hpIek","./compile/templates.js":"1B2Pe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lBUk4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stratifiedGrid", ()=>stratifiedGrid
);
var _system = require("@thi.ng/random/system");
var _mapcat = require("@thi.ng/transducers/mapcat");
var _rangeNd = require("@thi.ng/transducers/range-nd");
var _repeatedly = require("@thi.ng/transducers/repeatedly");
var _add = require("@thi.ng/vectors/add");
var _random = require("@thi.ng/vectors/random");
const stratifiedGrid = (opts)=>{
    const { rnd , samples  } = {
        samples: 1,
        rnd: _system.SYSTEM,
        ...opts
    };
    const tmp = new Array(opts.dim.length);
    return _mapcat.mapcat((p)=>_repeatedly.repeatedly(()=>_add.add([], p, _random.random(tmp, 0, 1, rnd))
        , samples)
    , _rangeNd.rangeNd(opts.dim));
};

},{"@thi.ng/random/system":"bSLzr","@thi.ng/transducers/mapcat":"9sxcu","@thi.ng/transducers/range-nd":"aQxOa","@thi.ng/transducers/repeatedly":"4kJU5","@thi.ng/vectors/add":"6HmvS","@thi.ng/vectors/random":"8bjGw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9sxcu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapcat", ()=>mapcat
);
var _isIterable = require("@thi.ng/checks/is-iterable");
var _catJs = require("./cat.js");
var _compJs = require("./comp.js");
var _iteratorJs = require("./iterator.js");
var _mapJs = require("./map.js");
function mapcat(fn, src) {
    return _isIterable.isIterable(src) ? _iteratorJs.iterator(mapcat(fn), src) : _compJs.comp(_mapJs.map(fn), _catJs.cat());
}

},{"@thi.ng/checks/is-iterable":"bDbbO","./cat.js":"8F4Zk","./comp.js":"7g4yM","./iterator.js":"8km8L","./map.js":"fW6Xn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8F4Zk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cat", ()=>cat
);
var _comprJs = require("./compr.js");
var _reducedJs = require("./reduced.js");
const cat = ()=>(rfn)=>{
        const r = rfn[2];
        return _comprJs.compR(rfn, (acc, x)=>{
            if (x) for (let y of _reducedJs.unreduced(x)){
                acc = r(acc, y);
                if (_reducedJs.isReduced(acc)) break;
            }
            return _reducedJs.isReduced(x) ? _reducedJs.ensureReduced(acc) : acc;
        });
    }
;

},{"./compr.js":"ePFjm","./reduced.js":"cAjrZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aQxOa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rangeNd", ()=>rangeNd
);
var _mapJs = require("./map.js");
var _permutationsJs = require("./permutations.js");
var _rangeJs = require("./range.js");
var _zipJs = require("./zip.js");
const rangeNd = (min, max)=>_permutationsJs.permutations.apply(null, max ? [
        ..._mapJs.map(([a, b])=>_rangeJs.range(a, b)
        , _zipJs.zip(min, max))
    ] : [
        ..._mapJs.map(_rangeJs.range, min)
    ])
;

},{"./map.js":"fW6Xn","./permutations.js":"jj5MK","./range.js":"lUHc9","./zip.js":"ithYS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4kJU5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Iterator yielding return values of given single-arg function `fn` (called
 * with `i`, current iteration count). If `n` is given, only that many values
 * will be produced, else the iterator is infinite.
 *
 * @example
 * ```ts
 * [...repeatedly(() => Math.floor(Math.random() * 10), 5)]
 * // [7, 0, 9, 3, 1]
 *
 * [...repeatedly((i) => i, 5)]
 * // [0, 1, 2, 3, 4]
 * ```
 *
 * @param fn - value producer
 * @param n - num values (default: )
 */ parcelHelpers.export(exports, "repeatedly", ()=>repeatedly
);
function* repeatedly(fn, n = Infinity) {
    for(let i = 0; i < n; i++)yield fn(i);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3WkEt":[function(require,module,exports) {
'use strict';
module.exports = angleNormals;
function hypot(x, y, z) {
    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
}
function weight(s, r, a) {
    return Math.atan2(r, s - a);
}
function mulAdd(dest, s, x, y, z) {
    dest[0] += s * x;
    dest[1] += s * y;
    dest[2] += s * z;
}
function angleNormals(cells, positions) {
    var numVerts = positions.length;
    var numCells = cells.length;
    //Allocate normal array
    var normals = new Array(numVerts);
    for(var i = 0; i < numVerts; ++i)normals[i] = [
        0,
        0,
        0
    ];
    //Scan cells, and
    for(var i = 0; i < numCells; ++i){
        var cell = cells[i];
        var a = positions[cell[0]];
        var b = positions[cell[1]];
        var c = positions[cell[2]];
        var abx = a[0] - b[0];
        var aby = a[1] - b[1];
        var abz = a[2] - b[2];
        var ab = hypot(abx, aby, abz);
        var bcx = b[0] - c[0];
        var bcy = b[1] - c[1];
        var bcz = b[2] - c[2];
        var bc = hypot(bcx, bcy, bcz);
        var cax = c[0] - a[0];
        var cay = c[1] - a[1];
        var caz = c[2] - a[2];
        var ca = hypot(cax, cay, caz);
        if (Math.min(ab, bc, ca) < 0.000001) continue;
        var s = 0.5 * (ab + bc + ca);
        var r = Math.sqrt((s - ab) * (s - bc) * (s - ca) / s);
        var nx = aby * bcz - abz * bcy;
        var ny = abz * bcx - abx * bcz;
        var nz = abx * bcy - aby * bcx;
        var nl = hypot(nx, ny, nz);
        nx /= nl;
        ny /= nl;
        nz /= nl;
        mulAdd(normals[cell[0]], weight(s, r, bc), nx, ny, nz);
        mulAdd(normals[cell[1]], weight(s, r, ca), nx, ny, nz);
        mulAdd(normals[cell[2]], weight(s, r, ab), nx, ny, nz);
    }
    //Normalize all the normals
    for(var i = 0; i < numVerts; ++i){
        var n = normals[i];
        var l = Math.sqrt(Math.pow(n[0], 2) + Math.pow(n[1], 2) + Math.pow(n[2], 2));
        if (l < 0.00000001) {
            n[0] = 1;
            n[1] = 0;
            n[2] = 0;
            continue;
        }
        n[0] /= l;
        n[1] /= l;
        n[2] /= l;
    }
    return normals;
}

},{}],"9J7Dv":[function(require,module,exports) {
// Data Structure
exports.Edge = require("./mda/Core/Edge.js");
exports.HalfEdge = require("./mda/Core/HalfEdge.js");
exports.Vertex = require("./mda/Core/Vertex.js");
exports.Face = require("./mda/Core/Face.js");
exports.Mesh = require("./mda/Core/Mesh.js");
// Checks
exports.Integrity = require("./mda/Integrity/Integrity.js");
exports.MeshIntegrity = require("./mda/Integrity/MeshIntegrity.js");
exports.FaceIntegrity = require("./mda/Integrity/FaceIntegrity.js");
exports.EdgeIntegrity = require("./mda/Integrity/EdgeIntegrity.js");
exports.HalfEdgeIntegrity = require("./mda/Integrity/HalfEdgeIntegrity.js");
exports.VertexIntegrity = require("./mda/Integrity/VertexIntegrity.js");
// Queries
exports.HalfEdgePrev = require("./mda/Queries/HalfEdgePrev.js");
exports.EdgeVertices = require("./mda/Queries/EdgeVertices.js");
exports.FaceHalfEdges = require("./mda/Queries/FaceHalfEdges.js");
exports.FaceVertices = require("./mda/Queries/FaceVertices.js");
exports.VertexFaces = require("./mda/Queries/VertexFaces.js");
exports.VertexHalfEdges = require("./mda/Queries/VertexHalfEdges.js");
exports.VertexNeighbors = require("./mda/Queries/VertexNeighbors.js");
exports.MeshCentroid = require("./mda/Queries/MeshCentroid.js");
// Operators
exports.InsertVertexOperator = require("./mda/Operators/InsertVertex.js");
exports.InsertEdgeOperator = require("./mda/Operators/InsertEdge.js");
exports.DeleteEdgeOperator = require("./mda/Operators/DeleteEdge.js");
exports.LoopOperator = require("./mda/Operators/Loop.js");
exports.CatmullClarkOperator = require("./mda/Operators/CatmullClark.js");
exports.QuadSubdivideOperator = require("./mda/Operators/QuadSubdivide.js");
exports.TriangulateOperator = require("./mda/Operators/Triangulate.js");
exports.ExtrudeOperator = require('./mda/Operators/Extrude.js');
exports.PipeOperator = require('./mda/Operators/Pipe.js');
exports.DuplicateOperator = require('./mda/Operators/Duplicate.js');
exports.CombineOperator = require('./mda/Operators/Combine.js');
exports.ScaleOperator = require('./mda/Operators/Scale.js');
exports.MoveOperator = require('./mda/Operators/Move.js');
exports.InvertOperator = require('./mda/Operators/Invert.js');
exports.WireframeOperator = require('./mda/Operators/Wireframe.js');
exports.CreateFaceOperator = require('./mda/Operators/CreateFace.js');
// Generator
exports.ProfileGenerator = require("./mda/Generators/Profile.js");

},{"./mda/Core/Edge.js":"dOHcN","./mda/Core/HalfEdge.js":"72nec","./mda/Core/Vertex.js":"aMW4R","./mda/Core/Face.js":"fVwz7","./mda/Core/Mesh.js":"lGuYv","./mda/Integrity/Integrity.js":"ePOBu","./mda/Integrity/MeshIntegrity.js":"bU9N9","./mda/Integrity/FaceIntegrity.js":"aJGqU","./mda/Integrity/EdgeIntegrity.js":"bJZiZ","./mda/Integrity/HalfEdgeIntegrity.js":"hnjcF","./mda/Integrity/VertexIntegrity.js":"gBmpk","./mda/Queries/HalfEdgePrev.js":"lRsPN","./mda/Queries/EdgeVertices.js":"2K4CD","./mda/Queries/FaceHalfEdges.js":"eum8y","./mda/Queries/FaceVertices.js":"elyLX","./mda/Queries/VertexFaces.js":"gqIAR","./mda/Queries/VertexHalfEdges.js":"8DhJJ","./mda/Queries/VertexNeighbors.js":"f9YBN","./mda/Queries/MeshCentroid.js":"kKwVL","./mda/Operators/InsertVertex.js":"aoQ2o","./mda/Operators/InsertEdge.js":"e3H1k","./mda/Operators/DeleteEdge.js":"69uv4","./mda/Operators/Loop.js":"5MnuS","./mda/Operators/CatmullClark.js":"cnkNJ","./mda/Operators/QuadSubdivide.js":"dLOrr","./mda/Operators/Triangulate.js":"1FODs","./mda/Operators/Extrude.js":"bARYg","./mda/Operators/Pipe.js":"7E3Pw","./mda/Operators/Duplicate.js":"5Bekj","./mda/Operators/Combine.js":"1rKhw","./mda/Operators/Scale.js":"ggWoq","./mda/Operators/Move.js":"iT2PL","./mda/Operators/Invert.js":"dwfab","./mda/Operators/Wireframe.js":"fEWOP","./mda/Operators/CreateFace.js":"lxPIU","./mda/Generators/Profile.js":"7Nhm8"}],"dOHcN":[function(require,module,exports) {
function Edge() {
    this.halfEdge = undefined;
    this.index = -1;
}
Edge.prototype.setIndex = function(index) {
    this.index = index;
};
Edge.prototype.getIndex = function() {
    return this.index;
};
Edge.prototype.setHalfEdge = function(halfEdge) {
    this.halfEdge = halfEdge;
};
Edge.prototype.getHalfEdge = function() {
    return this.halfEdge;
};
module.exports = Edge;

},{}],"72nec":[function(require,module,exports) {
function HalfEdge() {
    this.nextHalfEdge = undefined; // points to the next halfedge around the current face (CCW)
    this.flipHalfEdge = undefined; // points to the other halfedge associated with this edge
    this.vertex = undefined; // points to the vertex at the "tail" of this halfedge
    this.edge = undefined; // points to the edge associated with this halfedge
    this.face = undefined; // points to the face containing this halfedge  
}
HalfEdge.prototype.setVertex = function(vertex) {
    this.vertex = vertex;
};
HalfEdge.prototype.getVertex = function() {
    return this.vertex;
};
HalfEdge.prototype.setFace = function(face) {
    this.face = face;
};
HalfEdge.prototype.getFace = function() {
    return this.face;
};
HalfEdge.prototype.setEdge = function(edge) {
    this.edge = edge;
};
HalfEdge.prototype.getEdge = function() {
    return this.edge;
};
HalfEdge.prototype.setNextHalfEdge = function(nextHalfEdge) {
    this.nextHalfEdge = nextHalfEdge;
};
HalfEdge.prototype.getNextHalfEdge = function() {
    return this.nextHalfEdge;
};
HalfEdge.prototype.setFlipHalfEdge = function(flipHalfEdge) {
    this.flipHalfEdge = flipHalfEdge;
};
HalfEdge.prototype.getFlipHalfEdge = function() {
    return this.flipHalfEdge;
};
HalfEdge.prototype.onBoundary = function() {
    if (this.getFlipHalfEdge()) return false;
    return true;
};
module.exports = HalfEdge;

},{}],"aMW4R":[function(require,module,exports) {
var vec3 = require('gl-matrix').vec3;
function Vertex() {
    this.halfEdge = undefined;
    this.index = -1;
}
Vertex.prototype.setIndex = function(index) {
    this.index = index;
};
Vertex.prototype.getIndex = function() {
    return this.index;
};
Vertex.prototype.setHalfEdge = function(halfEdge) {
    this.halfEdge = halfEdge;
};
Vertex.prototype.getHalfEdge = function() {
    return this.halfEdge;
};
module.exports = Vertex;

},{"gl-matrix":"3TXam"}],"3TXam":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "glMatrix", ()=>_commonJs
);
parcelHelpers.export(exports, "mat2", ()=>_mat2Js
);
parcelHelpers.export(exports, "mat2d", ()=>_mat2DJs
);
parcelHelpers.export(exports, "mat3", ()=>_mat3Js
);
parcelHelpers.export(exports, "mat4", ()=>_mat4Js
);
parcelHelpers.export(exports, "quat", ()=>_quatJs
);
parcelHelpers.export(exports, "quat2", ()=>_quat2Js
);
parcelHelpers.export(exports, "vec2", ()=>_vec2Js
);
parcelHelpers.export(exports, "vec3", ()=>_vec3Js
);
parcelHelpers.export(exports, "vec4", ()=>_vec4Js
);
var _commonJs = require("./gl-matrix/common.js");
var _mat2Js = require("./gl-matrix/mat2.js");
var _mat2DJs = require("./gl-matrix/mat2d.js");
var _mat3Js = require("./gl-matrix/mat3.js");
var _mat4Js = require("./gl-matrix/mat4.js");
var _quatJs = require("./gl-matrix/quat.js");
var _quat2Js = require("./gl-matrix/quat2.js");
var _vec2Js = require("./gl-matrix/vec2.js");
var _vec3Js = require("./gl-matrix/vec3.js");
var _vec4Js = require("./gl-matrix/vec4.js");

},{"./gl-matrix/common.js":"iRm9m","./gl-matrix/mat2.js":"i2DYt","./gl-matrix/mat2d.js":"8BNZN","./gl-matrix/mat3.js":"a3LaH","./gl-matrix/mat4.js":"jXHYx","./gl-matrix/quat.js":"8nyyw","./gl-matrix/quat2.js":"4kivg","./gl-matrix/vec2.js":"gQ8Wp","./gl-matrix/vec3.js":"kunHs","./gl-matrix/vec4.js":"1kX6y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iRm9m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EPSILON", ()=>EPSILON
);
parcelHelpers.export(exports, "ARRAY_TYPE", ()=>ARRAY_TYPE
);
parcelHelpers.export(exports, "RANDOM", ()=>RANDOM
);
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */ parcelHelpers.export(exports, "setMatrixArrayType", ()=>setMatrixArrayType
);
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */ parcelHelpers.export(exports, "toRadian", ()=>toRadian
);
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
function setMatrixArrayType(type) {
    ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
function toRadian(a) {
    return a * degree;
}
function equals(a, b) {
    return Math.abs(a - b) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i2DYt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 2x2 Matrix
 * @module mat2
 */ /**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "transpose", ()=>transpose
);
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "adjoint", ()=>adjoint
);
/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */ parcelHelpers.export(exports, "determinant", ()=>determinant
);
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "fromScaling", ()=>fromScaling
);
/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */ parcelHelpers.export(exports, "frob", ()=>frob
);
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */ parcelHelpers.export(exports, "LDU", ()=>LDU
);
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "multiplyScalar", ()=>multiplyScalar
);
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "multiplyScalarAndAdd", ()=>multiplyScalarAndAdd
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "sub", ()=>sub
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(4);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
    }
    out[0] = 1;
    out[3] = 1;
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
}
function fromValues(m00, m01, m10, m11) {
    var out = new _commonJs.ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
}
function set(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
}
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache
    // some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    return out;
}
function invert(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    // Calculate the determinant
    var det = a0 * a3 - a2 * a1;
    if (!det) return null;
    det = 1 / det;
    out[0] = a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] = a0 * det;
    return out;
}
function adjoint(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] = a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a0;
    return out;
}
function determinant(a) {
    return a[0] * a[3] - a[2] * a[1];
}
function multiply(out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
}
function rotate(out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
}
function scale(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
}
function fromRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}
function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}
function str(a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
}
function LDU(L, D, U, a) {
    L[2] = a[2] / a[0];
    U[0] = a[0];
    U[1] = a[1];
    U[3] = a[3] - L[2] * U[1];
    return [
        L,
        D,
        U
    ];
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
}
function multiplyScalarAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    return out;
}
var mul = multiply;
var sub = subtract;

},{"./common.js":"iRm9m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8BNZN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */ /**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */ parcelHelpers.export(exports, "determinant", ()=>determinant
);
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "fromScaling", ()=>fromScaling
);
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "fromTranslation", ()=>fromTranslation
);
/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */ parcelHelpers.export(exports, "frob", ()=>frob
);
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "multiplyScalar", ()=>multiplyScalar
);
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "multiplyScalarAndAdd", ()=>multiplyScalarAndAdd
);
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "sub", ()=>sub
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(6);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[4] = 0;
        out[5] = 0;
    }
    out[0] = 1;
    out[3] = 1;
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
}
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
}
function fromValues(a, b, c, d, tx, ty) {
    var out = new _commonJs.ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
}
function set(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
}
function invert(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3];
    var atx = a[4], aty = a[5];
    var det = aa * ad - ab * ac;
    if (!det) return null;
    det = 1 / det;
    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
}
function determinant(a) {
    return a[0] * a[3] - a[1] * a[2];
}
function multiply(out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
}
function rotate(out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
}
function scale(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
}
function translate(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
}
function fromRotation(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}
function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}
function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}
function str(a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}
function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
}
function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
}
function multiplyScalarAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    out[4] = a[4] + b[4] * scale1;
    out[5] = a[5] + b[5] * scale1;
    return out;
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _commonJs.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _commonJs.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5));
}
var mul = multiply;
var sub = subtract;

},{"./common.js":"iRm9m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a3LaH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 3x3 Matrix
 * @module mat3
 */ /**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "fromMat4", ()=>fromMat4
);
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "transpose", ()=>transpose
);
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "adjoint", ()=>adjoint
);
/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */ parcelHelpers.export(exports, "determinant", ()=>determinant
);
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "fromTranslation", ()=>fromTranslation
);
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "fromScaling", ()=>fromScaling
);
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/ parcelHelpers.export(exports, "fromMat2d", ()=>fromMat2d
);
/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/ parcelHelpers.export(exports, "fromQuat", ()=>fromQuat
);
/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/ parcelHelpers.export(exports, "normalFromMat4", ()=>normalFromMat4
);
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "projection", ()=>projection
);
/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */ parcelHelpers.export(exports, "frob", ()=>frob
);
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "multiplyScalar", ()=>multiplyScalar
);
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "multiplyScalarAndAdd", ()=>multiplyScalarAndAdd
);
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "sub", ()=>sub
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(9);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
}
function fromMat4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new _commonJs.ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
}
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
}
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    return out;
}
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    // Calculate the determinant
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) return null;
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
}
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
}
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
}
function translate(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
}
function rotate(out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
}
function scale(out, a, v) {
    var x = v[0], y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
}
function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}
function fromRotation(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}
function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}
function fromMat2d(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;
    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;
    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
}
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
}
function normalFromMat4(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    // Calculate the determinant
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) return null;
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
}
function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
}
function str(a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}
function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
}
function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
}
function multiplyScalarAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    out[4] = a[4] + b[4] * scale1;
    out[5] = a[5] + b[5] * scale1;
    out[6] = a[6] + b[6] * scale1;
    out[7] = a[7] + b[7] * scale1;
    out[8] = a[8] + b[8] * scale1;
    return out;
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _commonJs.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _commonJs.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _commonJs.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _commonJs.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _commonJs.EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul = multiply;
var sub = subtract;

},{"./common.js":"iRm9m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jXHYx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */ /**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "transpose", ()=>transpose
);
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "adjoint", ()=>adjoint
);
/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */ parcelHelpers.export(exports, "determinant", ()=>determinant
);
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromTranslation", ()=>fromTranslation
);
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromScaling", ()=>fromScaling
);
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromXRotation", ()=>fromXRotation
);
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromYRotation", ()=>fromYRotation
);
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromZRotation", ()=>fromZRotation
);
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromRotationTranslation", ()=>fromRotationTranslation
);
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */ parcelHelpers.export(exports, "fromQuat2", ()=>fromQuat2
);
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */ parcelHelpers.export(exports, "getTranslation", ()=>getTranslation
);
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */ parcelHelpers.export(exports, "getScaling", ()=>getScaling
);
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */ parcelHelpers.export(exports, "getRotation", ()=>getRotation
);
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromRotationTranslationScale", ()=>fromRotationTranslationScale
);
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromRotationTranslationScaleOrigin", ()=>fromRotationTranslationScaleOrigin
);
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromQuat", ()=>fromQuat
);
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "frustum", ()=>frustum
);
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "perspective", ()=>perspective
);
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "perspectiveFromFieldOfView", ()=>perspectiveFromFieldOfView
);
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "ortho", ()=>ortho
);
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "lookAt", ()=>lookAt
);
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "targetTo", ()=>targetTo
);
/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */ parcelHelpers.export(exports, "frob", ()=>frob
);
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "multiplyScalar", ()=>multiplyScalar
);
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "multiplyScalarAndAdd", ()=>multiplyScalarAndAdd
);
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "sub", ()=>sub
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(16);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new _commonJs.ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
}
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
}
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3];
        var a12 = a[6], a13 = a[7];
        var a23 = a[11];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    return out;
}
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    // Calculate the determinant
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) return null;
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
}
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
}
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    // Cache only the current line of the second matrix
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
}
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    var a00 = void 0, a01 = void 0, a02 = void 0, a03 = void 0;
    var a10 = void 0, a11 = void 0, a12 = void 0, a13 = void 0;
    var a20 = void 0, a21 = void 0, a22 = void 0, a23 = void 0;
    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0];
        a01 = a[1];
        a02 = a[2];
        a03 = a[3];
        a10 = a[4];
        a11 = a[5];
        a12 = a[6];
        a13 = a[7];
        a20 = a[8];
        a21 = a[9];
        a22 = a[10];
        a23 = a[11];
        out[0] = a00;
        out[1] = a01;
        out[2] = a02;
        out[3] = a03;
        out[4] = a10;
        out[5] = a11;
        out[6] = a12;
        out[7] = a13;
        out[8] = a20;
        out[9] = a21;
        out[10] = a22;
        out[11] = a23;
        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
}
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len = Math.sqrt(x * x + y * y + z * z);
    var s = void 0, c = void 0, t = void 0;
    var a00 = void 0, a01 = void 0, a02 = void 0, a03 = void 0;
    var a10 = void 0, a11 = void 0, a12 = void 0, a13 = void 0;
    var a20 = void 0, a21 = void 0, a22 = void 0, a23 = void 0;
    var b00 = void 0, b01 = void 0, b02 = void 0;
    var b10 = void 0, b11 = void 0, b12 = void 0;
    var b20 = void 0, b21 = void 0, b22 = void 0;
    if (len < _commonJs.EPSILON) return null;
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    // Construct the elements of the rotation matrix
    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c;
    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
        // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
}
function rotateX(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
}
function rotateY(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
}
function rotateZ(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged last row
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
}
function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromRotation(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len = Math.sqrt(x * x + y * y + z * z);
    var s = void 0, c = void 0, t = void 0;
    if (len < _commonJs.EPSILON) return null;
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromXRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    // Perform axis-specific matrix multiplication
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromYRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    // Perform axis-specific matrix multiplication
    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromZRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    // Perform axis-specific matrix multiplication
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function fromQuat2(out, a) {
    var translation = new _commonJs.ARRAY_TYPE(3);
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw;
    //Only scale if it makes sense
    if (magnitude > 0) {
        translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
        translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
        translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
        translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
        translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
        translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    fromRotationTranslation(out, a, translation);
    return out;
}
function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
}
function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    return out;
}
function getRotation(out, mat) {
    // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    var trace = mat[0] + mat[5] + mat[10];
    var S = 0;
    if (trace > 0) {
        S = Math.sqrt(trace + 1) * 2;
        out[3] = 0.25 * S;
        out[0] = (mat[6] - mat[9]) / S;
        out[1] = (mat[8] - mat[2]) / S;
        out[2] = (mat[1] - mat[4]) / S;
    } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
        S = Math.sqrt(1 + mat[0] - mat[5] - mat[10]) * 2;
        out[3] = (mat[6] - mat[9]) / S;
        out[0] = 0.25 * S;
        out[1] = (mat[1] + mat[4]) / S;
        out[2] = (mat[8] + mat[2]) / S;
    } else if (mat[5] > mat[10]) {
        S = Math.sqrt(1 + mat[5] - mat[0] - mat[10]) * 2;
        out[3] = (mat[8] - mat[2]) / S;
        out[0] = (mat[1] + mat[4]) / S;
        out[1] = 0.25 * S;
        out[2] = (mat[6] + mat[9]) / S;
    } else {
        S = Math.sqrt(1 + mat[10] - mat[0] - mat[5]) * 2;
        out[3] = (mat[1] - mat[4]) / S;
        out[0] = (mat[8] + mat[2]) / S;
        out[1] = (mat[6] + mat[9]) / S;
        out[2] = 0.25 * S;
    }
    return out;
}
function fromRotationTranslationScale(out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
}
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
}
function perspective(out, fovy, aspect, near, far) {
    var f = 1 / Math.tan(fovy / 2), nf = void 0;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
        nf = 1 / (near - far);
        out[10] = (far + near) * nf;
        out[14] = 2 * far * near * nf;
    } else {
        out[10] = -1;
        out[14] = -2 * near;
    }
    return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    var xScale = 2 / (leftTan + rightTan);
    var yScale = 2 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = yScale;
    out[6] = 0;
    out[7] = 0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near / (near - far);
    out[15] = 0;
    return out;
}
function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
}
function lookAt(out, eye, center, up) {
    var x0 = void 0, x1 = void 0, x2 = void 0, y0 = void 0, y1 = void 0, y2 = void 0, z0 = void 0, z1 = void 0, z2 = void 0, len = void 0;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];
    if (Math.abs(eyex - centerx) < _commonJs.EPSILON && Math.abs(eyey - centery) < _commonJs.EPSILON && Math.abs(eyez - centerz) < _commonJs.EPSILON) return identity(out);
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
}
function targetTo(out, eye, target, up) {
    var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
    var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
    var len = z0 * z0 + z1 * z1 + z2 * z2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        z0 *= len;
        z1 *= len;
        z2 *= len;
    }
    var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
}
function str(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}
function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
}
function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
}
function multiplyScalarAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    out[4] = a[4] + b[4] * scale1;
    out[5] = a[5] + b[5] * scale1;
    out[6] = a[6] + b[6] * scale1;
    out[7] = a[7] + b[7] * scale1;
    out[8] = a[8] + b[8] * scale1;
    out[9] = a[9] + b[9] * scale1;
    out[10] = a[10] + b[10] * scale1;
    out[11] = a[11] + b[11] * scale1;
    out[12] = a[12] + b[12] * scale1;
    out[13] = a[13] + b[13] * scale1;
    out[14] = a[14] + b[14] * scale1;
    out[15] = a[15] + b[15] * scale1;
    return out;
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
    var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
    var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
    var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _commonJs.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _commonJs.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _commonJs.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _commonJs.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _commonJs.EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _commonJs.EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _commonJs.EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _commonJs.EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _commonJs.EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _commonJs.EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _commonJs.EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _commonJs.EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul = multiply;
var sub = subtract;

},{"./common.js":"iRm9m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8nyyw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Quaternion
 * @module quat
 */ /**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/ parcelHelpers.export(exports, "setAxisAngle", ()=>setAxisAngle
);
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */ parcelHelpers.export(exports, "getAxisAngle", ()=>getAxisAngle
);
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */ parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */ parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */ parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */ parcelHelpers.export(exports, "calculateW", ()=>calculateW
);
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */ parcelHelpers.export(exports, "slerp", ()=>slerp
);
/**
 * Generates a random quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */ parcelHelpers.export(exports, "random", ()=>random
);
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */ parcelHelpers.export(exports, "conjugate", ()=>conjugate
);
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */ parcelHelpers.export(exports, "fromMat3", ()=>fromMat3
);
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */ parcelHelpers.export(exports, "fromEuler", ()=>fromEuler
);
/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */ parcelHelpers.export(exports, "str", ()=>str
);
parcelHelpers.export(exports, "clone", ()=>clone
);
parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
parcelHelpers.export(exports, "copy", ()=>copy
);
parcelHelpers.export(exports, "set", ()=>set
);
parcelHelpers.export(exports, "add", ()=>add
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "scale", ()=>scale
);
parcelHelpers.export(exports, "dot", ()=>dot
);
parcelHelpers.export(exports, "lerp", ()=>lerp
);
parcelHelpers.export(exports, "length", ()=>length
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
parcelHelpers.export(exports, "normalize", ()=>normalize
);
parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "rotationTo", ()=>rotationTo
);
parcelHelpers.export(exports, "sqlerp", ()=>sqlerp
);
parcelHelpers.export(exports, "setAxes", ()=>setAxes
);
var _commonJs = require("./common.js");
var _mat3Js = require("./mat3.js");
var _vec3Js = require("./vec3.js");
var _vec4Js = require("./vec4.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(4);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
    }
    out[3] = 1;
    return out;
}
function identity(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
}
function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
}
function getAxisAngle(out_axis, q) {
    var rad = Math.acos(q[3]) * 2;
    var s = Math.sin(rad / 2);
    if (s > _commonJs.EPSILON) {
        out_axis[0] = q[0] / s;
        out_axis[1] = q[1] / s;
        out_axis[2] = q[2] / s;
    } else {
        // If s is zero, return any axis (no rotation - axis does not matter)
        out_axis[0] = 1;
        out_axis[1] = 0;
        out_axis[2] = 0;
    }
    return rad;
}
function multiply(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
}
function rotateX(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
}
function rotateY(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var by = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
}
function rotateZ(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bz = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
}
function calculateW(out, a) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
    return out;
}
function slerp(out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    var omega = void 0, cosom = void 0, sinom = void 0, scale0 = void 0, scale1 = void 0;
    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if (cosom < 0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
    }
    // calculate coefficients
    if (1 - cosom > _commonJs.EPSILON) {
        // standard case (slerp)
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {
        // "from" and "to" quaternions are very close
        //  ... so we can do a linear interpolation
        scale0 = 1 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
}
function random(out) {
    // Implementation of http://planning.cs.uiuc.edu/node198.html
    // TODO: Calling random 3 times is probably not the fastest solution
    var u1 = _commonJs.RANDOM();
    var u2 = _commonJs.RANDOM();
    var u3 = _commonJs.RANDOM();
    var sqrt1MinusU1 = Math.sqrt(1 - u1);
    var sqrtU1 = Math.sqrt(u1);
    out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
    out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
    out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
    out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
    return out;
}
function invert(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var dot1 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
    var invDot = dot1 ? 1 / dot1 : 0;
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a2 * invDot;
    out[3] = a3 * invDot;
    return out;
}
function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
}
function fromMat3(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot = void 0;
    if (fTrace > 0) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1); // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot; // 1/(4w)
        out[0] = (m[5] - m[7]) * fRoot;
        out[1] = (m[6] - m[2]) * fRoot;
        out[2] = (m[1] - m[3]) * fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if (m[4] > m[0]) i = 1;
        if (m[8] > m[i * 3 + i]) i = 2;
        var j = (i + 1) % 3;
        var k = (i + 2) % 3;
        fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
        out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
        out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }
    return out;
}
function fromEuler(out, x, y, z) {
    var halfToRad = 0.5 * Math.PI / 180;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
}
function str(a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
var clone = _vec4Js.clone;
var fromValues = _vec4Js.fromValues;
var copy = _vec4Js.copy;
var set = _vec4Js.set;
var add = _vec4Js.add;
var mul = multiply;
var scale = _vec4Js.scale;
var dot = _vec4Js.dot;
var lerp = _vec4Js.lerp;
var length = _vec4Js.length;
var len = length;
var squaredLength = _vec4Js.squaredLength;
var sqrLen = squaredLength;
var normalize = _vec4Js.normalize;
var exactEquals = _vec4Js.exactEquals;
var equals = _vec4Js.equals;
var rotationTo = function() {
    var tmpvec3 = _vec3Js.create();
    var xUnitVec3 = _vec3Js.fromValues(1, 0, 0);
    var yUnitVec3 = _vec3Js.fromValues(0, 1, 0);
    return function(out, a, b) {
        var dot2 = _vec3Js.dot(a, b);
        if (dot2 < -0.999999) {
            _vec3Js.cross(tmpvec3, xUnitVec3, a);
            if (_vec3Js.len(tmpvec3) < 0.000001) _vec3Js.cross(tmpvec3, yUnitVec3, a);
            _vec3Js.normalize(tmpvec3, tmpvec3);
            setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot2 > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            _vec3Js.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot2;
            return normalize(out, out);
        }
    };
}();
var sqlerp = function() {
    var temp1 = create();
    var temp2 = create();
    return function(out, a, b, c, d, t) {
        slerp(temp1, a, d, t);
        slerp(temp2, b, c, t);
        slerp(out, temp1, temp2, 2 * t * (1 - t));
        return out;
    };
}();
var setAxes = function() {
    var matr = _mat3Js.create();
    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];
        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];
        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];
        return normalize(out, fromMat3(out, matr));
    };
}();

},{"./common.js":"iRm9m","./mat3.js":"a3LaH","./vec3.js":"kunHs","./vec4.js":"1kX6y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kunHs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 3 Dimensional Vector
 * @module vec3
 */ /**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */ parcelHelpers.export(exports, "length", ()=>length
);
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "divide", ()=>divide
);
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "ceil", ()=>ceil
);
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "floor", ()=>floor
);
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "min", ()=>min
);
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "max", ()=>max
);
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "round", ()=>round
);
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "scaleAndAdd", ()=>scaleAndAdd
);
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */ parcelHelpers.export(exports, "distance", ()=>distance
);
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance
);
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */ parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "negate", ()=>negate
);
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "inverse", ()=>inverse
);
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */ parcelHelpers.export(exports, "dot", ()=>dot
);
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "cross", ()=>cross
);
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "lerp", ()=>lerp
);
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "hermite", ()=>hermite
);
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "bezier", ()=>bezier
);
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "random", ()=>random
);
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "transformMat4", ()=>transformMat4
);
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "transformMat3", ()=>transformMat3
);
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "transformQuat", ()=>transformQuat
);
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */ parcelHelpers.export(exports, "angle", ()=>angle
);
/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "sub", ()=>sub
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "div", ()=>div
);
parcelHelpers.export(exports, "dist", ()=>dist
);
parcelHelpers.export(exports, "sqrDist", ()=>sqrDist
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
parcelHelpers.export(exports, "forEach", ()=>forEach
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(3);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
    }
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
}
function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.sqrt(x * x + y * y + z * z);
}
function fromValues(x, y, z) {
    var out = new _commonJs.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
}
function set(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
}
function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
}
function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
}
function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
}
function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
}
function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
}
function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
}
function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
}
function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
}
function scaleAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    return out;
}
function distance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.sqrt(x * x + y * y + z * z);
}
function squaredDistance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
}
function squaredLength(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
}
function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
}
function inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    return out;
}
function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len1 = x * x + y * y + z * z;
    if (len1 > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len1 = 1 / Math.sqrt(len1);
        out[0] = a[0] * len1;
        out[1] = a[1] * len1;
        out[2] = a[2] * len1;
    }
    return out;
}
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
}
function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
}
function hermite(out, a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
}
function bezier(out, a, b, c, d, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
}
function random(out, scale2) {
    scale2 = scale2 || 1;
    var r = _commonJs.RANDOM() * 2 * Math.PI;
    var z = _commonJs.RANDOM() * 2 - 1;
    var zScale = Math.sqrt(1 - z * z) * scale2;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale2;
    return out;
}
function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
}
function transformMat3(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
}
function transformQuat(out, a, q) {
    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x = a[0], y = a[1], z = a[2];
    // var qvec = [qx, qy, qz];
    // var uv = vec3.cross([], qvec, a);
    var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
    // var uuv = vec3.cross([], qvec, uv);
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    // vec3.scale(uv, uv, 2 * w);
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    // vec3.scale(uuv, uuv, 2);
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    // return vec3.add(out, a, vec3.add(out, uv, uuv));
    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
}
function rotateX(out, a, b, c) {
    var p = [], r = [];
    //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    //perform rotation
    r[0] = p[0];
    r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
    r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);
    //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function rotateY(out, a, b, c) {
    var p = [], r = [];
    //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    //perform rotation
    r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);
    //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function rotateZ(out, a, b, c) {
    var p = [], r = [];
    //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    //perform rotation
    r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
    r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
    r[2] = p[2];
    //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function angle(a, b) {
    var tempA = fromValues(a[0], a[1], a[2]);
    var tempB = fromValues(b[0], b[1], b[2]);
    normalize(tempA, tempA);
    normalize(tempB, tempB);
    var cosine = dot(tempA, tempB);
    if (cosine > 1) return 0;
    else if (cosine < -1) return Math.PI;
    else return Math.acos(cosine);
}
function str(a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
    var vec = create();
    return function(a, stride, offset, count, fn, arg) {
        var i = void 0, l = void 0;
        if (!stride) stride = 3;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
        }
        return a;
    };
}();

},{"./common.js":"iRm9m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1kX6y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 4 Dimensional Vector
 * @module vec4
 */ /**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "divide", ()=>divide
);
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "ceil", ()=>ceil
);
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "floor", ()=>floor
);
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "min", ()=>min
);
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "max", ()=>max
);
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "round", ()=>round
);
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "scaleAndAdd", ()=>scaleAndAdd
);
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */ parcelHelpers.export(exports, "distance", ()=>distance
);
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance
);
/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */ parcelHelpers.export(exports, "length", ()=>length
);
/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */ parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "negate", ()=>negate
);
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "inverse", ()=>inverse
);
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */ parcelHelpers.export(exports, "dot", ()=>dot
);
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "lerp", ()=>lerp
);
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "random", ()=>random
);
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "transformMat4", ()=>transformMat4
);
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "transformQuat", ()=>transformQuat
);
/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "sub", ()=>sub
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "div", ()=>div
);
parcelHelpers.export(exports, "dist", ()=>dist
);
parcelHelpers.export(exports, "sqrDist", ()=>sqrDist
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
parcelHelpers.export(exports, "forEach", ()=>forEach
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(4);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
    }
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function fromValues(x, y, z, w) {
    var out = new _commonJs.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function set(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
}
function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
}
function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
}
function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
}
function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
}
function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
}
function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
}
function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
}
function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
}
function scaleAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    return out;
}
function distance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return Math.sqrt(x * x + y * y + z * z + w * w);
}
function squaredDistance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return x * x + y * y + z * z + w * w;
}
function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return Math.sqrt(x * x + y * y + z * z + w * w);
}
function squaredLength(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return x * x + y * y + z * z + w * w;
}
function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
}
function inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    out[3] = 1 / a[3];
    return out;
}
function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len1 = x * x + y * y + z * z + w * w;
    if (len1 > 0) {
        len1 = 1 / Math.sqrt(len1);
        out[0] = x * len1;
        out[1] = y * len1;
        out[2] = z * len1;
        out[3] = w * len1;
    }
    return out;
}
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
}
function random(out, scale2) {
    scale2 = scale2 || 1;
    // Marsaglia, George. Choosing a Point from the Surface of a
    // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
    // http://projecteuclid.org/euclid.aoms/1177692644;
    var v1, v2, v3, v4;
    var s1, s2;
    do {
        v1 = _commonJs.RANDOM() * 2 - 1;
        v2 = _commonJs.RANDOM() * 2 - 1;
        s1 = v1 * v1 + v2 * v2;
    }while (s1 >= 1)
    do {
        v3 = _commonJs.RANDOM() * 2 - 1;
        v4 = _commonJs.RANDOM() * 2 - 1;
        s2 = v3 * v3 + v4 * v4;
    }while (s2 >= 1)
    var d = Math.sqrt((1 - s1) / s2);
    out[0] = scale2 * v1;
    out[1] = scale2 * v2;
    out[2] = scale2 * v3 * d;
    out[3] = scale2 * v4 * d;
    return out;
}
function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
}
function transformQuat(out, a, q) {
    var x = a[0], y = a[1], z = a[2];
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    // calculate quat * vec
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
}
function str(a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
    var vec = create();
    return function(a, stride, offset, count, fn, arg) {
        var i = void 0, l = void 0;
        if (!stride) stride = 4;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            vec[3] = a[i + 3];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
            a[i + 3] = vec[3];
        }
        return a;
    };
}();

},{"./common.js":"iRm9m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4kivg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */ /**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */ parcelHelpers.export(exports, "fromRotationTranslationValues", ()=>fromRotationTranslationValues
);
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q quaternion
 * @param {vec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */ parcelHelpers.export(exports, "fromRotationTranslation", ()=>fromRotationTranslation
);
/**
 * Creates a dual quat from a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {vec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */ parcelHelpers.export(exports, "fromTranslation", ()=>fromTranslation
);
/**
 * Creates a dual quat from a quaternion
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {mat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */ parcelHelpers.export(exports, "fromMat4", ()=>fromMat4
);
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "set", ()=>set
);
parcelHelpers.export(exports, "getReal", ()=>getReal
);
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} dual part
 */ parcelHelpers.export(exports, "getDual", ()=>getDual
);
parcelHelpers.export(exports, "setReal", ()=>setReal
);
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "setDual", ()=>setDual
);
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {quat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */ parcelHelpers.export(exports, "getTranslation", ()=>getTranslation
);
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to translate
 * @param {vec3} v vector to translate by
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {quat} q quaternion to rotate by
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateByQuatAppend", ()=>rotateByQuatAppend
);
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat} q quaternion to rotate by
 * @param {quat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateByQuatPrepend", ()=>rotateByQuatPrepend
);
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {vec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateAroundAxis", ()=>rotateAroundAxis
);
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
parcelHelpers.export(exports, "mul", ()=>mul
);
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
parcelHelpers.export(exports, "dot", ()=>dot
);
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "lerp", ()=>lerp
);
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "conjugate", ()=>conjugate
);
parcelHelpers.export(exports, "length", ()=>length
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {quat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat2} a the first dual quaternion.
 * @param {quat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {quat2} a the first dual quat.
 * @param {quat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
var _commonJs = require("./common.js");
var _quatJs = require("./quat.js");
var _mat4Js = require("./mat4.js");
function create() {
    var dq = new _commonJs.ARRAY_TYPE(8);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        dq[0] = 0;
        dq[1] = 0;
        dq[2] = 0;
        dq[4] = 0;
        dq[5] = 0;
        dq[6] = 0;
        dq[7] = 0;
    }
    dq[3] = 1;
    return dq;
}
function clone(a) {
    var dq = new _commonJs.ARRAY_TYPE(8);
    dq[0] = a[0];
    dq[1] = a[1];
    dq[2] = a[2];
    dq[3] = a[3];
    dq[4] = a[4];
    dq[5] = a[5];
    dq[6] = a[6];
    dq[7] = a[7];
    return dq;
}
function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
    var dq = new _commonJs.ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    dq[4] = x2;
    dq[5] = y2;
    dq[6] = z2;
    dq[7] = w2;
    return dq;
}
function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
    var dq = new _commonJs.ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    var ax = x2 * 0.5, ay = y2 * 0.5, az = z2 * 0.5;
    dq[4] = ax * w1 + ay * z1 - az * y1;
    dq[5] = ay * w1 + az * x1 - ax * z1;
    dq[6] = az * w1 + ax * y1 - ay * x1;
    dq[7] = -ax * x1 - ay * y1 - az * z1;
    return dq;
}
function fromRotationTranslation(out, q, t) {
    var ax = t[0] * 0.5, ay = t[1] * 0.5, az = t[2] * 0.5, bx = q[0], by = q[1], bz = q[2], bw = q[3];
    out[0] = bx;
    out[1] = by;
    out[2] = bz;
    out[3] = bw;
    out[4] = ax * bw + ay * bz - az * by;
    out[5] = ay * bw + az * bx - ax * bz;
    out[6] = az * bw + ax * by - ay * bx;
    out[7] = -ax * bx - ay * by - az * bz;
    return out;
}
function fromTranslation(out, t) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = t[0] * 0.5;
    out[5] = t[1] * 0.5;
    out[6] = t[2] * 0.5;
    out[7] = 0;
    return out;
}
function fromRotation(out, q) {
    out[0] = q[0];
    out[1] = q[1];
    out[2] = q[2];
    out[3] = q[3];
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
}
function fromMat4(out, a) {
    //TODO Optimize this
    var outer = _quatJs.create();
    _mat4Js.getRotation(outer, a);
    var t = new _commonJs.ARRAY_TYPE(3);
    _mat4Js.getTranslation(t, a);
    fromRotationTranslation(out, outer, t);
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    return out;
}
function identity(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
}
function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
    out[0] = x1;
    out[1] = y1;
    out[2] = z1;
    out[3] = w1;
    out[4] = x2;
    out[5] = y2;
    out[6] = z2;
    out[7] = w2;
    return out;
}
var getReal = _quatJs.copy;
function getDual(out, a) {
    out[0] = a[4];
    out[1] = a[5];
    out[2] = a[6];
    out[3] = a[7];
    return out;
}
var setReal = _quatJs.copy;
function setDual(out, q) {
    out[4] = q[0];
    out[5] = q[1];
    out[6] = q[2];
    out[7] = q[3];
    return out;
}
function getTranslation(out, a) {
    var ax = a[4], ay = a[5], az = a[6], aw = a[7], bx = -a[0], by = -a[1], bz = -a[2], bw = a[3];
    out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    return out;
}
function translate(out, a, v) {
    var ax1 = a[0], ay1 = a[1], az1 = a[2], aw1 = a[3], bx1 = v[0] * 0.5, by1 = v[1] * 0.5, bz1 = v[2] * 0.5, ax2 = a[4], ay2 = a[5], az2 = a[6], aw2 = a[7];
    out[0] = ax1;
    out[1] = ay1;
    out[2] = az1;
    out[3] = aw1;
    out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
    out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
    out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
    out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
    return out;
}
function rotateX(out, a, rad) {
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
    _quatJs.rotateX(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
}
function rotateY(out, a, rad) {
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
    _quatJs.rotateY(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
}
function rotateZ(out, a, rad) {
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
    _quatJs.rotateZ(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
}
function rotateByQuatAppend(out, a, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3], ax = a[0], ay = a[1], az = a[2], aw = a[3];
    out[0] = ax * qw + aw * qx + ay * qz - az * qy;
    out[1] = ay * qw + aw * qy + az * qx - ax * qz;
    out[2] = az * qw + aw * qz + ax * qy - ay * qx;
    out[3] = aw * qw - ax * qx - ay * qy - az * qz;
    ax = a[4];
    ay = a[5];
    az = a[6];
    aw = a[7];
    out[4] = ax * qw + aw * qx + ay * qz - az * qy;
    out[5] = ay * qw + aw * qy + az * qx - ax * qz;
    out[6] = az * qw + aw * qz + ax * qy - ay * qx;
    out[7] = aw * qw - ax * qx - ay * qy - az * qz;
    return out;
}
function rotateByQuatPrepend(out, q, a) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3], bx = a[0], by = a[1], bz = a[2], bw = a[3];
    out[0] = qx * bw + qw * bx + qy * bz - qz * by;
    out[1] = qy * bw + qw * by + qz * bx - qx * bz;
    out[2] = qz * bw + qw * bz + qx * by - qy * bx;
    out[3] = qw * bw - qx * bx - qy * by - qz * bz;
    bx = a[4];
    by = a[5];
    bz = a[6];
    bw = a[7];
    out[4] = qx * bw + qw * bx + qy * bz - qz * by;
    out[5] = qy * bw + qw * by + qz * bx - qx * bz;
    out[6] = qz * bw + qw * bz + qx * by - qy * bx;
    out[7] = qw * bw - qx * bx - qy * by - qz * bz;
    return out;
}
function rotateAroundAxis(out, a, axis, rad) {
    //Special case for rad = 0
    if (Math.abs(rad) < _commonJs.EPSILON) return copy(out, a);
    var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);
    rad = rad * 0.5;
    var s = Math.sin(rad);
    var bx = s * axis[0] / axisLength;
    var by = s * axis[1] / axisLength;
    var bz = s * axis[2] / axisLength;
    var bw = Math.cos(rad);
    var ax1 = a[0], ay1 = a[1], az1 = a[2], aw1 = a[3];
    out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    var ax = a[4], ay = a[5], az = a[6], aw = a[7];
    out[4] = ax * bw + aw * bx + ay * bz - az * by;
    out[5] = ay * bw + aw * by + az * bx - ax * bz;
    out[6] = az * bw + aw * bz + ax * by - ay * bx;
    out[7] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    return out;
}
function multiply(out, a, b) {
    var ax0 = a[0], ay0 = a[1], az0 = a[2], aw0 = a[3], bx1 = b[4], by1 = b[5], bz1 = b[6], bw1 = b[7], ax1 = a[4], ay1 = a[5], az1 = a[6], aw1 = a[7], bx0 = b[0], by0 = b[1], bz0 = b[2], bw0 = b[3];
    out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
    out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
    out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
    out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
    out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
    out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
    out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
    out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
    return out;
}
var mul = multiply;
function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    return out;
}
var dot = _quatJs.dot;
function lerp(out, a, b, t) {
    var mt = 1 - t;
    if (dot(a, b) < 0) t = -t;
    out[0] = a[0] * mt + b[0] * t;
    out[1] = a[1] * mt + b[1] * t;
    out[2] = a[2] * mt + b[2] * t;
    out[3] = a[3] * mt + b[3] * t;
    out[4] = a[4] * mt + b[4] * t;
    out[5] = a[5] * mt + b[5] * t;
    out[6] = a[6] * mt + b[6] * t;
    out[7] = a[7] * mt + b[7] * t;
    return out;
}
function invert(out, a) {
    var sqlen = squaredLength(a);
    out[0] = -a[0] / sqlen;
    out[1] = -a[1] / sqlen;
    out[2] = -a[2] / sqlen;
    out[3] = a[3] / sqlen;
    out[4] = -a[4] / sqlen;
    out[5] = -a[5] / sqlen;
    out[6] = -a[6] / sqlen;
    out[7] = a[7] / sqlen;
    return out;
}
function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    out[4] = -a[4];
    out[5] = -a[5];
    out[6] = -a[6];
    out[7] = a[7];
    return out;
}
var length = _quatJs.length;
var len = length;
var squaredLength = _quatJs.squaredLength;
var sqrLen = squaredLength;
function normalize(out, a) {
    var magnitude = squaredLength(a);
    if (magnitude > 0) {
        magnitude = Math.sqrt(magnitude);
        var a0 = a[0] / magnitude;
        var a1 = a[1] / magnitude;
        var a2 = a[2] / magnitude;
        var a3 = a[3] / magnitude;
        var b0 = a[4];
        var b1 = a[5];
        var b2 = a[6];
        var b3 = a[7];
        var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
        out[0] = a0;
        out[1] = a1;
        out[2] = a2;
        out[3] = a3;
        out[4] = (b0 - a0 * a_dot_b) / magnitude;
        out[5] = (b1 - a1 * a_dot_b) / magnitude;
        out[6] = (b2 - a2 * a_dot_b) / magnitude;
        out[7] = (b3 - a3 * a_dot_b) / magnitude;
    }
    return out;
}
function str(a) {
    return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _commonJs.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _commonJs.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _commonJs.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _commonJs.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7));
}

},{"./common.js":"iRm9m","./quat.js":"8nyyw","./mat4.js":"jXHYx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gQ8Wp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 2 Dimensional Vector
 * @module vec2
 */ /**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "divide", ()=>divide
);
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "ceil", ()=>ceil
);
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "floor", ()=>floor
);
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "min", ()=>min
);
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "max", ()=>max
);
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "round", ()=>round
);
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "scaleAndAdd", ()=>scaleAndAdd
);
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */ parcelHelpers.export(exports, "distance", ()=>distance
);
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance
);
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */ parcelHelpers.export(exports, "length", ()=>length
);
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */ parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "negate", ()=>negate
);
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "inverse", ()=>inverse
);
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */ parcelHelpers.export(exports, "dot", ()=>dot
);
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "cross", ()=>cross
);
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "lerp", ()=>lerp
);
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "random", ()=>random
);
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "transformMat2", ()=>transformMat2
);
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "transformMat2d", ()=>transformMat2d
);
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "transformMat3", ()=>transformMat3
);
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "transformMat4", ()=>transformMat4
);
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */ parcelHelpers.export(exports, "angle", ()=>angle
);
/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "sub", ()=>sub
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "div", ()=>div
);
parcelHelpers.export(exports, "dist", ()=>dist
);
parcelHelpers.export(exports, "sqrDist", ()=>sqrDist
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
parcelHelpers.export(exports, "forEach", ()=>forEach
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(2);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
    }
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
}
function fromValues(x, y) {
    var out = new _commonJs.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
}
function set(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
}
function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
}
function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
}
function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
}
function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
}
function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
}
function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
}
function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
}
function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
}
function scaleAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    return out;
}
function distance(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return Math.sqrt(x * x + y * y);
}
function squaredDistance(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return x * x + y * y;
}
function length(a) {
    var x = a[0], y = a[1];
    return Math.sqrt(x * x + y * y);
}
function squaredLength(a) {
    var x = a[0], y = a[1];
    return x * x + y * y;
}
function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
}
function inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    return out;
}
function normalize(out, a) {
    var x = a[0], y = a[1];
    var len1 = x * x + y * y;
    if (len1 > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len1 = 1 / Math.sqrt(len1);
        out[0] = a[0] * len1;
        out[1] = a[1] * len1;
    }
    return out;
}
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
}
function cross(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
}
function lerp(out, a, b, t) {
    var ax = a[0], ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
}
function random(out, scale2) {
    scale2 = scale2 || 1;
    var r = _commonJs.RANDOM() * 2 * Math.PI;
    out[0] = Math.cos(r) * scale2;
    out[1] = Math.sin(r) * scale2;
    return out;
}
function transformMat2(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
}
function transformMat2d(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
}
function transformMat3(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
}
function transformMat4(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
}
function rotate(out, a, b, c) {
    //Translate point to the origin
    var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(c), cosC = Math.cos(c);
    //perform rotation and translate to correct position
    out[0] = p0 * cosC - p1 * sinC + b[0];
    out[1] = p0 * sinC + p1 * cosC + b[1];
    return out;
}
function angle(a, b) {
    var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1];
    var len1 = x1 * x1 + y1 * y1;
    if (len1 > 0) //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
    var len2 = x2 * x2 + y2 * y2;
    if (len2 > 0) //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
    var cosine = (x1 * x2 + y1 * y2) * len1 * len2;
    if (cosine > 1) return 0;
    else if (cosine < -1) return Math.PI;
    else return Math.acos(cosine);
}
function str(a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len = length;
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var sqrLen = squaredLength;
var forEach = function() {
    var vec = create();
    return function(a, stride, offset, count, fn, arg) {
        var i = void 0, l = void 0;
        if (!stride) stride = 2;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
        }
        return a;
    };
}();

},{"./common.js":"iRm9m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fVwz7":[function(require,module,exports) {
function Face() {
    this.halfEdge = undefined; // points to one of the halfedges associated with this face
    this.index = -1;
}
Face.prototype.setIndex = function(index) {
    this.index = index;
};
Face.prototype.getIndex = function() {
    return this.index;
};
Face.prototype.setHalfEdge = function(halfEdge) {
    this.halfEdge = halfEdge;
};
Face.prototype.getHalfEdge = function() {
    return this.halfEdge;
};
module.exports = Face;

},{}],"lGuYv":[function(require,module,exports) {
var vec3 = require('gl-matrix').vec3;
var Vertex = require('./Vertex');
var Edge = require('./Edge');
var HalfEdge = require('./HalfEdge');
var Face = require('./Face');
function Mesh() {
    this.halfEdges = []; // Half - check;
    this.vertices = []; // Vert - check
    this.edges = []; // Edge - check
    this.faces = []; // Face - check
    this.boundaries = []; // Face - not done
    this.positions = []; // For Faster Rendering
    this.cells = []; // For Faster Rendering
    this.edgeMap = {
    } // ( 1 - 3 ) <==> ( 3 - 1 )
    ;
}
Mesh.prototype.getFaces = function() {
    return this.faces;
};
Mesh.prototype.getEdges = function() {
    return this.edges;
};
Mesh.prototype.getEdgeMap = function() {
    return this.edgeMap;
};
Mesh.prototype.getVertices = function() {
    return this.vertices;
};
Mesh.prototype.getHalfEdges = function() {
    return this.halfEdges;
};
Mesh.prototype.getEdgeKey = function(vertexIndex0, vertexIndex1) {
    return vertexIndex0 + '-' + vertexIndex1;
};
Mesh.prototype.getEdgeKeys = function(vertexIndex0, vertexIndex1) {
    return [
        this.getEdgeKey(vertexIndex0, vertexIndex1),
        this.getEdgeKey(vertexIndex1, vertexIndex0)
    ];
};
Mesh.prototype.containsEdge = function(vertexIndex0, vertexIndex1) {
    var edgeMap = this.edgeMap;
    var keys = this.getEdgeKeys(vertexIndex0, vertexIndex1);
    if (edgeMap[keys[0]] !== undefined && edgeMap[keys[1]] !== undefined) return true;
    return false;
};
Mesh.prototype.getEdge = function(vertexIndex0, vertexIndex1) {
    var edgeMap = this.edgeMap;
    var keys = this.getEdgeKeys(vertexIndex0, vertexIndex1);
    if (edgeMap[keys[0]] !== undefined && edgeMap[keys[1]] !== undefined) return edgeMap[keys[0]];
    return;
};
Mesh.prototype.setPositions = function(positions) {
    this.positions = positions;
    var len = positions.length;
    for(var i = 0; i < len; i++){
        var vertex = new Vertex();
        vertex.setIndex(i);
        this.vertices.push(vertex);
    }
};
Mesh.prototype.getPositions = function() {
    var results = [];
    var vertices = this.vertices;
    var positions = this.positions;
    var len = vertices.length;
    for(var i = 0; i < len; i++){
        var index = vertices[i].getIndex();
        results.push(positions[index]);
    }
    return results;
};
Mesh.prototype.setCells = function(cells) {
    this.cells = cells.slice();
    var len = cells.length;
    for(var i = 0; i < len; i++){
        var face = new Face();
        face.setIndex(i);
        this.faces.push(face);
    }
    this.buildEdgeMap();
};
Mesh.prototype.getCells = function() {
    var results = [];
    var faces = this.faces;
    var vertices = this.vertices;
    var len = faces.length;
    var halfEdge;
    for(var i = 0; i < len; i++){
        var face = faces[i];
        var halfEdgeStart = halfEdge = face.getHalfEdge();
        var cell = [];
        do {
            var vertex = halfEdge.getVertex();
            var index = vertex.getIndex();
            cell.push(index);
            halfEdge = halfEdge.getNextHalfEdge();
        }while (halfEdge != halfEdgeStart)
        results.push(cell);
    }
    return results;
};
Mesh.prototype.buildEdgeMap = function() {
    var cells = this.cells;
    var edges = this.edges;
    var edgeMap = this.edgeMap;
    var len = cells.length;
    for(var i = 0; i < len; i++){
        var cell = cells[i];
        var flen = cell.length;
        for(var j = 0; j < flen; j++){
            var i0 = cell[j];
            var i1 = cell[(j + 1) % flen];
            var key0 = i0 + '-' + i1;
            var key1 = i1 + '-' + i0;
            if (edgeMap[key0] === undefined && edgeMap[key1] === undefined) {
                var edge = new Edge();
                edge.setIndex(edges.length);
                edges.push(edge);
                edgeMap[key0] = edge;
                edgeMap[key1] = edge;
            }
        }
    }
};
Mesh.prototype.process = function() {
    var edgeMap = this.edgeMap;
    var edges = this.edges;
    var cells = this.cells;
    var vertices = this.vertices;
    var faces = this.faces;
    var halfEdges = this.halfEdges;
    var clen = cells.length;
    for(var faceIndex = 0; faceIndex < clen; faceIndex++){
        var cell = cells[faceIndex];
        var face = faces[faceIndex];
        var flen = cells[faceIndex].length;
        var prevHalfEdge = undefined;
        var firstHalfEdge = undefined;
        for(var vertexIndex = 0; vertexIndex < flen; vertexIndex++){
            var vertexIndexCurr = cell[vertexIndex];
            var vertexIndexNext = cell[(vertexIndex + 1) % flen];
            var edge = edgeMap[vertexIndexCurr + '-' + vertexIndexNext];
            var vertex = vertices[vertexIndexCurr];
            //Set Half Edge Properties
            var halfedge = new HalfEdge();
            halfedge.setVertex(vertex);
            halfedge.setFace(face);
            halfedge.setEdge(edge);
            if (edge.getHalfEdge()) {
                halfedge.setFlipHalfEdge(edge.getHalfEdge());
                edge.getHalfEdge().setFlipHalfEdge(halfedge);
            } else edge.setHalfEdge(halfedge);
            if (prevHalfEdge !== undefined) prevHalfEdge.setNextHalfEdge(halfedge);
            prevHalfEdge = halfedge;
            if (vertexIndex === 0) firstHalfEdge = halfedge;
            halfEdges.push(halfedge);
            //Set Vertex Properties
            vertex.setHalfEdge(halfedge);
        }
        //Set Face Properties
        face.setHalfEdge(firstHalfEdge);
        prevHalfEdge.setNextHalfEdge(firstHalfEdge);
    }
};
module.exports = Mesh;

},{"gl-matrix":"3TXam","./Vertex":"aMW4R","./Edge":"dOHcN","./HalfEdge":"72nec","./Face":"fVwz7"}],"ePOBu":[function(require,module,exports) {
var FaceIntegrity = require('./FaceIntegrity');
var EdgeIntegrity = require('./EdgeIntegrity');
var VertexIntegrity = require('./VertexIntegrity');
var HalfEdgeIntegrity = require('./HalfEdgeIntegrity');
var Integrity = {
};
Integrity.checkMesh = function(mesh) {
    var passed = true;
    if (!this.checkFaces(mesh.getFaces())) {
        console.log('faces are messed up');
        passed = false;
    }
    if (!this.checkEdges(mesh.getEdges())) {
        console.log('edges are messed up');
        passed = false;
    }
    if (!this.checkVertices(mesh.getVertices())) {
        console.log('vertices are messed up');
        passed = false;
    }
    if (!this.checkHalfEdges(mesh.getHalfEdges())) {
        console.log('half edges are messed up');
        passed = false;
    }
    console.log('mesh is valid!');
    return passed;
};
Integrity.checkEdges = function(edges) {
    var passed = true;
    var len = edges.length;
    for(var i = 0; i < len; i++){
        var edge = edges[i];
        passed = EdgeIntegrity(edge);
    }
    return passed;
};
Integrity.checkFaces = function(faces) {
    var passed = true;
    var len = faces.length;
    for(var i = 0; i < len; i++){
        var face = faces[i];
        passed = FaceIntegrity(face);
    }
    return passed;
};
Integrity.checkVertices = function(vertices) {
    var passed = true;
    var len = vertices.length;
    for(var i = 0; i < len; i++){
        var vertex = vertices[i];
        passed = VertexIntegrity(vertex);
    }
    return passed;
};
Integrity.checkHalfEdges = function(halfEdges) {
    var passed = true;
    var len = halfEdges.length;
    for(var i = 0; i < len; i++){
        var halfedge = halfEdges[i];
        passed = HalfEdgeIntegrity(halfedge);
    }
    return passed;
};
module.exports = Integrity;

},{"./FaceIntegrity":"aJGqU","./EdgeIntegrity":"bJZiZ","./VertexIntegrity":"gBmpk","./HalfEdgeIntegrity":"hnjcF"}],"aJGqU":[function(require,module,exports) {
module.exports = function(face) {
    var passed = true;
    if (face.getIndex() === -1) {
        console.log('face: ', face.getIndex(), ' does not have a proper index');
        passed = false;
    }
    if (face.getHalfEdge() === undefined) {
        console.log('face: ', face.getIndex(), ' does not have a half edge');
        passed = false;
    }
    return passed;
};

},{}],"bJZiZ":[function(require,module,exports) {
module.exports = function(edge) {
    var passed = true;
    if (edge.getIndex() === -1) {
        console.log('edge: ', edge.getIndex(), ' does not have a proper index');
        passed = false;
    }
    if (edge.getHalfEdge() === undefined) {
        console.log('edge: ', edge.getIndex(), ' does not have a half edge');
        passed = false;
    }
    return passed;
};

},{}],"gBmpk":[function(require,module,exports) {
module.exports = function(vertex) {
    var passed = true;
    if (vertex.getIndex() === -1) {
        console.log('vertex : ', vertex.getIndex(), ' does not have a proper index');
        passed = false;
    }
    if (vertex.getHalfEdge() === undefined) {
        console.log('vertex : ', vertex.getIndex(), ' does not have a half edge');
        passed = false;
    }
    return passed;
};

},{}],"hnjcF":[function(require,module,exports) {
var HalfEdgePrev = require('./../Queries/HalfEdgePrev');
module.exports = function(halfEdge) {
    var passed = true;
    var he = halfEdge;
    if (he.getNextHalfEdge() === undefined) {
        console.log('halfEdge: does not have a next half edge');
        passed = false;
    }
    if (he.getFlipHalfEdge() === undefined) {
        console.log('halfEdge: does not have a flip half edge');
        passed = false;
    }
    if (he.getVertex() === undefined) {
        console.log('halfEdge: does not have a valid vertex');
        passed = false;
    }
    if (he.getEdge() === undefined) {
        console.log('halfEdge: does not have an edge');
        passed = false;
    }
    if (he.getFace() === undefined) {
        console.log('halfEdge: does not have a face');
        passed = false;
    }
    return passed;
};

},{"./../Queries/HalfEdgePrev":"lRsPN"}],"lRsPN":[function(require,module,exports) {
module.exports = function(he) {
    var startHalfEdge = he;
    while(he.getNextHalfEdge() != startHalfEdge)he = he.getNextHalfEdge();
    return he;
};

},{}],"bU9N9":[function(require,module,exports) {
var Integrity = require('./Integrity');
module.exports = function(mesh) {
    var passed = true;
    console.log('checking faces');
    if (!Integrity.checkFaces(mesh.getFaces())) {
        console.log('faces are messed up');
        passed = false;
    }
    console.log('checking edges');
    if (!Integrity.checkEdges(mesh.getEdges())) {
        console.log('edges are messed up');
        passed = false;
    }
    console.log('checking vertices');
    if (!Integrity.checkVertices(mesh.getVertices())) {
        console.log('vertices are messed up');
        passed = false;
    }
    console.log('checking halfedges');
    if (!Integrity.checkHalfEdges(mesh.getHalfEdges())) {
        console.log('half edges are messed up');
        passed = false;
    }
    console.log('mesh is valid!');
    return passed;
};

},{"./Integrity":"ePOBu"}],"2K4CD":[function(require,module,exports) {
module.exports = function(edge) {
    var results = [];
    var he = edge.getHalfEdge();
    results.push(he.getVertex());
    he = he.getFlipHalfEdge();
    results.push(he.getVertex());
    return results;
};

},{}],"eum8y":[function(require,module,exports) {
module.exports = function(face) {
    var originalHalfEdge = he = face.getHalfEdge();
    var halfEdges = [];
    do {
        halfEdges.push(he);
        he = he.getNextHalfEdge();
    }while (he != originalHalfEdge)
    return halfEdges;
};

},{}],"elyLX":[function(require,module,exports) {
module.exports = function(face) {
    var originalHalfEdge = he = face.getHalfEdge();
    var vertices = [];
    do {
        vertices.push(he.getVertex());
        he = he.getNextHalfEdge();
    }while (he != originalHalfEdge)
    return vertices;
};

},{}],"gqIAR":[function(require,module,exports) {
module.exports = function(vertex) {
    var startHalfEdge = originalHalfEdge = he = vertex.getHalfEdge();
    var faces = [];
    do if (he.getNextHalfEdge() === startHalfEdge) {
        faces.push(he.getFace());
        he = he.getFlipHalfEdge();
        startHalfEdge = he;
    } else he = he.getNextHalfEdge();
    while (he != originalHalfEdge)
    return faces;
};

},{}],"8DhJJ":[function(require,module,exports) {
module.exports = function(vertex) {
    var startHalfEdge = originalHalfEdge = he = vertex.getHalfEdge();
    var halfEdges = [];
    do if (he.getNextHalfEdge() === startHalfEdge) {
        he = he.getFlipHalfEdge();
        startHalfEdge = he;
        halfEdges.push(he);
    } else he = he.getNextHalfEdge();
    while (he != originalHalfEdge)
    return halfEdges;
};

},{}],"f9YBN":[function(require,module,exports) {
module.exports = function(vertex) {
    var startHalfEdge = originalHalfEdge = he = vertex.getHalfEdge();
    var neighbors = [];
    do if (he.getNextHalfEdge() === startHalfEdge) {
        neighbors.push(he.getVertex());
        he = he.getFlipHalfEdge();
        startHalfEdge = he;
    } else he = he.getNextHalfEdge();
    while (he != originalHalfEdge)
    return neighbors;
};

},{}],"kKwVL":[function(require,module,exports) {
var vec3 = require('gl-matrix').vec3;
module.exports = function(mesh) {
    var center = vec3.create();
    var positions = mesh.positions;
    var plen = positions.length;
    for(var i = 0; i < plen; i++)vec3.add(center, center, positions[i]);
    vec3.scale(center, center, 1 / plen);
    return center;
};

},{"gl-matrix":"3TXam"}],"aoQ2o":[function(require,module,exports) {
var Face = require('./../Core/Face');
var Edge = require('./../Core/Edge');
var Vertex = require('./../Core/Vertex');
var HalfEdge = require('./../Core/HalfEdge');
var vec3 = require('gl-matrix').vec3;
module.exports = function(mesh, edgeIndex, position) {
    // when you create a new vertex
    // you create a new edge
    // you create two new half edges
    // you create a new vertex
    var edges = mesh.getEdges();
    var halfEdges = mesh.getHalfEdges();
    var edgeMap = mesh.getEdgeMap();
    var vertices = mesh.getVertices();
    var positions = mesh.positions; //hack fix this <-
    var originalEdge = edges[edgeIndex];
    var originalHalfEdge = originalEdge.getHalfEdge();
    var originalHalfEdgeFace = originalHalfEdge.getFace();
    var originalHalfEdgeNext = originalHalfEdge.getNextHalfEdge();
    var originalHalfEdgeFlip = originalHalfEdge.getFlipHalfEdge();
    var originalVertex = originalHalfEdge.getVertex();
    var originalVertexIndex = originalVertex.getIndex();
    var originalVertexPosition = positions[originalVertexIndex];
    var originalVertexNext = originalHalfEdgeNext.getVertex();
    var originalVertexNextIndex = originalVertexNext.getIndex();
    var originalVertexNextPosition = positions[originalVertexNextIndex];
    var newEdge = new Edge();
    var newVertex = new Vertex();
    var newHalfEdge = new HalfEdge();
    var newHalfEdgeFlip = new HalfEdge();
    //Set New Vertex Properties
    var newVertexIndex = positions.length;
    var newVertexPosition = vec3.create();
    if (position !== undefined) vec3.copy(newVertexPosition, position);
    else {
        vec3.add(newVertexPosition, originalVertexPosition, originalVertexNextPosition);
        vec3.scale(newVertexPosition, newVertexPosition, 0.5);
    }
    newVertex.setIndex(newVertexIndex);
    newVertex.setHalfEdge(newHalfEdge);
    positions.push(newVertexPosition);
    vertices.push(newVertex);
    //Set New Half Edge Properties
    newHalfEdge.setVertex(newVertex);
    newHalfEdge.setFace(originalHalfEdgeFace);
    newHalfEdge.setNextHalfEdge(originalHalfEdgeNext);
    newHalfEdge.setFlipHalfEdge(originalHalfEdgeFlip);
    newHalfEdge.setEdge(newEdge);
    // Set Original Half Edge Properties
    originalHalfEdge.setNextHalfEdge(newHalfEdge);
    originalHalfEdge.setFlipHalfEdge(newHalfEdgeFlip);
    //fix Edge map
    var originalEdgeKey0Old = originalVertexIndex + '-' + originalVertexNextIndex;
    var originalEdgeKey1Old = originalVertexNextIndex + '-' + originalVertexIndex;
    delete edgeMap[originalEdgeKey0Old]; //deletes edge key
    delete edgeMap[originalEdgeKey1Old]; //deletes edge key
    var originalEdgeKey0New = originalVertexIndex + '-' + newVertexIndex;
    var originalEdgeKey1New = newVertexIndex + '-' + originalVertexIndex;
    edgeMap[originalEdgeKey0New] = originalEdge;
    edgeMap[originalEdgeKey1New] = originalEdge;
    newEdge.setIndex(edges.length);
    edges.push(newEdge);
    newEdge.setHalfEdge(newHalfEdge);
    var newEdgeKey0 = newVertexIndex + '-' + originalVertexNextIndex;
    var newEdgeKey1 = originalVertexNextIndex + '-' + newVertexIndex;
    edgeMap[newEdgeKey0] = newEdge;
    edgeMap[newEdgeKey1] = newEdge;
    // Set original half edge flip properties
    var originalHalfEdgeFlipFace = originalHalfEdgeFlip.getFace();
    var originalHalfEdgeFlipNext = originalHalfEdgeFlip.getNextHalfEdge();
    originalHalfEdgeFlip.setNextHalfEdge(newHalfEdgeFlip);
    originalHalfEdgeFlip.setFlipHalfEdge(newHalfEdge);
    originalHalfEdgeFlip.setEdge(newEdge);
    newHalfEdgeFlip.setNextHalfEdge(originalHalfEdgeFlipNext);
    newHalfEdgeFlip.setFlipHalfEdge(originalHalfEdge);
    newHalfEdgeFlip.setVertex(newVertex);
    newHalfEdgeFlip.setEdge(originalEdge);
    newHalfEdgeFlip.setFace(originalHalfEdgeFlipFace);
    halfEdges.push(newHalfEdgeFlip);
    return newVertex;
};

},{"./../Core/Face":"fVwz7","./../Core/Edge":"dOHcN","./../Core/Vertex":"aMW4R","./../Core/HalfEdge":"72nec","gl-matrix":"3TXam"}],"e3H1k":[function(require,module,exports) {
var Face = require('./../Core/Face');
var Edge = require('./../Core/Edge');
var HalfEdge = require('./../Core/HalfEdge');
var HalfEdgePrev = require('./../Queries/HalfEdgePrev');
var VertexHalfEdges = require('./../Queries/VertexHalfEdges');
module.exports = function(mesh, startVertexIndex, endVertexIndex) {
    // console.log( 'faceIndex:', faceIndex );
    // console.log( 'startVertexIndex:', startVertexIndex );
    // console.log( 'endVertexIndex:', endVertexIndex );
    if (startVertexIndex === endVertexIndex) throw 'illegal edge inseration: ' + startVertexIndex + ' , ' + endVertexIndex;
    var edges = mesh.getEdges();
    var halfEdges = mesh.getHalfEdges();
    var edgeMap = mesh.getEdgeMap();
    var vertices = mesh.getVertices();
    var faces = mesh.getFaces();
    var edge = mesh.getEdge(startVertexIndex, endVertexIndex);
    if (edge) // console.log( 'mesh already contains edge: ', mesh.getEdgeKeys( startVertexIndex, endVertexIndex ) );
    return; //{ edge: edge, face: faces[ edge.getHalfEdge().getFace().getIndex() ] };
    var startVertex = vertices[startVertexIndex];
    var endVertex = vertices[endVertexIndex];
    var cfaces = commonFaces(startVertex, endVertex);
    var clen = cfaces.length;
    var halfEdgeA, halfEdgeB, halfEdgeC, halfEdgeD;
    for(var i = 0; i < clen; i++){
        var face = faces[cfaces[i]];
        var faceHalfEdge = face.getHalfEdge();
        var he = faceHalfEdge;
        do {
            var vertexIndex = he.getVertex().getIndex();
            // var vertexIndexNext = hef.getVertex().getIndex();
            if (vertexIndex === startVertexIndex) halfEdgeA = he;
            if (vertexIndex === endVertexIndex) halfEdgeC = he;
            he = he.getNextHalfEdge();
        }while (he != faceHalfEdge)
        if (halfEdgeC != undefined || halfEdgeA != undefined) break;
        halfEdgeC = undefined;
        halfEdgeA = undefined;
    }
    // console.log( halfEdgeC );
    // console.log( halfEdgeA );
    halfEdgeB = HalfEdgePrev(halfEdgeC);
    halfEdgeD = HalfEdgePrev(halfEdgeA);
    if (halfEdgeA === undefined || halfEdgeB === undefined || halfEdgeC === undefined || halfEdgeD === undefined) throw 'error finding neighboring half edges when inserting edge';
    // Set New Edge Properties
    var newEdge = new Edge();
    newEdge.setIndex(edges.length);
    var edgeKeys = mesh.getEdgeKeys(startVertexIndex, endVertexIndex);
    edgeMap[edgeKeys[0]] = newEdge;
    edgeMap[edgeKeys[1]] = newEdge;
    edges.push(newEdge);
    var newFace = new Face();
    newFace.setIndex(faces.length);
    faces.push(newFace);
    //create new half edges
    var newHalfEdgeAB = new HalfEdge();
    var newHalfEdgeCD = new HalfEdge();
    newHalfEdgeAB.setNextHalfEdge(halfEdgeA);
    newHalfEdgeAB.setFlipHalfEdge(newHalfEdgeCD);
    newHalfEdgeAB.setVertex(endVertex);
    newHalfEdgeAB.setEdge(newEdge);
    newHalfEdgeAB.setFace(face);
    halfEdges.push(newHalfEdgeAB);
    newHalfEdgeCD.setNextHalfEdge(halfEdgeC);
    newHalfEdgeCD.setFlipHalfEdge(newHalfEdgeAB);
    newHalfEdgeCD.setVertex(startVertex);
    newHalfEdgeCD.setEdge(newEdge);
    newHalfEdgeCD.setFace(newFace);
    halfEdges.push(newHalfEdgeCD);
    //set all other edge & halfedge & face properties so they are accurate
    newEdge.setHalfEdge(newHalfEdgeAB);
    face.setHalfEdge(newHalfEdgeAB);
    newFace.setHalfEdge(newHalfEdgeCD);
    halfEdgeD.setNextHalfEdge(newHalfEdgeCD);
    halfEdgeB.setNextHalfEdge(newHalfEdgeAB);
    setHalfEdgeLoopFace(newHalfEdgeCD, newFace);
    setHalfEdgeLoopFace(newHalfEdgeAB, face);
    return {
        edge: newEdge,
        face: newFace
    };
};
function commonFaces(vertex0, vertex1) {
    var results = {
    };
    var hes0 = VertexHalfEdges(vertex0);
    var hes0l = hes0.length;
    var hes1 = VertexHalfEdges(vertex1);
    var hes1l = hes1.length;
    for(var i = 0; i < hes0l; i++){
        var he0f = hes0[i].getFace();
        for(var j = 0; j < hes1l; j++){
            var he1f = hes1[j].getFace();
            if (he0f.getIndex() === he1f.getIndex()) results[he0f.getIndex()] = he1f;
        }
    }
    return Object.keys(results);
}
function setHalfEdgeLoopFace(he, face) {
    var starthe = he;
    do {
        he.setFace(face);
        he = he.getNextHalfEdge();
    }while (he != starthe)
}

},{"./../Core/Face":"fVwz7","./../Core/Edge":"dOHcN","./../Core/HalfEdge":"72nec","./../Queries/HalfEdgePrev":"lRsPN","./../Queries/VertexHalfEdges":"8DhJJ"}],"69uv4":[function(require,module,exports) {
var Face = require('./../Core/Face');
var Edge = require('./../Core/Edge');
var HalfEdge = require('./../Core/HalfEdge');
var HalfEdgePrev = require('./../Queries/HalfEdgePrev');
module.exports = function(mesh, edgeIndex) {
    var edges = mesh.getEdges();
    var edge = edges[edgeIndex];
    var edgeHalfEdge = edge.getHalfEdge();
    var edgeHalfEdgePrev = HalfEdgePrev(edgeHalfEdge);
    var edgeHalfEdgeNext = edgeHalfEdge.getNextHalfEdge();
    var edgeHalfEdgeVertex = edgeHalfEdge.getVertex();
    var edgeHalfEdgeFace = edgeHalfEdge.getFace();
    var edgeHalfEdgeFlip = edgeHalfEdge.getFlipHalfEdge();
    var edgeHalfEdgeFlipPrev = HalfEdgePrev(edgeHalfEdgeFlip);
    var edgeHalfEdgeFlipNext = edgeHalfEdgeFlip.getNextHalfEdge();
    var edgeHalfEdgeFlipVertex = edgeHalfEdgeFlip.getVertex();
    var edgeHalfEdgeFlipFace = edgeHalfEdgeFlip.getFace();
    // Set Face Half Edge
    edgeHalfEdgeFace.setHalfEdge(edgeHalfEdgeNext);
    //Set Half Edge Face Properties
    edgeHalfEdgePrev.setNextHalfEdge(edgeHalfEdgeFlipNext);
    edgeHalfEdgeVertex.setHalfEdge(edgeHalfEdgeFlipNext);
    // Set Half Edge Flip Face Properties
    edgeHalfEdgeFlipPrev.setNextHalfEdge(edgeHalfEdgeNext);
    edgeHalfEdgeFlipVertex.setHalfEdge(edgeHalfEdgeNext);
    // Remove Half Edge Flip Face
    var faces = mesh.getFaces();
    faces.splice(edgeHalfEdgeFlipFace.getIndex(), 1);
    var flen = faces.length;
    for(var i = 0; i < flen; i++)faces[i].setIndex(i);
    // Remove Edge from Edges Array
    edges.splice(edgeIndex, 1);
    var elen = edges.length;
    for(var i = 0; i < elen; i++)edges[i].setIndex(i);
    // Remove Edge from Edge Hash Map
    var keys = mesh.getEdgeKeys(edgeHalfEdgeVertex.getIndex(), edgeHalfEdgeFlipVertex.getIndex());
    var edgeMap = mesh.getEdgeMap();
    delete edgeMap[keys[0]];
    delete edgeMap[keys[1]];
};

},{"./../Core/Face":"fVwz7","./../Core/Edge":"dOHcN","./../Core/HalfEdge":"72nec","./../Queries/HalfEdgePrev":"lRsPN"}],"5MnuS":[function(require,module,exports) {
var vec3 = require('gl-matrix').vec3;
var FaceVertices = require('./../Queries/FaceVertices');
var VertexNeighbors = require('./../Queries/VertexNeighbors');
var InsertVertex = require('./InsertVertex');
var InsertEdge = require('./InsertEdge');
module.exports = function(mesh) {
    var positions = mesh.positions;
    var plen = positions.length;
    var newPositions = [];
    for(var i = 0; i < plen; i++)newPositions.push(vec3.create());
    var vertices = mesh.getVertices();
    var vlen = vertices.length;
    var beta;
    for(var i = 0; i < vlen; i++){
        var vertex = vertices[i];
        var vertexIndex = vertex.getIndex();
        var vertexPos = positions[vertexIndex];
        var newPos = newPositions[vertexIndex];
        var neighbors = VertexNeighbors(vertex);
        var nlen = neighbors.length;
        if (nlen === 3) beta = 0.1875;
        else if (nlen > 3) beta = (0.625 - Math.pow(0.375 + 0.25 * Math.cos(Math.PI * 2 / nlen), 2)) / nlen;
        vec3.scaleAndAdd(newPos, newPos, vertexPos, 1 - nlen * beta);
        for(var j = 0; j < nlen; j++){
            var neighborPos = positions[neighbors[j].getIndex()];
            vec3.scaleAndAdd(newPos, newPos, neighborPos, beta);
        }
    }
    var edges = mesh.getEdges();
    var len = edges.length;
    var newVerts = [];
    var vertexAdjacentFactor = 0.375;
    var vertexOppositeFactor = 0.125;
    var newPos = vec3.create();
    for(var i = 0; i < len; i++){
        vec3.set(newPos, 0, 0, 0);
        var edge = edges[i];
        var halfEdge = edge.getHalfEdge();
        var halfEdgeFlip = halfEdge.getFlipHalfEdge();
        var halfEdgeTop = halfEdge.getNextHalfEdge().getNextHalfEdge();
        var halfEdgeFlipTop = halfEdgeFlip.getNextHalfEdge().getNextHalfEdge();
        var halfEdgeVertex = halfEdge.getVertex();
        var halfEdgeFlipVertex = halfEdgeFlip.getVertex();
        var halfEdgeTopVertex = halfEdgeTop.getVertex();
        var halfEdgeFlipTopVertex = halfEdgeFlipTop.getVertex();
        var halfEdgeVertexPos = positions[halfEdgeVertex.getIndex()];
        var halfEdgeFlipVertexPos = positions[halfEdgeFlipVertex.getIndex()];
        var halfEdgeTopVertexPos = positions[halfEdgeTopVertex.getIndex()];
        var halfEdgeFlipTopVertexPos = positions[halfEdgeFlipTopVertex.getIndex()];
        vec3.scaleAndAdd(newPos, newPos, halfEdgeVertexPos, vertexAdjacentFactor);
        vec3.scaleAndAdd(newPos, newPos, halfEdgeFlipVertexPos, vertexAdjacentFactor);
        vec3.scaleAndAdd(newPos, newPos, halfEdgeTopVertexPos, vertexOppositeFactor);
        vec3.scaleAndAdd(newPos, newPos, halfEdgeFlipTopVertexPos, vertexOppositeFactor);
        newVerts.push(InsertVertex(mesh, edge.getIndex(), newPos));
    }
    var faces = mesh.getFaces();
    var flen = faces.length;
    var result;
    for(var i = 0; i < flen; i++){
        var face = faces[i];
        var vertices = FaceVertices(face);
        var vlen = vertices.length;
        var v1 = vertices[1];
        var v3 = vertices[3];
        var v5 = vertices[5];
        result = InsertEdge(mesh, v1.getIndex(), v3.getIndex());
        result = InsertEdge(mesh, v3.getIndex(), v5.getIndex());
        result = InsertEdge(mesh, v5.getIndex(), v1.getIndex());
    }
    for(var i = 0; i < plen; i++)vec3.copy(positions[i], newPositions[i]);
};

},{"gl-matrix":"3TXam","./../Queries/FaceVertices":"elyLX","./../Queries/VertexNeighbors":"f9YBN","./InsertVertex":"aoQ2o","./InsertEdge":"e3H1k"}],"cnkNJ":[function(require,module,exports) {
var VertexNeighbors = require('./../Queries/VertexNeighbors');
var FaceVertices = require('./../Queries/FaceVertices');
var FaceHalfEdges = require('./../Queries/FaceHalfEdges');
var VertexHalfEdges = require('./../Queries/VertexHalfEdges');
var InsertVertex = require('./InsertVertex');
var InsertEdge = require('./InsertEdge');
var vec3 = require('gl-matrix').vec3;
module.exports = function(mesh) {
    var newPositions = [];
    var positions = mesh.positions;
    var plen = positions.length;
    for(var i = 0; i < plen; i++)newPositions.push(vec3.clone(positions[i]));
    var tmp = vec3.create();
    var newPos = vec3.create();
    //calculate new original vertex positions
    var vertices = mesh.getVertices();
    var vlen = vertices.length;
    var kmap = {
    };
    for(var i = 0; i < 32; i++){
        var beta = 3 / (2 * i);
        var rho = 1 / (4 * i);
        kmap[i] = [
            1 - beta - rho,
            beta / i,
            rho / i
        ];
    }
    for(var i = 0; i < vlen; i++){
        var vertex = vertices[i];
        var vertexIndex = vertex.getIndex();
        var vertexPos = positions[vertexIndex];
        var neighbors = VertexHalfEdges(vertex);
        var nlen = neighbors.length;
        var kernel = kmap[nlen];
        vec3.copy(newPos, vertexPos);
        vec3.scale(newPos, newPos, kernel[0]);
        for(var j = 0; j < nlen; j++){
            var he = neighbors[j];
            var hen = he.getNextHalfEdge();
            var v0iPos = positions[hen.getVertex().getIndex()];
            vec3.scaleAndAdd(newPos, newPos, v0iPos, kernel[1]);
            var henn = hen.getNextHalfEdge();
            var v1iPos = positions[henn.getVertex().getIndex()];
            vec3.scaleAndAdd(newPos, newPos, v1iPos, kernel[2]);
        }
        vec3.copy(newPositions[vertexIndex], newPos);
    }
    //Calculate Face Verts
    var faceVerticesPosHash = {
    };
    var faces = mesh.getFaces();
    var flen = faces.length;
    for(var i = 0; i < flen; i++){
        var face = faces[i];
        var faceVertices = FaceVertices(face);
        var vlen = faceVertices.length;
        var faceVertexPos = vec3.create();
        faceVerticesPosHash[face.getIndex()] = faceVertexPos;
        for(var j = 0; j < vlen; j++){
            var vertex = faceVertices[j];
            var vertexIndex = vertex.getIndex();
            var vertexPos = positions[vertexIndex];
            vec3.scaleAndAdd(faceVertexPos, faceVertexPos, vertexPos, 0.25);
        }
    }
    //Calculate Edge Verts
    var edgeVerticesPosHash = {
    };
    var edges = mesh.getEdges();
    var elen = edges.length;
    for(var i = 0; i < elen; i++){
        var edge = edges[i];
        var edgeVertexPos = vec3.create();
        edgeVerticesPosHash[edge.getIndex()] = edgeVertexPos;
        var he = edge.getHalfEdge();
        var heVertex = he.getVertex();
        var heVertexPos = positions[heVertex.getIndex()];
        vec3.scaleAndAdd(edgeVertexPos, edgeVertexPos, heVertexPos, 0.375);
        var heVertexPos0 = positions[he.getNextHalfEdge().getNextHalfEdge().getVertex().getIndex()];
        var heVertexPos1 = positions[he.getNextHalfEdge().getNextHalfEdge().getNextHalfEdge().getVertex().getIndex()];
        vec3.scaleAndAdd(edgeVertexPos, edgeVertexPos, heVertexPos0, 0.0625);
        vec3.scaleAndAdd(edgeVertexPos, edgeVertexPos, heVertexPos1, 0.0625);
        var hef = he.getFlipHalfEdge();
        var hefVertex = hef.getVertex();
        var hefVertexPos = positions[hefVertex.getIndex()];
        vec3.scaleAndAdd(edgeVertexPos, edgeVertexPos, hefVertexPos, 0.375);
        var hefVertexPos0 = positions[hef.getNextHalfEdge().getNextHalfEdge().getVertex().getIndex()];
        var hefVertexPos1 = positions[hef.getNextHalfEdge().getNextHalfEdge().getNextHalfEdge().getVertex().getIndex()];
        vec3.scaleAndAdd(edgeVertexPos, edgeVertexPos, hefVertexPos0, 0.0625);
        vec3.scaleAndAdd(edgeVertexPos, edgeVertexPos, hefVertexPos1, 0.0625);
    }
    // console.log( edgeVerticesPosHash );
    // insert edges and set vertex positions
    for(var i = 0; i < elen; i++){
        var edge = edges[i];
        var edgeIndex = edge.getIndex();
        InsertVertex(mesh, edge.getIndex(), edgeVerticesPosHash[edgeIndex]);
    }
    var edgeVertices = {
    };
    for(var i = 0; i < flen; i++){
        var face = faces[i];
        edgeVertices[face.getIndex()] = [];
        var vertices = FaceVertices(face);
        var vlen = vertices.length;
        for(var j = 0; j < vlen; j++){
            var vertex = vertices[j];
            var neighbors = VertexNeighbors(vertex);
            if (neighbors.length == 2) edgeVertices[face.getIndex()].push(vertex);
        }
    }
    var keys = Object.keys(edgeVertices);
    for(var i = 0; i < keys.length; i++){
        var faceIndex = keys[i];
        var vertices = edgeVertices[faceIndex];
        var v0 = vertices[0];
        var v1 = vertices[1];
        var v2 = vertices[2];
        var v3 = vertices[3];
        var result = InsertEdge(mesh, v0.getIndex(), v2.getIndex());
        var cv = InsertVertex(mesh, result.edge.getIndex(), faceVerticesPosHash[faceIndex]);
        edgeVertices[faceIndex].push(cv);
        InsertEdge(mesh, v1.getIndex(), cv.getIndex());
        InsertEdge(mesh, v3.getIndex(), cv.getIndex());
    }
    for(var i = 0; i < plen; i++)vec3.copy(positions[i], newPositions[i]);
};

},{"./../Queries/VertexNeighbors":"f9YBN","./../Queries/FaceVertices":"elyLX","./../Queries/FaceHalfEdges":"eum8y","./../Queries/VertexHalfEdges":"8DhJJ","./InsertVertex":"aoQ2o","./InsertEdge":"e3H1k","gl-matrix":"3TXam"}],"dLOrr":[function(require,module,exports) {
var vec3 = require('gl-matrix').vec3;
var VertexNeighbors = require('./../Queries/VertexNeighbors');
var FaceVertices = require('./../Queries/FaceVertices');
var InsertVertex = require('./InsertVertex');
var InsertEdge = require('./InsertEdge');
module.exports = function(mesh) {
    var edges = mesh.getEdges();
    var elen = edges.length;
    var edgeVertices = {
    };
    for(var i = 0; i < elen; i++){
        var edge = edges[i];
        InsertVertex(mesh, edge.getIndex());
    }
    var faces = mesh.getFaces();
    var flen = faces.length;
    for(var i = 0; i < flen; i++){
        var face = faces[i];
        edgeVertices[face.getIndex()] = [];
        var vertices = FaceVertices(face);
        var vlen = vertices.length;
        for(var j = 0; j < vlen; j++){
            var vertex = vertices[j];
            var neighbors = VertexNeighbors(vertex);
            if (neighbors.length == 2) edgeVertices[face.getIndex()].push(vertex);
        }
    }
    var keys = Object.keys(edgeVertices);
    for(var i = 0; i < keys.length; i++){
        var faceIndex = keys[i];
        var vertices = edgeVertices[faceIndex];
        var v0 = vertices[0];
        var v1 = vertices[1];
        var v2 = vertices[2];
        var v3 = vertices[3];
        var result = InsertEdge(mesh, v0.getIndex(), v2.getIndex());
        var cv = InsertVertex(mesh, result.edge.getIndex());
        edgeVertices[faceIndex].push(cv);
        InsertEdge(mesh, v1.getIndex(), cv.getIndex());
        InsertEdge(mesh, v3.getIndex(), cv.getIndex());
    }
};

},{"gl-matrix":"3TXam","./../Queries/VertexNeighbors":"f9YBN","./../Queries/FaceVertices":"elyLX","./InsertVertex":"aoQ2o","./InsertEdge":"e3H1k"}],"1FODs":[function(require,module,exports) {
var FaceVertices = require('./../Queries/FaceVertices');
var calculateNormal = require('guf').calculateNormal;
var triangulatePolygon = require('cga').triangulatePolygon2;
var vec3 = require('gl-matrix').vec3;
var quat = require('gl-matrix').quat;
var InsertEdge = require('./InsertEdge');
module.exports = function(mesh) {
    // console.log( 'starting triangulation' );
    var positions = mesh.positions;
    var faces = mesh.getFaces();
    var flen = faces.length;
    var zAxis = vec3.fromValues(0, 0, 1);
    var res = {
    };
    for(var i = 0; i < flen; i++){
        var face = faces[i];
        var vertices = FaceVertices(face);
        var vlen = vertices.length;
        if (vlen === 3) continue;
        var v0 = positions[vertices[0].getIndex()];
        var v1 = positions[vertices[1].getIndex()];
        var v2 = positions[vertices[2].getIndex()];
        var normal = calculateNormal(v0, v1, v2);
        var faceOri = quat.create();
        quat.rotationTo(faceOri, normal, zAxis);
        var polygon = [];
        var indicies = [];
        for(var j = 0; j < vlen; j++){
            var vertex = vertices[j];
            var vertexIndex = vertex.getIndex();
            var vertexPos = vec3.clone(positions[vertexIndex]);
            vec3.transformQuat(vertexPos, vertexPos, faceOri);
            polygon.push([
                vertexPos[0],
                vertexPos[1]
            ]);
            indicies.push(vertexIndex);
        }
        var results = triangulatePolygon(polygon);
        var rlen = results.length;
        for(var k = 0; k < rlen; k++){
            var result = results[k];
            var i1 = indicies[result[1]];
            var i2 = indicies[result[2]];
            InsertEdge(mesh, i1, i2);
        }
    }
};

},{"./../Queries/FaceVertices":"elyLX","guf":"hlcpy","cga":"6OXri","gl-matrix":"3TXam","./InsertEdge":"e3H1k"}],"hlcpy":[function(require,module,exports) {
//ARRAYS
exports.normalizeArray = require('./guf/normalize-array');
//NORMALS
exports.faceNormals = require('./guf/face-normals');
exports.vertexNormals = require('./guf/vertex-normals');
//ONE NORMAL
exports.calculateNormal = require('./guf/calculate-normal');
//HELPFUL UTILS
exports.cross = require('./guf/cross');
exports.normalize = require('./guf/normalize');

},{"./guf/normalize-array":"hbYme","./guf/face-normals":"pRQIg","./guf/vertex-normals":"4Wsz2","./guf/calculate-normal":"2LifG","./guf/cross":"2QhQE","./guf/normalize":"dO7Tz"}],"hbYme":[function(require,module,exports) {
module.exports = function(a) {
    var result = [];
    var len = a.length;
    var slen = a[0].length;
    var addZ = slen < 3 ? true : false;
    for(var i = 0; i < len; i++){
        for(var j = 0; j < slen; j++)result.push(a[i][j]);
        if (addZ) result.push(0);
    }
    return result;
};

},{}],"pRQIg":[function(require,module,exports) {
var normalize = require('guf').normalizeArray;
var calculateNormal = require('./calculate-normal');
module.exports = function(verts, faces) {
    var positions = verts;
    var con = verts[0].constructor;
    if (con === Array || con == Float32Array) positions = normalize(verts);
    var cells = faces[0].constructor === Array ? normalize(faces) : faces;
    var normals = [];
    var i0, i1, i2;
    var a = [];
    var b = [];
    var c = [];
    var d = [];
    for(var i = 0; i < cells.length; i += 3){
        i0 = cells[i] * 3;
        i1 = cells[i + 1] * 3;
        i2 = cells[i + 2] * 3;
        a[0] = positions[i0];
        a[1] = positions[i0 + 1];
        a[2] = positions[i0 + 2];
        b[0] = positions[i1];
        b[1] = positions[i1 + 1];
        b[2] = positions[i1 + 2];
        c[0] = positions[i2];
        c[1] = positions[i2 + 1];
        c[2] = positions[i2 + 2];
        d = calculateNormal(a, b, c);
        normals[i] = d[0];
        normals[i + 1] = d[1];
        normals[i + 2] = d[2];
    }
    return normals;
};

},{"guf":"hlcpy","./calculate-normal":"2LifG"}],"2LifG":[function(require,module,exports) {
var cross = require('./cross');
var normalize = require('./normalize');
module.exports = function(a, b, c) {
    var r = [
        0,
        0,
        0
    ];
    cross(r, a, b, c);
    normalize(r, r);
    return r;
};

},{"./cross":"2QhQE","./normalize":"dO7Tz"}],"2QhQE":[function(require,module,exports) {
module.exports = function(out, a, b, c) {
    var abx = b[0] - a[0], aby = b[1] - a[1], abz = b[2] - a[2], acx = c[0] - a[0], acy = c[1] - a[1], acz = c[2] - a[2];
    out[0] = aby * acz - abz * acy;
    out[1] = abz * acx - abx * acz;
    out[2] = abx * acy - aby * acx;
    return out;
};

},{}],"dO7Tz":[function(require,module,exports) {
module.exports = function(out, v) {
    var length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
    out[0] = v[0] / length;
    out[1] = v[1] / length;
    out[2] = v[2] / length;
    return out;
};

},{}],"4Wsz2":[function(require,module,exports) {
var cross = require('./cross');
var normalize = require('./normalize');
var normalizeArray = require('./normalize-array');
module.exports = function(verts, faces) {
    var positions = verts[0].constructor === Array ? normalizeArray(verts) : verts;
    var cells = faces[0].constructor === Array ? normalizeArray(faces) : faces;
    //Create Vertex Face Map ( tells you which vert belong to what faces )
    var map = {
    };
    var plen = positions.length / 3;
    for(var i = 0; i < plen; i++)map[i] = [];
    //Fill in Map
    var clen = cells.length;
    var i0, i1, i2, index;
    for(var i = 0; i < clen; i += 3){
        index = i;
        i0 = index;
        i1 = index + 1;
        i2 = index + 2;
        map[cells[i0]].push(i);
        map[cells[i1]].push(i);
        map[cells[i2]].push(i);
    }
    //Calculate Vertex Normals
    var normals = [];
    var temp = [
        0,
        0,
        0
    ];
    var norm = [
        0,
        0,
        0
    ];
    var keys = Object.keys(map);
    var v0, v1, v2, a = [
        0,
        0,
        0
    ], b = [
        0,
        0,
        0
    ], c = [
        0,
        0,
        0
    ];
    for(var i = 0; i < keys.length; i++){
        var faces = map[keys[i]];
        for(var j = 0; j < faces.length; j++){
            var index = faces[j];
            v0 = cells[index];
            v1 = cells[index + 1];
            v2 = cells[index + 2];
            a[0] = positions[v0 * 3];
            a[1] = positions[v0 * 3 + 1];
            a[2] = positions[v0 * 3 + 2];
            b[0] = positions[v1 * 3];
            b[1] = positions[v1 * 3 + 1];
            b[2] = positions[v1 * 3 + 2];
            c[0] = positions[v2 * 3];
            c[1] = positions[v2 * 3 + 1];
            c[2] = positions[v2 * 3 + 2];
            cross(temp, a, b, c);
            norm[0] += temp[0];
            norm[1] += temp[1];
            norm[2] += temp[2];
        }
        normalize(norm, norm);
        normals.push(norm[0], norm[1], norm[2]);
        norm[0] = 0;
        norm[1] = 0;
        norm[2] = 0;
    }
    return normals;
};

},{"./cross":"2QhQE","./normalize":"dO7Tz","./normalize-array":"hbYme"}],"6OXri":[function(require,module,exports) {
//1D Functions
exports.greaterThanZero = require("./cga/greater-than-zero-1d.js");
exports.isEqual = require("./cga/is-equal-1d.js");
exports.isZero = require("./cga/is-zero-1d.js");
//2D Functions
exports.area2 = require("./cga/area2-2d.js");
exports.convexHull2 = require("./cga/convex-hull-2d.js");
exports.cross2 = require("./cga/cross-2d.js");
exports.expandPolygon2 = require("./cga/expand-polygon-2d.js");
exports.inCone2 = require("./cga/in-cone-2d.js");
exports.intersection2 = require("./cga/intersection-2d.js");
exports.intersects2 = require("./cga/intersects-2d.js");
exports.intersectsProper2 = require("./cga/intersects-proper-2d.js");
exports.isBetween2 = require("./cga/is-between-2d.js");
exports.isColinear2 = require("./cga/is-colinear-2d.js");
exports.isDiagonal2 = require("./cga/is-diagonal-2d.js");
exports.isDiagonalie2 = require("./cga/is-diagonalie-2d.js");
exports.isEqual2 = require("./cga/is-equal-2d.js");
exports.isLeft2 = require("./cga/is-left-2d.js");
exports.isLeftOn2 = require("./cga/is-left-on-2d.js");
exports.triangulatePolygon2 = require("./cga/triangulate-polygon-2d.js");
//3D Functions
exports.isColinear3 = require("./cga/is-colinear-3d.js");

},{"./cga/greater-than-zero-1d.js":"2i5lt","./cga/is-equal-1d.js":"3tsmP","./cga/is-zero-1d.js":"bzoFj","./cga/area2-2d.js":"jmO8T","./cga/convex-hull-2d.js":"bVbna","./cga/cross-2d.js":"66ave","./cga/expand-polygon-2d.js":"dPgq8","./cga/in-cone-2d.js":"3D3fk","./cga/intersection-2d.js":"hL4qm","./cga/intersects-2d.js":"JHiGh","./cga/intersects-proper-2d.js":"hFVyS","./cga/is-between-2d.js":"gs80s","./cga/is-colinear-2d.js":"avCJ3","./cga/is-diagonal-2d.js":"3uoBd","./cga/is-diagonalie-2d.js":"cykSS","./cga/is-equal-2d.js":"e4Ra3","./cga/is-left-2d.js":"kloc4","./cga/is-left-on-2d.js":"1Bcyb","./cga/triangulate-polygon-2d.js":"kAGmZ","./cga/is-colinear-3d.js":"fgQl4"}],"2i5lt":[function(require,module,exports) {
module.exports = function(a) {
    return a > 0.00001;
};

},{}],"3tsmP":[function(require,module,exports) {
var isZero = require('./is-zero-1d');
module.exports = function(a, b) {
    return a === b || isZero(a - b);
};

},{"./is-zero-1d":"bzoFj"}],"bzoFj":[function(require,module,exports) {
module.exports = function(a) {
    return a === 0 || Math.abs(a) < 0.000001;
};

},{}],"jmO8T":[function(require,module,exports) {
module.exports = function(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
};

},{}],"bVbna":[function(require,module,exports) {
var isEqual = require('./is-equal-1d');
var isLeft = require('./is-left-2d');
module.exports = function(polygon) {
    // find the lowest rightmost point
    var ri = -1;
    var rx = -1000000, ry = 10000000;
    var len = polygon.length;
    var x, y;
    for(var i = 0; i < len; i++){
        x = polygon[i][0];
        y = polygon[i][1];
        if (y < ry || y == ry && x > rx) {
            ri = i;
            rx = x;
            ry = y;
        }
    }
    // calculate the angles (relative to the positive x-axis) from bottom
    // right most point and every other point
    var angles = [];
    for(var i = 0; i < len; i++){
        x = polygon[i][0] - rx;
        y = polygon[i][1] - ry;
        angles[i] = {
            'key': i,
            'value': Math.atan2(y, x),
            'length': x * x + y * y
        };
    }
    // sort the angles, keep the indicies of the original points for referece
    angles.sort(function(a, b) {
        if (isEqual(a.value, b.value)) return 0;
        else if (a.value < b.value) return -1;
        return 1;
    });
    // remove points that have the same angle ( only remove the one closest to
    // the bottom right most point )
    var a1, b1;
    for(var i = 1; i < angles.length; i++){
        a1 = angles[i - 1];
        b1 = angles[i];
        if (isEqual(a1.value, b1.value)) {
            if (a1.length > b1.length) angles.splice(i, 1); //remove b ( 1 )
            else angles.splice(i - 1, 1); //remove a ( 0 )
            i--;
        }
    }
    // use graham's algorithm to find the convex hull ( checks
    // to see if the next point on the stack turns left or right
    // if it turns right, the remove it and test again till you turn left
    var i = 1;
    var limit = angles.length;
    var index;
    var stack = [
        angles[limit - 1].key,
        ri
    ];
    while(i < limit){
        index = angles[i].key;
        var s = stack.length - 1;
        var sl = s - 1;
        if (isLeft(polygon[stack[sl]], polygon[stack[s]], polygon[index])) {
            stack.push(index);
            i++;
        } else stack.pop();
    }
    return stack;
};

},{"./is-equal-1d":"3tsmP","./is-left-2d":"kloc4"}],"kloc4":[function(require,module,exports) {
var greaterThanZero = require('./greater-than-zero-1d');
var area2 = require('./area2-2d');
module.exports = function(a, b, c) {
    return greaterThanZero(area2(a, b, c));
};

},{"./greater-than-zero-1d":"2i5lt","./area2-2d":"jmO8T"}],"66ave":[function(require,module,exports) {
module.exports = function(a, b) {
    return a[0] * b[1] - b[0] * a[1];
};

},{}],"dPgq8":[function(require,module,exports) {
var vec2 = require('gl-matrix').vec2;
var vec3 = require('gl-matrix').vec3;
var intersection = require('./intersection-2d');
module.exports = function(polygon, amount) {
    amount = amount == undefined ? 0.5 : amount;
    var result = [];
    var len = polygon.length;
    var cpr = vec3.create();
    var zdir = vec3.fromValues(0, 0, 1);
    var cdir = vec3.create();
    var a = vec2.create();
    var b = vec2.create();
    var c = vec2.create();
    var d = vec2.create();
    var dir = vec2.create();
    var at, bt, ct, t;
    // Preform first a, b, calculation so we optimise loop
    at = polygon[len - 1];
    bt = polygon[0];
    vec2.copy(a, at);
    vec2.copy(b, bt);
    vec2.subtract(dir, b, a);
    vec3.set(cdir, dir[0], dir[1], 0);
    vec3.cross(cpr, cdir, zdir);
    vec3.normalize(cpr, cpr);
    vec3.scale(cpr, cpr, amount);
    vec2.copy(dir, cpr);
    vec2.add(a, a, dir);
    vec2.add(b, b, dir);
    for(var i = 0; i < len; i++){
        bt = polygon[i];
        ct = polygon[(i + 1) % len];
        vec2.copy(c, bt);
        vec2.copy(d, ct);
        vec2.subtract(dir, d, c);
        vec3.set(cdir, dir[0], dir[1], 0);
        vec3.cross(cpr, cdir, zdir);
        vec3.normalize(cpr, cpr);
        vec3.scale(cpr, cpr, amount);
        vec2.copy(dir, cpr);
        vec2.add(c, c, dir);
        vec2.add(d, d, dir);
        result.push(intersection(a, b, c, d));
        vec2.copy(a, c);
        vec2.copy(b, d);
    }
    return result;
};

},{"gl-matrix":"kzvF6","./intersection-2d":"hL4qm"}],"kzvF6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "glMatrix", ()=>_commonJs
);
parcelHelpers.export(exports, "mat2", ()=>_mat2Js
);
parcelHelpers.export(exports, "mat2d", ()=>_mat2DJs
);
parcelHelpers.export(exports, "mat3", ()=>_mat3Js
);
parcelHelpers.export(exports, "mat4", ()=>_mat4Js
);
parcelHelpers.export(exports, "quat", ()=>_quatJs
);
parcelHelpers.export(exports, "quat2", ()=>_quat2Js
);
parcelHelpers.export(exports, "vec2", ()=>_vec2Js
);
parcelHelpers.export(exports, "vec3", ()=>_vec3Js
);
parcelHelpers.export(exports, "vec4", ()=>_vec4Js
);
var _commonJs = require("./gl-matrix/common.js");
var _mat2Js = require("./gl-matrix/mat2.js");
var _mat2DJs = require("./gl-matrix/mat2d.js");
var _mat3Js = require("./gl-matrix/mat3.js");
var _mat4Js = require("./gl-matrix/mat4.js");
var _quatJs = require("./gl-matrix/quat.js");
var _quat2Js = require("./gl-matrix/quat2.js");
var _vec2Js = require("./gl-matrix/vec2.js");
var _vec3Js = require("./gl-matrix/vec3.js");
var _vec4Js = require("./gl-matrix/vec4.js");

},{"./gl-matrix/common.js":"fLrSS","./gl-matrix/mat2.js":"cAnzp","./gl-matrix/mat2d.js":"7P4Yo","./gl-matrix/mat3.js":"62qxW","./gl-matrix/mat4.js":"4qMJv","./gl-matrix/quat.js":"lPOiD","./gl-matrix/quat2.js":"aGpcr","./gl-matrix/vec2.js":"1PFsL","./gl-matrix/vec3.js":"baThR","./gl-matrix/vec4.js":"eMR41","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fLrSS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EPSILON", ()=>EPSILON
);
parcelHelpers.export(exports, "ARRAY_TYPE", ()=>ARRAY_TYPE
);
parcelHelpers.export(exports, "RANDOM", ()=>RANDOM
);
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */ parcelHelpers.export(exports, "setMatrixArrayType", ()=>setMatrixArrayType
);
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */ parcelHelpers.export(exports, "toRadian", ()=>toRadian
);
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
function setMatrixArrayType(type) {
    ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
function toRadian(a) {
    return a * degree;
}
function equals(a, b) {
    return Math.abs(a - b) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cAnzp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 2x2 Matrix
 * @module mat2
 */ /**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "transpose", ()=>transpose
);
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "adjoint", ()=>adjoint
);
/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */ parcelHelpers.export(exports, "determinant", ()=>determinant
);
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "fromScaling", ()=>fromScaling
);
/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */ parcelHelpers.export(exports, "frob", ()=>frob
);
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */ parcelHelpers.export(exports, "LDU", ()=>LDU
);
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "multiplyScalar", ()=>multiplyScalar
);
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */ parcelHelpers.export(exports, "multiplyScalarAndAdd", ()=>multiplyScalarAndAdd
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "sub", ()=>sub
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(4);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
    }
    out[0] = 1;
    out[3] = 1;
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
}
function fromValues(m00, m01, m10, m11) {
    var out = new _commonJs.ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
}
function set(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
}
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache
    // some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    return out;
}
function invert(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    // Calculate the determinant
    var det = a0 * a3 - a2 * a1;
    if (!det) return null;
    det = 1 / det;
    out[0] = a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] = a0 * det;
    return out;
}
function adjoint(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] = a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a0;
    return out;
}
function determinant(a) {
    return a[0] * a[3] - a[2] * a[1];
}
function multiply(out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
}
function rotate(out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
}
function scale(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
}
function fromRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}
function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}
function str(a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
}
function LDU(L, D, U, a) {
    L[2] = a[2] / a[0];
    U[0] = a[0];
    U[1] = a[1];
    U[3] = a[3] - L[2] * U[1];
    return [
        L,
        D,
        U
    ];
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
}
function multiplyScalarAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    return out;
}
var mul = multiply;
var sub = subtract;

},{"./common.js":"fLrSS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7P4Yo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */ /**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */ parcelHelpers.export(exports, "determinant", ()=>determinant
);
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "fromScaling", ()=>fromScaling
);
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "fromTranslation", ()=>fromTranslation
);
/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */ parcelHelpers.export(exports, "frob", ()=>frob
);
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "multiplyScalar", ()=>multiplyScalar
);
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */ parcelHelpers.export(exports, "multiplyScalarAndAdd", ()=>multiplyScalarAndAdd
);
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "sub", ()=>sub
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(6);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[4] = 0;
        out[5] = 0;
    }
    out[0] = 1;
    out[3] = 1;
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
}
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
}
function fromValues(a, b, c, d, tx, ty) {
    var out = new _commonJs.ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
}
function set(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
}
function invert(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3];
    var atx = a[4], aty = a[5];
    var det = aa * ad - ab * ac;
    if (!det) return null;
    det = 1 / det;
    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
}
function determinant(a) {
    return a[0] * a[3] - a[1] * a[2];
}
function multiply(out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
}
function rotate(out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
}
function scale(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
}
function translate(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
}
function fromRotation(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}
function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}
function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}
function str(a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}
function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
}
function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
}
function multiplyScalarAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    out[4] = a[4] + b[4] * scale1;
    out[5] = a[5] + b[5] * scale1;
    return out;
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _commonJs.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _commonJs.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5));
}
var mul = multiply;
var sub = subtract;

},{"./common.js":"fLrSS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"62qxW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 3x3 Matrix
 * @module mat3
 */ /**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "fromMat4", ()=>fromMat4
);
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "transpose", ()=>transpose
);
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "adjoint", ()=>adjoint
);
/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */ parcelHelpers.export(exports, "determinant", ()=>determinant
);
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "fromTranslation", ()=>fromTranslation
);
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "fromScaling", ()=>fromScaling
);
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/ parcelHelpers.export(exports, "fromMat2d", ()=>fromMat2d
);
/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/ parcelHelpers.export(exports, "fromQuat", ()=>fromQuat
);
/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/ parcelHelpers.export(exports, "normalFromMat4", ()=>normalFromMat4
);
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "projection", ()=>projection
);
/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */ parcelHelpers.export(exports, "frob", ()=>frob
);
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "multiplyScalar", ()=>multiplyScalar
);
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */ parcelHelpers.export(exports, "multiplyScalarAndAdd", ()=>multiplyScalarAndAdd
);
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "sub", ()=>sub
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(9);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
}
function fromMat4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new _commonJs.ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
}
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
}
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    return out;
}
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    // Calculate the determinant
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) return null;
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
}
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
}
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
}
function translate(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
}
function rotate(out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
}
function scale(out, a, v) {
    var x = v[0], y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
}
function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}
function fromRotation(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}
function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}
function fromMat2d(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;
    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;
    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
}
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
}
function normalFromMat4(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    // Calculate the determinant
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) return null;
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
}
function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
}
function str(a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}
function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
}
function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
}
function multiplyScalarAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    out[4] = a[4] + b[4] * scale1;
    out[5] = a[5] + b[5] * scale1;
    out[6] = a[6] + b[6] * scale1;
    out[7] = a[7] + b[7] * scale1;
    out[8] = a[8] + b[8] * scale1;
    return out;
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _commonJs.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _commonJs.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _commonJs.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _commonJs.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _commonJs.EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul = multiply;
var sub = subtract;

},{"./common.js":"fLrSS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4qMJv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */ /**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "transpose", ()=>transpose
);
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "adjoint", ()=>adjoint
);
/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */ parcelHelpers.export(exports, "determinant", ()=>determinant
);
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromTranslation", ()=>fromTranslation
);
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromScaling", ()=>fromScaling
);
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromXRotation", ()=>fromXRotation
);
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromYRotation", ()=>fromYRotation
);
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromZRotation", ()=>fromZRotation
);
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromRotationTranslation", ()=>fromRotationTranslation
);
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */ parcelHelpers.export(exports, "fromQuat2", ()=>fromQuat2
);
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */ parcelHelpers.export(exports, "getTranslation", ()=>getTranslation
);
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */ parcelHelpers.export(exports, "getScaling", ()=>getScaling
);
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */ parcelHelpers.export(exports, "getRotation", ()=>getRotation
);
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromRotationTranslationScale", ()=>fromRotationTranslationScale
);
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromRotationTranslationScaleOrigin", ()=>fromRotationTranslationScaleOrigin
);
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "fromQuat", ()=>fromQuat
);
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "frustum", ()=>frustum
);
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "perspective", ()=>perspective
);
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "perspectiveFromFieldOfView", ()=>perspectiveFromFieldOfView
);
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "ortho", ()=>ortho
);
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "lookAt", ()=>lookAt
);
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "targetTo", ()=>targetTo
);
/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */ parcelHelpers.export(exports, "frob", ()=>frob
);
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "multiplyScalar", ()=>multiplyScalar
);
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */ parcelHelpers.export(exports, "multiplyScalarAndAdd", ()=>multiplyScalarAndAdd
);
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "sub", ()=>sub
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(16);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new _commonJs.ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
}
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
}
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3];
        var a12 = a[6], a13 = a[7];
        var a23 = a[11];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    return out;
}
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    // Calculate the determinant
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) return null;
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
}
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
}
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    // Cache only the current line of the second matrix
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
}
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    var a00 = void 0, a01 = void 0, a02 = void 0, a03 = void 0;
    var a10 = void 0, a11 = void 0, a12 = void 0, a13 = void 0;
    var a20 = void 0, a21 = void 0, a22 = void 0, a23 = void 0;
    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0];
        a01 = a[1];
        a02 = a[2];
        a03 = a[3];
        a10 = a[4];
        a11 = a[5];
        a12 = a[6];
        a13 = a[7];
        a20 = a[8];
        a21 = a[9];
        a22 = a[10];
        a23 = a[11];
        out[0] = a00;
        out[1] = a01;
        out[2] = a02;
        out[3] = a03;
        out[4] = a10;
        out[5] = a11;
        out[6] = a12;
        out[7] = a13;
        out[8] = a20;
        out[9] = a21;
        out[10] = a22;
        out[11] = a23;
        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
}
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len = Math.sqrt(x * x + y * y + z * z);
    var s = void 0, c = void 0, t = void 0;
    var a00 = void 0, a01 = void 0, a02 = void 0, a03 = void 0;
    var a10 = void 0, a11 = void 0, a12 = void 0, a13 = void 0;
    var a20 = void 0, a21 = void 0, a22 = void 0, a23 = void 0;
    var b00 = void 0, b01 = void 0, b02 = void 0;
    var b10 = void 0, b11 = void 0, b12 = void 0;
    var b20 = void 0, b21 = void 0, b22 = void 0;
    if (len < _commonJs.EPSILON) return null;
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    // Construct the elements of the rotation matrix
    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c;
    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
        // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
}
function rotateX(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
}
function rotateY(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
}
function rotateZ(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged last row
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
}
function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromRotation(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len = Math.sqrt(x * x + y * y + z * z);
    var s = void 0, c = void 0, t = void 0;
    if (len < _commonJs.EPSILON) return null;
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromXRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    // Perform axis-specific matrix multiplication
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromYRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    // Perform axis-specific matrix multiplication
    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromZRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    // Perform axis-specific matrix multiplication
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function fromQuat2(out, a) {
    var translation = new _commonJs.ARRAY_TYPE(3);
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw;
    //Only scale if it makes sense
    if (magnitude > 0) {
        translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
        translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
        translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
        translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
        translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
        translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    fromRotationTranslation(out, a, translation);
    return out;
}
function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
}
function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    return out;
}
function getRotation(out, mat) {
    // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    var trace = mat[0] + mat[5] + mat[10];
    var S = 0;
    if (trace > 0) {
        S = Math.sqrt(trace + 1) * 2;
        out[3] = 0.25 * S;
        out[0] = (mat[6] - mat[9]) / S;
        out[1] = (mat[8] - mat[2]) / S;
        out[2] = (mat[1] - mat[4]) / S;
    } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
        S = Math.sqrt(1 + mat[0] - mat[5] - mat[10]) * 2;
        out[3] = (mat[6] - mat[9]) / S;
        out[0] = 0.25 * S;
        out[1] = (mat[1] + mat[4]) / S;
        out[2] = (mat[8] + mat[2]) / S;
    } else if (mat[5] > mat[10]) {
        S = Math.sqrt(1 + mat[5] - mat[0] - mat[10]) * 2;
        out[3] = (mat[8] - mat[2]) / S;
        out[0] = (mat[1] + mat[4]) / S;
        out[1] = 0.25 * S;
        out[2] = (mat[6] + mat[9]) / S;
    } else {
        S = Math.sqrt(1 + mat[10] - mat[0] - mat[5]) * 2;
        out[3] = (mat[1] - mat[4]) / S;
        out[0] = (mat[8] + mat[2]) / S;
        out[1] = (mat[6] + mat[9]) / S;
        out[2] = 0.25 * S;
    }
    return out;
}
function fromRotationTranslationScale(out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
}
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
}
function perspective(out, fovy, aspect, near, far) {
    var f = 1 / Math.tan(fovy / 2), nf = void 0;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
        nf = 1 / (near - far);
        out[10] = (far + near) * nf;
        out[14] = 2 * far * near * nf;
    } else {
        out[10] = -1;
        out[14] = -2 * near;
    }
    return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    var xScale = 2 / (leftTan + rightTan);
    var yScale = 2 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = yScale;
    out[6] = 0;
    out[7] = 0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near / (near - far);
    out[15] = 0;
    return out;
}
function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
}
function lookAt(out, eye, center, up) {
    var x0 = void 0, x1 = void 0, x2 = void 0, y0 = void 0, y1 = void 0, y2 = void 0, z0 = void 0, z1 = void 0, z2 = void 0, len = void 0;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];
    if (Math.abs(eyex - centerx) < _commonJs.EPSILON && Math.abs(eyey - centery) < _commonJs.EPSILON && Math.abs(eyez - centerz) < _commonJs.EPSILON) return identity(out);
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
}
function targetTo(out, eye, target, up) {
    var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
    var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
    var len = z0 * z0 + z1 * z1 + z2 * z2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        z0 *= len;
        z1 *= len;
        z2 *= len;
    }
    var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
}
function str(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}
function frob(a) {
    return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
}
function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
}
function multiplyScalarAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    out[4] = a[4] + b[4] * scale1;
    out[5] = a[5] + b[5] * scale1;
    out[6] = a[6] + b[6] * scale1;
    out[7] = a[7] + b[7] * scale1;
    out[8] = a[8] + b[8] * scale1;
    out[9] = a[9] + b[9] * scale1;
    out[10] = a[10] + b[10] * scale1;
    out[11] = a[11] + b[11] * scale1;
    out[12] = a[12] + b[12] * scale1;
    out[13] = a[13] + b[13] * scale1;
    out[14] = a[14] + b[14] * scale1;
    out[15] = a[15] + b[15] * scale1;
    return out;
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
    var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
    var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
    var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _commonJs.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _commonJs.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _commonJs.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _commonJs.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _commonJs.EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _commonJs.EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _commonJs.EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _commonJs.EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _commonJs.EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _commonJs.EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _commonJs.EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _commonJs.EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul = multiply;
var sub = subtract;

},{"./common.js":"fLrSS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lPOiD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Quaternion
 * @module quat
 */ /**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/ parcelHelpers.export(exports, "setAxisAngle", ()=>setAxisAngle
);
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */ parcelHelpers.export(exports, "getAxisAngle", ()=>getAxisAngle
);
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */ parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */ parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */ parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */ parcelHelpers.export(exports, "calculateW", ()=>calculateW
);
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */ parcelHelpers.export(exports, "slerp", ()=>slerp
);
/**
 * Generates a random quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */ parcelHelpers.export(exports, "random", ()=>random
);
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */ parcelHelpers.export(exports, "conjugate", ()=>conjugate
);
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */ parcelHelpers.export(exports, "fromMat3", ()=>fromMat3
);
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */ parcelHelpers.export(exports, "fromEuler", ()=>fromEuler
);
/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */ parcelHelpers.export(exports, "str", ()=>str
);
parcelHelpers.export(exports, "clone", ()=>clone
);
parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
parcelHelpers.export(exports, "copy", ()=>copy
);
parcelHelpers.export(exports, "set", ()=>set
);
parcelHelpers.export(exports, "add", ()=>add
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "scale", ()=>scale
);
parcelHelpers.export(exports, "dot", ()=>dot
);
parcelHelpers.export(exports, "lerp", ()=>lerp
);
parcelHelpers.export(exports, "length", ()=>length
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
parcelHelpers.export(exports, "normalize", ()=>normalize
);
parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "rotationTo", ()=>rotationTo
);
parcelHelpers.export(exports, "sqlerp", ()=>sqlerp
);
parcelHelpers.export(exports, "setAxes", ()=>setAxes
);
var _commonJs = require("./common.js");
var _mat3Js = require("./mat3.js");
var _vec3Js = require("./vec3.js");
var _vec4Js = require("./vec4.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(4);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
    }
    out[3] = 1;
    return out;
}
function identity(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
}
function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
}
function getAxisAngle(out_axis, q) {
    var rad = Math.acos(q[3]) * 2;
    var s = Math.sin(rad / 2);
    if (s > _commonJs.EPSILON) {
        out_axis[0] = q[0] / s;
        out_axis[1] = q[1] / s;
        out_axis[2] = q[2] / s;
    } else {
        // If s is zero, return any axis (no rotation - axis does not matter)
        out_axis[0] = 1;
        out_axis[1] = 0;
        out_axis[2] = 0;
    }
    return rad;
}
function multiply(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
}
function rotateX(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
}
function rotateY(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var by = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
}
function rotateZ(out, a, rad) {
    rad *= 0.5;
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bz = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
}
function calculateW(out, a) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
    return out;
}
function slerp(out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations
    var ax = a[0], ay = a[1], az = a[2], aw = a[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    var omega = void 0, cosom = void 0, sinom = void 0, scale0 = void 0, scale1 = void 0;
    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if (cosom < 0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
    }
    // calculate coefficients
    if (1 - cosom > _commonJs.EPSILON) {
        // standard case (slerp)
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {
        // "from" and "to" quaternions are very close
        //  ... so we can do a linear interpolation
        scale0 = 1 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
}
function random(out) {
    // Implementation of http://planning.cs.uiuc.edu/node198.html
    // TODO: Calling random 3 times is probably not the fastest solution
    var u1 = _commonJs.RANDOM();
    var u2 = _commonJs.RANDOM();
    var u3 = _commonJs.RANDOM();
    var sqrt1MinusU1 = Math.sqrt(1 - u1);
    var sqrtU1 = Math.sqrt(u1);
    out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
    out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
    out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
    out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
    return out;
}
function invert(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var dot1 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
    var invDot = dot1 ? 1 / dot1 : 0;
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a2 * invDot;
    out[3] = a3 * invDot;
    return out;
}
function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
}
function fromMat3(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot = void 0;
    if (fTrace > 0) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1); // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot; // 1/(4w)
        out[0] = (m[5] - m[7]) * fRoot;
        out[1] = (m[6] - m[2]) * fRoot;
        out[2] = (m[1] - m[3]) * fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if (m[4] > m[0]) i = 1;
        if (m[8] > m[i * 3 + i]) i = 2;
        var j = (i + 1) % 3;
        var k = (i + 2) % 3;
        fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
        out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
        out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }
    return out;
}
function fromEuler(out, x, y, z) {
    var halfToRad = 0.5 * Math.PI / 180;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
}
function str(a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
var clone = _vec4Js.clone;
var fromValues = _vec4Js.fromValues;
var copy = _vec4Js.copy;
var set = _vec4Js.set;
var add = _vec4Js.add;
var mul = multiply;
var scale = _vec4Js.scale;
var dot = _vec4Js.dot;
var lerp = _vec4Js.lerp;
var length = _vec4Js.length;
var len = length;
var squaredLength = _vec4Js.squaredLength;
var sqrLen = squaredLength;
var normalize = _vec4Js.normalize;
var exactEquals = _vec4Js.exactEquals;
var equals = _vec4Js.equals;
var rotationTo = function() {
    var tmpvec3 = _vec3Js.create();
    var xUnitVec3 = _vec3Js.fromValues(1, 0, 0);
    var yUnitVec3 = _vec3Js.fromValues(0, 1, 0);
    return function(out, a, b) {
        var dot2 = _vec3Js.dot(a, b);
        if (dot2 < -0.999999) {
            _vec3Js.cross(tmpvec3, xUnitVec3, a);
            if (_vec3Js.len(tmpvec3) < 0.000001) _vec3Js.cross(tmpvec3, yUnitVec3, a);
            _vec3Js.normalize(tmpvec3, tmpvec3);
            setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot2 > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            _vec3Js.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot2;
            return normalize(out, out);
        }
    };
}();
var sqlerp = function() {
    var temp1 = create();
    var temp2 = create();
    return function(out, a, b, c, d, t) {
        slerp(temp1, a, d, t);
        slerp(temp2, b, c, t);
        slerp(out, temp1, temp2, 2 * t * (1 - t));
        return out;
    };
}();
var setAxes = function() {
    var matr = _mat3Js.create();
    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];
        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];
        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];
        return normalize(out, fromMat3(out, matr));
    };
}();

},{"./common.js":"fLrSS","./mat3.js":"62qxW","./vec3.js":"baThR","./vec4.js":"eMR41","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"baThR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 3 Dimensional Vector
 * @module vec3
 */ /**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */ parcelHelpers.export(exports, "length", ()=>length
);
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "divide", ()=>divide
);
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "ceil", ()=>ceil
);
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "floor", ()=>floor
);
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "min", ()=>min
);
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "max", ()=>max
);
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "round", ()=>round
);
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "scaleAndAdd", ()=>scaleAndAdd
);
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */ parcelHelpers.export(exports, "distance", ()=>distance
);
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance
);
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */ parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "negate", ()=>negate
);
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "inverse", ()=>inverse
);
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */ parcelHelpers.export(exports, "dot", ()=>dot
);
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "cross", ()=>cross
);
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "lerp", ()=>lerp
);
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "hermite", ()=>hermite
);
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "bezier", ()=>bezier
);
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "random", ()=>random
);
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "transformMat4", ()=>transformMat4
);
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "transformMat3", ()=>transformMat3
);
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "transformQuat", ()=>transformQuat
);
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */ parcelHelpers.export(exports, "angle", ()=>angle
);
/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "sub", ()=>sub
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "div", ()=>div
);
parcelHelpers.export(exports, "dist", ()=>dist
);
parcelHelpers.export(exports, "sqrDist", ()=>sqrDist
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
parcelHelpers.export(exports, "forEach", ()=>forEach
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(3);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
    }
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
}
function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.sqrt(x * x + y * y + z * z);
}
function fromValues(x, y, z) {
    var out = new _commonJs.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
}
function set(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
}
function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
}
function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
}
function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
}
function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
}
function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
}
function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
}
function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
}
function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
}
function scaleAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    return out;
}
function distance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.sqrt(x * x + y * y + z * z);
}
function squaredDistance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
}
function squaredLength(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
}
function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
}
function inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    return out;
}
function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len1 = x * x + y * y + z * z;
    if (len1 > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len1 = 1 / Math.sqrt(len1);
        out[0] = a[0] * len1;
        out[1] = a[1] * len1;
        out[2] = a[2] * len1;
    }
    return out;
}
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
}
function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
}
function hermite(out, a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
}
function bezier(out, a, b, c, d, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
}
function random(out, scale2) {
    scale2 = scale2 || 1;
    var r = _commonJs.RANDOM() * 2 * Math.PI;
    var z = _commonJs.RANDOM() * 2 - 1;
    var zScale = Math.sqrt(1 - z * z) * scale2;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale2;
    return out;
}
function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
}
function transformMat3(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
}
function transformQuat(out, a, q) {
    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x = a[0], y = a[1], z = a[2];
    // var qvec = [qx, qy, qz];
    // var uv = vec3.cross([], qvec, a);
    var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
    // var uuv = vec3.cross([], qvec, uv);
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    // vec3.scale(uv, uv, 2 * w);
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    // vec3.scale(uuv, uuv, 2);
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    // return vec3.add(out, a, vec3.add(out, uv, uuv));
    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
}
function rotateX(out, a, b, c) {
    var p = [], r = [];
    //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    //perform rotation
    r[0] = p[0];
    r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
    r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);
    //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function rotateY(out, a, b, c) {
    var p = [], r = [];
    //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    //perform rotation
    r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);
    //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function rotateZ(out, a, b, c) {
    var p = [], r = [];
    //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    //perform rotation
    r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
    r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
    r[2] = p[2];
    //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function angle(a, b) {
    var tempA = fromValues(a[0], a[1], a[2]);
    var tempB = fromValues(b[0], b[1], b[2]);
    normalize(tempA, tempA);
    normalize(tempB, tempB);
    var cosine = dot(tempA, tempB);
    if (cosine > 1) return 0;
    else if (cosine < -1) return Math.PI;
    else return Math.acos(cosine);
}
function str(a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
    var vec = create();
    return function(a, stride, offset, count, fn, arg) {
        var i = void 0, l = void 0;
        if (!stride) stride = 3;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
        }
        return a;
    };
}();

},{"./common.js":"fLrSS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eMR41":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 4 Dimensional Vector
 * @module vec4
 */ /**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "divide", ()=>divide
);
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "ceil", ()=>ceil
);
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "floor", ()=>floor
);
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "min", ()=>min
);
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "max", ()=>max
);
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "round", ()=>round
);
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "scaleAndAdd", ()=>scaleAndAdd
);
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */ parcelHelpers.export(exports, "distance", ()=>distance
);
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance
);
/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */ parcelHelpers.export(exports, "length", ()=>length
);
/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */ parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "negate", ()=>negate
);
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "inverse", ()=>inverse
);
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */ parcelHelpers.export(exports, "dot", ()=>dot
);
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "lerp", ()=>lerp
);
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "random", ()=>random
);
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "transformMat4", ()=>transformMat4
);
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */ parcelHelpers.export(exports, "transformQuat", ()=>transformQuat
);
/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "sub", ()=>sub
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "div", ()=>div
);
parcelHelpers.export(exports, "dist", ()=>dist
);
parcelHelpers.export(exports, "sqrDist", ()=>sqrDist
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
parcelHelpers.export(exports, "forEach", ()=>forEach
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(4);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
    }
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function fromValues(x, y, z, w) {
    var out = new _commonJs.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function set(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
}
function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
}
function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
}
function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
}
function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
}
function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
}
function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
}
function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
}
function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
}
function scaleAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    return out;
}
function distance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return Math.sqrt(x * x + y * y + z * z + w * w);
}
function squaredDistance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return x * x + y * y + z * z + w * w;
}
function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return Math.sqrt(x * x + y * y + z * z + w * w);
}
function squaredLength(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return x * x + y * y + z * z + w * w;
}
function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
}
function inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    out[3] = 1 / a[3];
    return out;
}
function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len1 = x * x + y * y + z * z + w * w;
    if (len1 > 0) {
        len1 = 1 / Math.sqrt(len1);
        out[0] = x * len1;
        out[1] = y * len1;
        out[2] = z * len1;
        out[3] = w * len1;
    }
    return out;
}
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
}
function random(out, scale2) {
    scale2 = scale2 || 1;
    // Marsaglia, George. Choosing a Point from the Surface of a
    // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
    // http://projecteuclid.org/euclid.aoms/1177692644;
    var v1, v2, v3, v4;
    var s1, s2;
    do {
        v1 = _commonJs.RANDOM() * 2 - 1;
        v2 = _commonJs.RANDOM() * 2 - 1;
        s1 = v1 * v1 + v2 * v2;
    }while (s1 >= 1)
    do {
        v3 = _commonJs.RANDOM() * 2 - 1;
        v4 = _commonJs.RANDOM() * 2 - 1;
        s2 = v3 * v3 + v4 * v4;
    }while (s2 >= 1)
    var d = Math.sqrt((1 - s1) / s2);
    out[0] = scale2 * v1;
    out[1] = scale2 * v2;
    out[2] = scale2 * v3 * d;
    out[3] = scale2 * v4 * d;
    return out;
}
function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
}
function transformQuat(out, a, q) {
    var x = a[0], y = a[1], z = a[2];
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    // calculate quat * vec
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
}
function str(a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
    var vec = create();
    return function(a, stride, offset, count, fn, arg) {
        var i = void 0, l = void 0;
        if (!stride) stride = 4;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            vec[3] = a[i + 3];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
            a[i + 3] = vec[3];
        }
        return a;
    };
}();

},{"./common.js":"fLrSS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aGpcr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */ /**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */ parcelHelpers.export(exports, "fromRotationTranslationValues", ()=>fromRotationTranslationValues
);
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q quaternion
 * @param {vec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */ parcelHelpers.export(exports, "fromRotationTranslation", ()=>fromRotationTranslation
);
/**
 * Creates a dual quat from a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {vec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */ parcelHelpers.export(exports, "fromTranslation", ()=>fromTranslation
);
/**
 * Creates a dual quat from a quaternion
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */ parcelHelpers.export(exports, "fromRotation", ()=>fromRotation
);
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {mat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */ parcelHelpers.export(exports, "fromMat4", ()=>fromMat4
);
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "identity", ()=>identity
);
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "set", ()=>set
);
parcelHelpers.export(exports, "getReal", ()=>getReal
);
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} dual part
 */ parcelHelpers.export(exports, "getDual", ()=>getDual
);
parcelHelpers.export(exports, "setReal", ()=>setReal
);
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "setDual", ()=>setDual
);
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {quat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */ parcelHelpers.export(exports, "getTranslation", ()=>getTranslation
);
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to translate
 * @param {vec3} v vector to translate by
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateX", ()=>rotateX
);
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateY", ()=>rotateY
);
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateZ", ()=>rotateZ
);
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {quat} q quaternion to rotate by
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateByQuatAppend", ()=>rotateByQuatAppend
);
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat} q quaternion to rotate by
 * @param {quat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateByQuatPrepend", ()=>rotateByQuatPrepend
);
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {vec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "rotateAroundAxis", ()=>rotateAroundAxis
);
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
parcelHelpers.export(exports, "mul", ()=>mul
);
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
parcelHelpers.export(exports, "dot", ()=>dot
);
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "lerp", ()=>lerp
);
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */ parcelHelpers.export(exports, "conjugate", ()=>conjugate
);
parcelHelpers.export(exports, "length", ()=>length
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {quat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat2} a the first dual quaternion.
 * @param {quat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {quat2} a the first dual quat.
 * @param {quat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
var _commonJs = require("./common.js");
var _quatJs = require("./quat.js");
var _mat4Js = require("./mat4.js");
function create() {
    var dq = new _commonJs.ARRAY_TYPE(8);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        dq[0] = 0;
        dq[1] = 0;
        dq[2] = 0;
        dq[4] = 0;
        dq[5] = 0;
        dq[6] = 0;
        dq[7] = 0;
    }
    dq[3] = 1;
    return dq;
}
function clone(a) {
    var dq = new _commonJs.ARRAY_TYPE(8);
    dq[0] = a[0];
    dq[1] = a[1];
    dq[2] = a[2];
    dq[3] = a[3];
    dq[4] = a[4];
    dq[5] = a[5];
    dq[6] = a[6];
    dq[7] = a[7];
    return dq;
}
function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
    var dq = new _commonJs.ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    dq[4] = x2;
    dq[5] = y2;
    dq[6] = z2;
    dq[7] = w2;
    return dq;
}
function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
    var dq = new _commonJs.ARRAY_TYPE(8);
    dq[0] = x1;
    dq[1] = y1;
    dq[2] = z1;
    dq[3] = w1;
    var ax = x2 * 0.5, ay = y2 * 0.5, az = z2 * 0.5;
    dq[4] = ax * w1 + ay * z1 - az * y1;
    dq[5] = ay * w1 + az * x1 - ax * z1;
    dq[6] = az * w1 + ax * y1 - ay * x1;
    dq[7] = -ax * x1 - ay * y1 - az * z1;
    return dq;
}
function fromRotationTranslation(out, q, t) {
    var ax = t[0] * 0.5, ay = t[1] * 0.5, az = t[2] * 0.5, bx = q[0], by = q[1], bz = q[2], bw = q[3];
    out[0] = bx;
    out[1] = by;
    out[2] = bz;
    out[3] = bw;
    out[4] = ax * bw + ay * bz - az * by;
    out[5] = ay * bw + az * bx - ax * bz;
    out[6] = az * bw + ax * by - ay * bx;
    out[7] = -ax * bx - ay * by - az * bz;
    return out;
}
function fromTranslation(out, t) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = t[0] * 0.5;
    out[5] = t[1] * 0.5;
    out[6] = t[2] * 0.5;
    out[7] = 0;
    return out;
}
function fromRotation(out, q) {
    out[0] = q[0];
    out[1] = q[1];
    out[2] = q[2];
    out[3] = q[3];
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
}
function fromMat4(out, a) {
    //TODO Optimize this
    var outer = _quatJs.create();
    _mat4Js.getRotation(outer, a);
    var t = new _commonJs.ARRAY_TYPE(3);
    _mat4Js.getTranslation(t, a);
    fromRotationTranslation(out, outer, t);
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    return out;
}
function identity(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    return out;
}
function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
    out[0] = x1;
    out[1] = y1;
    out[2] = z1;
    out[3] = w1;
    out[4] = x2;
    out[5] = y2;
    out[6] = z2;
    out[7] = w2;
    return out;
}
var getReal = _quatJs.copy;
function getDual(out, a) {
    out[0] = a[4];
    out[1] = a[5];
    out[2] = a[6];
    out[3] = a[7];
    return out;
}
var setReal = _quatJs.copy;
function setDual(out, q) {
    out[4] = q[0];
    out[5] = q[1];
    out[6] = q[2];
    out[7] = q[3];
    return out;
}
function getTranslation(out, a) {
    var ax = a[4], ay = a[5], az = a[6], aw = a[7], bx = -a[0], by = -a[1], bz = -a[2], bw = a[3];
    out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    return out;
}
function translate(out, a, v) {
    var ax1 = a[0], ay1 = a[1], az1 = a[2], aw1 = a[3], bx1 = v[0] * 0.5, by1 = v[1] * 0.5, bz1 = v[2] * 0.5, ax2 = a[4], ay2 = a[5], az2 = a[6], aw2 = a[7];
    out[0] = ax1;
    out[1] = ay1;
    out[2] = az1;
    out[3] = aw1;
    out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
    out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
    out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
    out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
    return out;
}
function rotateX(out, a, rad) {
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
    _quatJs.rotateX(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
}
function rotateY(out, a, rad) {
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
    _quatJs.rotateY(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
}
function rotateZ(out, a, rad) {
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
    _quatJs.rotateZ(out, a, rad);
    bx = out[0];
    by = out[1];
    bz = out[2];
    bw = out[3];
    out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    return out;
}
function rotateByQuatAppend(out, a, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3], ax = a[0], ay = a[1], az = a[2], aw = a[3];
    out[0] = ax * qw + aw * qx + ay * qz - az * qy;
    out[1] = ay * qw + aw * qy + az * qx - ax * qz;
    out[2] = az * qw + aw * qz + ax * qy - ay * qx;
    out[3] = aw * qw - ax * qx - ay * qy - az * qz;
    ax = a[4];
    ay = a[5];
    az = a[6];
    aw = a[7];
    out[4] = ax * qw + aw * qx + ay * qz - az * qy;
    out[5] = ay * qw + aw * qy + az * qx - ax * qz;
    out[6] = az * qw + aw * qz + ax * qy - ay * qx;
    out[7] = aw * qw - ax * qx - ay * qy - az * qz;
    return out;
}
function rotateByQuatPrepend(out, q, a) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3], bx = a[0], by = a[1], bz = a[2], bw = a[3];
    out[0] = qx * bw + qw * bx + qy * bz - qz * by;
    out[1] = qy * bw + qw * by + qz * bx - qx * bz;
    out[2] = qz * bw + qw * bz + qx * by - qy * bx;
    out[3] = qw * bw - qx * bx - qy * by - qz * bz;
    bx = a[4];
    by = a[5];
    bz = a[6];
    bw = a[7];
    out[4] = qx * bw + qw * bx + qy * bz - qz * by;
    out[5] = qy * bw + qw * by + qz * bx - qx * bz;
    out[6] = qz * bw + qw * bz + qx * by - qy * bx;
    out[7] = qw * bw - qx * bx - qy * by - qz * bz;
    return out;
}
function rotateAroundAxis(out, a, axis, rad) {
    //Special case for rad = 0
    if (Math.abs(rad) < _commonJs.EPSILON) return copy(out, a);
    var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);
    rad = rad * 0.5;
    var s = Math.sin(rad);
    var bx = s * axis[0] / axisLength;
    var by = s * axis[1] / axisLength;
    var bz = s * axis[2] / axisLength;
    var bw = Math.cos(rad);
    var ax1 = a[0], ay1 = a[1], az1 = a[2], aw1 = a[3];
    out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
    out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
    out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
    out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
    var ax = a[4], ay = a[5], az = a[6], aw = a[7];
    out[4] = ax * bw + aw * bx + ay * bz - az * by;
    out[5] = ay * bw + aw * by + az * bx - ax * bz;
    out[6] = az * bw + aw * bz + ax * by - ay * bx;
    out[7] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    return out;
}
function multiply(out, a, b) {
    var ax0 = a[0], ay0 = a[1], az0 = a[2], aw0 = a[3], bx1 = b[4], by1 = b[5], bz1 = b[6], bw1 = b[7], ax1 = a[4], ay1 = a[5], az1 = a[6], aw1 = a[7], bx0 = b[0], by0 = b[1], bz0 = b[2], bw0 = b[3];
    out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
    out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
    out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
    out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
    out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
    out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
    out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
    out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
    return out;
}
var mul = multiply;
function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    return out;
}
var dot = _quatJs.dot;
function lerp(out, a, b, t) {
    var mt = 1 - t;
    if (dot(a, b) < 0) t = -t;
    out[0] = a[0] * mt + b[0] * t;
    out[1] = a[1] * mt + b[1] * t;
    out[2] = a[2] * mt + b[2] * t;
    out[3] = a[3] * mt + b[3] * t;
    out[4] = a[4] * mt + b[4] * t;
    out[5] = a[5] * mt + b[5] * t;
    out[6] = a[6] * mt + b[6] * t;
    out[7] = a[7] * mt + b[7] * t;
    return out;
}
function invert(out, a) {
    var sqlen = squaredLength(a);
    out[0] = -a[0] / sqlen;
    out[1] = -a[1] / sqlen;
    out[2] = -a[2] / sqlen;
    out[3] = a[3] / sqlen;
    out[4] = -a[4] / sqlen;
    out[5] = -a[5] / sqlen;
    out[6] = -a[6] / sqlen;
    out[7] = a[7] / sqlen;
    return out;
}
function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    out[4] = -a[4];
    out[5] = -a[5];
    out[6] = -a[6];
    out[7] = a[7];
    return out;
}
var length = _quatJs.length;
var len = length;
var squaredLength = _quatJs.squaredLength;
var sqrLen = squaredLength;
function normalize(out, a) {
    var magnitude = squaredLength(a);
    if (magnitude > 0) {
        magnitude = Math.sqrt(magnitude);
        var a0 = a[0] / magnitude;
        var a1 = a[1] / magnitude;
        var a2 = a[2] / magnitude;
        var a3 = a[3] / magnitude;
        var b0 = a[4];
        var b1 = a[5];
        var b2 = a[6];
        var b3 = a[7];
        var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
        out[0] = a0;
        out[1] = a1;
        out[2] = a2;
        out[3] = a3;
        out[4] = (b0 - a0 * a_dot_b) / magnitude;
        out[5] = (b1 - a1 * a_dot_b) / magnitude;
        out[6] = (b2 - a2 * a_dot_b) / magnitude;
        out[7] = (b3 - a3 * a_dot_b) / magnitude;
    }
    return out;
}
function str(a) {
    return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _commonJs.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _commonJs.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _commonJs.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _commonJs.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _commonJs.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _commonJs.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7));
}

},{"./common.js":"fLrSS","./quat.js":"lPOiD","./mat4.js":"4qMJv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1PFsL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * 2 Dimensional Vector
 * @module vec2
 */ /**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */ parcelHelpers.export(exports, "fromValues", ()=>fromValues
);
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "copy", ()=>copy
);
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "subtract", ()=>subtract
);
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "divide", ()=>divide
);
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "ceil", ()=>ceil
);
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "floor", ()=>floor
);
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "min", ()=>min
);
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "max", ()=>max
);
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "round", ()=>round
);
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "scaleAndAdd", ()=>scaleAndAdd
);
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */ parcelHelpers.export(exports, "distance", ()=>distance
);
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance
);
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */ parcelHelpers.export(exports, "length", ()=>length
);
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */ parcelHelpers.export(exports, "squaredLength", ()=>squaredLength
);
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "negate", ()=>negate
);
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "inverse", ()=>inverse
);
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */ parcelHelpers.export(exports, "dot", ()=>dot
);
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */ parcelHelpers.export(exports, "cross", ()=>cross
);
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "lerp", ()=>lerp
);
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "random", ()=>random
);
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "transformMat2", ()=>transformMat2
);
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "transformMat2d", ()=>transformMat2d
);
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "transformMat3", ()=>transformMat3
);
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "transformMat4", ()=>transformMat4
);
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */ parcelHelpers.export(exports, "angle", ()=>angle
);
/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */ parcelHelpers.export(exports, "str", ()=>str
);
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "exactEquals", ()=>exactEquals
);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
parcelHelpers.export(exports, "len", ()=>len
);
parcelHelpers.export(exports, "sub", ()=>sub
);
parcelHelpers.export(exports, "mul", ()=>mul
);
parcelHelpers.export(exports, "div", ()=>div
);
parcelHelpers.export(exports, "dist", ()=>dist
);
parcelHelpers.export(exports, "sqrDist", ()=>sqrDist
);
parcelHelpers.export(exports, "sqrLen", ()=>sqrLen
);
parcelHelpers.export(exports, "forEach", ()=>forEach
);
var _commonJs = require("./common.js");
function create() {
    var out = new _commonJs.ARRAY_TYPE(2);
    if (_commonJs.ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
    }
    return out;
}
function clone(a) {
    var out = new _commonJs.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
}
function fromValues(x, y) {
    var out = new _commonJs.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
}
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
}
function set(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
}
function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
}
function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
}
function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
}
function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
}
function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
}
function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
}
function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
}
function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
}
function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
}
function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
}
function scaleAndAdd(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    return out;
}
function distance(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return Math.sqrt(x * x + y * y);
}
function squaredDistance(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return x * x + y * y;
}
function length(a) {
    var x = a[0], y = a[1];
    return Math.sqrt(x * x + y * y);
}
function squaredLength(a) {
    var x = a[0], y = a[1];
    return x * x + y * y;
}
function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
}
function inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    return out;
}
function normalize(out, a) {
    var x = a[0], y = a[1];
    var len1 = x * x + y * y;
    if (len1 > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len1 = 1 / Math.sqrt(len1);
        out[0] = a[0] * len1;
        out[1] = a[1] * len1;
    }
    return out;
}
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
}
function cross(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
}
function lerp(out, a, b, t) {
    var ax = a[0], ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
}
function random(out, scale2) {
    scale2 = scale2 || 1;
    var r = _commonJs.RANDOM() * 2 * Math.PI;
    out[0] = Math.cos(r) * scale2;
    out[1] = Math.sin(r) * scale2;
    return out;
}
function transformMat2(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
}
function transformMat2d(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
}
function transformMat3(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
}
function transformMat4(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
}
function rotate(out, a, b, c) {
    //Translate point to the origin
    var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(c), cosC = Math.cos(c);
    //perform rotation and translate to correct position
    out[0] = p0 * cosC - p1 * sinC + b[0];
    out[1] = p0 * sinC + p1 * cosC + b[1];
    return out;
}
function angle(a, b) {
    var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1];
    var len1 = x1 * x1 + y1 * y1;
    if (len1 > 0) //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
    var len2 = x2 * x2 + y2 * y2;
    if (len2 > 0) //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
    var cosine = (x1 * x2 + y1 * y2) * len1 * len2;
    if (cosine > 1) return 0;
    else if (cosine < -1) return Math.PI;
    else return Math.acos(cosine);
}
function str(a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
}
function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1];
}
function equals(a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return Math.abs(a0 - b0) <= _commonJs.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _commonJs.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len = length;
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var sqrLen = squaredLength;
var forEach = function() {
    var vec = create();
    return function(a, stride, offset, count, fn, arg) {
        var i = void 0, l = void 0;
        if (!stride) stride = 2;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
        }
        return a;
    };
}();

},{"./common.js":"fLrSS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hL4qm":[function(require,module,exports) {
var vec2 = require('gl-matrix').vec2;
var cross = require('./cross-2d');
var isZero = require('./is-zero-1d');
module.exports = function(a, b, c, d) {
    var p = vec2.clone(a);
    var r = vec2.clone(b);
    vec2.subtract(r, r, p);
    var q = vec2.clone(c);
    var s = vec2.clone(d);
    vec2.subtract(s, s, q);
    var dqp = vec2.create();
    vec2.subtract(dqp, q, p);
    var t = -1;
    var rxs = cross(r, s);
    var qpxr = cross(dqp, r);
    var qpxs = cross(dqp, s);
    if (rxs != 0) t = qpxs / rxs;
    else if (isZero(qpxr) && isZero(rxs)) var t = vec2.dot(dqp, r) / vec2.dot(r, r);
    else if (!isZero(qpxr) && isZero(rxs)) throw 'lines are parallel and do no intersect';
    return vec2.fromValues(p[0] + t * r[0], p[1] + t * r[1]);
};

},{"gl-matrix":"kzvF6","./cross-2d":"66ave","./is-zero-1d":"bzoFj"}],"3D3fk":[function(require,module,exports) {
var isLeftOn = require('./is-left-on-2d');
var isLeft = require('./is-left-2d');
module.exports = function(a0, a, a1, b) {
    if (isLeftOn(a, a1, a0)) return isLeft(a, b, a0) && isLeft(b, a, a1);
    return !(isLeftOn(b, a, a0) && isLeftOn(a, b, a1));
};

},{"./is-left-on-2d":"1Bcyb","./is-left-2d":"kloc4"}],"1Bcyb":[function(require,module,exports) {
var area2 = require('./area2-2d');
var greaterThanZero = require('./greater-than-zero-1d');
var isZero = require('./is-zero-1d');
module.exports = function(a, b, c) {
    var res = area2(a, b, c);
    return greaterThanZero(res) || isZero(res);
};

},{"./area2-2d":"jmO8T","./greater-than-zero-1d":"2i5lt","./is-zero-1d":"bzoFj"}],"JHiGh":[function(require,module,exports) {
var intersectsProper = require('./intersects-proper-2d');
var isBetween = require('./is-between-2d');
module.exports = function(a, b, c, d) {
    if (intersectsProper(a, b, c, d)) return true;
    else if (isBetween(a, b, c) || isBetween(a, b, d) || isBetween(c, d, a) || isBetween(c, d, b)) return true;
    return false;
};

},{"./intersects-proper-2d":"hFVyS","./is-between-2d":"gs80s"}],"hFVyS":[function(require,module,exports) {
var isColinear = require('./is-colinear-2d');
var isLeft = require('./is-left-2d');
module.exports = function(a, b, c, d) {
    if (isColinear(a, b, c) || isColinear(a, b, d) || isColinear(c, d, a) || isColinear(c, d, b)) return false;
    if (isLeft(a, b, c) != isLeft(a, b, d) && isLeft(c, d, a) != isLeft(c, d, b)) return true;
    return false;
};

},{"./is-colinear-2d":"avCJ3","./is-left-2d":"kloc4"}],"avCJ3":[function(require,module,exports) {
var isZero = require('./is-zero-1d');
var area2 = require('./area2-2d');
module.exports = function(a, b, c) {
    return isZero(area2(a, b, c));
};

},{"./is-zero-1d":"bzoFj","./area2-2d":"jmO8T"}],"gs80s":[function(require,module,exports) {
var isColinear = require('./is-colinear-2d');
module.exports = function(a, b, c) {
    if (!isColinear(a, b, c)) return false;
    if (a[0] !== b[0]) return a[0] <= c[0] && c[0] <= b[0] || a[0] >= c[0] && c[0] >= b[0];
    else return a[1] <= c[1] && c[1] <= b[1] || a[1] >= c[1] && c[1] >= b[1];
    return false;
};

},{"./is-colinear-2d":"avCJ3"}],"3uoBd":[function(require,module,exports) {
var inCone = require('./in-cone-2d');
var isDiagonalie = require('./is-diagonalie-2d');
module.exports = function(i, j, polygon) {
    var len = polygon.length;
    var a0 = polygon[i - 1 < 0 ? len - 1 : i - 1];
    var a = polygon[i];
    var a1 = polygon[(i + 1) % len];
    var b0 = polygon[j - 1 < 0 ? len - 1 : j - 1];
    var b = polygon[j];
    var b1 = polygon[(j + 1) % len];
    if (inCone(a0, a, a1, b) && inCone(b0, b, b1, a) && isDiagonalie(a, b, polygon)) return true;
    return false;
};

},{"./in-cone-2d":"3D3fk","./is-diagonalie-2d":"cykSS"}],"cykSS":[function(require,module,exports) {
var isEqual = require('./is-equal-2d');
var intersectsProper = require('./intersects-proper-2d');
module.exports = function(a, b, polygon) {
    var c, c1, len = polygon.length;
    for(var i = 0; i < len; i++){
        c = polygon[i];
        c1 = polygon[(i + 1) % len];
        if (!isEqual(c, a) && !isEqual(c1, a) && !isEqual(c, b) && !isEqual(c1, b) && intersectsProper(a, b, c, c1)) return false;
    }
    return true;
};

},{"./is-equal-2d":"e4Ra3","./intersects-proper-2d":"hFVyS"}],"e4Ra3":[function(require,module,exports) {
var isZero = require('./is-zero-1d');
var isEqual = require('./is-equal-1d');
module.exports = function(a, b) {
    if (isEqual(a[0], b[0]) && isEqual(a[1], b[1])) return true;
    return false;
};

},{"./is-zero-1d":"bzoFj","./is-equal-1d":"3tsmP"}],"kAGmZ":[function(require,module,exports) {
var isDiagonal = require('./is-diagonal-2d');
module.exports = function(polygon) {
    var len = polygon.length;
    var ears = [];
    for(var i = 0; i < len; i++){
        var i0 = i - 1 < 0 ? len - 1 : i - 1;
        var i1 = (i + 1) % len;
        ears.push(isDiagonal(i0, i1, polygon));
    }
    var polys = polygon.slice(0);
    var v0, v1, v2 = 0, v3, v4, n = polys.length, end = 0;
    var lookups = [];
    var llen = 0;
    for(var i = 0; i < len; i++)lookups[i] = i;
    var cells = [];
    while(n > 3)do {
        llen = lookups.length;
        v2 = v2 % llen;
        if (ears[lookups[v2]]) {
            v4 = (v2 + 2) % llen;
            v3 = (v2 + 1) % llen;
            //v2//
            v1 = v2 - 1;
            v1 = v1 < 0 ? llen + v1 : v1;
            v0 = v1 - 1;
            v0 = v0 < 0 ? llen + v0 : v0;
            v0 = v0 % llen;
            v1 = v1 % llen;
            v2 = v2 % llen;
            v3 = v3 % llen;
            v4 = v4 % llen;
            ears[lookups[v1]] = isDiagonal(lookups[v0], lookups[v3], polys);
            ears[lookups[v3]] = isDiagonal(lookups[v1], lookups[v4], polys);
            cells.push([
                lookups[v2],
                lookups[v3],
                lookups[v1]
            ]);
            lookups.splice(v2, 1);
            end = v3;
            n--;
            break;
        }
        v2++;
    }while (v2 != end)
    cells.push([
        lookups[1],
        lookups[2],
        lookups[0]
    ]);
    return cells;
};

},{"./is-diagonal-2d":"3uoBd"}],"fgQl4":[function(require,module,exports) {
var isZero = require('./is-zero-1d');
module.exports = function(a, b, c) {
    var cax = c[0] - a[0];
    var cay = c[1] - a[1];
    var caz = c[2] - a[2];
    var bax = b[0] - a[0];
    var bay = b[1] - a[1];
    var baz = b[2] - a[2];
    return isZero(caz * bay - baz * cay) && isZero(baz * cax - bax * caz) && isZero(bax * cay - bay * cax);
};

},{"./is-zero-1d":"bzoFj"}],"bARYg":[function(require,module,exports) {
var Vertex = require('./../Core/Vertex');
var Edge = require('./../Core/Edge');
var HalfEdge = require('./../Core/HalfEdge');
var Face = require('./../Core/Face');
var FaceHalfEdges = require('./../Queries/FaceHalfEdges');
var MeshCentroid = require('./../Queries/MeshCentroid');
var calculateNormal = require('guf').calculateNormal;
var expandPolygon = require('cga').expandPolygon2;
var vec3 = require('gl-matrix').vec3;
var quat = require('gl-matrix').quat;
var zAxis = vec3.fromValues(0, 0, 1);
module.exports = function(mesh, faceIndex, distance, scale) {
    var meshVerts = mesh.getVertices();
    var meshHalfEdges = mesh.getHalfEdges();
    var meshEdges = mesh.getEdges();
    var meshEdgeMap = mesh.getEdgeMap();
    var meshFaces = mesh.getFaces();
    var meshPositions = mesh.positions;
    var originalFace = meshFaces[faceIndex];
    var faceHalfEdges = FaceHalfEdges(originalFace);
    var flen = faceHalfEdges.length;
    var originalVertices = [];
    for(var i = 0; i < flen; i++){
        var he = faceHalfEdges[i];
        var vertex = he.getVertex();
        var vertexIndex = vertex.getIndex();
        originalVertices.push(vertex);
    }
    var vlen = originalVertices.length;
    var v0 = meshPositions[originalVertices[0].getIndex()];
    var v1 = meshPositions[originalVertices[1].getIndex()];
    var v2 = meshPositions[originalVertices[2].getIndex()];
    var normal = calculateNormal(v0, v1, v2);
    var faceOri = quat.create();
    quat.rotationTo(faceOri, normal, zAxis);
    var newVertices = [];
    var polygon = [];
    var indicies = [];
    var zOffset = 0;
    for(var j = 0; j < vlen; j++){
        var vertex = originalVertices[j];
        var vertexIndex = vertex.getIndex();
        var vertexPos = vec3.clone(meshPositions[vertexIndex]);
        vec3.transformQuat(vertexPos, vertexPos, faceOri);
        zOffset = vertexPos[2];
        polygon.push([
            vertexPos[0],
            vertexPos[1]
        ]);
        indicies.push(vertexIndex);
        newVertices.push(new Vertex());
    }
    // console.log( zOffset );
    quat.rotationTo(faceOri, zAxis, normal);
    var results = expandPolygon(polygon, -(scale ? scale : 0.00001));
    var rlen = results.length;
    var newPositions = [];
    var newEdges = [];
    var newHalfEdges = [];
    zOffset += distance != undefined ? distance : 0;
    for(var i = 0; i < rlen; i++){
        var pos = results[i];
        var vpos = vec3.fromValues(pos[0], pos[1], zOffset);
        vec3.transformQuat(vpos, vpos, faceOri);
        // vec3.add( vpos, vpos, [0,0,zOffset]);
        newPositions.push(vpos);
        var vertex = newVertices[i];
        vertex.setIndex(meshPositions.length);
        meshPositions.push(vpos);
        meshVerts.push(vertex);
    }
    var lhe = undefined;
    var lhef = undefined;
    for(var i = 0; i < rlen; i++){
        var f = originalFace;
        var v = newVertices[i];
        var vn = newVertices[(i + 1) % rlen];
        var e = new Edge();
        var he = new HalfEdge();
        var hef = new HalfEdge();
        //he
        he.setFlipHalfEdge(hef);
        he.setEdge(e);
        he.setVertex(v);
        he.setFace(f);
        meshHalfEdges.push(he);
        //hef
        hef.setFlipHalfEdge(he);
        hef.setEdge(e);
        hef.setVertex(vn);
        meshHalfEdges.push(hef);
        //e
        e.setIndex(meshEdges.length);
        e.setHalfEdge(he);
        meshEdges.push(e);
        var keys = mesh.getEdgeKeys(v.getIndex(), vn.getIndex());
        meshEdgeMap[keys[0]] = e;
        meshEdgeMap[keys[1]] = e;
        //v
        v.setHalfEdge(he);
        newEdges.push(e);
        newHalfEdges.push(he);
        if (lhe) {
            lhe.setNextHalfEdge(he);
            hef.setNextHalfEdge(lhef);
        }
        lhe = he;
        lhef = hef;
    }
    var he = newHalfEdges[0];
    var hef = he.getFlipHalfEdge();
    lhe.setNextHalfEdge(he);
    hef.setNextHalfEdge(lhef);
    originalFace.setHalfEdge(he);
    var newFaces = [];
    var holeHalfEdges = [];
    var lf = undefined;
    var lhe = undefined;
    for(var i = 0; i < rlen; i++){
        var v = newVertices[i];
        var vo = originalVertices[i];
        var heo = v.getHalfEdge();
        var heof = heo.getFlipHalfEdge();
        var ofhe = faceHalfEdges[i];
        var li = i - 1;
        li = li < 0 ? rlen + li : li;
        var ofhep = faceHalfEdges[li];
        var f = new Face();
        var e = new Edge();
        var he = new HalfEdge();
        var hef = new HalfEdge();
        //he
        he.setFlipHalfEdge(hef);
        he.setNextHalfEdge(ofhe);
        he.setEdge(e);
        he.setVertex(v);
        he.setFace(f);
        //hef
        hef.setFlipHalfEdge(he);
        hef.setNextHalfEdge(heof.getNextHalfEdge());
        hef.setEdge(e);
        hef.setVertex(vo);
        hef.setFace(lf);
        //e
        e.setIndex(meshEdges.length);
        meshEdges.push(e);
        e.setHalfEdge(he);
        //f
        f.setIndex(meshFaces.length);
        f.setHalfEdge(he);
        meshFaces.push(f);
        newFaces.push(f);
        //vo
        vo.setHalfEdge(hef);
        //old connections
        heof.setNextHalfEdge(he);
        heof.setFace(f);
        ofhe.setFace(f);
        ofhep.setNextHalfEdge(hef);
        holeHalfEdges.push(he);
        lf = f;
    }
    var he = holeHalfEdges[0];
    var hef = he.getFlipHalfEdge();
    hef.setFace(newFaces[newFaces.length - 1]);
    // //didn't work for more than 1
    // for( var i = 0; i < rlen; i++ ) {
    //   var vn0 = newVertices[ i ];
    //   var vn1 = newVertices[ ( i + 1 ) % rlen ];
    //
    //   var vo0 = originalVertices[ i ];
    //   var vo1 = originalVertices[ ( i + 1 ) % rlen ];
    //
    //   meshFaces.push( createFace( mesh, [ vo0, vo1, vn1, vn0 ] ) );
    // }
    return originalFace;
};
function createFace(mesh, vertices, face) {
    var meshEdgeMap = mesh.getEdgeMap();
    var meshFaces = mesh.getFaces();
    var meshHalfEdges = mesh.getHalfEdges();
    var meshEdges = mesh.getEdges();
    if (!face) {
        face = new Face();
        face.setIndex(meshFaces.length);
    }
    var vlen = vertices.length;
    var lhe;
    var hes = [];
    for(var i = 0; i < vlen; i++){
        var v0 = vertices[i];
        var v1 = vertices[(i + 1) % vlen];
        var i0 = v0.getIndex();
        var i1 = v1.getIndex();
        var he = new HalfEdge();
        var edge = mesh.getEdge(i0, i1);
        if (edge) {
            var het = edge.getHalfEdge();
            var hetv = het.getVertex();
            if (hetv == v0) he = het;
            else {
                he.setFlipHalfEdge(het);
                het.setFlipHalfEdge(he);
            }
        } else {
            edge = new Edge();
            var keys = mesh.getEdgeKeys(i0, i1);
            edge.setIndex(meshEdges.length);
            meshEdges.push(edge);
            edge.setHalfEdge(he);
            meshEdgeMap[keys[0]] = edge;
            meshEdgeMap[keys[1]] = edge;
        }
        //he
        he.setEdge(edge);
        he.setFace(face);
        he.setVertex(v0);
        if (lhe) lhe.setNextHalfEdge(he);
        hes.push(he);
        lhe = he;
        meshHalfEdges.push(he);
    }
    face.setHalfEdge(lhe);
    lhe.setNextHalfEdge(hes[0]);
    return face;
}

},{"./../Core/Vertex":"aMW4R","./../Core/Edge":"dOHcN","./../Core/HalfEdge":"72nec","./../Core/Face":"fVwz7","./../Queries/FaceHalfEdges":"eum8y","./../Queries/MeshCentroid":"kKwVL","guf":"hlcpy","cga":"6OXri","gl-matrix":"3TXam"}],"7E3Pw":[function(require,module,exports) {
var Vertex = require('./../Core/Vertex');
var Edge = require('./../Core/Edge');
var HalfEdge = require('./../Core/HalfEdge');
var Face = require('./../Core/Face');
var FaceHalfEdges = require('./../Queries/FaceHalfEdges');
var FaceVertices = require('./../Queries/FaceVertices');
var HalfEdgePrev = require('./../Queries/HalfEdgePrev');
var createFace = require('./CreateFace');
module.exports = function(mesh, faceIndex0, faceIndex1, vertexOffset) {
    var meshFaces = mesh.getFaces();
    var f0 = meshFaces[faceIndex0];
    var f0HalfEdges = FaceHalfEdges(f0);
    var f0Vertices = FaceVertices(f0);
    var f0len = f0Vertices.length;
    var f1 = meshFaces[faceIndex1];
    var f1HalfEdges = FaceHalfEdges(f1);
    var f1Vertices = FaceVertices(f1);
    var f1len = f1Vertices.length;
    if (f0len != f1len) throw 'faces do not have the same number of vertices, can not create pipe';
    var faces = [
        f0,
        f1
    ];
    var offset = vertexOffset != undefined ? vertexOffset : 2;
    for(var i = 0; i < f0len; i++){
        var v0i0 = i - offset;
        v0i0 = v0i0 >= f0len ? v0i0 % f0len : v0i0;
        v0i0 = v0i0 < 0 ? f0len + v0i0 : v0i0;
        var v0i1 = (i + 1) % f0len - offset;
        v0i1 = v0i1 >= f0len ? v0i1 % f0len : v0i1;
        v0i1 = v0i1 < 0 ? f0len + v0i1 : v0i1;
        var v1i0 = (f0len - i) % f0len;
        var v1i1 = f0len - (i + 1);
        var oldFace = faces[i];
        var inputFace = oldFace ? true : false;
        var result = createFace(mesh, [
            f0Vertices[v0i0],
            f0Vertices[v0i1],
            f1Vertices[v1i1],
            f1Vertices[v1i0]
        ], oldFace);
        if (!inputFace) meshFaces.push(result);
    }
};

},{"./../Core/Vertex":"aMW4R","./../Core/Edge":"dOHcN","./../Core/HalfEdge":"72nec","./../Core/Face":"fVwz7","./../Queries/FaceHalfEdges":"eum8y","./../Queries/FaceVertices":"elyLX","./../Queries/HalfEdgePrev":"lRsPN","./CreateFace":"lxPIU"}],"lxPIU":[function(require,module,exports) {
var Edge = require('./../Core/Edge');
var HalfEdge = require('./../Core/HalfEdge');
var Face = require('./../Core/Face');
module.exports = function(mesh, vertices, face) {
    var meshEdgeMap = mesh.getEdgeMap();
    var meshFaces = mesh.getFaces();
    var meshHalfEdges = mesh.getHalfEdges();
    var meshEdges = mesh.getEdges();
    if (!face) {
        face = new Face();
        face.setIndex(meshFaces.length);
    }
    var vlen = vertices.length;
    var hel;
    var hes = [];
    for(var i = 0; i < vlen; i++){
        var v0 = vertices[i];
        var v1 = vertices[(i + 1) % vlen];
        var i0 = v0.getIndex();
        var i1 = v1.getIndex();
        var he = new HalfEdge();
        var edge = mesh.getEdge(i0, i1);
        if (edge) {
            var het = edge.getHalfEdge();
            var hetv = het.getVertex();
            if (hetv == v0) he = het;
            else {
                he.setFlipHalfEdge(het);
                het.setFlipHalfEdge(he);
            }
        } else {
            edge = new Edge();
            var keys = mesh.getEdgeKeys(i0, i1);
            edge.setIndex(meshEdges.length);
            meshEdges.push(edge);
            edge.setHalfEdge(he);
            meshEdgeMap[keys[0]] = edge;
            meshEdgeMap[keys[1]] = edge;
        }
        //he
        he.setEdge(edge);
        he.setFace(face);
        he.setVertex(v0);
        if (hel) hel.setNextHalfEdge(he);
        //v
        v0.setHalfEdge(he);
        hes.push(he);
        hel = he;
        meshHalfEdges.push(he);
    }
    face.setHalfEdge(hes[0]);
    hel.setNextHalfEdge(hes[0]);
    return face;
};

},{"./../Core/Edge":"dOHcN","./../Core/HalfEdge":"72nec","./../Core/Face":"fVwz7"}],"5Bekj":[function(require,module,exports) {
var Mesh = require('./../Core/Mesh');
var vec3 = require('gl-matrix').vec3;
module.exports = function(mesh) {
    var newMesh = new Mesh();
    var newPositions = [];
    var positions = mesh.getPositions();
    var plen = positions.length;
    for(var i = 0; i < plen; i++)newPositions.push(vec3.clone(positions[i]));
    newMesh.setPositions(newPositions);
    newMesh.setCells(mesh.getCells());
    newMesh.process();
    return newMesh;
};

},{"./../Core/Mesh":"lGuYv","gl-matrix":"3TXam"}],"1rKhw":[function(require,module,exports) {
var Mesh = require('./../Core/Mesh');
var Vertex = require('./../Core/Vertex');
var Edge = require('./../Core/Edge');
var HalfEdge = require('./../Core/HalfEdge');
var Face = require('./../Core/Face');
var FaceHalfEdges = require('./../Queries/FaceHalfEdges');
var vec3 = require('gl-matrix').vec3;
module.exports = function(mesh, other) {
    var meshPositions = mesh.positions;
    var mplen = meshPositions.length;
    var meshVerticies = mesh.getVertices();
    var mvlen = meshVerticies.length;
    var meshFaces = mesh.getFaces();
    var mflen = meshFaces.length;
    var meshEdges = mesh.getEdges();
    var melen = meshEdges.length;
    var meshEdgeMap = mesh.getEdgeMap();
    var otherPositions = other.positions;
    var oplen = otherPositions.length;
    var otherVertices = other.getVertices();
    var ovlen = otherVertices.length;
    var otherCells = other.getCells();
    var oclen = otherCells.length;
    for(var i = 0; i < oplen; i++){
        var v = new Vertex();
        v.setIndex(meshVerticies.length);
        meshVerticies.push(v);
        var p = vec3.clone(otherPositions[i]);
        meshPositions.push(p);
    }
    for(var i = 0; i < oclen; i++){
        var cell = otherCells[i];
        var clen = cell.length;
        var face = new Face();
        face.setIndex(meshFaces.length);
        meshFaces.push(face);
        var lhe = undefined;
        var hes = [];
        for(var j = 0; j < clen; j++){
            var i0 = mvlen + cell[j];
            var i1 = mvlen + cell[(j + 1) % clen];
            var vertex = meshVerticies[i0];
            var edge = mesh.getEdge(i0, i1);
            var hasEdge = edge ? true : false;
            var he = new HalfEdge();
            if (!hasEdge) {
                edge = new Edge();
                edge.setIndex(meshEdges.length);
                edge.setHalfEdge(he);
                meshEdges.push(edge);
                var keys = mesh.getEdgeKeys(i0, i1);
                meshEdgeMap[keys[0]] = edge;
                meshEdgeMap[keys[1]] = edge;
            } else {
                var hef = edge.getHalfEdge();
                hef.setFlipHalfEdge(he);
                he.setFlipHalfEdge(hef);
            }
            //he
            he.setFace(face);
            he.setEdge(edge);
            he.setVertex(vertex);
            if (lhe) lhe.setNextHalfEdge(he);
            hes.push(he);
            lhe = he;
            //vertex
            vertex.setHalfEdge(he);
        }
        face.setHalfEdge(lhe);
        lhe.setNextHalfEdge(hes[0]);
    }
};

},{"./../Core/Mesh":"lGuYv","./../Core/Vertex":"aMW4R","./../Core/Edge":"dOHcN","./../Core/HalfEdge":"72nec","./../Core/Face":"fVwz7","./../Queries/FaceHalfEdges":"eum8y","gl-matrix":"3TXam"}],"ggWoq":[function(require,module,exports) {
var MeshCentroid = require('./../Queries/MeshCentroid');
var vec3 = require('gl-matrix').vec3;
var tmp = vec3.create();
module.exports = function(mesh, scale) {
    if (scale.constructor != Array) scale = [
        scale,
        scale,
        scale
    ];
    vec3.set(tmp, 0, 0, 0);
    var centroid = MeshCentroid(mesh);
    var positions = mesh.positions;
    var plen = positions.length;
    for(var i = 0; i < plen; i++){
        var pos = positions[i];
        vec3.subtract(pos, pos, centroid);
        vec3.multiply(pos, pos, scale);
        vec3.add(pos, pos, centroid);
    }
};

},{"./../Queries/MeshCentroid":"kKwVL","gl-matrix":"3TXam"}],"iT2PL":[function(require,module,exports) {
var Mesh = require('./../Core/Mesh');
var vec3 = require('gl-matrix').vec3;
var tmp = vec3.create();
module.exports = function(mesh, displacement) {
    vec3.set(tmp, 0, 0, 0);
    var positions = mesh.positions;
    var plen = positions.length;
    for(var i = 0; i < plen; i++){
        var pos = positions[i];
        vec3.subtract(pos, pos, displacement);
    }
};

},{"./../Core/Mesh":"lGuYv","gl-matrix":"3TXam"}],"dwfab":[function(require,module,exports) {
var Mesh = require('./../Core/Mesh');
var FaceHalfEdges = require('./../Queries/FaceHalfEdges');
var FaceVertices = require('./../Queries/FaceVertices');
var vec3 = require('gl-matrix').vec3;
module.exports = function(mesh) {
    var faces = mesh.getFaces();
    var flen = faces.length;
    for(var i = 0; i < flen; i++){
        var hes = FaceHalfEdges(faces[i]);
        var vts = FaceVertices(faces[i]);
        var hlen = hes.length;
        for(var j = 0; j < hlen; j++){
            var i0 = j;
            var i1 = (j + 1) % hlen;
            var v0 = vts[i0];
            var v1 = vts[i1];
            var h0 = hes[i0];
            var h1 = hes[i1];
            h1.setNextHalfEdge(h0);
            h0.setVertex(v1);
            v1.setHalfEdge(h0);
        }
    }
};

},{"./../Core/Mesh":"lGuYv","./../Queries/FaceHalfEdges":"eum8y","./../Queries/FaceVertices":"elyLX","gl-matrix":"3TXam"}],"fEWOP":[function(require,module,exports) {
var Vertex = require('./../Core/Vertex');
var FaceHalfEdges = require('./../Queries/FaceHalfEdges');
var FaceVertices = require('./../Queries/FaceVertices');
var VertexHalfEdges = require('./../Queries/VertexHalfEdges');
var CreateFace = require('./CreateFace');
var Cross = require('guf').cross;
var CalculateNormal = require('guf').calculateNormal;
var ExpandPolygon = require('cga').expandPolygon2;
var vec3 = require('gl-matrix').vec3;
var quat = require('gl-matrix').quat;
var tmp = vec3.create();
var tmp2 = vec3.create();
var p0p1 = vec3.create();
var p2p1 = vec3.create();
var zAxis = vec3.fromValues(0, 0, 1);
module.exports = function(mesh, offset, depth) {
    var meshPositions = mesh.positions;
    var meshVertices = mesh.getVertices();
    var mvlen = meshVertices.length;
    var meshFaces = mesh.getFaces();
    var mflen = meshFaces.length;
    offset = offset != undefined ? offset : 1;
    depth = depth != undefined ? depth : offset;
    for(var i = 0; i < mvlen; i++){
        var vertex = meshVertices[i];
        var vertexPosition = meshPositions[vertex.getIndex()];
        var vertexHalfEdges = VertexHalfEdges(vertex);
        var hlen = vertexHalfEdges.length;
        vec3.set(tmp, 0, 0, 0);
        for(var j = 0; j < hlen; j++){
            var h0 = vertexHalfEdges[j];
            var h1 = vertexHalfEdges[(j + 1) % hlen];
            var h0n = h0.getNextHalfEdge();
            var h1n = h1.getNextHalfEdge();
            var v0 = h0n.getVertex();
            var v1 = h1n.getVertex();
            var p0 = meshPositions[v0.getIndex()];
            var p1 = meshPositions[v1.getIndex()];
            Cross(tmp2, p0, vertexPosition, p1);
            vec3.add(tmp, tmp, tmp2);
        }
        vec3.normalize(tmp, tmp);
        vec3.scale(tmp, tmp, depth);
        var newPosition = vec3.create();
        vec3.add(newPosition, vertexPosition, tmp);
        var vertex = new Vertex();
        vertex.setIndex(meshVertices.length);
        meshVertices.push(vertex);
        meshPositions.push(newPosition);
    }
    for(var k = 0; k < mflen; k++){
        var face = meshFaces[k];
        var faceVertices = FaceVertices(face);
        var vlen = faceVertices.length;
        var v0 = meshPositions[faceVertices[0].getIndex()];
        var v1 = meshPositions[faceVertices[1].getIndex()];
        var v2 = meshPositions[faceVertices[2].getIndex()];
        var normal = CalculateNormal(v0, v1, v2);
        var faceOri = quat.create();
        quat.rotationTo(faceOri, normal, zAxis);
        var newFaceVertices = [];
        var polygon = [];
        var zOffset = 0;
        for(var j = 0; j < vlen; j++){
            var vertex = faceVertices[j];
            var vertexIndex = vertex.getIndex();
            var vertexPos = vec3.clone(meshPositions[vertexIndex]);
            vec3.transformQuat(vertexPos, vertexPos, faceOri);
            zOffset = vertexPos[2];
            polygon.push([
                vertexPos[0],
                vertexPos[1]
            ]);
            newFaceVertices.push(new Vertex());
        }
        quat.rotationTo(faceOri, zAxis, normal);
        var results = ExpandPolygon(polygon, -offset);
        var rlen = results.length;
        for(var i = 0; i < rlen; i++){
            var pos = results[i];
            var vpos = vec3.fromValues(pos[0], pos[1], zOffset);
            vec3.transformQuat(vpos, vpos, faceOri);
            var vertex = newFaceVertices[i];
            vertex.setIndex(meshVertices.length);
            meshPositions.push(vpos);
            meshVertices.push(vertex);
        }
        var faces = [
            face
        ];
        for(var i = 0; i < vlen; i++){
            var i0 = i;
            var i1 = (i + 1) % vlen;
            var v0 = faceVertices[i0];
            var v1 = faceVertices[i1];
            var v0e = meshVertices[v0.getIndex() + mvlen];
            var v1e = meshVertices[v1.getIndex() + mvlen];
            var v2 = newFaceVertices[i1];
            var v3 = newFaceVertices[i0];
            var f = faces[i];
            var add = f == undefined ? true : false;
            var result;
            if (depth > 0) {
                result = CreateFace(mesh, [
                    v0,
                    v1,
                    v2,
                    v3
                ], f);
                meshFaces.push(CreateFace(mesh, [
                    v0e,
                    v3,
                    v2,
                    v1e
                ]));
            } else {
                result = CreateFace(mesh, [
                    v3,
                    v2,
                    v1,
                    v0
                ], f);
                meshFaces.push(CreateFace(mesh, [
                    v1e,
                    v2,
                    v3,
                    v0e
                ]));
            }
            if (add) meshFaces.push(result);
        }
    }
};

},{"./../Core/Vertex":"aMW4R","./../Queries/FaceHalfEdges":"eum8y","./../Queries/FaceVertices":"elyLX","./../Queries/VertexHalfEdges":"8DhJJ","./CreateFace":"lxPIU","guf":"hlcpy","cga":"6OXri","gl-matrix":"3TXam"}],"7Nhm8":[function(require,module,exports) {
var Mesh = require('./../Core/Mesh');
module.exports = function(profile) {
    if (profile.length < 0 || profile[0].length < 2) throw "profile must be a non-zero array of atleast 3 2D positions [ [ x0, y0 ], [ x1, y1 ], [ x2, y2 ] ]";
    var mesh = new Mesh();
    var positions = [];
    var frontFace = [];
    var backFace = [];
    var len = profile.length;
    for(var i = 0; i < len; i++){
        positions.push([
            profile[i][0],
            profile[i][1],
            0
        ]);
        frontFace.push(i);
        backFace.push(len - 1 - i);
    }
    var cells = [
        frontFace,
        backFace
    ];
    mesh = new Mesh();
    mesh.setPositions(positions);
    mesh.setCells(cells);
    mesh.process();
    return mesh;
};

},{"./../Core/Mesh":"lGuYv"}],"k2VZu":[function(require,module,exports) {
!function(t, i) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = t || self).RBush = i();
}(this, function() {
    "use strict";
    function t1(t2, r2, e2, a2, h2) {
        !function t(n, r, e, a, h) {
            for(; a > e;){
                if (a - e > 600) {
                    var o = a - e + 1, s = r - e + 1, l = Math.log(o), f = 0.5 * Math.exp(2 * l / 3), u = 0.5 * Math.sqrt(l * f * (o - f) / o) * (s - o / 2 < 0 ? -1 : 1), m = Math.max(e, Math.floor(r - s * f / o + u)), c = Math.min(a, Math.floor(r + (o - s) * f / o + u));
                    t(n, r, m, c, h);
                }
                var p = n[r], d = e, x = a;
                for(i1(n, e, r), h(n[a], p) > 0 && i1(n, e, a); d < x;){
                    for(i1(n, d, x), d++, x--; h(n[d], p) < 0;)d++;
                    for(; h(n[x], p) > 0;)x--;
                }
                0 === h(n[e], p) ? i1(n, e, x) : i1(n, ++x, a), x <= r && (e = x + 1), r <= x && (a = x - 1);
            }
        }(t2, r2, e2 || 0, a2 || t2.length - 1, h2 || n1);
    }
    function i1(t, i, n) {
        var r = t[i];
        t[i] = t[n], t[n] = r;
    }
    function n1(t, i) {
        return t < i ? -1 : t > i ? 1 : 0;
    }
    var r1 = function(t) {
        void 0 === t && (t = 9), this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
    };
    function e1(t, i, n) {
        if (!n) return i.indexOf(t);
        for(var r = 0; r < i.length; r++)if (n(t, i[r])) return r;
        return -1;
    }
    function a1(t, i) {
        h1(t, 0, t.children.length, i, t);
    }
    function h1(t, i, n, r, e) {
        e || (e = p1(null)), e.minX = 1 / 0, e.minY = 1 / 0, e.maxX = -1 / 0, e.maxY = -1 / 0;
        for(var a = i; a < n; a++){
            var h = t.children[a];
            o1(e, t.leaf ? r(h) : h);
        }
        return e;
    }
    function o1(t, i) {
        return t.minX = Math.min(t.minX, i.minX), t.minY = Math.min(t.minY, i.minY), t.maxX = Math.max(t.maxX, i.maxX), t.maxY = Math.max(t.maxY, i.maxY), t;
    }
    function s1(t, i) {
        return t.minX - i.minX;
    }
    function l1(t, i) {
        return t.minY - i.minY;
    }
    function f1(t) {
        return (t.maxX - t.minX) * (t.maxY - t.minY);
    }
    function u1(t) {
        return t.maxX - t.minX + (t.maxY - t.minY);
    }
    function m1(t, i) {
        return t.minX <= i.minX && t.minY <= i.minY && i.maxX <= t.maxX && i.maxY <= t.maxY;
    }
    function c1(t, i) {
        return i.minX <= t.maxX && i.minY <= t.maxY && i.maxX >= t.minX && i.maxY >= t.minY;
    }
    function p1(t) {
        return {
            children: t,
            height: 1,
            leaf: !0,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
        };
    }
    function d1(i, n, r, e, a) {
        for(var h = [
            n,
            r
        ]; h.length;)if (!((r = h.pop()) - (n = h.pop()) <= e)) {
            var o = n + Math.ceil((r - n) / e / 2) * e;
            t1(i, o, n, r, a), h.push(n, o, o, r);
        }
    }
    return r1.prototype.all = function() {
        return this._all(this.data, []);
    }, r1.prototype.search = function(t) {
        var i = this.data, n = [];
        if (!c1(t, i)) return n;
        for(var r = this.toBBox, e = []; i;){
            for(var a = 0; a < i.children.length; a++){
                var h = i.children[a], o = i.leaf ? r(h) : h;
                c1(t, o) && (i.leaf ? n.push(h) : m1(t, o) ? this._all(h, n) : e.push(h));
            }
            i = e.pop();
        }
        return n;
    }, r1.prototype.collides = function(t) {
        var i = this.data;
        if (!c1(t, i)) return !1;
        for(var n = []; i;){
            for(var r = 0; r < i.children.length; r++){
                var e = i.children[r], a = i.leaf ? this.toBBox(e) : e;
                if (c1(t, a)) {
                    if (i.leaf || m1(t, a)) return !0;
                    n.push(e);
                }
            }
            i = n.pop();
        }
        return !1;
    }, r1.prototype.load = function(t) {
        if (!t || !t.length) return this;
        if (t.length < this._minEntries) {
            for(var i = 0; i < t.length; i++)this.insert(t[i]);
            return this;
        }
        var n = this._build(t.slice(), 0, t.length - 1, 0);
        if (this.data.children.length) {
            if (this.data.height === n.height) this._splitRoot(this.data, n);
            else {
                if (this.data.height < n.height) {
                    var r = this.data;
                    this.data = n, n = r;
                }
                this._insert(n, this.data.height - n.height - 1, !0);
            }
        } else this.data = n;
        return this;
    }, r1.prototype.insert = function(t) {
        return t && this._insert(t, this.data.height - 1), this;
    }, r1.prototype.clear = function() {
        return this.data = p1([]), this;
    }, r1.prototype.remove = function(t, i) {
        if (!t) return this;
        for(var n, r, a, h = this.data, o = this.toBBox(t), s = [], l = []; h || s.length;){
            if (h || (h = s.pop(), r = s[s.length - 1], n = l.pop(), a = !0), h.leaf) {
                var f = e1(t, h.children, i);
                if (-1 !== f) return h.children.splice(f, 1), s.push(h), this._condense(s), this;
            }
            a || h.leaf || !m1(h, o) ? r ? (n++, h = r.children[n], a = !1) : h = null : (s.push(h), l.push(n), n = 0, r = h, h = h.children[0]);
        }
        return this;
    }, r1.prototype.toBBox = function(t) {
        return t;
    }, r1.prototype.compareMinX = function(t, i) {
        return t.minX - i.minX;
    }, r1.prototype.compareMinY = function(t, i) {
        return t.minY - i.minY;
    }, r1.prototype.toJSON = function() {
        return this.data;
    }, r1.prototype.fromJSON = function(t) {
        return this.data = t, this;
    }, r1.prototype._all = function(t, i) {
        for(var n = []; t;)t.leaf ? i.push.apply(i, t.children) : n.push.apply(n, t.children), t = n.pop();
        return i;
    }, r1.prototype._build = function(t, i, n, r) {
        var e, h = n - i + 1, o = this._maxEntries;
        if (h <= o) return a1(e = p1(t.slice(i, n + 1)), this.toBBox), e;
        r || (r = Math.ceil(Math.log(h) / Math.log(o)), o = Math.ceil(h / Math.pow(o, r - 1))), (e = p1([])).leaf = !1, e.height = r;
        var s = Math.ceil(h / o), l = s * Math.ceil(Math.sqrt(o));
        d1(t, i, n, l, this.compareMinX);
        for(var f = i; f <= n; f += l){
            var u = Math.min(f + l - 1, n);
            d1(t, f, u, s, this.compareMinY);
            for(var m = f; m <= u; m += s){
                var c = Math.min(m + s - 1, u);
                e.children.push(this._build(t, m, c, r - 1));
            }
        }
        return a1(e, this.toBBox), e;
    }, r1.prototype._chooseSubtree = function(t, i, n, r) {
        for(; r.push(i), !i.leaf && r.length - 1 !== n;){
            for(var e = 1 / 0, a = 1 / 0, h = void 0, o = 0; o < i.children.length; o++){
                var s = i.children[o], l = f1(s), u = (m = t, c = s, (Math.max(c.maxX, m.maxX) - Math.min(c.minX, m.minX)) * (Math.max(c.maxY, m.maxY) - Math.min(c.minY, m.minY)) - l);
                u < a ? (a = u, e = l < e ? l : e, h = s) : u === a && l < e && (e = l, h = s);
            }
            i = h || i.children[0];
        }
        var m, c;
        return i;
    }, r1.prototype._insert = function(t, i, n) {
        var r = n ? t : this.toBBox(t), e = [], a = this._chooseSubtree(r, this.data, i, e);
        for(a.children.push(t), o1(a, r); i >= 0 && e[i].children.length > this._maxEntries;)this._split(e, i), i--;
        this._adjustParentBBoxes(r, e, i);
    }, r1.prototype._split = function(t, i) {
        var n = t[i], r = n.children.length, e = this._minEntries;
        this._chooseSplitAxis(n, e, r);
        var h = this._chooseSplitIndex(n, e, r), o = p1(n.children.splice(h, n.children.length - h));
        o.height = n.height, o.leaf = n.leaf, a1(n, this.toBBox), a1(o, this.toBBox), i ? t[i - 1].children.push(o) : this._splitRoot(n, o);
    }, r1.prototype._splitRoot = function(t, i) {
        this.data = p1([
            t,
            i
        ]), this.data.height = t.height + 1, this.data.leaf = !1, a1(this.data, this.toBBox);
    }, r1.prototype._chooseSplitIndex = function(t, i, n) {
        for(var r, e, a, o, s, l, u, m = 1 / 0, c = 1 / 0, p = i; p <= n - i; p++){
            var d = h1(t, 0, p, this.toBBox), x = h1(t, p, n, this.toBBox), v = (e = d, a = x, o = void 0, s = void 0, l = void 0, u = void 0, o = Math.max(e.minX, a.minX), s = Math.max(e.minY, a.minY), l = Math.min(e.maxX, a.maxX), u = Math.min(e.maxY, a.maxY), Math.max(0, l - o) * Math.max(0, u - s)), M = f1(d) + f1(x);
            v < m ? (m = v, r = p, c = M < c ? M : c) : v === m && M < c && (c = M, r = p);
        }
        return r || n - i;
    }, r1.prototype._chooseSplitAxis = function(t, i, n) {
        var r = t.leaf ? this.compareMinX : s1, e = t.leaf ? this.compareMinY : l1;
        this._allDistMargin(t, i, n, r) < this._allDistMargin(t, i, n, e) && t.children.sort(r);
    }, r1.prototype._allDistMargin = function(t, i, n, r) {
        t.children.sort(r);
        for(var e = this.toBBox, a = h1(t, 0, i, e), s = h1(t, n - i, n, e), l = u1(a) + u1(s), f = i; f < n - i; f++){
            var m = t.children[f];
            o1(a, t.leaf ? e(m) : m), l += u1(a);
        }
        for(var c = n - i - 1; c >= i; c--){
            var p = t.children[c];
            o1(s, t.leaf ? e(p) : p), l += u1(s);
        }
        return l;
    }, r1.prototype._adjustParentBBoxes = function(t, i, n) {
        for(var r = n; r >= 0; r--)o1(i[r], t);
    }, r1.prototype._condense = function(t) {
        for(var i = t.length - 1, n = void 0; i >= 0; i--)0 === t[i].children.length ? i > 0 ? (n = t[i - 1].children).splice(n.indexOf(t[i]), 1) : this.clear() : a1(t[i], this.toBBox);
    }, r1;
});

},{}],"4dkwQ":[function(require,module,exports) {
/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/ var _polymerLegacyJs = require("@polymer/polymer/polymer-legacy.js");
var _colorJs = require("@polymer/paper-styles/color.js");
var _paperSpinnerStylesJs = require("./paper-spinner-styles.js");
var _polymerFnJs = require("@polymer/polymer/lib/legacy/polymer-fn.js");
var _htmlTagJs = require("@polymer/polymer/lib/utils/html-tag.js");
var _paperSpinnerBehaviorJs = require("./paper-spinner-behavior.js");
const template = _htmlTagJs.html`
  <style include="paper-spinner-styles"></style>

  <div id="spinnerContainer" class-name="[[__computeContainerClasses(active, __coolingDown)]]" on-animationend="__reset" on-webkit-animation-end="__reset">
    <div class="spinner-layer">
      <div class="circle-clipper left">
        <div class="circle"></div>
      </div>
      <div class="circle-clipper right">
        <div class="circle"></div>
      </div>
    </div>
  </div>
`;
template.setAttribute('strip-whitespace', '');
/**
Material design: [Progress &
activity](https://www.google.com/design/spec/components/progress-activity.html)

Element providing a single color material design circular spinner.

    <paper-spinner-lite active></paper-spinner-lite>

The default spinner is blue. It can be customized to be a different color.

### Accessibility

Alt attribute should be set to provide adequate context for accessibility. If
not provided, it defaults to 'loading'. Empty alt can be provided to mark the
element as decorative if alternative content is provided in another form (e.g. a
text block following the spinner).

    <paper-spinner-lite alt="Loading contacts list" active></paper-spinner-lite>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-spinner-color` | Color of the spinner | `--google-blue-500`
`--paper-spinner-stroke-width` | The width of the spinner stroke | 3px

@group Paper Elements
@element paper-spinner-lite
@hero hero.svg
@demo demo/index.html
*/ _polymerFnJs.Polymer({
    _template: template,
    is: 'paper-spinner-lite',
    behaviors: [
        _paperSpinnerBehaviorJs.PaperSpinnerBehavior
    ]
});

},{"@polymer/polymer/polymer-legacy.js":"4rrHB","@polymer/paper-styles/color.js":"cP0Rx","./paper-spinner-styles.js":"ef69Z","@polymer/polymer/lib/legacy/polymer-fn.js":"6nJFW","@polymer/polymer/lib/utils/html-tag.js":"2ZOZT","./paper-spinner-behavior.js":"fXl8X"}],"4rrHB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Polymer", ()=>_polymerFnJs.Polymer
);
/* import html-tag to export html */ parcelHelpers.export(exports, "html", ()=>_htmlTagJs.html
);
parcelHelpers.export(exports, "Base", ()=>Base
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _legacyElementMixinJs = require("./lib/legacy/legacy-element-mixin.js");
/* template elements */ var _templatizerBehaviorJs = require("./lib/legacy/templatizer-behavior.js");
var _domBindJs = require("./lib/elements/dom-bind.js");
var _domRepeatJs = require("./lib/elements/dom-repeat.js");
var _domIfJs = require("./lib/elements/dom-if.js");
var _arraySelectorJs = require("./lib/elements/array-selector.js");
/* custom-style */ var _customStyleJs = require("./lib/elements/custom-style.js");
/* bc behaviors */ var _mutableDataBehaviorJs = require("./lib/legacy/mutable-data-behavior.js");
var _polymerFnJs = require("./lib/legacy/polymer-fn.js");
var _htmlTagJs = require("./lib/utils/html-tag.js");
const Base = _legacyElementMixinJs.LegacyElementMixin(HTMLElement).prototype;

},{"./lib/legacy/legacy-element-mixin.js":"2mHGE","./lib/legacy/templatizer-behavior.js":"kIpx3","./lib/elements/dom-bind.js":"cW7Ly","./lib/elements/dom-repeat.js":"g0rSr","./lib/elements/dom-if.js":"l26Yf","./lib/elements/array-selector.js":"2xCnx","./lib/elements/custom-style.js":"kqK3F","./lib/legacy/mutable-data-behavior.js":"gDNo1","./lib/legacy/polymer-fn.js":"6nJFW","./lib/utils/html-tag.js":"2ZOZT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2mHGE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LegacyElementMixin", ()=>LegacyElementMixin
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _applyShimJs = require("@webcomponents/shadycss/entrypoints/apply-shim.js");
var _elementMixinJs = require("../mixins/element-mixin.js");
var _gestureEventListenersJs = require("../mixins/gesture-event-listeners.js");
var _dirMixinJs = require("../mixins/dir-mixin.js");
var _mixinJs = require("../utils/mixin.js");
var _renderStatusJs = require("../utils/render-status.js");
var _unresolvedJs = require("../utils/unresolved.js");
var _polymerDomJs = require("./polymer.dom.js");
var _gesturesJs = require("../utils/gestures.js");
var _debounceJs = require("../utils/debounce.js");
var _asyncJs = require("../utils/async.js");
var _pathJs = require("../utils/path.js");
var _wrapJs = require("../utils/wrap.js");
var _scopeSubtreeJs = require("../utils/scope-subtree.js");
var _settingsJs = require("../utils/settings.js");
var _disableUpgradeMixinJs = require("../mixins/disable-upgrade-mixin.js");
var _telemetryJs = require("../utils/telemetry.js");
const DISABLED_ATTR = 'disable-upgrade';
let styleInterface = window.ShadyCSS;
const LegacyElementMixin = _mixinJs.dedupingMixin((base)=>{
    // TODO(kschaaf): Note, the `@implements {Polymer_DirMixin}` is required here
    // (rather than on legacyElementBase) for unknown reasons.
    /**
   * @constructor
   * @implements {Polymer_ElementMixin}
   * @implements {Polymer_GestureEventListeners}
   * @implements {Polymer_DirMixin}
   * @extends {HTMLElement}
   * @private
   */ const GesturesElement = _gestureEventListenersJs.GestureEventListeners(_elementMixinJs.ElementMixin(base));
    // Note, the DirMixin does nothing if css is built so avoid including it
    // in that case.
    /**
   * @constructor
   * @extends {GesturesElement}
   * @private
   */ const legacyElementBase = _elementMixinJs.builtCSS ? GesturesElement : _dirMixinJs.DirMixin(GesturesElement);
    const observedAttributesGetter = _disableUpgradeMixinJs.findObservedAttributesGetter(legacyElementBase);
    /**
   * Map of simple names to touch action names
   * @dict
   */ const DIRECTION_MAP = {
        'x': 'pan-x',
        'y': 'pan-y',
        'none': 'none',
        'all': 'auto'
    };
    /**
   * @polymer
   * @mixinClass
   * @extends {legacyElementBase}
   * @implements {Polymer_LegacyElementMixin}
   * @unrestricted
   */ class LegacyElement extends legacyElementBase {
        constructor(){
            super();
            /** @type {boolean} */ this.isAttached;
            /** @type {?WeakMap<!Element, !Object<string, !Function>>} */ this.__boundListeners;
            /** @type {?Object<string, ?Function>} */ this._debouncers;
            // NOTE: Inlined for perf from version of DisableUpgradeMixin.
            /** @type {boolean|undefined} */ this.__isUpgradeDisabled;
            /** @type {boolean|undefined} */ this.__needsAttributesAtConnected;
            /** @type {boolean|undefined} */ this._legacyForceObservedAttributes;
        }
        /**
     * Forwards `importMeta` from the prototype (i.e. from the info object
     * passed to `Polymer({...})`) to the static API.
     *
     * @return {!Object} The `import.meta` object set on the prototype
     * @suppress {missingProperties} `this` is always in the instance in
     *  closure for some reason even in a static method, rather than the class
     * @nocollapse
     */ static get importMeta() {
            return this.prototype.importMeta;
        }
        /**
     * Legacy callback called during the `constructor`, for overriding
     * by the user.
     * @override
     * @return {void}
     */ created() {
        }
        /**
     * Processes an attribute reaction when the `legacyNoObservedAttributes`
     * setting is in use.
     * @param {string} name Name of attribute that changed
     * @param {?string} old Old attribute value
     * @param {?string} value New attribute value
     * @return {void}
     */ __attributeReaction(name, old, value) {
            if (this.__dataAttributes && this.__dataAttributes[name] || name === DISABLED_ATTR) this.attributeChangedCallback(name, old, value, null);
        }
        /**
     * Sets the value of an attribute.
     * @override
     */ setAttribute(name, value) {
            if (_settingsJs.legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {
                const oldValue = this.getAttribute(name);
                super.setAttribute(name, value);
                // value coerced to String for closure's benefit
                this.__attributeReaction(name, oldValue, String(value));
            } else super.setAttribute(name, value);
        }
        /**
     * Removes an attribute.
     * @override
     */ removeAttribute(name) {
            if (_settingsJs.legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {
                const oldValue = this.getAttribute(name);
                super.removeAttribute(name);
                this.__attributeReaction(name, oldValue, null);
            } else super.removeAttribute(name);
        }
        // NOTE: Inlined for perf from version of DisableUpgradeMixin.
        static get observedAttributes() {
            if (_settingsJs.legacyNoObservedAttributes && !this.prototype._legacyForceObservedAttributes) {
                // Ensure this element is property registered with the telemetry system.
                if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
                    this.__observedAttributes = [];
                    _telemetryJs.register(this.prototype);
                }
                return this.__observedAttributes;
            } else return observedAttributesGetter.call(this).concat(DISABLED_ATTR);
        }
        // NOTE: Inlined for perf from version of DisableUpgradeMixin.
        // Prevent element from enabling properties when it's upgrade disabled.
        // Normally overriding connectedCallback would be enough, but dom-* elements
        /** @override */ _enableProperties() {
            if (!this.__isUpgradeDisabled) super._enableProperties();
        }
        // NOTE: Inlined for perf from version of DisableUpgradeMixin.
        // If the element starts upgrade-disabled and a property is set for
        // which an accessor exists, the default should not be applied.
        // This additional check is needed because defaults are applied via
        // `_initializeProperties` which is called after initial properties
        // have been set when the element starts upgrade-disabled.
        /** @override */ _canApplyPropertyDefault(property) {
            return super._canApplyPropertyDefault(property) && !(this.__isUpgradeDisabled && this._isPropertyPending(property));
        }
        /**
     * Provides an implementation of `connectedCallback`
     * which adds Polymer legacy API's `attached` method.
     * @return {void}
     * @override
     */ connectedCallback() {
            if (this.__needsAttributesAtConnected) this._takeAttributes();
            // NOTE: Inlined for perf from version of DisableUpgradeMixin.
            if (!this.__isUpgradeDisabled) {
                super.connectedCallback();
                this.isAttached = true;
                this.attached();
            }
        }
        /**
     * Legacy callback called during `connectedCallback`, for overriding
     * by the user.
     * @override
     * @return {void}
     */ attached() {
        }
        /**
     * Provides an implementation of `disconnectedCallback`
     * which adds Polymer legacy API's `detached` method.
     * @return {void}
     * @override
     */ disconnectedCallback() {
            // NOTE: Inlined for perf from version of DisableUpgradeMixin.
            if (!this.__isUpgradeDisabled) {
                super.disconnectedCallback();
                this.isAttached = false;
                this.detached();
            }
        }
        /**
     * Legacy callback called during `disconnectedCallback`, for overriding
     * by the user.
     * @override
     * @return {void}
     */ detached() {
        }
        /**
     * Provides an override implementation of `attributeChangedCallback`
     * which adds the Polymer legacy API's `attributeChanged` method.
     * @param {string} name Name of attribute.
     * @param {?string} old Old value of attribute.
     * @param {?string} value Current value of attribute.
     * @param {?string} namespace Attribute namespace.
     * @return {void}
     * @override
     */ attributeChangedCallback(name, old, value, namespace) {
            if (old !== value) {
                // NOTE: Inlined for perf from version of DisableUpgradeMixin.
                if (name == DISABLED_ATTR) // When disable-upgrade is removed, intialize properties and
                // provoke connectedCallback if the element is already connected.
                {
                    if (this.__isUpgradeDisabled && value == null) {
                        this._initializeProperties();
                        this.__isUpgradeDisabled = false;
                        if (_wrapJs.wrap(this).isConnected) this.connectedCallback();
                    }
                } else {
                    super.attributeChangedCallback(name, old, value, namespace);
                    this.attributeChanged(name, old, value);
                }
            }
        }
        /**
     * Legacy callback called during `attributeChangedChallback`, for overriding
     * by the user.
     * @param {string} name Name of attribute.
     * @param {?string} old Old value of attribute.
     * @param {?string} value Current value of attribute.
     * @return {void}
     * @override
     */ attributeChanged(name, old, value) {
        }
        /**
     * Overrides the default `Polymer.PropertyEffects` implementation to
     * add support for class initialization via the `_registered` callback.
     * This is called only when the first instance of the element is created.
     *
     * @return {void}
     * @override
     * @suppress {invalidCasts}
     */ _initializeProperties() {
            // NOTE: Inlined for perf from version of DisableUpgradeMixin.
            // Only auto-use disable-upgrade if legacyOptimizations is set.
            if (_settingsJs.legacyOptimizations && this.hasAttribute(DISABLED_ATTR)) this.__isUpgradeDisabled = true;
            else {
                let proto = Object.getPrototypeOf(this);
                if (!proto.hasOwnProperty(JSCompiler_renameProperty('__hasRegisterFinished', proto))) {
                    this._registered();
                    // backstop in case the `_registered` implementation does not set this
                    proto.__hasRegisterFinished = true;
                }
                super._initializeProperties();
                this.root = this;
                this.created();
                // Pull all attribute values 1x if `legacyNoObservedAttributes` is set.
                if (_settingsJs.legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {
                    if (this.hasAttributes()) this._takeAttributes();
                    else if (!this.parentNode) this.__needsAttributesAtConnected = true;
                }
                // Ensure listeners are applied immediately so that they are
                // added before declarative event listeners. This allows an element to
                // decorate itself via an event prior to any declarative listeners
                // seeing the event. Note, this ensures compatibility with 1.x ordering.
                this._applyListeners();
            }
        }
        _takeAttributes() {
            const a = this.attributes;
            for(let i = 0, l = a.length; i < l; i++){
                const attr = a[i];
                this.__attributeReaction(attr.name, null, attr.value);
            }
        }
        /**
     * Called automatically when an element is initializing.
     * Users may override this method to perform class registration time
     * work. The implementation should ensure the work is performed
     * only once for the class.
     * @protected
     * @return {void}
     * @override
     */ _registered() {
        }
        /**
     * Overrides the default `Polymer.PropertyEffects` implementation to
     * add support for installing `hostAttributes` and `listeners`.
     *
     * @return {void}
     * @override
     */ ready() {
            this._ensureAttributes();
            super.ready();
        }
        /**
     * Ensures an element has required attributes. Called when the element
     * is being readied via `ready`. Users should override to set the
     * element's required attributes. The implementation should be sure
     * to check and not override existing attributes added by
     * the user of the element. Typically, setting attributes should be left
     * to the element user and not done here; reasonable exceptions include
     * setting aria roles and focusability.
     * @protected
     * @return {void}
     * @override
     */ _ensureAttributes() {
        }
        /**
     * Adds element event listeners. Called when the element
     * is being readied via `ready`. Users should override to
     * add any required element event listeners.
     * In performance critical elements, the work done here should be kept
     * to a minimum since it is done before the element is rendered. In
     * these elements, consider adding listeners asynchronously so as not to
     * block render.
     * @protected
     * @return {void}
     * @override
     */ _applyListeners() {
        }
        /**
     * Converts a typed JavaScript value to a string.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features. To customize
     * how properties are serialized to attributes for attribute bindings and
     * `reflectToAttribute: true` properties as well as this method, override
     * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.
     *
     * @param {*} value Value to deserialize
     * @return {string | undefined} Serialized value
     * @override
     */ serialize(value) {
            return this._serializeValue(value);
        }
        /**
     * Converts a string to a typed JavaScript value.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.  To customize
     * how attributes are deserialized to properties for in
     * `attributeChangedCallback`, override `_deserializeValue` method
     * provided by `Polymer.PropertyAccessors`.
     *
     * @param {string} value String to deserialize
     * @param {*} type Type to deserialize the string to
     * @return {*} Returns the deserialized value in the `type` given.
     * @override
     */ deserialize(value, type) {
            return this._deserializeValue(value, type);
        }
        /**
     * Serializes a property to its associated attribute.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.
     *
     * @param {string} property Property name to reflect.
     * @param {string=} attribute Attribute name to reflect.
     * @param {*=} value Property value to reflect.
     * @return {void}
     * @override
     */ reflectPropertyToAttribute(property, attribute, value) {
            this._propertyToAttribute(property, attribute, value);
        }
        /**
     * Sets a typed value to an HTML attribute on a node.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.
     *
     * @param {*} value Value to serialize.
     * @param {string} attribute Attribute name to serialize to.
     * @param {Element} node Element to set attribute to.
     * @return {void}
     * @override
     */ serializeValueToAttribute(value, attribute, node) {
            this._valueToNodeAttribute(node || this, value, attribute);
        }
        /**
     * Copies own properties (including accessor descriptors) from a source
     * object to a target object.
     *
     * @param {Object} prototype Target object to copy properties to.
     * @param {Object} api Source object to copy properties from.
     * @return {Object} prototype object that was passed as first argument.
     * @override
     */ extend(prototype, api) {
            if (!(prototype && api)) return prototype || api;
            let n$ = Object.getOwnPropertyNames(api);
            for(let i = 0, n; i < n$.length && (n = n$[i]); i++){
                let pd = Object.getOwnPropertyDescriptor(api, n);
                if (pd) Object.defineProperty(prototype, n, pd);
            }
            return prototype;
        }
        /**
     * Copies props from a source object to a target object.
     *
     * Note, this method uses a simple `for...in` strategy for enumerating
     * properties.  To ensure only `ownProperties` are copied from source
     * to target and that accessor implementations are copied, use `extend`.
     *
     * @param {!Object} target Target object to copy properties to.
     * @param {!Object} source Source object to copy properties from.
     * @return {!Object} Target object that was passed as first argument.
     * @override
     */ mixin(target, source) {
            for(let i in source)target[i] = source[i];
            return target;
        }
        /**
     * Sets the prototype of an object.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.
     * @param {Object} object The object on which to set the prototype.
     * @param {Object} prototype The prototype that will be set on the given
     * `object`.
     * @return {Object} Returns the given `object` with its prototype set
     * to the given `prototype` object.
     * @override
     */ chainObject(object, prototype) {
            if (object && prototype && object !== prototype) object.__proto__ = prototype;
            return object;
        }
        /* **** Begin Template **** */ /**
     * Calls `importNode` on the `content` of the `template` specified and
     * returns a document fragment containing the imported content.
     *
     * @param {HTMLTemplateElement} template HTML template element to instance.
     * @return {!DocumentFragment} Document fragment containing the imported
     *   template content.
     * @override
     * @suppress {missingProperties} go/missingfnprops
     */ instanceTemplate(template) {
            let content = this.constructor._contentForTemplate(template);
            let dom = document.importNode(content, true);
            return dom;
        }
        /* **** Begin Events **** */ /**
     * Dispatches a custom event with an optional detail value.
     *
     * @param {string} type Name of event type.
     * @param {*=} detail Detail value containing event-specific
     *   payload.
     * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined),
     *     composed: (boolean|undefined) }=}
     *  options Object specifying options.  These may include:
     *  `bubbles` (boolean, defaults to `true`),
     *  `cancelable` (boolean, defaults to false), and
     *  `node` on which to fire the event (HTMLElement, defaults to `this`).
     * @return {!Event} The new event that was fired.
     * @override
     */ fire(type, detail, options) {
            options = options || {
            };
            detail = detail === null || detail === undefined ? {
            } : detail;
            let event = new Event(type, {
                bubbles: options.bubbles === undefined ? true : options.bubbles,
                cancelable: Boolean(options.cancelable),
                composed: options.composed === undefined ? true : options.composed
            });
            event.detail = detail;
            let node = options.node || this;
            _wrapJs.wrap(node).dispatchEvent(event);
            return event;
        }
        /**
     * Convenience method to add an event listener on a given element,
     * late bound to a named method on this element.
     *
     * @param {?EventTarget} node Element to add event listener to.
     * @param {string} eventName Name of event to listen for.
     * @param {string} methodName Name of handler method on `this` to call.
     * @return {void}
     * @override
     */ listen(node, eventName, methodName) {
            node = node || this;
            let hbl = this.__boundListeners || (this.__boundListeners = new WeakMap());
            let bl = hbl.get(node);
            if (!bl) {
                bl = {
                };
                hbl.set(node, bl);
            }
            let key = eventName + methodName;
            if (!bl[key]) bl[key] = this._addMethodEventListenerToNode(node, eventName, methodName, this);
        }
        /**
     * Convenience method to remove an event listener from a given element,
     * late bound to a named method on this element.
     *
     * @param {?EventTarget} node Element to remove event listener from.
     * @param {string} eventName Name of event to stop listening to.
     * @param {string} methodName Name of handler method on `this` to not call
     anymore.
     * @return {void}
     * @override
     */ unlisten(node, eventName, methodName) {
            node = node || this;
            let bl = this.__boundListeners && this.__boundListeners.get(node);
            let key = eventName + methodName;
            let handler = bl && bl[key];
            if (handler) {
                this._removeEventListenerFromNode(node, eventName, handler);
                bl[key] = null;
            }
        }
        /**
     * Override scrolling behavior to all direction, one direction, or none.
     *
     * Valid scroll directions:
     *   - 'all': scroll in any direction
     *   - 'x': scroll only in the 'x' direction
     *   - 'y': scroll only in the 'y' direction
     *   - 'none': disable scrolling for this node
     *
     * @param {string=} direction Direction to allow scrolling
     * Defaults to `all`.
     * @param {Element=} node Element to apply scroll direction setting.
     * Defaults to `this`.
     * @return {void}
     * @override
     */ setScrollDirection(direction, node) {
            _gesturesJs.setTouchAction(node || this, DIRECTION_MAP[direction] || 'auto');
        }
        /* **** End Events **** */ /**
     * Convenience method to run `querySelector` on this local DOM scope.
     *
     * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
     *
     * @param {string} slctr Selector to run on this local DOM scope
     * @return {Element} Element found by the selector, or null if not found.
     * @override
     */ $$(slctr) {
            // Note, no need to `wrap` this because root is always patched
            return this.root.querySelector(slctr);
        }
        /**
     * Return the element whose local dom within which this element
     * is contained. This is a shorthand for
     * `this.getRootNode().host`.
     * @this {Element}
     * @return {?Node} The element whose local dom within which this element is
     * contained.
     * @override
     */ get domHost() {
            let root = _wrapJs.wrap(this).getRootNode();
            return root instanceof DocumentFragment ? /** @type {ShadowRoot} */ root.host : root;
        }
        /**
     * Force this element to distribute its children to its local dom.
     * This should not be necessary as of Polymer 2.0.2 and is provided only
     * for backwards compatibility.
     * @return {void}
     * @override
     */ distributeContent() {
            const thisEl = this;
            const domApi = _polymerDomJs.dom(thisEl);
            if (window.ShadyDOM && domApi.shadowRoot) ShadyDOM.flush();
        }
        /**
     * Returns a list of nodes that are the effective childNodes. The effective
     * childNodes list is the same as the element's childNodes except that
     * any `<content>` elements are replaced with the list of nodes distributed
     * to the `<content>`, the result of its `getDistributedNodes` method.
     * @return {!Array<!Node>} List of effective child nodes.
     * @suppress {invalidCasts} LegacyElementMixin must be applied to an
     *     HTMLElement
     * @override
     */ getEffectiveChildNodes() {
            const thisEl = this;
            const domApi = _polymerDomJs.dom(thisEl);
            return domApi.getEffectiveChildNodes();
        }
        /**
     * Returns a list of nodes distributed within this element that match
     * `selector`. These can be dom children or elements distributed to
     * children that are insertion points.
     * @param {string} selector Selector to run.
     * @return {!Array<!Node>} List of distributed elements that match selector.
     * @suppress {invalidCasts} LegacyElementMixin must be applied to an
     * HTMLElement
     * @override
     */ queryDistributedElements(selector) {
            const thisEl = this;
            const domApi = _polymerDomJs.dom(thisEl);
            return domApi.queryDistributedElements(selector);
        }
        /**
     * Returns a list of elements that are the effective children. The effective
     * children list is the same as the element's children except that
     * any `<content>` elements are replaced with the list of elements
     * distributed to the `<content>`.
     *
     * @return {!Array<!Node>} List of effective children.
     * @override
     */ getEffectiveChildren() {
            let list = this.getEffectiveChildNodes();
            return list.filter(function(/** @type {!Node} */ n) {
                return n.nodeType === Node.ELEMENT_NODE;
            });
        }
        /**
     * Returns a string of text content that is the concatenation of the
     * text content's of the element's effective childNodes (the elements
     * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
     *
     * @return {string} List of effective children.
     * @override
     */ getEffectiveTextContent() {
            let cn = this.getEffectiveChildNodes();
            let tc = [];
            for(let i = 0, c; c = cn[i]; i++)if (c.nodeType !== Node.COMMENT_NODE) tc.push(c.textContent);
            return tc.join('');
        }
        /**
     * Returns the first effective childNode within this element that
     * match `selector`. These can be dom child nodes or elements distributed
     * to children that are insertion points.
     * @param {string} selector Selector to run.
     * @return {Node} First effective child node that matches selector.
     * @override
     */ queryEffectiveChildren(selector) {
            let e$ = this.queryDistributedElements(selector);
            return e$ && e$[0];
        }
        /**
     * Returns a list of effective childNodes within this element that
     * match `selector`. These can be dom child nodes or elements distributed
     * to children that are insertion points.
     * @param {string} selector Selector to run.
     * @return {!Array<!Node>} List of effective child nodes that match
     *     selector.
     * @override
     */ queryAllEffectiveChildren(selector) {
            return this.queryDistributedElements(selector);
        }
        /**
     * Returns a list of nodes distributed to this element's `<slot>`.
     *
     * If this element contains more than one `<slot>` in its local DOM,
     * an optional selector may be passed to choose the desired content.
     *
     * @param {string=} slctr CSS selector to choose the desired
     *   `<slot>`.  Defaults to `content`.
     * @return {!Array<!Node>} List of distributed nodes for the `<slot>`.
     * @override
     */ getContentChildNodes(slctr) {
            // Note, no need to `wrap` this because root is always
            let content = this.root.querySelector(slctr || 'slot');
            return content ? /** @type {PolymerDomApi} */ _polymerDomJs.dom(content).getDistributedNodes() : [];
        }
        /**
     * Returns a list of element children distributed to this element's
     * `<slot>`.
     *
     * If this element contains more than one `<slot>` in its
     * local DOM, an optional selector may be passed to choose the desired
     * content.  This method differs from `getContentChildNodes` in that only
     * elements are returned.
     *
     * @param {string=} slctr CSS selector to choose the desired
     *   `<content>`.  Defaults to `content`.
     * @return {!Array<!HTMLElement>} List of distributed nodes for the
     *   `<slot>`.
     * @suppress {invalidCasts}
     * @override
     */ getContentChildren(slctr) {
            let children = this.getContentChildNodes(slctr).filter(function(n) {
                return n.nodeType === Node.ELEMENT_NODE;
            });
            return children;
        }
        /**
     * Checks whether an element is in this element's light DOM tree.
     *
     * @param {?Node} node The element to be checked.
     * @return {boolean} true if node is in this element's light DOM tree.
     * @suppress {invalidCasts} LegacyElementMixin must be applied to an
     * HTMLElement
     * @override
     */ isLightDescendant(node) {
            const thisNode = this;
            return thisNode !== node && _wrapJs.wrap(thisNode).contains(node) && _wrapJs.wrap(thisNode).getRootNode() === _wrapJs.wrap(node).getRootNode();
        }
        /**
     * Checks whether an element is in this element's local DOM tree.
     *
     * @param {!Element} node The element to be checked.
     * @return {boolean} true if node is in this element's local DOM tree.
     * @override
     */ isLocalDescendant(node) {
            return this.root === _wrapJs.wrap(node).getRootNode();
        }
        /**
     * No-op for backwards compatibility. This should now be handled by
     * ShadyCss library.
     * @param  {!Element} container Container element to scope
     * @param  {boolean=} shouldObserve if true, start a mutation observer for added nodes to the container
     * @return {?MutationObserver} Returns a new MutationObserver on `container` if `shouldObserve` is true.
     * @override
     */ scopeSubtree(container, shouldObserve = false) {
            return _scopeSubtreeJs.scopeSubtree(container, shouldObserve);
        }
        /**
     * Returns the computed style value for the given property.
     * @param {string} property The css property name.
     * @return {string} Returns the computed css property value for the given
     * `property`.
     * @suppress {invalidCasts} LegacyElementMixin must be applied to an
     *     HTMLElement
     * @override
     */ getComputedStyleValue(property) {
            return styleInterface.getComputedStyleValue(this, property);
        }
        // debounce
        /**
     * Call `debounce` to collapse multiple requests for a named task into
     * one invocation which is made after the wait time has elapsed with
     * no new request.  If no wait time is given, the callback will be called
     * at microtask timing (guaranteed before paint).
     *
     *     debouncedClickAction(e) {
     *       // will not call `processClick` more than once per 100ms
     *       this.debounce('click', function() {
     *        this.processClick();
     *       } 100);
     *     }
     *
     * @param {string} jobName String to identify the debounce job.
     * @param {function():void} callback Function that is called (with `this`
     *   context) when the wait time elapses.
     * @param {number=} wait Optional wait time in milliseconds (ms) after the
     *   last signal that must elapse before invoking `callback`
     * @return {!Object} Returns a debouncer object on which exists the
     * following methods: `isActive()` returns true if the debouncer is
     * active; `cancel()` cancels the debouncer if it is active;
     * `flush()` immediately invokes the debounced callback if the debouncer
     * is active.
     * @override
     */ debounce(jobName, callback, wait) {
            this._debouncers = this._debouncers || {
            };
            return this._debouncers[jobName] = _debounceJs.Debouncer.debounce(this._debouncers[jobName], wait > 0 ? _asyncJs.timeOut.after(wait) : _asyncJs.microTask, callback.bind(this));
        }
        /**
     * Returns whether a named debouncer is active.
     *
     * @param {string} jobName The name of the debouncer started with `debounce`
     * @return {boolean} Whether the debouncer is active (has not yet fired).
     * @override
     */ isDebouncerActive(jobName) {
            this._debouncers = this._debouncers || {
            };
            let debouncer = this._debouncers[jobName];
            return !!(debouncer && debouncer.isActive());
        }
        /**
     * Immediately calls the debouncer `callback` and inactivates it.
     *
     * @param {string} jobName The name of the debouncer started with `debounce`
     * @return {void}
     * @override
     */ flushDebouncer(jobName) {
            this._debouncers = this._debouncers || {
            };
            let debouncer = this._debouncers[jobName];
            if (debouncer) debouncer.flush();
        }
        /**
     * Cancels an active debouncer.  The `callback` will not be called.
     *
     * @param {string} jobName The name of the debouncer started with `debounce`
     * @return {void}
     * @override
     */ cancelDebouncer(jobName) {
            this._debouncers = this._debouncers || {
            };
            let debouncer = this._debouncers[jobName];
            if (debouncer) debouncer.cancel();
        }
        /**
     * Runs a callback function asynchronously.
     *
     * By default (if no waitTime is specified), async callbacks are run at
     * microtask timing, which will occur before paint.
     *
     * @param {!Function} callback The callback function to run, bound to
     *     `this`.
     * @param {number=} waitTime Time to wait before calling the
     *   `callback`.  If unspecified or 0, the callback will be run at microtask
     *   timing (before paint).
     * @return {number} Handle that may be used to cancel the async job.
     * @override
     */ async(callback, waitTime) {
            return waitTime > 0 ? _asyncJs.timeOut.run(callback.bind(this), waitTime) : ~_asyncJs.microTask.run(callback.bind(this));
        }
        /**
     * Cancels an async operation started with `async`.
     *
     * @param {number} handle Handle returned from original `async` call to
     *   cancel.
     * @return {void}
     * @override
     */ cancelAsync(handle) {
            handle < 0 ? _asyncJs.microTask.cancel(~handle) : _asyncJs.timeOut.cancel(handle);
        }
        // other
        /**
     * Convenience method for creating an element and configuring it.
     *
     * @param {string} tag HTML element tag to create.
     * @param {Object=} props Object of properties to configure on the
     *    instance.
     * @return {!Element} Newly created and configured element.
     * @override
     */ create(tag, props) {
            let elt = document.createElement(tag);
            if (props) {
                if (elt.setProperties) elt.setProperties(props);
                else for(let n in props)elt[n] = props[n];
            }
            return elt;
        }
        /**
     * Polyfill for Element.prototype.matches, which is sometimes still
     * prefixed.
     *
     * @param {string} selector Selector to test.
     * @param {!Element=} node Element to test the selector against.
     * @return {boolean} Whether the element matches the selector.
     * @override
     */ elementMatches(selector, node) {
            return _polymerDomJs.matchesSelector(node || this, selector);
        }
        /**
     * Toggles an HTML attribute on or off.
     *
     * @param {string} name HTML attribute name
     * @param {boolean=} bool Boolean to force the attribute on or off.
     *    When unspecified, the state of the attribute will be reversed.
     * @return {boolean} true if the attribute now exists
     * @override
     */ toggleAttribute(name, bool) {
            let node = this;
            if (arguments.length === 3) node = arguments[2];
            if (arguments.length == 1) bool = !node.hasAttribute(name);
            if (bool) {
                _wrapJs.wrap(node).setAttribute(name, '');
                return true;
            } else {
                _wrapJs.wrap(node).removeAttribute(name);
                return false;
            }
        }
        /**
     * Toggles a CSS class on or off.
     *
     * @param {string} name CSS class name
     * @param {boolean=} bool Boolean to force the class on or off.
     *    When unspecified, the state of the class will be reversed.
     * @param {Element=} node Node to target.  Defaults to `this`.
     * @return {void}
     * @override
     */ toggleClass(name, bool, node) {
            node = node || this;
            if (arguments.length == 1) bool = !node.classList.contains(name);
            if (bool) node.classList.add(name);
            else node.classList.remove(name);
        }
        /**
     * Cross-platform helper for setting an element's CSS `transform` property.
     *
     * @param {string} transformText Transform setting.
     * @param {Element=} node Element to apply the transform to.
     * Defaults to `this`
     * @return {void}
     * @override
     */ transform(transformText, node) {
            node = node || this;
            node.style.webkitTransform = transformText;
            node.style.transform = transformText;
        }
        /**
     * Cross-platform helper for setting an element's CSS `translate3d`
     * property.
     *
     * @param {number|string} x X offset.
     * @param {number|string} y Y offset.
     * @param {number|string} z Z offset.
     * @param {Element=} node Element to apply the transform to.
     * Defaults to `this`.
     * @return {void}
     * @override
     */ translate3d(x, y, z, node) {
            node = node || this;
            this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
        }
        /**
     * Removes an item from an array, if it exists.
     *
     * If the array is specified by path, a change notification is
     * generated, so that observers, data bindings and computed
     * properties watching that path can update.
     *
     * If the array is passed directly, **no change
     * notification is generated**.
     *
     * @param {string | !Array<number|string>} arrayOrPath Path to array from
     *     which to remove the item
     *   (or the array itself).
     * @param {*} item Item to remove.
     * @return {Array} Array containing item removed.
     * @override
     */ arrayDelete(arrayOrPath, item) {
            let index;
            if (Array.isArray(arrayOrPath)) {
                index = arrayOrPath.indexOf(item);
                if (index >= 0) return arrayOrPath.splice(index, 1);
            } else {
                let arr = _pathJs.get(this, arrayOrPath);
                index = arr.indexOf(item);
                if (index >= 0) return this.splice(arrayOrPath, index, 1);
            }
            return null;
        }
        // logging
        /**
     * Facades `console.log`/`warn`/`error` as override point.
     *
     * @param {string} level One of 'log', 'warn', 'error'
     * @param {Array} args Array of strings or objects to log
     * @return {void}
     * @override
     */ _logger(level, args) {
            // accept ['foo', 'bar'] and [['foo', 'bar']]
            if (Array.isArray(args) && args.length === 1 && Array.isArray(args[0])) args = args[0];
            switch(level){
                case 'log':
                case 'warn':
                case 'error':
                    console[level](...args);
            }
        }
        /**
     * Facades `console.log` as an override point.
     *
     * @param {...*} args Array of strings or objects to log
     * @return {void}
     * @override
     */ _log(...args) {
            this._logger('log', args);
        }
        /**
     * Facades `console.warn` as an override point.
     *
     * @param {...*} args Array of strings or objects to log
     * @return {void}
     * @override
     */ _warn(...args) {
            this._logger('warn', args);
        }
        /**
     * Facades `console.error` as an override point.
     *
     * @param {...*} args Array of strings or objects to log
     * @return {void}
     * @override
     */ _error(...args) {
            this._logger('error', args);
        }
        /**
     * Formats a message using the element type an a method name.
     *
     * @param {string} methodName Method name to associate with message
     * @param {...*} args Array of strings or objects to log
     * @return {!Array} Array with formatting information for `console`
     *   logging.
     * @override
     */ _logf(methodName, ...args) {
            return [
                '[%s::%s]',
                this.is,
                methodName,
                ...args
            ];
        }
    }
    LegacyElement.prototype.is = '';
    return LegacyElement;
});

},{"@webcomponents/shadycss/entrypoints/apply-shim.js":"kGnxk","../mixins/element-mixin.js":"52pSj","../mixins/gesture-event-listeners.js":"fN0Ep","../mixins/dir-mixin.js":"6Tpi0","../utils/mixin.js":"488pD","../utils/render-status.js":"eDHaR","../utils/unresolved.js":"91wkM","./polymer.dom.js":"jrPMz","../utils/gestures.js":"aS7Zd","../utils/debounce.js":"hbgki","../utils/async.js":"knspW","../utils/path.js":"fr2Rw","../utils/wrap.js":"cQBlD","../utils/scope-subtree.js":"gdzC5","../utils/settings.js":"44bo5","../mixins/disable-upgrade-mixin.js":"fXYPk","../utils/telemetry.js":"fTowj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kGnxk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _applyShimJs = require("../src/apply-shim.js");
var _applyShimJsDefault = parcelHelpers.interopDefault(_applyShimJs);
var _templateMapJs = require("../src/template-map.js");
var _templateMapJsDefault = parcelHelpers.interopDefault(_templateMapJs);
// prettier-ignore
var _styleUtilJs = require("../src/style-util.js");
var _applyShimUtilsJs = require("../src/apply-shim-utils.js");
// prettier-ignore
var _commonUtilsJs = require("../src/common-utils.js");
var _customStyleInterfaceJs = require("../src/custom-style-interface.js"); // eslint-disable-line @typescript-eslint/no-unused-vars
// prettier-ignore
var _styleSettingsJs = require("../src/style-settings.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ 'use strict';
/** @const {ApplyShim} */ const applyShim = new _applyShimJsDefault.default();
class ApplyShimInterface {
    constructor(){
        /** @type {?CustomStyleInterfaceInterface} */ this.customStyleInterface = null;
        applyShim['invalidCallback'] = _applyShimUtilsJs.invalidate;
    }
    ensure() {
        if (this.customStyleInterface) return;
        if (window.ShadyCSS.CustomStyleInterface) {
            this.customStyleInterface = window.ShadyCSS.CustomStyleInterface;
            this.customStyleInterface['transformCallback'] = (style)=>{
                applyShim.transformCustomStyle(style);
            };
            this.customStyleInterface['validateCallback'] = ()=>{
                requestAnimationFrame(()=>{
                    if (this.customStyleInterface['enqueued']) this.flushCustomStyles();
                });
            };
        }
    }
    /**
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   */ prepareTemplate(template, elementName) {
        this.ensure();
        if (_styleUtilJs.elementHasBuiltCss(template)) return;
        _templateMapJsDefault.default[elementName] = template;
        let ast = applyShim.transformTemplate(template, elementName);
        // save original style ast to use for revalidating instances
        template['_styleAst'] = ast;
    }
    flushCustomStyles() {
        this.ensure();
        if (!this.customStyleInterface) return;
        let styles = this.customStyleInterface['processStyles']();
        if (!this.customStyleInterface['enqueued']) return;
        for(let i = 0; i < styles.length; i++){
            let cs = styles[i];
            let style = this.customStyleInterface['getStyleForCustomStyle'](cs);
            if (style) applyShim.transformCustomStyle(style);
        }
        this.customStyleInterface['enqueued'] = false;
    }
    /**
   * @param {HTMLElement} element
   * @param {Object=} properties
   */ styleSubtree(element, properties) {
        this.ensure();
        if (properties) _commonUtilsJs.updateNativeProperties(element, properties);
        if (element.shadowRoot) {
            this.styleElement(element);
            let shadowChildren = /** @type {!ParentNode} */ element.shadowRoot.children || element.shadowRoot.childNodes;
            for(let i = 0; i < shadowChildren.length; i++)this.styleSubtree(shadowChildren[i]);
        } else {
            let children = element.children || element.childNodes;
            for(let i = 0; i < children.length; i++)this.styleSubtree(children[i]);
        }
    }
    /**
   * @param {HTMLElement} element
   */ styleElement(element) {
        this.ensure();
        let { is  } = _styleUtilJs.getIsExtends(element);
        let template = _templateMapJsDefault.default[is];
        if (template && _styleUtilJs.elementHasBuiltCss(template)) return;
        if (template && !_applyShimUtilsJs.templateIsValid(template)) {
            // only revalidate template once
            if (!_applyShimUtilsJs.templateIsValidating(template)) {
                this.prepareTemplate(template, is);
                _applyShimUtilsJs.startValidatingTemplate(template);
            }
            // update this element instance
            let root = element.shadowRoot;
            if (root) {
                let style = root.querySelector('style');
                if (style) {
                    // reuse the template's style ast, it has all the original css text
                    style['__cssRules'] = template['_styleAst'];
                    style.textContent = _styleUtilJs.toCssText(template['_styleAst']);
                }
            }
        }
    }
    /**
   * @param {Object=} properties
   */ styleDocument(properties) {
        this.ensure();
        this.styleSubtree(document.body, properties);
    }
}
if (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {
    const applyShimInterface = new ApplyShimInterface();
    let CustomStyleInterface = window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;
    /** @suppress {duplicate} */ window.ShadyCSS = {
        /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
        prepareTemplate (template, elementName, elementExtends) {
            applyShimInterface.flushCustomStyles();
            applyShimInterface.prepareTemplate(template, elementName);
        },
        /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */ prepareTemplateStyles (template, elementName, elementExtends) {
            window.ShadyCSS.prepareTemplate(template, elementName, elementExtends);
        },
        /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     */ prepareTemplateDom (template, elementName) {
        },
        /**
     * @param {!HTMLElement} element
     * @param {Object=} properties
     */ styleSubtree (element, properties) {
            applyShimInterface.flushCustomStyles();
            applyShimInterface.styleSubtree(element, properties);
        },
        /**
     * @param {!HTMLElement} element
     */ styleElement (element) {
            applyShimInterface.flushCustomStyles();
            applyShimInterface.styleElement(element);
        },
        /**
     * @param {Object=} properties
     */ styleDocument (properties) {
            applyShimInterface.flushCustomStyles();
            applyShimInterface.styleDocument(properties);
        },
        /**
     * @param {Element} element
     * @param {string} property
     * @return {string}
     */ getComputedStyleValue (element, property) {
            return _commonUtilsJs.getComputedStyleValue(element, property);
        },
        flushCustomStyles () {
            applyShimInterface.flushCustomStyles();
        },
        nativeCss: _styleSettingsJs.nativeCssVariables,
        nativeShadow: _styleSettingsJs.nativeShadow,
        cssBuild: _styleSettingsJs.cssBuild,
        disableRuntime: _styleSettingsJs.disableRuntime
    };
    if (CustomStyleInterface) window.ShadyCSS.CustomStyleInterface = CustomStyleInterface;
}
window.ShadyCSS.ApplyShim = applyShim;

},{"../src/apply-shim.js":"dwxJp","../src/template-map.js":"amm2p","../src/style-util.js":"3H8qv","../src/apply-shim-utils.js":"kpx2A","../src/common-utils.js":"6AJbp","../src/custom-style-interface.js":"9kEPT","../src/style-settings.js":"lUdAU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dwxJp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// prettier-ignore
var _styleUtilJs = require("./style-util.js");
var _commonRegexJs = require("./common-regex.js");
var _commonUtilsJs = require("./common-utils.js");
var _cssParseJs = require("./css-parse.js"); // eslint-disable-line @typescript-eslint/no-unused-vars
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ /*
 * The apply shim simulates the behavior of `@apply` proposed at
 * https://tabatkins.github.io/specs/css-apply-rule/.
 * The approach is to convert a property like this:
 *
 *    --foo: {color: red; background: blue;}
 *
 * to this:
 *
 *    --foo_-_color: red;
 *    --foo_-_background: blue;
 *
 * Then where `@apply --foo` is used, that is converted to:
 *
 *    color: var(--foo_-_color);
 *    background: var(--foo_-_background);
 *
 * This approach generally works but there are some issues and limitations.
 * Consider, for example, that somewhere *between* where `--foo` is set and used,
 * another element sets it to:
 *
 *    --foo: { border: 2px solid red; }
 *
 * We must now ensure that the color and background from the previous setting
 * do not apply. This is accomplished by changing the property set to this:
 *
 *    --foo_-_border: 2px solid red;
 *    --foo_-_color: initial;
 *    --foo_-_background: initial;
 *
 * This works but introduces one new issue.
 * Consider this setup at the point where the `@apply` is used:
 *
 *    background: orange;
 *    `@apply` --foo;
 *
 * In this case the background will be unset (initial) rather than the desired
 * `orange`. We address this by altering the property set to use a fallback
 * value like this:
 *
 *    color: var(--foo_-_color);
 *    background: var(--foo_-_background, orange);
 *    border: var(--foo_-_border);
 *
 * Note that the default is retained in the property set and the `background` is
 * the desired `orange`. This leads us to a limitation.
 *
 * Limitation 1:

 * Only properties in the rule where the `@apply`
 * is used are considered as default values.
 * If another rule matches the element and sets `background` with
 * less specificity than the rule in which `@apply` appears,
 * the `background` will not be set.
 *
 * Limitation 2:
 *
 * When using Polymer's `updateStyles` api, new properties may not be set for
 * `@apply` properties.

*/ 'use strict';
const APPLY_NAME_CLEAN = /;\s*/m;
const INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;
const IMPORTANT = /\s*!important/;
// separator used between mixin-name and mixin-property-name when producing properties
// NOTE: plain '-' may cause collisions in user styles
const MIXIN_VAR_SEP = '_-_';
/**
 * @typedef {!Object<string, string>}
 */ let PropertyEntry; // eslint-disable-line @typescript-eslint/no-unused-vars
/**
 * @typedef {!Object<string, boolean>}
 */ let DependantsEntry; // eslint-disable-line @typescript-eslint/no-unused-vars
/** @typedef {{
 *    properties: PropertyEntry,
 *    dependants: DependantsEntry
 * }}
 */ let MixinMapEntry; // eslint-disable-line @typescript-eslint/no-unused-vars
// map of mixin to property names
// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}
class MixinMap {
    constructor(){
        /** @type {!Object<string, !MixinMapEntry>} */ this._map = {
        };
    }
    /**
   * @param {string} name
   * @param {!PropertyEntry} props
   */ set(name, props) {
        name = name.trim();
        this._map[name] = {
            properties: props,
            dependants: {
            }
        };
    }
    /**
   * @param {string} name
   * @return {MixinMapEntry}
   */ get(name) {
        name = name.trim();
        return this._map[name] || null;
    }
}
/**
 * Callback for when an element is marked invalid
 * @type {?function(string)}
 */ let invalidCallback = null;
/** @unrestricted */ class ApplyShim {
    constructor(){
        /** @type {?string} */ this._currentElement = null;
        /** @type {HTMLMetaElement} */ this._measureElement = null;
        this._map = new MixinMap();
    }
    /**
   * return true if `cssText` contains a mixin definition or consumption
   * @param {string} cssText
   * @return {boolean}
   */ detectMixin(cssText) {
        return _commonUtilsJs.detectMixin(cssText);
    }
    /**
   * Gather styles into one style for easier processing
   * @param {!HTMLTemplateElement} template
   * @return {HTMLStyleElement}
   */ gatherStyles(template) {
        const styleText = _styleUtilJs.gatherStyleText(template.content);
        if (styleText) {
            const style = document.createElement('style');
            style.textContent = styleText;
            template.content.insertBefore(style, template.content.firstChild);
            return style;
        }
        return null;
    }
    /**
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   * @return {StyleNode}
   */ transformTemplate(template, elementName) {
        if (template._gatheredStyle === undefined) template._gatheredStyle = this.gatherStyles(template);
        /** @type {HTMLStyleElement} */ const style = template._gatheredStyle;
        return style ? this.transformStyle(style, elementName) : null;
    }
    /**
   * @param {!HTMLStyleElement} style
   * @param {string} elementName
   * @return {StyleNode}
   */ transformStyle(style, elementName = '') {
        let ast = _styleUtilJs.rulesForStyle(style);
        this.transformRules(ast, elementName);
        style.textContent = _styleUtilJs.toCssText(ast);
        return ast;
    }
    /**
   * @param {!HTMLStyleElement} style
   * @return {StyleNode}
   */ transformCustomStyle(style) {
        let ast = _styleUtilJs.rulesForStyle(style);
        _styleUtilJs.forEachRule(ast, (rule)=>{
            if (rule['selector'] === ':root') rule['selector'] = 'html';
            this.transformRule(rule);
        });
        style.textContent = _styleUtilJs.toCssText(ast);
        return ast;
    }
    /**
   * @param {StyleNode} rules
   * @param {string} elementName
   */ transformRules(rules, elementName) {
        this._currentElement = elementName;
        _styleUtilJs.forEachRule(rules, (r)=>{
            this.transformRule(r);
        });
        this._currentElement = null;
    }
    /**
   * @param {!StyleNode} rule
   */ transformRule(rule) {
        rule['cssText'] = this.transformCssText(rule['parsedCssText'], rule);
        // :root was only used for variable assignment in property shim,
        // but generates invalid selectors with real properties.
        // replace with `:host > *`, which serves the same effect
        if (rule['selector'] === ':root') rule['selector'] = ':host > *';
    }
    /**
   * @param {string} cssText
   * @param {!StyleNode} rule
   * @return {string}
   */ transformCssText(cssText, rule) {
        // produce variables
        cssText = cssText.replace(_commonRegexJs.VAR_ASSIGN, (matchText, propertyName, valueProperty, valueMixin)=>this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule)
        );
        // consume mixins
        return this._consumeCssProperties(cssText, rule);
    }
    /**
   * @param {string} property
   * @return {string}
   */ _getInitialValueForProperty(property) {
        if (!this._measureElement) {
            this._measureElement = document.createElement('meta');
            this._measureElement.setAttribute('apply-shim-measure', '');
            this._measureElement.style.all = 'initial';
            document.head.appendChild(this._measureElement);
        }
        return window.getComputedStyle(this._measureElement).getPropertyValue(property);
    }
    /**
   * Walk over all rules before this rule to find fallbacks for mixins
   *
   * @param {!StyleNode} startRule
   * @return {!Object}
   */ _fallbacksFromPreviousRules(startRule) {
        // find the "top" rule
        let topRule = startRule;
        while(topRule['parent'])topRule = topRule['parent'];
        const fallbacks = {
        };
        let seenStartRule = false;
        _styleUtilJs.forEachRule(topRule, (r)=>{
            // stop when we hit the input rule
            seenStartRule = seenStartRule || r === startRule;
            if (seenStartRule) return;
            // NOTE: Only matching selectors are "safe" for this fallback processing
            // It would be prohibitive to run `matchesSelector()` on each selector,
            // so we cheat and only check if the same selector string is used, which
            // guarantees things like specificity matching
            if (r['selector'] === startRule['selector']) Object.assign(fallbacks, this._cssTextToMap(r['parsedCssText']));
        });
        return fallbacks;
    }
    /**
   * replace mixin consumption with variable consumption
   * @param {string} text
   * @param {!StyleNode=} rule
   * @return {string}
   */ _consumeCssProperties(text, rule) {
        /** @type {Array} */ let m = null;
        // loop over text until all mixins with defintions have been applied
        while(m = _commonRegexJs.MIXIN_MATCH.exec(text)){
            let matchText = m[0];
            let mixinName = m[1];
            let idx = m.index;
            // collect properties before apply to be "defaults" if mixin might override them
            // match includes a "prefix", so find the start and end positions of @apply
            let applyPos = idx + matchText.indexOf('@apply');
            let afterApplyPos = idx + matchText.length;
            // find props defined before this @apply
            let textBeforeApply = text.slice(0, applyPos);
            let textAfterApply = text.slice(afterApplyPos);
            let defaults = rule ? this._fallbacksFromPreviousRules(rule) : {
            };
            Object.assign(defaults, this._cssTextToMap(textBeforeApply));
            let replacement = this._atApplyToCssProperties(mixinName, defaults);
            // use regex match position to replace mixin, keep linear processing time
            text = `${textBeforeApply}${replacement}${textAfterApply}`;
            // move regex search to _after_ replacement
            _commonRegexJs.MIXIN_MATCH.lastIndex = idx + replacement.length;
        }
        return text;
    }
    /**
   * produce variable consumption at the site of mixin consumption
   * `@apply` --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))
   * Example:
   *  border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)
   *
   * @param {string} mixinName
   * @param {Object} fallbacks
   * @return {string}
   */ _atApplyToCssProperties(mixinName, fallbacks) {
        mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
        let vars = [];
        let mixinEntry = this._map.get(mixinName);
        // if we depend on a mixin before it is created
        // make a sentinel entry in the map to add this element as a dependency for when it is defined.
        if (!mixinEntry) {
            this._map.set(mixinName, {
            });
            mixinEntry = this._map.get(mixinName);
        }
        if (mixinEntry) {
            if (this._currentElement) mixinEntry.dependants[this._currentElement] = true;
            let p, parts, f;
            const properties = mixinEntry.properties;
            for(p in properties){
                f = fallbacks && fallbacks[p];
                parts = [
                    p,
                    ': var(',
                    mixinName,
                    MIXIN_VAR_SEP,
                    p
                ];
                if (f) parts.push(',', f.replace(IMPORTANT, ''));
                parts.push(')');
                if (IMPORTANT.test(properties[p])) parts.push(' !important');
                vars.push(parts.join(''));
            }
        }
        return vars.join('; ');
    }
    /**
   * @param {string} property
   * @param {string} value
   * @return {string}
   */ _replaceInitialOrInherit(property, value) {
        let match = INITIAL_INHERIT.exec(value);
        if (match) {
            if (match[1]) // initial
            // replace `initial` with the concrete initial value for this property
            value = this._getInitialValueForProperty(property);
            else // inherit
            // with this purposfully illegal value, the variable will be invalid at
            // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)
            // and for inheriting values, will behave similarly
            // we cannot support the same behavior for non inheriting values like 'border'
            value = 'apply-shim-inherit';
        }
        return value;
    }
    /**
   * "parse" a mixin definition into a map of properties and values
   * cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')
   * @param {string} text
   * @param {boolean=} replaceInitialOrInherit
   * @return {!Object<string, string>}
   */ _cssTextToMap(text, replaceInitialOrInherit = false) {
        let props = text.split(';');
        let property, value;
        let out = {
        };
        for(let i = 0, p, sp; i < props.length; i++){
            p = props[i];
            if (p) {
                sp = p.split(':');
                // ignore lines that aren't definitions like @media
                if (sp.length > 1) {
                    property = sp[0].trim();
                    // some properties may have ':' in the value, like data urls
                    value = sp.slice(1).join(':');
                    if (replaceInitialOrInherit) value = this._replaceInitialOrInherit(property, value);
                    out[property] = value;
                }
            }
        }
        return out;
    }
    /**
   * @param {MixinMapEntry} mixinEntry
   */ _invalidateMixinEntry(mixinEntry) {
        if (!invalidCallback) return;
        for(let elementName in mixinEntry.dependants)if (elementName !== this._currentElement) invalidCallback(elementName);
    }
    /**
   * @param {string} matchText
   * @param {string} propertyName
   * @param {?string} valueProperty
   * @param {?string} valueMixin
   * @param {!StyleNode} rule
   * @return {string}
   */ _produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule) {
        // handle case where property value is a mixin
        if (valueProperty) // form: --mixin2: var(--mixin1), where --mixin1 is in the map
        _styleUtilJs.processVariableAndFallback(valueProperty, (prefix, value)=>{
            if (value && this._map.get(value)) valueMixin = `@apply ${value};`;
        });
        if (!valueMixin) return matchText;
        let mixinAsProperties = this._consumeCssProperties('' + valueMixin, rule);
        let prefix = matchText.slice(0, matchText.indexOf('--'));
        // `initial` and `inherit` as properties in a map should be replaced because
        // these keywords are eagerly evaluated when the mixin becomes CSS Custom Properties,
        // and would set the variable value, rather than carry the keyword to the `var()` usage.
        let mixinValues = this._cssTextToMap(mixinAsProperties, true);
        let combinedProps = mixinValues;
        let mixinEntry = this._map.get(propertyName);
        let oldProps = mixinEntry && mixinEntry.properties;
        if (oldProps) // NOTE: since we use mixin, the map of properties is updated here
        // and this is what we want.
        combinedProps = Object.assign(Object.create(oldProps), mixinValues);
        else this._map.set(propertyName, combinedProps);
        let out = [];
        let p, v;
        // set variables defined by current mixin
        let needToInvalidate = false;
        for(p in combinedProps){
            v = mixinValues[p];
            // if property not defined by current mixin, set initial
            if (v === undefined) v = 'initial';
            if (oldProps && !(p in oldProps)) needToInvalidate = true;
            out.push(`${propertyName}${MIXIN_VAR_SEP}${p}: ${v}`);
        }
        if (needToInvalidate) this._invalidateMixinEntry(mixinEntry);
        if (mixinEntry) mixinEntry.properties = combinedProps;
        // because the mixinMap is global, the mixin might conflict with
        // a different scope's simple variable definition:
        // Example:
        // some style somewhere:
        // --mixin1:{ ... }
        // --mixin2: var(--mixin1);
        // some other element:
        // --mixin1: 10px solid red;
        // --foo: var(--mixin1);
        // In this case, we leave the original variable definition in place.
        if (valueProperty) prefix = `${matchText};${prefix}`;
        return `${prefix}${out.join('; ')};`;
    }
}
/* exports */ /* eslint-disable no-self-assign */ ApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;
ApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;
ApplyShim.prototype['transformCustomStyle'] = ApplyShim.prototype.transformCustomStyle;
ApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;
ApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;
ApplyShim.prototype['transformTemplate'] = ApplyShim.prototype.transformTemplate;
ApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;
/* eslint-enable no-self-assign */ Object.defineProperty(ApplyShim.prototype, 'invalidCallback', {
    /** @return {?function(string)} */ get () {
        return invalidCallback;
    },
    /** @param {?function(string)} cb */ set (cb) {
        invalidCallback = cb;
    }
});
exports.default = ApplyShim;

},{"./style-util.js":"3H8qv","./common-regex.js":"2VjDN","./common-utils.js":"6AJbp","./css-parse.js":"2Zzaa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3H8qv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {string|StyleNode} rules
 * @param {function(StyleNode)=} callback
 * @return {string}
 */ parcelHelpers.export(exports, "toCssText", ()=>toCssText
);
/**
 * @param {HTMLStyleElement} style
 * @return {StyleNode}
 */ parcelHelpers.export(exports, "rulesForStyle", ()=>rulesForStyle
);
// Tests if a rule is a keyframes selector, which looks almost exactly
// like a normal selector but is not (it has nothing to do with scoping
// for example).
/**
 * @param {StyleNode} rule
 * @return {boolean}
 */ parcelHelpers.export(exports, "isKeyframesSelector", ()=>isKeyframesSelector
);
/**
 * @param {StyleNode} node
 * @param {Function=} styleRuleCallback
 * @param {Function=} keyframesRuleCallback
 * @param {boolean=} onlyActiveRules
 */ parcelHelpers.export(exports, "forEachRule", ()=>forEachRule
);
// add a string of cssText to the document.
/**
 * @param {string} cssText
 * @param {string} moniker
 * @param {Node} target
 * @param {Node} contextNode
 * @return {HTMLStyleElement}
 */ parcelHelpers.export(exports, "applyCss", ()=>applyCss
);
/**
 * @param {string} cssText
 * @param {string} moniker
 * @return {!HTMLStyleElement}
 */ parcelHelpers.export(exports, "createScopeStyle", ()=>createScopeStyle
);
// insert a comment node as a styling position placeholder.
/**
 * @param {string} moniker
 * @return {!Comment}
 */ parcelHelpers.export(exports, "applyStylePlaceHolder", ()=>applyStylePlaceHolder
);
/**
 * @param {HTMLStyleElement} style
 * @param {?Node} target
 * @param {?Node} contextNode
 */ parcelHelpers.export(exports, "applyStyle", ()=>applyStyle
);
/**
 * @param {string} buildType
 * @return {boolean}
 */ parcelHelpers.export(exports, "isTargetedBuild", ()=>isTargetedBuild
);
/**
 * Walk from text[start] matching parens and
 * returns position of the outer end paren
 * @param {string} text
 * @param {number} start
 * @return {number}
 */ parcelHelpers.export(exports, "findMatchingParen", ()=>findMatchingParen
);
/**
 * @param {string} str
 * @param {function(string, string, string, string)} callback
 */ parcelHelpers.export(exports, "processVariableAndFallback", ()=>processVariableAndFallback
);
/**
 * @param {Element} element
 * @param {string} value
 */ parcelHelpers.export(exports, "setElementClassRaw", ()=>setElementClassRaw
);
parcelHelpers.export(exports, "wrap", ()=>wrap
);
/**
 * @param {Element | {is: string, extends: string}} element
 * @return {{is: string, typeExtension: string}}
 */ parcelHelpers.export(exports, "getIsExtends", ()=>getIsExtends
);
/**
 * @param {Element|DocumentFragment} element
 * @return {string}
 */ parcelHelpers.export(exports, "gatherStyleText", ()=>gatherStyleText
);
/**
 * Split a selector separated by commas into an array in a smart way
 * @param {string} selector
 * @return {!Array<string>}
 */ parcelHelpers.export(exports, "splitSelectorList", ()=>splitSelectorList
);
/**
 * Return the polymer-css-build "build type" applied to this element
 *
 * @param {!HTMLElement} element
 * @return {string} Can be "", "shady", or "shadow"
 */ parcelHelpers.export(exports, "getCssBuild", ()=>getCssBuild
);
/**
 * Check if the given element, either a <template> or <style>, has been processed
 * by polymer-css-build.
 *
 * If so, then we can make a number of optimizations:
 * - polymer-css-build will decompose mixins into individual CSS Custom Properties,
 * so the ApplyShim can be skipped entirely.
 * - Under native ShadowDOM, the style text can just be copied into each instance
 * without modification
 * - If the build is "shady" and ShadyDOM is in use, the styling does not need
 * scoping beyond the shimming of CSS Custom Properties
 *
 * @param {!HTMLElement} element
 * @return {boolean}
 */ parcelHelpers.export(exports, "elementHasBuiltCss", ()=>elementHasBuiltCss
);
/**
 * For templates made with tagged template literals, polymer-css-build will
 * insert a comment of the form `<!--css-build:shadow-->`
 *
 * @param {!HTMLElement} element
 * @return {string}
 */ parcelHelpers.export(exports, "getBuildComment", ()=>getBuildComment
);
/**
 * Check if the css build status is optimal, and do no unneeded work.
 *
 * @param {string=} cssBuild CSS build status
 * @return {boolean} css build is optimal or not
 */ parcelHelpers.export(exports, "isOptimalCssBuild", ()=>isOptimalCssBuild
);
var _styleSettingsJs = require("./style-settings.js");
var _cssParseJs = require("./css-parse.js"); // eslint-disable-line @typescript-eslint/no-unused-vars
var _commonRegexJs = require("./common-regex.js");
// prettier-ignore
var _unscopedStyleHandlerJs = require("./unscoped-style-handler.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ 'use strict';
function toCssText(rules, callback) {
    if (!rules) return '';
    if (typeof rules === 'string') rules = _cssParseJs.parse(rules);
    if (callback) forEachRule(rules, callback);
    return _cssParseJs.stringify(rules, _styleSettingsJs.nativeCssVariables);
}
function rulesForStyle(style) {
    if (!style['__cssRules'] && style.textContent) style['__cssRules'] = _cssParseJs.parse(style.textContent);
    return style['__cssRules'] || null;
}
function isKeyframesSelector(rule) {
    return Boolean(rule['parent']) && rule['parent']['type'] === _cssParseJs.types.KEYFRAMES_RULE;
}
function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
    if (!node) return;
    let skipRules = false;
    let type = node['type'];
    if (onlyActiveRules) {
        if (type === _cssParseJs.types.MEDIA_RULE) {
            let matchMedia = node['selector'].match(_commonRegexJs.MEDIA_MATCH);
            if (matchMedia) // if rule is a non matching @media rule, skip subrules
            {
                if (!window.matchMedia(matchMedia[1]).matches) skipRules = true;
            }
        }
    }
    if (type === _cssParseJs.types.STYLE_RULE) styleRuleCallback(node);
    else if (keyframesRuleCallback && type === _cssParseJs.types.KEYFRAMES_RULE) keyframesRuleCallback(node);
    else if (type === _cssParseJs.types.MIXIN_RULE) skipRules = true;
    let r$ = node['rules'];
    if (r$ && !skipRules) for(let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++)forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
}
function applyCss(cssText, moniker, target, contextNode) {
    let style = createScopeStyle(cssText, moniker);
    applyStyle(style, target, contextNode);
    return style;
}
function createScopeStyle(cssText, moniker) {
    let style = document.createElement('style');
    if (moniker) style.setAttribute('scope', moniker);
    style.textContent = cssText;
    return style;
}
/**
 * Track the position of the last added style for placing placeholders
 * @type {Node}
 */ let lastHeadApplyNode = null;
function applyStylePlaceHolder(moniker) {
    let placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');
    let after = lastHeadApplyNode ? lastHeadApplyNode['nextSibling'] : null;
    let scope = document.head;
    scope.insertBefore(placeHolder, after || scope.firstChild);
    lastHeadApplyNode = placeHolder;
    return placeHolder;
}
function applyStyle(style, target, contextNode) {
    target = target || document.head;
    let after = contextNode && contextNode.nextSibling || target.firstChild;
    target.insertBefore(style, after);
    if (!lastHeadApplyNode) lastHeadApplyNode = style;
    else {
        // only update lastHeadApplyNode if the new style is inserted after the old lastHeadApplyNode
        let position = style.compareDocumentPosition(lastHeadApplyNode);
        if (position === Node.DOCUMENT_POSITION_PRECEDING) lastHeadApplyNode = style;
    }
}
function isTargetedBuild(buildType) {
    return _styleSettingsJs.nativeShadow ? buildType === 'shadow' : buildType === 'shady';
}
function findMatchingParen(text, start) {
    let level = 0;
    for(let i = start, l = text.length; i < l; i++){
        if (text[i] === '(') level++;
        else if (text[i] === ')') {
            if (--level === 0) return i;
        }
    }
    return -1;
}
function processVariableAndFallback(str, callback) {
    // find 'var('
    let start = str.indexOf('var(');
    if (start === -1) // no var?, everything is prefix
    return callback(str, '', '', '');
    //${prefix}var(${inner})${suffix}
    let end = findMatchingParen(str, start + 3);
    let inner = str.substring(start + 4, end);
    let prefix = str.substring(0, start);
    // suffix may have other variables
    let suffix = processVariableAndFallback(str.substring(end + 1), callback);
    let comma = inner.indexOf(',');
    // value and fallback args should be trimmed to match in property lookup
    if (comma === -1) // variable, no fallback
    return callback(prefix, inner.trim(), '', suffix);
    // var(${value},${fallback})
    let value = inner.substring(0, comma).trim();
    let fallback = inner.substring(comma + 1).trim();
    return callback(prefix, value, fallback, suffix);
}
function setElementClassRaw(element, value) {
    // use native setAttribute provided by ShadyDOM when setAttribute is patched
    if (_styleSettingsJs.nativeShadow) element.setAttribute('class', value);
    else window['ShadyDOM']['nativeMethods']['setAttribute'].call(element, 'class', value);
}
const wrap = window['ShadyDOM'] && window['ShadyDOM']['wrap'] || ((node)=>node
);
function getIsExtends(element) {
    let localName = element['localName'];
    let is = '', typeExtension = '';
    /*
  NOTE: technically, this can be wrong for certain svg elements
  with `-` in the name like `<font-face>`
  */ if (localName) {
        if (localName.indexOf('-') > -1) is = localName;
        else {
            typeExtension = localName;
            is = element.getAttribute && element.getAttribute('is') || '';
        }
    } else {
        is = /** @type {?} */ element.is;
        typeExtension = /** @type {?} */ element.extends;
    }
    return {
        is,
        typeExtension
    };
}
function gatherStyleText(element) {
    /** @type {!Array<string>} */ const styleTextParts = [];
    const styles = element.querySelectorAll('style');
    for(let i = 0; i < styles.length; i++){
        const style = styles[i];
        if (_unscopedStyleHandlerJs.isUnscopedStyle(style)) {
            if (!_styleSettingsJs.nativeShadow) {
                _unscopedStyleHandlerJs.processUnscopedStyle(style);
                style.parentNode.removeChild(style);
            }
        } else {
            styleTextParts.push(style.textContent);
            style.parentNode.removeChild(style);
        }
    }
    return styleTextParts.join('').trim();
}
function splitSelectorList(selector) {
    const parts = [];
    let part = '';
    for(let i = 0; i >= 0 && i < selector.length; i++){
        // A selector with parentheses will be one complete part
        if (selector[i] === '(') {
            // find the matching paren
            const end = findMatchingParen(selector, i);
            // push the paren block into the part
            part += selector.slice(i, end + 1);
            // move the index to after the paren block
            i = end;
        } else if (selector[i] === ',') {
            parts.push(part);
            part = '';
        } else part += selector[i];
    }
    // catch any pieces after the last comma
    if (part) parts.push(part);
    return parts;
}
const CSS_BUILD_ATTR = 'css-build';
function getCssBuild(element) {
    if (_styleSettingsJs.cssBuild !== undefined) return _styleSettingsJs.cssBuild;
    if (element.__cssBuild === undefined) {
        // try attribute first, as it is the common case
        const attrValue = element.getAttribute(CSS_BUILD_ATTR);
        if (attrValue) element.__cssBuild = attrValue;
        else {
            const buildComment = getBuildComment(element);
            if (buildComment !== '') // remove build comment so it is not needlessly copied into every element instance
            removeBuildComment(element);
            element.__cssBuild = buildComment;
        }
    }
    return element.__cssBuild || '';
}
function elementHasBuiltCss(element) {
    return getCssBuild(element) !== '';
}
function getBuildComment(element) {
    const buildComment = element.localName === 'template' ? /** @type {!HTMLTemplateElement} */ element.content.firstChild : element.firstChild;
    if (buildComment instanceof Comment) {
        const commentParts = buildComment.textContent.trim().split(':');
        if (commentParts[0] === CSS_BUILD_ATTR) return commentParts[1];
    }
    return '';
}
function isOptimalCssBuild(cssBuild = '') {
    // CSS custom property shim always requires work
    if (cssBuild === '' || !_styleSettingsJs.nativeCssVariables) return false;
    return _styleSettingsJs.nativeShadow ? cssBuild === 'shadow' : cssBuild === 'shady';
}
/**
 * @param {!HTMLElement} element
 */ function removeBuildComment(element) {
    const buildComment = element.localName === 'template' ? /** @type {!HTMLTemplateElement} */ element.content.firstChild : element.firstChild;
    buildComment.parentNode.removeChild(buildComment);
}

},{"./style-settings.js":"lUdAU","./css-parse.js":"2Zzaa","./common-regex.js":"2VjDN","./unscoped-style-handler.js":"7bsVu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lUdAU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "nativeShadow", ()=>nativeShadow
);
parcelHelpers.export(exports, "cssBuild", ()=>cssBuild
);
parcelHelpers.export(exports, "disableRuntime", ()=>disableRuntime
);
parcelHelpers.export(exports, "nativeCssVariables", ()=>nativeCssVariables
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ 'use strict';
const nativeShadow = !(window['ShadyDOM'] && window['ShadyDOM']['inUse']);
let nativeCssVariables_;
/**
 * @param {(ShadyCSSOptions | ShadyCSSInterface)=} settings
 */ function calcCssVariables(settings) {
    if (settings && settings['shimcssproperties']) nativeCssVariables_ = false;
    else // chrome 49 has semi-working css vars, check if box-shadow works
    // safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782
    // However, shim css custom properties are only supported with ShadyDOM enabled,
    // so fall back on native if we do not detect ShadyDOM
    // Edge 15: custom properties used in ::before and ::after will also be used in the parent element
    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12414257/
    nativeCssVariables_ = nativeShadow || Boolean(!navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)'));
}
let cssBuild;
if (window.ShadyCSS && window.ShadyCSS.cssBuild !== undefined) cssBuild = window.ShadyCSS.cssBuild;
const disableRuntime = Boolean(window.ShadyCSS && window.ShadyCSS.disableRuntime);
if (window.ShadyCSS && window.ShadyCSS.nativeCss !== undefined) nativeCssVariables_ = window.ShadyCSS.nativeCss;
else if (window.ShadyCSS) {
    calcCssVariables(window.ShadyCSS);
    // reset window variable to let ShadyCSS API take its place
    window.ShadyCSS = undefined;
} else calcCssVariables(window['WebComponents'] && window['WebComponents']['flags']);
const nativeCssVariables = nativeCssVariables_;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2Zzaa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StyleNode", ()=>StyleNode
);
// given a string of css, return a simple rule tree
/**
 * @param {string} text
 * @return {StyleNode}
 */ parcelHelpers.export(exports, "parse", ()=>parse
);
/**
 * stringify parsed css.
 * @param {StyleNode} node
 * @param {boolean=} preserveProperties
 * @param {string=} text
 * @return {string}
 */ parcelHelpers.export(exports, "stringify", ()=>stringify
);
/**
 * @param {string} cssText
 * @return {string}
 */ parcelHelpers.export(exports, "removeCustomPropAssignment", ()=>removeCustomPropAssignment
);
parcelHelpers.export(exports, "types", ()=>types
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ /*
Extremely simple css parser. Intended to be not more than what we need
and definitely not necessarily correct =).
*/ 'use strict';
/** @unrestricted */ class StyleNode {
    constructor(){
        /** @type {number} */ this['start'] = 0;
        /** @type {number} */ this['end'] = 0;
        /** @type {StyleNode} */ this['previous'] = null;
        /** @type {StyleNode} */ this['parent'] = null;
        /** @type {Array<StyleNode>} */ this['rules'] = null;
        /** @type {string} */ this['parsedCssText'] = '';
        /** @type {string} */ this['cssText'] = '';
        /** @type {boolean} */ this['atRule'] = false;
        /** @type {number} */ this['type'] = 0;
        /** @type {string} */ this['keyframesName'] = '';
        /** @type {string} */ this['selector'] = '';
        /** @type {string} */ this['parsedSelector'] = '';
    }
}
function parse(text) {
    text = clean(text);
    return parseCss(lex(text), text);
}
// remove stuff we don't care about that may hinder parsing
/**
 * @param {string} cssText
 * @return {string}
 */ function clean(cssText) {
    return cssText.replace(RX.comments, '').replace(RX.port, '');
}
// super simple {...} lexer that returns a node tree
/**
 * @param {string} text
 * @return {!StyleNode}
 */ function lex(text) {
    let root = new StyleNode();
    root['start'] = 0;
    root['end'] = text.length;
    let n = root;
    for(let i = 0, l = text.length; i < l; i++){
        if (text[i] === OPEN_BRACE) {
            if (!n['rules']) n['rules'] = [];
            let p = n;
            let previous = p['rules'][p['rules'].length - 1] || null;
            n = new StyleNode();
            n['start'] = i + 1;
            n['parent'] = p;
            n['previous'] = previous;
            p['rules'].push(n);
        } else if (text[i] === CLOSE_BRACE) {
            n['end'] = i + 1;
            n = n['parent'] || root;
        }
    }
    return root;
}
// add selectors/cssText to node tree
/**
 * @param {StyleNode} node
 * @param {string} text
 * @return {!StyleNode}
 */ function parseCss(node, text) {
    let t = text.substring(node['start'], node['end'] - 1);
    node['parsedCssText'] = node['cssText'] = t.trim();
    if (node['parent']) {
        let ss = node['previous'] ? node['previous']['end'] : node['parent']['start'];
        t = text.substring(ss, node['start'] - 1);
        t = _expandUnicodeEscapes(t);
        t = t.replace(RX.multipleSpaces, ' ');
        // TODO(sorvell): ad hoc; make selector include only after last ;
        // helps with mixin syntax
        t = t.substring(t.lastIndexOf(';') + 1);
        let s = node['parsedSelector'] = node['selector'] = t.trim();
        node['atRule'] = s.indexOf(AT_START) === 0;
        // note, support a subset of rule types...
        if (node['atRule']) {
            if (s.indexOf(MEDIA_START) === 0) node['type'] = types.MEDIA_RULE;
            else if (s.match(RX.keyframesRule)) {
                node['type'] = types.KEYFRAMES_RULE;
                node['keyframesName'] = node['selector'].split(RX.multipleSpaces).pop();
            }
        } else if (s.indexOf(VAR_START) === 0) node['type'] = types.MIXIN_RULE;
        else node['type'] = types.STYLE_RULE;
    }
    let r$ = node['rules'];
    if (r$) for(let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++)parseCss(r, text);
    return node;
}
/**
 * conversion of sort unicode escapes with spaces like `\33 ` (and longer) into
 * expanded form that doesn't require trailing space `\000033`
 * @param {string} s
 * @return {string}
 */ function _expandUnicodeEscapes(s) {
    return s.replace(/\\([0-9a-f]{1,6})\s/gi, function() {
        let code = arguments[1], repeat = 6 - code.length;
        while(repeat--)code = '0' + code;
        return '\\' + code;
    });
}
function stringify(node, preserveProperties, text = '') {
    // calc rule cssText
    let cssText = '';
    if (node['cssText'] || node['rules']) {
        let r$ = node['rules'];
        if (r$ && !_hasMixinRules(r$)) for(let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++)cssText = stringify(r, preserveProperties, cssText);
        else {
            cssText = preserveProperties ? node['cssText'] : removeCustomProps(node['cssText']);
            cssText = cssText.trim();
            if (cssText) cssText = '  ' + cssText + '\n';
        }
    }
    // emit rule if there is cssText
    if (cssText) {
        if (node['selector']) text += node['selector'] + ' ' + OPEN_BRACE + '\n';
        text += cssText;
        if (node['selector']) text += CLOSE_BRACE + '\n\n';
    }
    return text;
}
/**
 * @param {Array<StyleNode>} rules
 * @return {boolean}
 */ function _hasMixinRules(rules) {
    let r = rules[0];
    return Boolean(r) && Boolean(r['selector']) && r['selector'].indexOf(VAR_START) === 0;
}
/**
 * @param {string} cssText
 * @return {string}
 */ function removeCustomProps(cssText) {
    cssText = removeCustomPropAssignment(cssText);
    return removeCustomPropApply(cssText);
}
function removeCustomPropAssignment(cssText) {
    return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');
}
/**
 * @param {string} cssText
 * @return {string}
 */ function removeCustomPropApply(cssText) {
    return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');
}
const types = {
    STYLE_RULE: 1,
    KEYFRAMES_RULE: 7,
    MEDIA_RULE: 4,
    MIXIN_RULE: 1000
};
const OPEN_BRACE = '{';
const CLOSE_BRACE = '}';
// helper regexp's
const RX = {
    comments: /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
    port: /@import[^;]*;/gim,
    customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
    mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
    mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
    varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
    keyframesRule: /^@[^\s]*keyframes/,
    multipleSpaces: /\s+/g
};
const VAR_START = '--';
const MEDIA_START = '@media';
const AT_START = '@';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2VjDN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VAR_ASSIGN", ()=>VAR_ASSIGN
);
parcelHelpers.export(exports, "MIXIN_MATCH", ()=>MIXIN_MATCH
);
parcelHelpers.export(exports, "VAR_CONSUMED", ()=>VAR_CONSUMED
);
parcelHelpers.export(exports, "ANIMATION_MATCH", ()=>ANIMATION_MATCH
);
parcelHelpers.export(exports, "MEDIA_MATCH", ()=>MEDIA_MATCH
);
parcelHelpers.export(exports, "IS_VAR", ()=>IS_VAR
);
parcelHelpers.export(exports, "BRACKETED", ()=>BRACKETED
);
parcelHelpers.export(exports, "HOST_PREFIX", ()=>HOST_PREFIX
);
parcelHelpers.export(exports, "HOST_SUFFIX", ()=>HOST_SUFFIX
);
const VAR_ASSIGN = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi;
const MIXIN_MATCH = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi;
const VAR_CONSUMED = /(--[\w-]+)\s*([:,;)]|$)/gi;
const ANIMATION_MATCH = /(animation\s*:)|(animation-name\s*:)/;
const MEDIA_MATCH = /@media\s(.*)/;
const IS_VAR = /^--/;
const BRACKETED = /\{[^}]*\}/g;
const HOST_PREFIX = '(?:^|[^.#[:])';
const HOST_SUFFIX = '($|[.:[\\s>+~])';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7bsVu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scopingAttribute", ()=>scopingAttribute
);
/**
 * Add a specifically-marked style to the document directly, and only one copy of that style.
 *
 * @param {!HTMLStyleElement} style
 * @return {undefined}
 */ parcelHelpers.export(exports, "processUnscopedStyle", ()=>processUnscopedStyle
);
/**
 * Check if a style is supposed to be unscoped
 * @param {!HTMLStyleElement} style
 * @return {boolean} true if the style has the unscoping attribute
 */ parcelHelpers.export(exports, "isUnscopedStyle", ()=>isUnscopedStyle
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ 'use strict';
/** @type {!Set<string>} */ const styleTextSet = new Set();
const scopingAttribute = 'shady-unscoped';
function processUnscopedStyle(style) {
    const text = style.textContent;
    if (!styleTextSet.has(text)) {
        styleTextSet.add(text);
        const newStyle = document.createElement('style');
        newStyle.setAttribute('shady-unscoped', '');
        newStyle.textContent = text;
        document.head.appendChild(newStyle);
    }
}
function isUnscopedStyle(style) {
    return style.hasAttribute(scopingAttribute);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6AJbp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Element} element
 * @param {Object=} properties
 */ parcelHelpers.export(exports, "updateNativeProperties", ()=>updateNativeProperties
);
/**
 * @param {Element} element
 * @param {string} property
 * @return {string}
 */ parcelHelpers.export(exports, "getComputedStyleValue", ()=>getComputedStyleValue
);
/**
 * return true if `cssText` contains a mixin definition or consumption
 * @param {string} cssText
 * @return {boolean}
 */ parcelHelpers.export(exports, "detectMixin", ()=>detectMixin
);
var _commonRegexJs = require("./common-regex.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ 'use strict';
function updateNativeProperties(element, properties) {
    // remove previous properties
    for(let p in properties)// NOTE: for bc with shim, don't apply null values.
    if (p === null) element.style.removeProperty(p);
    else element.style.setProperty(p, properties[p]);
}
function getComputedStyleValue(element, property) {
    /**
   * @const {string}
   */ const value = window.getComputedStyle(element).getPropertyValue(property);
    if (!value) return '';
    else return value.trim();
}
function detectMixin(cssText) {
    const has = _commonRegexJs.MIXIN_MATCH.test(cssText) || _commonRegexJs.VAR_ASSIGN.test(cssText);
    // reset state of the regexes
    _commonRegexJs.MIXIN_MATCH.lastIndex = 0;
    _commonRegexJs.VAR_ASSIGN.lastIndex = 0;
    return has;
}

},{"./common-regex.js":"2VjDN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"amm2p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ 'use strict';
/**
 * @const {!Object<string, !HTMLTemplateElement>}
 */ const templateMap = {
};
exports.default = templateMap;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kpx2A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {string} elementName
 */ parcelHelpers.export(exports, "invalidate", ()=>invalidate
);
/**
 * This function can be called multiple times to mark a template invalid
 * and signal that the style inside must be regenerated.
 *
 * Use `startValidatingTemplate` to begin an asynchronous validation cycle.
 * During that cycle, call `templateIsValidating` to see if the template must
 * be revalidated
 * @param {HTMLTemplateElement} template
 */ parcelHelpers.export(exports, "invalidateTemplate", ()=>invalidateTemplate
);
/**
 * @param {string} elementName
 * @return {boolean}
 */ parcelHelpers.export(exports, "isValid", ()=>isValid
);
/**
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */ parcelHelpers.export(exports, "templateIsValid", ()=>templateIsValid
);
/**
 * @param {string} elementName
 * @return {boolean}
 */ parcelHelpers.export(exports, "isValidating", ()=>isValidating
);
/**
 * Returns true if the template is currently invalid and `startValidating` has been called since the last invalidation.
 * If false, the template must be validated.
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */ parcelHelpers.export(exports, "templateIsValidating", ()=>templateIsValidating
);
/**
 * the template is marked as `validating` for one microtask so that all instances
 * found in the tree crawl of `applyStyle` will update themselves,
 * but the template will only be updated once.
 * @param {string} elementName
 */ parcelHelpers.export(exports, "startValidating", ()=>startValidating
);
/**
 * Begin an asynchronous invalidation cycle.
 * This should be called after every validation of a template
 *
 * After one microtask, the template will be marked as valid until the next call to `invalidateTemplate`
 * @param {HTMLTemplateElement} template
 */ parcelHelpers.export(exports, "startValidatingTemplate", ()=>startValidatingTemplate
);
/**
 * @return {boolean}
 */ parcelHelpers.export(exports, "elementsAreInvalid", ()=>elementsAreInvalid
);
var _templateMapJs = require("./template-map.js");
var _templateMapJsDefault = parcelHelpers.interopDefault(_templateMapJs);
var _cssParseJs = require("./css-parse.js"); // eslint-disable-line @typescript-eslint/no-unused-vars
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ 'use strict';
/*
 * Utilities for handling invalidating apply-shim mixins for a given template.
 *
 * The invalidation strategy involves keeping track of the "current" version of a template's mixins, and updating that count when a mixin is invalidated.
 * The template
 */ /** @const {string} */ const CURRENT_VERSION = '_applyShimCurrentVersion';
/** @const {string} */ const NEXT_VERSION = '_applyShimNextVersion';
/** @const {string} */ const VALIDATING_VERSION = '_applyShimValidatingVersion';
/**
 * @const {Promise<void>}
 */ const promise = Promise.resolve();
function invalidate(elementName) {
    let template = _templateMapJsDefault.default[elementName];
    if (template) invalidateTemplate(template);
}
function invalidateTemplate(template) {
    // default the current version to 0
    template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0;
    // ensure the "validating for" flag exists
    template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0;
    // increment the next version
    template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;
}
function isValid(elementName) {
    let template = _templateMapJsDefault.default[elementName];
    if (template) return templateIsValid(template);
    return true;
}
function templateIsValid(template) {
    return template[CURRENT_VERSION] === template[NEXT_VERSION];
}
function isValidating(elementName) {
    let template = _templateMapJsDefault.default[elementName];
    if (template) return templateIsValidating(template);
    return false;
}
function templateIsValidating(template) {
    return !templateIsValid(template) && template[VALIDATING_VERSION] === template[NEXT_VERSION];
}
function startValidating(elementName) {
    let template = _templateMapJsDefault.default[elementName];
    startValidatingTemplate(template);
}
function startValidatingTemplate(template) {
    // remember that the current "next version" is the reason for this validation cycle
    template[VALIDATING_VERSION] = template[NEXT_VERSION];
    // however, there only needs to be one async task to clear the counters
    if (!template._validating) {
        template._validating = true;
        promise.then(function() {
            // sync the current version to let future invalidations cause a refresh cycle
            template[CURRENT_VERSION] = template[NEXT_VERSION];
            template._validating = false;
        });
    }
}
function elementsAreInvalid() {
    for(let elementName in _templateMapJsDefault.default){
        let template = _templateMapJsDefault.default[elementName];
        if (!templateIsValid(template)) return true;
    }
    return false;
}

},{"./template-map.js":"amm2p","./css-parse.js":"2Zzaa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9kEPT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CustomStyleProvider", ()=>CustomStyleProvider
);
parcelHelpers.export(exports, "CustomStyleInterfaceInterface", ()=>CustomStyleInterfaceInterface
);
var _documentWaitJs = require("./document-wait.js");
var _documentWaitJsDefault = parcelHelpers.interopDefault(_documentWaitJs);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ 'use strict';
let CustomStyleProvider;
const SEEN_MARKER = '__seenByShadyCSS';
const CACHED_STYLE = '__shadyCSSCachedStyle';
/** @type {?function(!HTMLStyleElement)} */ let transformFn = null;
/** @type {?function()} */ let validateFn = null;
class CustomStyleInterface {
    constructor(){
        /** @type {!Array<!CustomStyleProvider>} */ this['customStyles'] = [];
        this['enqueued'] = false;
        // NOTE(dfreedm): use quotes here to prevent closure inlining to `function(){}`;
        _documentWaitJsDefault.default(()=>{
            if (window['ShadyCSS']['flushCustomStyles']) window['ShadyCSS']['flushCustomStyles']();
        });
    }
    /**
   * Queue a validation for new custom styles to batch style recalculations
   */ enqueueDocumentValidation() {
        if (this['enqueued'] || !validateFn) return;
        this['enqueued'] = true;
        _documentWaitJsDefault.default(validateFn);
    }
    /**
   * @param {!HTMLStyleElement} style
   */ addCustomStyle(style) {
        if (!style[SEEN_MARKER]) {
            style[SEEN_MARKER] = true;
            this['customStyles'].push(style);
            this.enqueueDocumentValidation();
        }
    }
    /**
   * @param {!CustomStyleProvider} customStyle
   * @return {HTMLStyleElement}
   */ getStyleForCustomStyle(customStyle) {
        if (customStyle[CACHED_STYLE]) return customStyle[CACHED_STYLE];
        let style;
        if (customStyle['getStyle']) style = customStyle['getStyle']();
        else style = customStyle;
        return style;
    }
    /**
   * @return {!Array<!CustomStyleProvider>}
   */ processStyles() {
        const cs = this['customStyles'];
        for(let i = 0; i < cs.length; i++){
            const customStyle = cs[i];
            if (customStyle[CACHED_STYLE]) continue;
            const style = this.getStyleForCustomStyle(customStyle);
            if (style) {
                // HTMLImports polyfill may have cloned the style into the main document,
                // which is referenced with __appliedElement.
                const styleToTransform = style['__appliedElement'] || style;
                if (transformFn) transformFn(styleToTransform);
                customStyle[CACHED_STYLE] = styleToTransform;
            }
        }
        return cs;
    }
}
exports.default = CustomStyleInterface;
/* eslint-disable no-self-assign */ CustomStyleInterface.prototype['addCustomStyle'] = CustomStyleInterface.prototype.addCustomStyle;
CustomStyleInterface.prototype['getStyleForCustomStyle'] = CustomStyleInterface.prototype.getStyleForCustomStyle;
CustomStyleInterface.prototype['processStyles'] = CustomStyleInterface.prototype.processStyles;
/* eslint-enable no-self-assign */ Object.defineProperties(CustomStyleInterface.prototype, {
    'transformCallback': {
        /** @return {?function(!HTMLStyleElement)} */ get () {
            return transformFn;
        },
        /** @param {?function(!HTMLStyleElement)} fn */ set (fn) {
            transformFn = fn;
        }
    },
    'validateCallback': {
        /** @return {?function()} */ get () {
            return validateFn;
        },
        /**
     * @param {?function()} fn
     * @this {CustomStyleInterface}
     */ set (fn) {
            let needsEnqueue = false;
            if (!validateFn) needsEnqueue = true;
            validateFn = fn;
            if (needsEnqueue) this.enqueueDocumentValidation();
        }
    }
});
const CustomStyleInterfaceInterface = {
};

},{"./document-wait.js":"hxcEi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hxcEi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ 'use strict';
/** @type {Promise<void>} */ let readyPromise = null;
/** @type {?function(?function())} */ let whenReady = window['HTMLImports'] && window['HTMLImports']['whenReady'] || null;
/** @type {function()} */ let resolveFn;
function documentWait(callback) {
    requestAnimationFrame(function() {
        if (whenReady) whenReady(callback);
        else {
            if (!readyPromise) {
                readyPromise = new Promise((resolve)=>{
                    resolveFn = resolve;
                });
                if (document.readyState === 'complete') resolveFn();
                else document.addEventListener('readystatechange', ()=>{
                    if (document.readyState === 'complete') resolveFn();
                });
            }
            readyPromise.then(function() {
                callback && callback();
            });
        }
    });
}
exports.default = documentWait;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"52pSj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version
);
parcelHelpers.export(exports, "builtCSS", ()=>builtCSS
);
parcelHelpers.export(exports, "ElementMixin", ()=>ElementMixin
);
parcelHelpers.export(exports, "updateStyles", ()=>updateStyles
);
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */ var _bootJs = require("../utils/boot.js");
var _settingsJs = require("../utils/settings.js");
var _mixinJs = require("../utils/mixin.js");
var _styleGatherJs = require("../utils/style-gather.js");
var _resolveUrlJs = require("../utils/resolve-url.js");
var _domModuleJs = require("../elements/dom-module.js");
var _propertyEffectsJs = require("./property-effects.js");
var _propertiesMixinJs = require("./properties-mixin.js");
var _wrapJs = require("../utils/wrap.js");
const version = '3.5.1';
const builtCSS = window.ShadyCSS && window.ShadyCSS['cssBuild'];
const ElementMixin = _mixinJs.dedupingMixin((base1)=>{
    /**
   * @constructor
   * @implements {Polymer_PropertyEffects}
   * @implements {Polymer_PropertiesMixin}
   * @extends {HTMLElement}
   * @private
   */ const polymerElementBase = _propertiesMixinJs.PropertiesMixin(_propertyEffectsJs.PropertyEffects(base1));
    /**
   * Returns a list of properties with default values.
   * This list is created as an optimization since it is a subset of
   * the list returned from `_properties`.
   * This list is used in `_initializeProperties` to set property defaults.
   *
   * @param {PolymerElementConstructor} constructor Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   *   that have default values
   * @private
   */ function propertyDefaults(constructor) {
        if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__propertyDefaults', constructor))) {
            constructor.__propertyDefaults = null;
            let props = constructor._properties;
            for(let p in props){
                let info = props[p];
                if ('value' in info) {
                    constructor.__propertyDefaults = constructor.__propertyDefaults || {
                    };
                    constructor.__propertyDefaults[p] = info;
                }
            }
        }
        return constructor.__propertyDefaults;
    }
    /**
   * Returns a memoized version of the `observers` array.
   * @param {PolymerElementConstructor} constructor Element class
   * @return {Array} Array containing own observers for the given class
   * @protected
   */ function ownObservers(constructor) {
        if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', constructor))) constructor.__ownObservers = constructor.hasOwnProperty(JSCompiler_renameProperty('observers', constructor)) ? /** @type {PolymerElementConstructor} */ constructor.observers : null;
        return constructor.__ownObservers;
    }
    /**
   * Creates effects for a property.
   *
   * Note, once a property has been set to
   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
   * these values may not be changed. For example, a subclass cannot
   * alter these settings. However, additional `observers` may be added
   * by subclasses.
   *
   * The info object should contain property metadata as follows:
   *
   * * `type`: {function} type to which an attribute matching the property
   * is deserialized. Note the property is camel-cased from a dash-cased
   * attribute. For example, 'foo-bar' attribute is deserialized to a
   * property named 'fooBar'.
   *
   * * `readOnly`: {boolean} creates a readOnly property and
   * makes a private setter for the private of the form '_setFoo' for a
   * property 'foo',
   *
   * * `computed`: {string} creates a computed property. A computed property
   * is also automatically set to `readOnly: true`. The value is calculated
   * by running a method and arguments parsed from the given string. For
   * example 'compute(foo)' will compute a given property when the
   * 'foo' property changes by executing the 'compute' method. This method
   * must return the computed value.
   *
   * * `reflectToAttribute`: {boolean} If true, the property value is reflected
   * to an attribute of the same name. Note, the attribute is dash-cased
   * so a property named 'fooBar' is reflected as 'foo-bar'.
   *
   * * `notify`: {boolean} sends a non-bubbling notification event when
   * the property changes. For example, a property named 'foo' sends an
   * event named 'foo-changed' with `event.detail` set to the value of
   * the property.
   *
   * * observer: {string} name of a method that runs when the property
   * changes. The arguments of the method are (value, previousValue).
   *
   * Note: Users may want control over modifying property
   * effects via subclassing. For example, a user might want to make a
   * reflectToAttribute property not do so in a subclass. We've chosen to
   * disable this because it leads to additional complication.
   * For example, a readOnly effect generates a special setter. If a subclass
   * disables the effect, the setter would fail unexpectedly.
   * Based on feedback, we may want to try to make effects more malleable
   * and/or provide an advanced api for manipulating them.
   *
   * @param {!PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {string} name Name of the property.
   * @param {Object} info Info object from which to create property effects.
   * Supported keys:
   * @param {Object} allProps Flattened map of all properties defined in this
   *   element (including inherited properties)
   * @return {void}
   * @private
   */ function createPropertyFromConfig(proto, name, info, allProps) {
        // computed forces readOnly...
        if (info.computed) info.readOnly = true;
        // Note, since all computed properties are readOnly, this prevents
        // adding additional computed property effects (which leads to a confusing
        // setup where multiple triggers for setting a property)
        // While we do have `hasComputedEffect` this is set on the property's
        // dependencies rather than itself.
        if (info.computed) {
            if (proto._hasReadOnlyEffect(name)) console.warn(`Cannot redefine computed property '${name}'.`);
            else proto._createComputedProperty(name, info.computed, allProps);
        }
        if (info.readOnly && !proto._hasReadOnlyEffect(name)) proto._createReadOnlyProperty(name, !info.computed);
        else if (info.readOnly === false && proto._hasReadOnlyEffect(name)) console.warn(`Cannot make readOnly property '${name}' non-readOnly.`);
        if (info.reflectToAttribute && !proto._hasReflectEffect(name)) proto._createReflectedProperty(name);
        else if (info.reflectToAttribute === false && proto._hasReflectEffect(name)) console.warn(`Cannot make reflected property '${name}' non-reflected.`);
        if (info.notify && !proto._hasNotifyEffect(name)) proto._createNotifyingProperty(name);
        else if (info.notify === false && proto._hasNotifyEffect(name)) console.warn(`Cannot make notify property '${name}' non-notify.`);
        // always add observer
        if (info.observer) proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
        // always create the mapping from attribute back to property for deserialization.
        proto._addPropertyToAttributeMap(name);
    }
    /**
   * Process all style elements in the element template. Styles with the
   * `include` attribute are processed such that any styles in
   * the associated "style modules" are included in the element template.
   * @param {PolymerElementConstructor} klass Element class
   * @param {!HTMLTemplateElement} template Template to process
   * @param {string} is Name of element
   * @param {string} baseURI Base URI for element
   * @private
   */ function processElementStyles(klass, template, is, baseURI) {
        if (!builtCSS) {
            const templateStyles = template.content.querySelectorAll('style');
            const stylesWithImports = _styleGatherJs.stylesFromTemplate(template);
            // insert styles from <link rel="import" type="css"> at the top of the template
            const linkedStyles = _styleGatherJs.stylesFromModuleImports(is);
            const firstTemplateChild = template.content.firstElementChild;
            for(let idx = 0; idx < linkedStyles.length; idx++){
                let s = linkedStyles[idx];
                s.textContent = klass._processStyleText(s.textContent, baseURI);
                template.content.insertBefore(s, firstTemplateChild);
            }
            // keep track of the last "concrete" style in the template we have encountered
            let templateStyleIndex = 0;
            // ensure all gathered styles are actually in this template.
            for(let i = 0; i < stylesWithImports.length; i++){
                let s = stylesWithImports[i];
                let templateStyle = templateStyles[templateStyleIndex];
                // if the style is not in this template, it's been "included" and
                // we put a clone of it in the template before the style that included it
                if (templateStyle !== s) {
                    s = s.cloneNode(true);
                    templateStyle.parentNode.insertBefore(s, templateStyle);
                } else templateStyleIndex++;
                s.textContent = klass._processStyleText(s.textContent, baseURI);
            }
        }
        if (window.ShadyCSS) window.ShadyCSS.prepareTemplate(template, is);
        // Support for `adoptedStylesheets` relies on using native Shadow DOM
        // and built CSS. Built CSS is required because runtime transformation of
        // `@apply` is not supported. This is because ShadyCSS relies on being able
        // to update a `style` element in the element template and this is
        // removed when using `adoptedStyleSheets`.
        // Note, it would be more efficient to allow style includes to become
        // separate stylesheets; however, because of `@apply` these are
        // potentially not shareable and sharing the ones that could be shared
        // would require some coordination. To keep it simple, all the includes
        // and styles are collapsed into a single shareable stylesheet.
        if (_settingsJs.useAdoptedStyleSheetsWithBuiltCSS && builtCSS && _settingsJs.supportsAdoptingStyleSheets) {
            // Remove styles in template and make a shareable stylesheet
            const styles = template.content.querySelectorAll('style');
            if (styles) {
                let css = '';
                Array.from(styles).forEach((s)=>{
                    css += s.textContent;
                    s.parentNode.removeChild(s);
                });
                klass._styleSheet = new CSSStyleSheet();
                klass._styleSheet.replaceSync(css);
            }
        }
    }
    /**
   * Look up template from dom-module for element
   *
   * @param {string} is Element name to look up
   * @return {?HTMLTemplateElement|undefined} Template found in dom module, or
   *   undefined if not found
   * @protected
   */ function getTemplateFromDomModule(is) {
        let template = null;
        // Under strictTemplatePolicy in 3.x+, dom-module lookup is only allowed
        // when opted-in via allowTemplateFromDomModule
        if (is && (!_settingsJs.strictTemplatePolicy || _settingsJs.allowTemplateFromDomModule)) {
            template = _domModuleJs.DomModule.import(is, 'template');
            // Under strictTemplatePolicy, require any element with an `is`
            // specified to have a dom-module
            if (_settingsJs.strictTemplatePolicy && !template) throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${is}`);
        }
        return template;
    }
    /**
   * @polymer
   * @mixinClass
   * @unrestricted
   * @implements {Polymer_ElementMixin}
   * @extends {polymerElementBase}
   */ class PolymerElement extends polymerElementBase {
        /**
     * Current Polymer version in Semver notation.
     * @type {string} Semver notation of the current version of Polymer.
     * @nocollapse
     */ static get polymerElementVersion() {
            return version;
        }
        /**
     * Override of PropertiesMixin _finalizeClass to create observers and
     * find the template.
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */ static _finalizeClass() {
            // TODO(https://github.com/google/closure-compiler/issues/3240):
            //     Change back to just super.methodCall()
            polymerElementBase._finalizeClass.call(this);
            const observers = ownObservers(this);
            if (observers) this.createObservers(observers, this._properties);
            this._prepareTemplate();
        }
        /** @nocollapse */ static _prepareTemplate() {
            // note: create "working" template that is finalized at instance time
            let template = /** @type {PolymerElementConstructor} */ this.template;
            if (template) {
                if (typeof template === 'string') {
                    console.error('template getter must return HTMLTemplateElement');
                    template = null;
                } else if (!_settingsJs.legacyOptimizations) template = template.cloneNode(true);
            }
            /** @override */ this.prototype._template = template;
        }
        /**
     * Override of PropertiesChanged createProperties to create accessors
     * and property effects for all of the properties.
     * @param {!Object} props .
     * @return {void}
     * @protected
     * @nocollapse
     */ static createProperties(props) {
            for(let p in props)createPropertyFromConfig(this.prototype, p, props[p], props);
        }
        /**
     * Creates observers for the given `observers` array.
     * Leverages `PropertyEffects` to create observers.
     * @param {Object} observers Array of observer descriptors for
     *   this class
     * @param {Object} dynamicFns Object containing keys for any properties
     *   that are functions and should trigger the effect when the function
     *   reference is changed
     * @return {void}
     * @protected
     * @nocollapse
     */ static createObservers(observers, dynamicFns) {
            const proto = this.prototype;
            for(let i = 0; i < observers.length; i++)proto._createMethodObserver(observers[i], dynamicFns);
        }
        /**
     * Returns the template that will be stamped into this element's shadow root.
     *
     * If a `static get is()` getter is defined, the default implementation will
     * return the first `<template>` in a `dom-module` whose `id` matches this
     * element's `is` (note that a `_template` property on the class prototype
     * takes precedence over the `dom-module` template, to maintain legacy
     * element semantics; a subclass will subsequently fall back to its super
     * class template if neither a `prototype._template` or a `dom-module` for
     * the class's `is` was found).
     *
     * Users may override this getter to return an arbitrary template
     * (in which case the `is` getter is unnecessary). The template returned
     * must be an `HTMLTemplateElement`.
     *
     * Note that when subclassing, if the super class overrode the default
     * implementation and the subclass would like to provide an alternate
     * template via a `dom-module`, it should override this getter and
     * return `DomModule.import(this.is, 'template')`.
     *
     * If a subclass would like to modify the super class template, it should
     * clone it rather than modify it in place.  If the getter does expensive
     * work such as cloning/modifying a template, it should memoize the
     * template for maximum performance:
     *
     *   let memoizedTemplate;
     *   class MySubClass extends MySuperClass {
     *     static get template() {
     *       if (!memoizedTemplate) {
     *         memoizedTemplate = super.template.cloneNode(true);
     *         let subContent = document.createElement('div');
     *         subContent.textContent = 'This came from MySubClass';
     *         memoizedTemplate.content.appendChild(subContent);
     *       }
     *       return memoizedTemplate;
     *     }
     *   }
     *
     * @return {!HTMLTemplateElement|string} Template to be stamped
     * @nocollapse
     */ static get template() {
            // Explanation of template-related properties:
            // - constructor.template (this getter): the template for the class.
            //     This can come from the prototype (for legacy elements), from a
            //     dom-module, or from the super class's template (or can be overridden
            //     altogether by the user)
            // - constructor._template: memoized version of constructor.template
            // - prototype._template: working template for the element, which will be
            //     parsed and modified in place. It is a cloned version of
            //     constructor.template, saved in _finalizeClass(). Note that before
            //     this getter is called, for legacy elements this could be from a
            //     _template field on the info object passed to Polymer(), a behavior,
            //     or set in registered(); once the static getter runs, a clone of it
            //     will overwrite it on the prototype as the working template.
            if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
                let protoTemplate = this.prototype.hasOwnProperty(JSCompiler_renameProperty('_template', this.prototype)) ? this.prototype._template : undefined;
                // Accept a function for the legacy Polymer({_template:...}) field for
                // lazy parsing
                if (typeof protoTemplate === 'function') protoTemplate = protoTemplate();
                this._template = // If user has put template on prototype (e.g. in legacy via registered
                // callback or info object), prefer that first. Note that `null` is
                // used as a sentinel to indicate "no template" and can be used to
                // override a super template, whereas `undefined` is used as a
                // sentinel to mean "fall-back to default template lookup" via
                // dom-module and/or super.template.
                protoTemplate !== undefined ? protoTemplate : this.hasOwnProperty(JSCompiler_renameProperty('is', this)) && getTemplateFromDomModule(/** @type {PolymerElementConstructor}*/ this.is) || // Next look for superclass template (call the super impl this
                // way so that `this` points to the superclass)
                Object.getPrototypeOf(/** @type {PolymerElementConstructor}*/ this.prototype).constructor.template;
            }
            return this._template;
        }
        /**
     * Set the template.
     *
     * @param {!HTMLTemplateElement|string} value Template to set.
     * @nocollapse
     */ static set template(value) {
            this._template = value;
        }
        /**
     * Path matching the url from which the element was imported.
     *
     * This path is used to resolve url's in template style cssText.
     * The `importPath` property is also set on element instances and can be
     * used to create bindings relative to the import path.
     *
     * For elements defined in ES modules, users should implement
     * `static get importMeta() { return import.meta; }`, and the default
     * implementation of `importPath` will  return `import.meta.url`'s path.
     * For elements defined in HTML imports, this getter will return the path
     * to the document containing a `dom-module` element matching this
     * element's static `is` property.
     *
     * Note, this path should contain a trailing `/`.
     *
     * @return {string} The import path for this element class
     * @suppress {missingProperties}
     * @nocollapse
     */ static get importPath() {
            if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
                const meta = this.importMeta;
                if (meta) this._importPath = _resolveUrlJs.pathFromUrl(meta.url);
                else {
                    const module = _domModuleJs.DomModule.import(/** @type {PolymerElementConstructor} */ this.is);
                    this._importPath = module && module.assetpath || Object.getPrototypeOf(/** @type {PolymerElementConstructor}*/ this.prototype).constructor.importPath;
                }
            }
            return this._importPath;
        }
        constructor(){
            super();
            /** @type {HTMLTemplateElement} */ this._template;
            /** @type {string} */ this._importPath;
            /** @type {string} */ this.rootPath;
            /** @type {string} */ this.importPath;
            /** @type {StampedTemplate | HTMLElement | ShadowRoot} */ this.root;
            /** @type {!Object<string, !Element>} */ this.$;
        }
        /**
     * Overrides the default `PropertyAccessors` to ensure class
     * metaprogramming related to property accessors and effects has
     * completed (calls `finalize`).
     *
     * It also initializes any property defaults provided via `value` in
     * `properties` metadata.
     *
     * @return {void}
     * @override
     * @suppress {invalidCasts,missingProperties} go/missingfnprops
     */ _initializeProperties() {
            this.constructor.finalize();
            // note: finalize template when we have access to `localName` to
            // avoid dependence on `is` for polyfilling styling.
            this.constructor._finalizeTemplate(/** @type {!HTMLElement} */ this.localName);
            super._initializeProperties();
            // set path defaults
            this.rootPath = _settingsJs.rootPath;
            this.importPath = this.constructor.importPath;
            // apply property defaults...
            let p$ = propertyDefaults(this.constructor);
            if (!p$) return;
            for(let p in p$){
                let info = p$[p];
                if (this._canApplyPropertyDefault(p)) {
                    let value = typeof info.value == 'function' ? info.value.call(this) : info.value;
                    // Set via `_setProperty` if there is an accessor, to enable
                    // initializing readOnly property defaults
                    if (this._hasAccessor(p)) this._setPendingProperty(p, value, true);
                    else this[p] = value;
                }
            }
        }
        /**
     * Determines if a property dfeault can be applied. For example, this
     * prevents a default from being applied when a property that has no
     * accessor is overridden by its host before upgrade (e.g. via a binding).
     * @override
     * @param {string} property Name of the property
     * @return {boolean} Returns true if the property default can be applied.
     */ _canApplyPropertyDefault(property) {
            return !this.hasOwnProperty(property);
        }
        /**
     * Gather style text for a style element in the template.
     *
     * @param {string} cssText Text containing styling to process
     * @param {string} baseURI Base URI to rebase CSS paths against
     * @return {string} The processed CSS text
     * @protected
     * @nocollapse
     */ static _processStyleText(cssText, baseURI) {
            return _resolveUrlJs.resolveCss(cssText, baseURI);
        }
        /**
    * Configures an element `proto` to function with a given `template`.
    * The element name `is` and extends `ext` must be specified for ShadyCSS
    * style scoping.
    *
    * @param {string} is Tag name (or type extension name) for this element
    * @return {void}
    * @protected
    * @nocollapse
    */ static _finalizeTemplate(is) {
            /** @const {HTMLTemplateElement} */ const template = this.prototype._template;
            if (template && !template.__polymerFinalized) {
                template.__polymerFinalized = true;
                const importPath = this.importPath;
                const baseURI = importPath ? _resolveUrlJs.resolveUrl(importPath) : '';
                // e.g. support `include="module-name"`, and ShadyCSS
                processElementStyles(this, template, is, baseURI);
                this.prototype._bindTemplate(template);
            }
        }
        /**
     * Provides a default implementation of the standard Custom Elements
     * `connectedCallback`.
     *
     * The default implementation enables the property effects system and
     * flushes any pending properties, and updates shimmed CSS properties
     * when using the ShadyCSS scoping/custom properties polyfill.
     *
     * @override
     * @suppress {missingProperties, invalidCasts} Super may or may not
     *     implement the callback
     * @return {void}
     */ connectedCallback() {
            if (window.ShadyCSS && this._template) window.ShadyCSS.styleElement(this);
            super.connectedCallback();
        }
        /**
     * Stamps the element template.
     *
     * @return {void}
     * @override
     */ ready() {
            if (this._template) {
                this.root = this._stampTemplate(this._template);
                this.$ = this.root.$;
            }
            super.ready();
        }
        /**
     * Implements `PropertyEffects`'s `_readyClients` call. Attaches
     * element dom by calling `_attachDom` with the dom stamped from the
     * element's template via `_stampTemplate`. Note that this allows
     * client dom to be attached to the element prior to any observers
     * running.
     *
     * @return {void}
     * @override
     */ _readyClients() {
            if (this._template) this.root = this._attachDom(this.root);
            // The super._readyClients here sets the clients initialized flag.
            // We must wait to do this until after client dom is created/attached
            // so that this flag can be checked to prevent notifications fired
            // during this process from being handled before clients are ready.
            super._readyClients();
        }
        /**
     * Attaches an element's stamped dom to itself. By default,
     * this method creates a `shadowRoot` and adds the dom to it.
     * However, this method may be overridden to allow an element
     * to put its dom in another location.
     *
     * @override
     * @throws {Error}
     * @suppress {missingReturn}
     * @param {StampedTemplate} dom to attach to the element.
     * @return {ShadowRoot} node to which the dom has been attached.
     */ _attachDom(dom) {
            const n = _wrapJs.wrap(this);
            if (n.attachShadow) {
                if (dom) {
                    if (!n.shadowRoot) {
                        n.attachShadow({
                            mode: 'open',
                            shadyUpgradeFragment: dom
                        });
                        n.shadowRoot.appendChild(dom);
                        // When `adoptedStyleSheets` is supported a stylesheet is made
                        // available on the element constructor.
                        if (this.constructor._styleSheet) n.shadowRoot.adoptedStyleSheets = [
                            this.constructor._styleSheet
                        ];
                    }
                    if (_settingsJs.syncInitialRender && window.ShadyDOM) window.ShadyDOM.flushInitial(n.shadowRoot);
                    return n.shadowRoot;
                }
                return null;
            } else throw new Error("ShadowDOM not available. PolymerElement can create dom as children instead of in ShadowDOM by setting `this.root = this;` before `ready`.");
        }
        /**
     * When using the ShadyCSS scoping and custom property shim, causes all
     * shimmed styles in this element (and its subtree) to be updated
     * based on current custom property values.
     *
     * The optional parameter overrides inline custom property styles with an
     * object of properties where the keys are CSS properties, and the values
     * are strings.
     *
     * Example: `this.updateStyles({'--color': 'blue'})`
     *
     * These properties are retained unless a value of `null` is set.
     *
     * Note: This function does not support updating CSS mixins.
     * You can not dynamically change the value of an `@apply`.
     *
     * @override
     * @param {Object=} properties Bag of custom property key/values to
     *   apply to this element.
     * @return {void}
     * @suppress {invalidCasts}
     */ updateStyles(properties) {
            if (window.ShadyCSS) window.ShadyCSS.styleSubtree(this, properties);
        }
        /**
     * Rewrites a given URL relative to a base URL. The base URL defaults to
     * the original location of the document containing the `dom-module` for
     * this element. This method will return the same URL before and after
     * bundling.
     *
     * Note that this function performs no resolution for URLs that start
     * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
     * URL resolution, use `window.URL`.
     *
     * @override
     * @param {string} url URL to resolve.
     * @param {string=} base Optional base URL to resolve against, defaults
     * to the element's `importPath`
     * @return {string} Rewritten URL relative to base
     */ resolveUrl(url, base) {
            if (!base && this.importPath) base = _resolveUrlJs.resolveUrl(this.importPath);
            return _resolveUrlJs.resolveUrl(url, base);
        }
        /**
     * Overrides `PropertyEffects` to add map of dynamic functions on
     * template info, for consumption by `PropertyEffects` template binding
     * code. This map determines which method templates should have accessors
     * created for them.
     *
     * @param {!HTMLTemplateElement} template Template
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} .
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */ static _parseTemplateContent(template, templateInfo, nodeInfo) {
            templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;
            // TODO(https://github.com/google/closure-compiler/issues/3240):
            //     Change back to just super.methodCall()
            return polymerElementBase._parseTemplateContent.call(this, template, templateInfo, nodeInfo);
        }
        /**
     * Overrides `PropertyEffects` to warn on use of undeclared properties in
     * template.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */ static _addTemplatePropertyEffect(templateInfo, prop, effect) {
            // Warn if properties are used in template without being declared.
            // Properties must be listed in `properties` to be included in
            // `observedAttributes` since CE V1 reads that at registration time, and
            // since we want to keep template parsing lazy, we can't automatically
            // add undeclared properties used in templates to `observedAttributes`.
            // The warning is only enabled in `legacyOptimizations` mode, since
            // we don't want to spam existing users who might have adopted the
            // shorthand when attribute deserialization is not important.
            if (_settingsJs.legacyWarnings && !(prop in this._properties) && // Methods used in templates with no dependencies (or only literal
            // dependencies) become accessors with template effects; ignore these
            !(effect.info.part.signature && effect.info.part.signature.static) && // Warnings for bindings added to nested templates are handled by
            // templatizer so ignore both the host-to-template bindings
            // (`hostProp`) and TemplateInstance-to-child bindings
            // (`nestedTemplate`)
            !effect.info.part.hostProp && !templateInfo.nestedTemplate) console.warn(`Property '${prop}' used in template but not declared in 'properties'; ` + `attribute will not be observed.`);
            // TODO(https://github.com/google/closure-compiler/issues/3240):
            //     Change back to just super.methodCall()
            return polymerElementBase._addTemplatePropertyEffect.call(this, templateInfo, prop, effect);
        }
    }
    return PolymerElement;
});
const updateStyles = function(props) {
    if (window.ShadyCSS) window.ShadyCSS.styleDocument(props);
};

},{"../utils/boot.js":"gVNgb","../utils/settings.js":"44bo5","../utils/mixin.js":"488pD","../utils/style-gather.js":"6nhLC","../utils/resolve-url.js":"eGK3B","../elements/dom-module.js":"edoup","./property-effects.js":"fKH56","./properties-mixin.js":"fLiQd","../utils/wrap.js":"cQBlD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gVNgb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ /* eslint-disable no-unused-vars */ /**
 * When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]
 * We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.
 *
 * @param {?} prop Property name
 * @param {*} obj Reference object
 * @return {string} Potentially renamed property name
 */ window.JSCompiler_renameProperty = function(prop, obj) {
    return prop;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"44bo5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useShadow", ()=>useShadow
);
parcelHelpers.export(exports, "useNativeCSSProperties", ()=>useNativeCSSProperties
);
parcelHelpers.export(exports, "useNativeCustomElements", ()=>useNativeCustomElements
);
parcelHelpers.export(exports, "supportsAdoptingStyleSheets", ()=>supportsAdoptingStyleSheets
);
parcelHelpers.export(exports, "rootPath", ()=>rootPath
);
parcelHelpers.export(exports, "setRootPath", ()=>setRootPath
);
parcelHelpers.export(exports, "sanitizeDOMValue", ()=>sanitizeDOMValue
);
parcelHelpers.export(exports, "setSanitizeDOMValue", ()=>setSanitizeDOMValue
);
parcelHelpers.export(exports, "getSanitizeDOMValue", ()=>getSanitizeDOMValue
);
parcelHelpers.export(exports, "passiveTouchGestures", ()=>passiveTouchGestures
);
parcelHelpers.export(exports, "setPassiveTouchGestures", ()=>setPassiveTouchGestures
);
parcelHelpers.export(exports, "strictTemplatePolicy", ()=>strictTemplatePolicy
);
parcelHelpers.export(exports, "setStrictTemplatePolicy", ()=>setStrictTemplatePolicy
);
parcelHelpers.export(exports, "allowTemplateFromDomModule", ()=>allowTemplateFromDomModule
);
parcelHelpers.export(exports, "setAllowTemplateFromDomModule", ()=>setAllowTemplateFromDomModule
);
parcelHelpers.export(exports, "legacyOptimizations", ()=>legacyOptimizations
);
parcelHelpers.export(exports, "setLegacyOptimizations", ()=>setLegacyOptimizations
);
parcelHelpers.export(exports, "legacyWarnings", ()=>legacyWarnings
);
parcelHelpers.export(exports, "setLegacyWarnings", ()=>setLegacyWarnings
);
parcelHelpers.export(exports, "syncInitialRender", ()=>syncInitialRender
);
parcelHelpers.export(exports, "setSyncInitialRender", ()=>setSyncInitialRender
);
parcelHelpers.export(exports, "legacyUndefined", ()=>legacyUndefined
);
parcelHelpers.export(exports, "setLegacyUndefined", ()=>setLegacyUndefined
);
parcelHelpers.export(exports, "orderedComputed", ()=>orderedComputed
);
parcelHelpers.export(exports, "setOrderedComputed", ()=>setOrderedComputed
);
parcelHelpers.export(exports, "cancelSyntheticClickEvents", ()=>cancelSyntheticClickEvents
);
parcelHelpers.export(exports, "setCancelSyntheticClickEvents", ()=>setCancelSyntheticClickEvents
);
parcelHelpers.export(exports, "removeNestedTemplates", ()=>removeNestedTemplates
);
parcelHelpers.export(exports, "setRemoveNestedTemplates", ()=>setRemoveNestedTemplates
);
parcelHelpers.export(exports, "fastDomIf", ()=>fastDomIf
);
parcelHelpers.export(exports, "setFastDomIf", ()=>setFastDomIf
);
parcelHelpers.export(exports, "suppressTemplateNotifications", ()=>suppressTemplateNotifications
);
parcelHelpers.export(exports, "setSuppressTemplateNotifications", ()=>setSuppressTemplateNotifications
);
parcelHelpers.export(exports, "legacyNoObservedAttributes", ()=>legacyNoObservedAttributes
);
parcelHelpers.export(exports, "setLegacyNoObservedAttributes", ()=>setLegacyNoObservedAttributes
);
parcelHelpers.export(exports, "useAdoptedStyleSheetsWithBuiltCSS", ()=>useAdoptedStyleSheetsWithBuiltCSS
);
parcelHelpers.export(exports, "setUseAdoptedStyleSheetsWithBuiltCSS", ()=>setUseAdoptedStyleSheetsWithBuiltCSS
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("./boot.js");
var _resolveUrlJs = require("./resolve-url.js");
const useShadow = !window.ShadyDOM || !window.ShadyDOM.inUse;
const useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
const useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;
const supportsAdoptingStyleSheets = useShadow && 'adoptedStyleSheets' in Document.prototype && 'replaceSync' in CSSStyleSheet.prototype && // Since spec may change, feature detect exact API we need
(()=>{
    try {
        const sheet = new CSSStyleSheet();
        sheet.replaceSync('');
        const host = document.createElement('div');
        host.attachShadow({
            mode: 'open'
        });
        host.shadowRoot.adoptedStyleSheets = [
            sheet
        ];
        return host.shadowRoot.adoptedStyleSheets[0] === sheet;
    } catch (e) {
        return false;
    }
})();
let rootPath = window.Polymer && window.Polymer.rootPath || _resolveUrlJs.pathFromUrl(document.baseURI || window.location.href);
const setRootPath = function(path) {
    rootPath = path;
};
let sanitizeDOMValue = window.Polymer && window.Polymer.sanitizeDOMValue || undefined;
const setSanitizeDOMValue = function(newSanitizeDOMValue) {
    sanitizeDOMValue = newSanitizeDOMValue;
};
const getSanitizeDOMValue = function() {
    return sanitizeDOMValue;
};
let passiveTouchGestures = window.Polymer && window.Polymer.setPassiveTouchGestures || false;
const setPassiveTouchGestures = function(usePassive) {
    passiveTouchGestures = usePassive;
};
let strictTemplatePolicy = window.Polymer && window.Polymer.strictTemplatePolicy || false;
const setStrictTemplatePolicy = function(useStrictPolicy) {
    strictTemplatePolicy = useStrictPolicy;
};
let allowTemplateFromDomModule = window.Polymer && window.Polymer.allowTemplateFromDomModule || false;
const setAllowTemplateFromDomModule = function(allowDomModule) {
    allowTemplateFromDomModule = allowDomModule;
};
let legacyOptimizations = window.Polymer && window.Polymer.legacyOptimizations || false;
const setLegacyOptimizations = function(useLegacyOptimizations) {
    legacyOptimizations = useLegacyOptimizations;
};
let legacyWarnings = window.Polymer && window.Polymer.legacyWarnings || false;
const setLegacyWarnings = function(useLegacyWarnings) {
    legacyWarnings = useLegacyWarnings;
};
let syncInitialRender = window.Polymer && window.Polymer.syncInitialRender || false;
const setSyncInitialRender = function(useSyncInitialRender) {
    syncInitialRender = useSyncInitialRender;
};
let legacyUndefined = window.Polymer && window.Polymer.legacyUndefined || false;
const setLegacyUndefined = function(useLegacyUndefined) {
    legacyUndefined = useLegacyUndefined;
};
let orderedComputed = window.Polymer && window.Polymer.orderedComputed || false;
const setOrderedComputed = function(useOrderedComputed) {
    orderedComputed = useOrderedComputed;
};
let cancelSyntheticClickEvents = true;
const setCancelSyntheticClickEvents = function(useCancelSyntheticClickEvents) {
    cancelSyntheticClickEvents = useCancelSyntheticClickEvents;
};
let removeNestedTemplates = window.Polymer && window.Polymer.removeNestedTemplates || false;
const setRemoveNestedTemplates = function(useRemoveNestedTemplates) {
    removeNestedTemplates = useRemoveNestedTemplates;
};
let fastDomIf = window.Polymer && window.Polymer.fastDomIf || false;
const setFastDomIf = function(useFastDomIf) {
    fastDomIf = useFastDomIf;
};
let suppressTemplateNotifications = window.Polymer && window.Polymer.suppressTemplateNotifications || false;
const setSuppressTemplateNotifications = function(suppress) {
    suppressTemplateNotifications = suppress;
};
let legacyNoObservedAttributes = window.Polymer && window.Polymer.legacyNoObservedAttributes || false;
const setLegacyNoObservedAttributes = function(noObservedAttributes) {
    legacyNoObservedAttributes = noObservedAttributes;
};
let useAdoptedStyleSheetsWithBuiltCSS = window.Polymer && window.Polymer.useAdoptedStyleSheetsWithBuiltCSS || false;
const setUseAdoptedStyleSheetsWithBuiltCSS = function(value) {
    useAdoptedStyleSheetsWithBuiltCSS = value;
};

},{"./boot.js":"gVNgb","./resolve-url.js":"eGK3B","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eGK3B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Resolves the given URL against the provided `baseUri'.
 *
 * Note that this function performs no resolution for URLs that start
 * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
 * URL resolution, use `window.URL`.
 *
 * @param {string} url Input URL to resolve
 * @param {?string=} baseURI Base URI to resolve the URL against
 * @return {string} resolved URL
 */ parcelHelpers.export(exports, "resolveUrl", ()=>resolveUrl
);
/**
 * Resolves any relative URL's in the given CSS text against the provided
 * `ownerDocument`'s `baseURI`.
 *
 * @param {string} cssText CSS text to process
 * @param {string} baseURI Base URI to resolve the URL against
 * @return {string} Processed CSS text with resolved URL's
 */ parcelHelpers.export(exports, "resolveCss", ()=>resolveCss
);
/**
 * Returns a path from a given `url`. The path includes the trailing
 * `/` from the url.
 *
 * @param {string} url Input URL to transform
 * @return {string} resolved path
 */ parcelHelpers.export(exports, "pathFromUrl", ()=>pathFromUrl
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("./boot.js");
let CSS_URL_RX = /(url\()([^)]*)(\))/g;
let ABS_URL = /(^\/[^\/])|(^#)|(^[\w-\d]*:)/;
let workingURL;
let resolveDoc;
function resolveUrl(url, baseURI) {
    if (url && ABS_URL.test(url)) return url;
    if (url === '//') return url;
    // Lazy feature detection.
    if (workingURL === undefined) {
        workingURL = false;
        try {
            const u = new URL('b', 'http://a');
            u.pathname = 'c%20d';
            workingURL = u.href === 'http://a/c%20d';
        } catch (e) {
        // silently fail
        }
    }
    if (!baseURI) baseURI = document.baseURI || window.location.href;
    if (workingURL) try {
        return new URL(url, baseURI).href;
    } catch (e) {
        // Bad url or baseURI structure. Do not attempt to resolve.
        return url;
    }
    // Fallback to creating an anchor into a disconnected document.
    if (!resolveDoc) {
        resolveDoc = document.implementation.createHTMLDocument('temp');
        resolveDoc.base = resolveDoc.createElement('base');
        resolveDoc.head.appendChild(resolveDoc.base);
        resolveDoc.anchor = resolveDoc.createElement('a');
        resolveDoc.body.appendChild(resolveDoc.anchor);
    }
    resolveDoc.base.href = baseURI;
    resolveDoc.anchor.href = url;
    return resolveDoc.anchor.href || url;
}
function resolveCss(cssText, baseURI) {
    return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {
        return pre + '\'' + resolveUrl(url.replace(/["']/g, ''), baseURI) + '\'' + post;
    });
}
function pathFromUrl(url) {
    return url.substring(0, url.lastIndexOf('/') + 1);
}

},{"./boot.js":"gVNgb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"488pD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dedupingMixin", ()=>dedupingMixin
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("./boot.js");
// unique global id for deduping mixins.
let dedupeId = 0;
/**
 * @constructor
 * @extends {Function}
 * @private
 */ function MixinFunction() {
}
/** @type {(WeakMap | undefined)} */ MixinFunction.prototype.__mixinApplications;
/** @type {(Object | undefined)} */ MixinFunction.prototype.__mixinSet;
const dedupingMixin = function(mixin) {
    let mixinApplications = /** @type {!MixinFunction} */ mixin.__mixinApplications;
    if (!mixinApplications) {
        mixinApplications = new WeakMap();
        /** @type {!MixinFunction} */ mixin.__mixinApplications = mixinApplications;
    }
    // maintain a unique id for each mixin
    let mixinDedupeId = dedupeId++;
    function dedupingMixin1(base) {
        let baseSet = /** @type {!MixinFunction} */ base.__mixinSet;
        if (baseSet && baseSet[mixinDedupeId]) return base;
        let map = mixinApplications;
        let extended = map.get(base);
        if (!extended) {
            extended = /** @type {!Function} */ mixin(base);
            map.set(base, extended);
            // copy inherited mixin set from the extended class, or the base class
            // NOTE: we avoid use of Set here because some browser (IE11)
            // cannot extend a base Set via the constructor.
            let mixinSet = Object.create(/** @type {!MixinFunction} */ extended.__mixinSet || baseSet || null);
            mixinSet[mixinDedupeId] = true;
            /** @type {!MixinFunction} */ extended.__mixinSet = mixinSet;
        }
        return extended;
    }
    return dedupingMixin1;
}; /* eslint-enable valid-jsdoc */ 

},{"./boot.js":"gVNgb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6nhLC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a list of <style> elements in a space-separated list of `dom-module`s.
 *
 * @function
 * @param {string} moduleIds List of dom-module id's within which to
 * search for css.
 * @return {!Array<!HTMLStyleElement>} Array of contained <style> elements
 */ parcelHelpers.export(exports, "stylesFromModules", ()=>stylesFromModules
);
/**
 * Returns a list of <style> elements in a given `dom-module`.
 * Styles in a `dom-module` can come either from `<style>`s within the
 * first `<template>`, or else from one or more
 * `<link rel="import" type="css">` links outside the template.
 *
 * @param {string} moduleId dom-module id to gather styles from
 * @return {!Array<!HTMLStyleElement>} Array of contained styles.
 */ parcelHelpers.export(exports, "stylesFromModule", ()=>stylesFromModule
);
/**
 * Returns the `<style>` elements within a given template.
 *
 * @param {!HTMLTemplateElement} template Template to gather styles from
 * @param {string=} baseURI baseURI for style content
 * @return {!Array<!HTMLStyleElement>} Array of styles
 */ parcelHelpers.export(exports, "stylesFromTemplate", ()=>stylesFromTemplate
);
/**
 * Returns a list of <style> elements  from stylesheets loaded via `<link rel="import" type="css">` links within the specified `dom-module`.
 *
 * @param {string} moduleId Id of `dom-module` to gather CSS from
 * @return {!Array<!HTMLStyleElement>} Array of contained styles.
 */ parcelHelpers.export(exports, "stylesFromModuleImports", ()=>stylesFromModuleImports
);
/**
 *
 * Returns CSS text of styles in a space-separated list of `dom-module`s.
 * Note: This method is deprecated, use `stylesFromModules` instead.
 *
 * @deprecated
 * @param {string} moduleIds List of dom-module id's within which to
 * search for css.
 * @return {string} Concatenated CSS content from specified `dom-module`s
 */ parcelHelpers.export(exports, "cssFromModules", ()=>cssFromModules
);
/**
 * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`
 * can come either from `<style>`s within the first `<template>`, or else
 * from one or more `<link rel="import" type="css">` links outside the
 * template.
 *
 * Any `<styles>` processed are removed from their original location.
 * Note: This method is deprecated, use `styleFromModule` instead.
 *
 * @deprecated
 * @param {string} moduleId dom-module id to gather styles from
 * @return {string} Concatenated CSS content from specified `dom-module`
 */ parcelHelpers.export(exports, "cssFromModule", ()=>cssFromModule
);
/**
 * Returns CSS text of `<styles>` within a given template.
 *
 * Any `<styles>` processed are removed from their original location.
 * Note: This method is deprecated, use `styleFromTemplate` instead.
 *
 * @deprecated
 * @param {!HTMLTemplateElement} template Template to gather styles from
 * @param {string} baseURI Base URI to resolve the URL against
 * @return {string} Concatenated CSS content from specified template
 */ parcelHelpers.export(exports, "cssFromTemplate", ()=>cssFromTemplate
);
/**
 * Returns CSS text from stylesheets loaded via `<link rel="import" type="css">`
 * links within the specified `dom-module`.
 *
 * Note: This method is deprecated, use `stylesFromModuleImports` instead.
 *
 * @deprecated
 *
 * @param {string} moduleId Id of `dom-module` to gather CSS from
 * @return {string} Concatenated CSS content from links in specified `dom-module`
 */ parcelHelpers.export(exports, "cssFromModuleImports", ()=>cssFromModuleImports
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ /**
 * Module with utilities for collection CSS text from `<templates>`, external
 * stylesheets, and `dom-module`s.
 *
 * @summary Module with utilities for collection CSS text from various sources.
 */ var _domModuleJs = require("../elements/dom-module.js");
var _resolveUrlJs = require("./resolve-url.js");
const MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
const INCLUDE_ATTR = 'include';
const SHADY_UNSCOPED_ATTR = 'shady-unscoped';
/**
 * @param {string} moduleId .
 * @return {?DomModule} .
 */ function importModule(moduleId) {
    return _domModuleJs.DomModule.import(moduleId);
}
function styleForImport(importDoc) {
    // NOTE: polyfill affordance.
    // under the HTMLImports polyfill, there will be no 'body',
    // but the import pseudo-doc can be used directly.
    let container = importDoc.body ? importDoc.body : importDoc;
    const importCss = _resolveUrlJs.resolveCss(container.textContent, importDoc.baseURI);
    const style = document.createElement('style');
    style.textContent = importCss;
    return style;
}
/** @typedef {{assetpath: string}} */ let templateWithAssetPath; // eslint-disable-line no-unused-vars
function stylesFromModules(moduleIds) {
    const modules = moduleIds.trim().split(/\s+/);
    const styles = [];
    for(let i = 0; i < modules.length; i++)styles.push(...stylesFromModule(modules[i]));
    return styles;
}
function stylesFromModule(moduleId) {
    const m = importModule(moduleId);
    if (!m) {
        console.warn('Could not find style data in module named', moduleId);
        return [];
    }
    if (m._styles === undefined) {
        const styles = [];
        // module imports: <link rel="import" type="css">
        styles.push(..._stylesFromModuleImports(m));
        // include css from the first template in the module
        const template = m.querySelector('template');
        if (template) styles.push(...stylesFromTemplate(template, /** @type {templateWithAssetPath} */ m.assetpath));
        m._styles = styles;
    }
    return m._styles;
}
function stylesFromTemplate(template, baseURI) {
    if (!template._styles) {
        const styles = [];
        // if element is a template, get content from its .content
        const e$ = template.content.querySelectorAll('style');
        for(let i = 0; i < e$.length; i++){
            let e = e$[i];
            // support style sharing by allowing styles to "include"
            // other dom-modules that contain styling
            let include = e.getAttribute(INCLUDE_ATTR);
            if (include) styles.push(...stylesFromModules(include).filter(function(item, index, self) {
                return self.indexOf(item) === index;
            }));
            if (baseURI) e.textContent = _resolveUrlJs.resolveCss(e.textContent, baseURI);
            styles.push(e);
        }
        template._styles = styles;
    }
    return template._styles;
}
function stylesFromModuleImports(moduleId) {
    let m = importModule(moduleId);
    return m ? _stylesFromModuleImports(m) : [];
}
/**
 * @param {!HTMLElement} module dom-module element that could contain `<link rel="import" type="css">` styles
 * @return {!Array<!HTMLStyleElement>} Array of contained styles
 */ function _stylesFromModuleImports(module) {
    const styles = [];
    const p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
    for(let i = 0; i < p$.length; i++){
        let p = p$[i];
        if (p.import) {
            const importDoc = p.import;
            const unscoped = p.hasAttribute(SHADY_UNSCOPED_ATTR);
            if (unscoped && !importDoc._unscopedStyle) {
                const style = styleForImport(importDoc);
                style.setAttribute(SHADY_UNSCOPED_ATTR, '');
                importDoc._unscopedStyle = style;
            } else if (!importDoc._style) importDoc._style = styleForImport(importDoc);
            styles.push(unscoped ? importDoc._unscopedStyle : importDoc._style);
        }
    }
    return styles;
}
function cssFromModules(moduleIds) {
    let modules = moduleIds.trim().split(/\s+/);
    let cssText = '';
    for(let i = 0; i < modules.length; i++)cssText += cssFromModule(modules[i]);
    return cssText;
}
function cssFromModule(moduleId) {
    let m = importModule(moduleId);
    if (m && m._cssText === undefined) {
        // module imports: <link rel="import" type="css">
        let cssText = _cssFromModuleImports(m);
        // include css from the first template in the module
        let t = m.querySelector('template');
        if (t) cssText += cssFromTemplate(t, /** @type {templateWithAssetPath} */ m.assetpath);
        m._cssText = cssText || null;
    }
    if (!m) console.warn('Could not find style data in module named', moduleId);
    return m && m._cssText || '';
}
function cssFromTemplate(template, baseURI) {
    let cssText = '';
    const e$ = stylesFromTemplate(template, baseURI);
    // if element is a template, get content from its .content
    for(let i = 0; i < e$.length; i++){
        let e = e$[i];
        if (e.parentNode) e.parentNode.removeChild(e);
        cssText += e.textContent;
    }
    return cssText;
}
function cssFromModuleImports(moduleId) {
    let m = importModule(moduleId);
    return m ? _cssFromModuleImports(m) : '';
}
/**
 * @deprecated
 * @param {!HTMLElement} module dom-module element that could contain `<link rel="import" type="css">` styles
 * @return {string} Concatenated CSS content from links in the dom-module
 */ function _cssFromModuleImports(module) {
    let cssText = '';
    let styles = _stylesFromModuleImports(module);
    for(let i = 0; i < styles.length; i++)cssText += styles[i].textContent;
    return cssText;
}

},{"../elements/dom-module.js":"edoup","./resolve-url.js":"eGK3B","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"edoup":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The `dom-module` element registers the dom it contains to the name given
 * by the module's id attribute. It provides a unified database of dom
 * accessible via its static `import` API.
 *
 * A key use case of `dom-module` is for providing custom element `<template>`s
 * via HTML imports that are parsed by the native HTML parser, that can be
 * relocated during a bundling pass and still looked up by `id`.
 *
 * Example:
 *
 *     <dom-module id="foo">
 *       <img src="stuff.png">
 *     </dom-module>
 *
 * Then in code in some other location that cannot access the dom-module above
 *
 *     let img = customElements.get('dom-module').import('foo', 'img');
 *
 * @customElement
 * @extends HTMLElement
 * @summary Custom element that provides a registry of relocatable DOM content
 *   by `id` that is agnostic to bundling.
 * @unrestricted
 */ parcelHelpers.export(exports, "DomModule", ()=>DomModule
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("../utils/boot.js");
var _resolveUrlJs = require("../utils/resolve-url.js");
var _settingsJs = require("../utils/settings.js");
let modules = {
};
let lcModules = {
};
/**
 * Sets a dom-module into the global registry by id.
 *
 * @param {string} id dom-module id
 * @param {DomModule} module dom-module instance
 * @return {void}
 */ function setModule(id, module) {
    // store id separate from lowercased id so that
    // in all cases mixedCase id will stored distinctly
    // and lowercase version is a fallback
    modules[id] = lcModules[id.toLowerCase()] = module;
}
/**
 * Retrieves a dom-module from the global registry by id.
 *
 * @param {string} id dom-module id
 * @return {DomModule!} dom-module instance
 */ function findModule(id) {
    return modules[id] || lcModules[id.toLowerCase()];
}
function styleOutsideTemplateCheck(inst) {
    if (inst.querySelector('style')) console.warn('dom-module %s has style outside template', inst.id);
}
class DomModule extends HTMLElement {
    /** @override */ static get observedAttributes() {
        return [
            'id'
        ];
    }
    /**
   * Retrieves the element specified by the css `selector` in the module
   * registered by `id`. For example, this.import('foo', 'img');
   * @param {string} id The id of the dom-module in which to search.
   * @param {string=} selector The css selector by which to find the element.
   * @return {Element} Returns the element which matches `selector` in the
   * module registered at the specified `id`.
   *
   * @export
   * @nocollapse Referred to indirectly in style-gather.js
   */ static import(id, selector) {
        if (id) {
            let m = findModule(id);
            if (m && selector) return m.querySelector(selector);
            return m;
        }
        return null;
    }
    /* eslint-disable no-unused-vars */ /**
   * @param {string} name Name of attribute.
   * @param {?string} old Old value of attribute.
   * @param {?string} value Current value of attribute.
   * @param {?string} namespace Attribute namespace.
   * @return {void}
   * @override
   */ attributeChangedCallback(name, old, value, namespace) {
        if (old !== value) this.register();
    }
    /* eslint-enable no-unused-args */ /**
   * The absolute URL of the original location of this `dom-module`.
   *
   * This value will differ from this element's `ownerDocument` in the
   * following ways:
   * - Takes into account any `assetpath` attribute added during bundling
   *   to indicate the original location relative to the bundled location
   * - Uses the HTMLImports polyfill's `importForElement` API to ensure
   *   the path is relative to the import document's location since
   *   `ownerDocument` is not currently polyfilled
   */ get assetpath() {
        // Don't override existing assetpath.
        if (!this.__assetpath) {
            // note: assetpath set via an attribute must be relative to this
            // element's location; accommodate polyfilled HTMLImports
            const owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
            const url = _resolveUrlJs.resolveUrl(this.getAttribute('assetpath') || '', owner.baseURI);
            this.__assetpath = _resolveUrlJs.pathFromUrl(url);
        }
        return this.__assetpath;
    }
    /**
   * Registers the dom-module at a given id. This method should only be called
   * when a dom-module is imperatively created. For
   * example, `document.createElement('dom-module').register('foo')`.
   * @param {string=} id The id at which to register the dom-module.
   * @return {void}
   */ register(id) {
        id = id || this.id;
        if (id) {
            // Under strictTemplatePolicy, reject and null out any re-registered
            // dom-module since it is ambiguous whether first-in or last-in is trusted
            if (_settingsJs.strictTemplatePolicy && findModule(id) !== undefined) {
                setModule(id, null);
                throw new Error(`strictTemplatePolicy: dom-module ${id} re-registered`);
            }
            this.id = id;
            setModule(id, this);
            styleOutsideTemplateCheck(this);
        }
    }
}
DomModule.prototype['modules'] = modules;
customElements.define('dom-module', DomModule);

},{"../utils/boot.js":"gVNgb","../utils/resolve-url.js":"eGK3B","../utils/settings.js":"44bo5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fKH56":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PropertyEffects", ()=>PropertyEffects
);
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */ var _bootJs = require("../utils/boot.js");
var _wrapJs = require("../utils/wrap.js");
var _mixinJs = require("../utils/mixin.js");
var _pathJs = require("../utils/path.js");
/* for notify, reflect */ var _caseMapJs = require("../utils/case-map.js");
var _propertyAccessorsJs = require("./property-accessors.js");
/* for annotated effects */ var _templateStampJs = require("./template-stamp.js");
var _settingsJs = require("../utils/settings.js");
// Monotonically increasing unique ID used for de-duping effects triggered
// from multiple properties in the same turn
let dedupeId = 0;
const NOOP = [];
/**
 * Property effect types; effects are stored on the prototype using these keys
 * @enum {string}
 */ const TYPES = {
    COMPUTE: '__computeEffects',
    REFLECT: '__reflectEffects',
    NOTIFY: '__notifyEffects',
    PROPAGATE: '__propagateEffects',
    OBSERVE: '__observeEffects',
    READ_ONLY: '__readOnly'
};
const COMPUTE_INFO = '__computeInfo';
/** @const {!RegExp} */ const capitalAttributeRegex = /[A-Z]/;
/**
 * @typedef {{
 * name: (string | undefined),
 * structured: (boolean | undefined),
 * wildcard: (boolean | undefined)
 * }}
 */ let DataTrigger; //eslint-disable-line no-unused-vars
/**
 * @typedef {{
 * info: ?,
 * trigger: (!DataTrigger | undefined),
 * fn: (!Function | undefined)
 * }}
 */ let DataEffect; //eslint-disable-line no-unused-vars
/**
 * Ensures that the model has an own-property map of effects for the given type.
 * The model may be a prototype or an instance.
 *
 * Property effects are stored as arrays of effects by property in a map,
 * by named type on the model. e.g.
 *
 *   __computeEffects: {
 *     foo: [ ... ],
 *     bar: [ ... ]
 *   }
 *
 * If the model does not yet have an effect map for the type, one is created
 * and returned.  If it does, but it is not an own property (i.e. the
 * prototype had effects), the the map is deeply cloned and the copy is
 * set on the model and returned, ready for new effects to be added.
 *
 * @param {Object} model Prototype or instance
 * @param {string} type Property effect type
 * @param {boolean=} cloneArrays Clone any arrays assigned to the map when
 *   extending a superclass map onto this subclass
 * @return {Object} The own-property map of effects for the given type
 * @private
 */ function ensureOwnEffectMap(model, type, cloneArrays) {
    let effects = model[type];
    if (!effects) effects = model[type] = {
    };
    else if (!model.hasOwnProperty(type)) {
        effects = model[type] = Object.create(model[type]);
        if (cloneArrays) for(let p in effects){
            let protoFx = effects[p];
            // Perf optimization over Array.slice
            let instFx = effects[p] = Array(protoFx.length);
            for(let i = 0; i < protoFx.length; i++)instFx[i] = protoFx[i];
        }
    }
    return effects;
}
// -- effects ----------------------------------------------
/**
 * Runs all effects of a given type for the given set of property changes
 * on an instance.
 *
 * @param {!Polymer_PropertyEffects} inst The instance with effects to run
 * @param {?Object} effects Object map of property-to-Array of effects
 * @param {?Object} props Bag of current property changes
 * @param {?Object=} oldProps Bag of previous values for changed properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */ function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
    if (effects) {
        let ran = false;
        const id = dedupeId++;
        for(let prop in props){
            // Inline `runEffectsForProperty` for perf.
            let rootProperty = hasPaths ? _pathJs.root(prop) : prop;
            let fxs = effects[rootProperty];
            if (fxs) {
                for(let i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++)if ((!fx.info || fx.info.lastRun !== id) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
                    if (fx.info) fx.info.lastRun = id;
                    fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
                    ran = true;
                }
            }
        }
        return ran;
    }
    return false;
}
/**
 * Runs a list of effects for a given property.
 *
 * @param {!Polymer_PropertyEffects} inst The instance with effects to run
 * @param {!Object} effects Object map of property-to-Array of effects
 * @param {number} dedupeId Counter used for de-duping effects
 * @param {string} prop Name of changed property
 * @param {*} props Changed properties
 * @param {*} oldProps Old properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */ function runEffectsForProperty(inst, effects, dedupeId1, prop, props, oldProps, hasPaths, extraArgs) {
    let ran = false;
    let rootProperty = hasPaths ? _pathJs.root(prop) : prop;
    let fxs = effects[rootProperty];
    if (fxs) {
        for(let i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++)if ((!fx.info || fx.info.lastRun !== dedupeId1) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
            if (fx.info) fx.info.lastRun = dedupeId1;
            fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
            ran = true;
        }
    }
    return ran;
}
/**
 * Determines whether a property/path that has changed matches the trigger
 * criteria for an effect.  A trigger is a descriptor with the following
 * structure, which matches the descriptors returned from `parseArg`.
 * e.g. for `foo.bar.*`:
 * ```
 * trigger: {
 *   name: 'a.b',
 *   structured: true,
 *   wildcard: true
 * }
 * ```
 * If no trigger is given, the path is deemed to match.
 *
 * @param {string} path Path or property that changed
 * @param {?DataTrigger} trigger Descriptor
 * @return {boolean} Whether the path matched the trigger
 */ function pathMatchesTrigger(path, trigger) {
    if (trigger) {
        let triggerPath = trigger.name;
        return triggerPath == path || !!(trigger.structured && _pathJs.isAncestor(triggerPath, path)) || !!(trigger.wildcard && _pathJs.isDescendant(triggerPath, path));
    } else return true;
}
/**
 * Implements the "observer" effect.
 *
 * Calls the method with `info.methodName` on the instance, passing the
 * new and old values.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {void}
 * @private
 */ function runObserverEffect(inst, property, props, oldProps, info) {
    let fn = typeof info.method === "string" ? inst[info.method] : info.method;
    let changedProp = info.property;
    if (fn) fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
    else if (!info.dynamicFn) console.warn('observer method `' + info.method + '` not defined');
}
/**
 * Runs "notify" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * will dispatch path notification events in the case that the property
 * changed was a path and the root property for that path didn't have a
 * "notify" effect.  This is to maintain 1.0 behavior that did not require
 * `notify: true` to ensure object sub-property notifications were
 * sent.
 *
 * @param {!Polymer_PropertyEffects} inst The instance with effects to run
 * @param {Object} notifyProps Bag of properties to notify
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @return {void}
 * @private
 */ function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
    // Notify
    let fxs = inst[TYPES.NOTIFY];
    let notified;
    let id = dedupeId++;
    // Try normal notify effects; if none, fall back to try path notification
    for(let prop in notifyProps)if (notifyProps[prop]) {
        if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) notified = true;
        else if (hasPaths && notifyPath(inst, prop, props)) notified = true;
    }
    // Flush host if we actually notified and host was batching
    // And the host has already initialized clients; this prevents
    // an issue with a host observing data changes before clients are ready.
    let host;
    if (notified && (host = inst.__dataHost) && host._invalidateProperties) host._invalidateProperties();
}
/**
 * Dispatches {property}-changed events with path information in the detail
 * object to indicate a sub-path of the property was changed.
 *
 * @param {!Polymer_PropertyEffects} inst The element from which to fire the
 *     event
 * @param {string} path The path that was changed
 * @param {Object} props Bag of current property changes
 * @return {boolean} Returns true if the path was notified
 * @private
 */ function notifyPath(inst, path, props) {
    let rootProperty = _pathJs.root(path);
    if (rootProperty !== path) {
        let eventName = _caseMapJs.camelToDashCase(rootProperty) + '-changed';
        dispatchNotifyEvent(inst, eventName, props[path], path);
        return true;
    }
    return false;
}
/**
 * Dispatches {property}-changed events to indicate a property (or path)
 * changed.
 *
 * @param {!Polymer_PropertyEffects} inst The element from which to fire the
 *     event
 * @param {string} eventName The name of the event to send
 *     ('{property}-changed')
 * @param {*} value The value of the changed property
 * @param {string | null | undefined} path If a sub-path of this property
 *     changed, the path that changed (optional).
 * @return {void}
 * @private
 * @suppress {invalidCasts}
 */ function dispatchNotifyEvent(inst, eventName, value, path) {
    let detail = {
        value: value,
        queueProperty: true
    };
    if (path) detail.path = path;
    // As a performance optimization, we could elide the wrap here since notifying
    // events are non-bubbling and shouldn't need retargeting. However, a very
    // small number of internal tests failed in obscure ways, which may indicate
    // user code relied on timing differences resulting from ShadyDOM flushing
    // as a result of the wrapped `dispatchEvent`.
    _wrapJs.wrap(inst).dispatchEvent(new CustomEvent(eventName, {
        detail
    }));
}
/**
 * Implements the "notify" effect.
 *
 * Dispatches a non-bubbling event named `info.eventName` on the instance
 * with a detail object containing the new `value`.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @return {void}
 * @private
 */ function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
    let rootProperty = hasPaths ? _pathJs.root(property) : property;
    let path = rootProperty != property ? property : null;
    let value = path ? _pathJs.get(inst, path) : inst.__data[property];
    if (path && value === undefined) value = props[property]; // specifically for .splices
    dispatchNotifyEvent(inst, info.eventName, value, path);
}
/**
 * Handler function for 2-way notification events. Receives context
 * information captured in the `addNotifyListener` closure from the
 * `__notifyListeners` metadata.
 *
 * Sets the value of the notified property to the host property or path.  If
 * the event contained path information, translate that path to the host
 * scope's name for that path first.
 *
 * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
 * @param {!Polymer_PropertyEffects} inst Host element instance handling the
 *     notification event
 * @param {string} fromProp Child element property that was bound
 * @param {string} toPath Host property/path that was bound
 * @param {boolean} negate Whether the binding was negated
 * @return {void}
 * @private
 */ function handleNotification(event, inst, fromProp, toPath, negate) {
    let value;
    let detail = event.detail;
    let fromPath = detail && detail.path;
    if (fromPath) {
        toPath = _pathJs.translate(fromProp, toPath, fromPath);
        value = detail && detail.value;
    } else value = event.currentTarget[fromProp];
    value = negate ? !value : value;
    if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
        if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) inst._invalidateProperties();
    }
}
/**
 * Implements the "reflect" effect.
 *
 * Sets the attribute named `info.attrName` to the given property value.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {void}
 * @private
 */ function runReflectEffect(inst, property, props, oldProps, info) {
    let value = inst.__data[property];
    if (_settingsJs.sanitizeDOMValue) value = _settingsJs.sanitizeDOMValue(value, info.attrName, 'attribute', inst);
    inst._propertyToAttribute(property, info.attrName, value);
}
/**
 * Runs "computed" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * continues to run computed effects based on the output of each pass until
 * there are no more newly computed properties.  This ensures that all
 * properties that will be computed by the initial set of changes are
 * computed before other effects (binding propagation, observers, and notify)
 * run.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {?Object} changedProps Bag of changed properties
 * @param {?Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @return {void}
 * @private
 */ function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
    let computeEffects = inst[TYPES.COMPUTE];
    if (computeEffects) {
        if (_settingsJs.orderedComputed) {
            // Runs computed effects in efficient order by keeping a topologically-
            // sorted queue of compute effects to run, and inserting subsequently
            // invalidated effects as they are run
            dedupeId++;
            const order = getComputedOrder(inst);
            const queue = [];
            for(let p in changedProps)enqueueEffectsFor(p, computeEffects, queue, order, hasPaths);
            let info;
            while(info = queue.shift())if (runComputedEffect(inst, '', changedProps, oldProps, info)) enqueueEffectsFor(info.methodInfo, computeEffects, queue, order, hasPaths);
            Object.assign(oldProps, inst.__dataOld);
            Object.assign(changedProps, inst.__dataPending);
            inst.__dataPending = null;
        } else {
            // Original Polymer 2.x computed effects order, which continues running
            // effects until no further computed properties have been invalidated
            let inputProps = changedProps;
            while(runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)){
                Object.assign(oldProps, inst.__dataOld);
                Object.assign(changedProps, inst.__dataPending);
                inputProps = inst.__dataPending;
                inst.__dataPending = null;
            }
        }
    }
}
/**
 * Inserts a computed effect into a queue, given the specified order. Performs
 * the insert using a binary search.
 *
 * Used by `orderedComputed: true` computed property algorithm.
 *
 * @param {Object} info Property effects metadata
 * @param {Array<Object>} queue Ordered queue of effects
 * @param {Map<string,number>} order Map of computed property name->topological
 *   sort order
 */ const insertEffect = (info, queue, order)=>{
    let start = 0;
    let end = queue.length - 1;
    let idx = -1;
    while(start <= end){
        const mid = start + end >> 1;
        // Note `methodInfo` is where the computed property name is stored in
        // the effect metadata
        const cmp = order.get(queue[mid].methodInfo) - order.get(info.methodInfo);
        if (cmp < 0) start = mid + 1;
        else if (cmp > 0) end = mid - 1;
        else {
            idx = mid;
            break;
        }
    }
    if (idx < 0) idx = end + 1;
    queue.splice(idx, 0, info);
};
/**
 * Inserts all downstream computed effects invalidated by the specified property
 * into the topologically-sorted queue of effects to be run.
 *
 * Used by `orderedComputed: true` computed property algorithm.
 *
 * @param {string} prop Property name
 * @param {Object} computeEffects Computed effects for this element
 * @param {Array<Object>} queue Topologically-sorted queue of computed effects
 *   to be run
 * @param {Map<string,number>} order Map of computed property name->topological
 *   sort order
 * @param {boolean} hasPaths True with `changedProps` contains one or more paths
 */ const enqueueEffectsFor = (prop, computeEffects, queue, order, hasPaths)=>{
    const rootProperty = hasPaths ? _pathJs.root(prop) : prop;
    const fxs = computeEffects[rootProperty];
    if (fxs) for(let i = 0; i < fxs.length; i++){
        const fx = fxs[i];
        if (fx.info.lastRun !== dedupeId && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
            fx.info.lastRun = dedupeId;
            insertEffect(fx.info, queue, order);
        }
    }
};
/**
 * Generates and retrieves a memoized map of computed property name to its
 * topologically-sorted order.
 *
 * The map is generated by first assigning a "dependency count" to each property
 * (defined as number properties it depends on, including its method for
 * "dynamic functions"). Any properties that have no dependencies are added to
 * the `ready` queue, which are properties whose order can be added to the final
 * order map. Properties are popped off the `ready` queue one by one and a.) added as
 * the next property in the order map, and b.) each property that it is a
 * dependency for has its dep count decremented (and if that property's dep
 * count goes to zero, it is added to the `ready` queue), until all properties
 * have been visited and ordered.
 *
 * Used by `orderedComputed: true` computed property algorithm.
 *
 * @param {!Polymer_PropertyEffects} inst The instance to retrieve the computed
 *   effect order for.
 * @return {Map<string,number>} Map of computed property name->topological sort
 *   order
 */ function getComputedOrder(inst) {
    let ordered = inst.constructor.__orderedComputedDeps;
    if (!ordered) {
        ordered = new Map();
        const effects = inst[TYPES.COMPUTE];
        let { counts , ready , total  } = dependencyCounts(inst);
        let curr;
        while(curr = ready.shift()){
            ordered.set(curr, ordered.size);
            const computedByCurr = effects[curr];
            if (computedByCurr) computedByCurr.forEach((fx)=>{
                // Note `methodInfo` is where the computed property name is stored
                const computedProp = fx.info.methodInfo;
                --total;
                if (--counts[computedProp] === 0) ready.push(computedProp);
            });
        }
        if (total !== 0) {
            const el = inst;
            console.warn(`Computed graph for ${el.localName} incomplete; circular?`);
        }
        inst.constructor.__orderedComputedDeps = ordered;
    }
    return ordered;
}
/**
 * Generates a map of property-to-dependency count (`counts`, where "dependency
 * count" is the number of dependencies a given property has assuming it is a
 * computed property, otherwise 0).  It also returns a pre-populated list of
 * `ready` properties that have no dependencies and a `total` count, which is
 * used for error-checking the graph.
 *
 * Used by `orderedComputed: true` computed property algorithm.
 *
 * @param {!Polymer_PropertyEffects} inst The instance to generate dependency
 *   counts for.
 * @return {!Object} Object containing `counts` map (property-to-dependency
 *   count) and pre-populated `ready` array of properties that had zero
 *   dependencies.
 */ function dependencyCounts(inst) {
    const infoForComputed = inst[COMPUTE_INFO];
    const counts = {
    };
    const computedDeps = inst[TYPES.COMPUTE];
    const ready = [];
    let total = 0;
    // Count dependencies for each computed property
    for(let p in infoForComputed){
        const info = infoForComputed[p];
        // Be sure to add the method name itself in case of "dynamic functions"
        total += counts[p] = info.args.filter((a)=>!a.literal
        ).length + (info.dynamicFn ? 1 : 0);
    }
    // Build list of ready properties (that aren't themselves computed)
    for(let p1 in computedDeps)if (!infoForComputed[p1]) ready.push(p1);
    return {
        counts,
        ready,
        total
    };
}
/**
 * Implements the "computed property" effect by running the method with the
 * values of the arguments specified in the `info` object and setting the
 * return value to the computed property specified.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {?Object} changedProps Bag of current property changes
 * @param {?Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {boolean} True when the property being computed changed
 * @private
 */ function runComputedEffect(inst, property, changedProps, oldProps, info) {
    // Dirty check dependencies and run if any invalid
    let result = runMethodEffect(inst, property, changedProps, oldProps, info);
    // Abort if method returns a no-op result
    if (result === NOOP) return false;
    let computedProp = info.methodInfo;
    if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) return inst._setPendingProperty(computedProp, result, true);
    else {
        inst[computedProp] = result;
        return false;
    }
}
/**
 * Computes path changes based on path links set up using the `linkPaths`
 * API.
 *
 * @param {!Polymer_PropertyEffects} inst The instance whose props are changing
 * @param {string} path Path that has changed
 * @param {*} value Value of changed path
 * @return {void}
 * @private
 */ function computeLinkedPaths(inst, path, value) {
    let links = inst.__dataLinkedPaths;
    if (links) {
        let link;
        for(let a in links){
            let b = links[a];
            if (_pathJs.isDescendant(a, path)) {
                link = _pathJs.translate(a, b, path);
                inst._setPendingPropertyOrPath(link, value, true, true);
            } else if (_pathJs.isDescendant(b, path)) {
                link = _pathJs.translate(b, a, path);
                inst._setPendingPropertyOrPath(link, value, true, true);
            }
        }
    }
}
// -- bindings ----------------------------------------------
/**
 * Adds binding metadata to the current `nodeInfo`, and binding effects
 * for all part dependencies to `templateInfo`.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {NodeInfo} nodeInfo Node metadata for current template node
 * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
 * @param {string} target Target property name
 * @param {!Array<!BindingPart>} parts Array of binding part metadata
 * @param {string=} literal Literal text surrounding binding parts (specified
 *   only for 'property' bindings, since these must be initialized as part
 *   of boot-up)
 * @return {void}
 * @private
 */ function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
    // Create binding metadata and add to nodeInfo
    nodeInfo.bindings = nodeInfo.bindings || [];
    let /** Binding */ binding = {
        kind,
        target,
        parts,
        literal,
        isCompound: parts.length !== 1
    };
    nodeInfo.bindings.push(binding);
    // Add listener info to binding metadata
    if (shouldAddListener(binding)) {
        let { event , negate  } = binding.parts[0];
        binding.listenerEvent = event || _caseMapJs.camelToDashCase(target) + '-changed';
        binding.listenerNegate = negate;
    }
    // Add "propagate" property effects to templateInfo
    let index = templateInfo.nodeInfoList.length;
    for(let i = 0; i < binding.parts.length; i++){
        let part = binding.parts[i];
        part.compoundIndex = i;
        addEffectForBindingPart(constructor, templateInfo, binding, part, index);
    }
}
/**
 * Adds property effects to the given `templateInfo` for the given binding
 * part.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {number} index Index into `nodeInfoList` for this node
 * @return {void}
 */ function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
    if (!part.literal) {
        if (binding.kind === 'attribute' && binding.target[0] === '-') console.warn('Cannot set attribute ' + binding.target + ' because "-" is not a valid attribute starting character');
        else {
            let dependencies = part.dependencies;
            let info = {
                index,
                binding,
                part,
                evaluator: constructor
            };
            for(let j = 0; j < dependencies.length; j++){
                let trigger = dependencies[j];
                if (typeof trigger == 'string') {
                    trigger = parseArg(trigger);
                    trigger.wildcard = true;
                }
                constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
                    fn: runBindingEffect,
                    info,
                    trigger
                });
            }
        }
    }
}
/**
 * Implements the "binding" (property/path binding) effect.
 *
 * Note that binding syntax is overridable via `_parseBindings` and
 * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
 * non-literal parts returned from `_parseBindings`.  However,
 * there is no support for _path_ bindings via custom binding parts,
 * as this is specific to Polymer's path binding syntax.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} path Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
 *   metadata
 * @return {void}
 * @private
 */ function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
    let node = nodeList[info.index];
    let binding = info.binding;
    let part = info.part;
    // Subpath notification: transform path and set to client
    // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop
    if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
        let value = props[path];
        path = _pathJs.translate(part.source, binding.target, path);
        if (node._setPendingPropertyOrPath(path, value, false, true)) inst._enqueueClient(node);
    } else {
        let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
        // Propagate value to child
        // Abort if value is a no-op result
        if (value !== NOOP) applyBindingValue(inst, node, binding, part, value);
    }
}
/**
 * Sets the value for an "binding" (binding) effect to a node,
 * either as a property or attribute.
 *
 * @param {!Polymer_PropertyEffects} inst The instance owning the binding effect
 * @param {Node} node Target node for binding
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {*} value Value to set
 * @return {void}
 * @private
 */ function applyBindingValue(inst, node, binding, part, value) {
    value = computeBindingValue(node, value, binding, part);
    if (_settingsJs.sanitizeDOMValue) value = _settingsJs.sanitizeDOMValue(value, binding.target, binding.kind, node);
    if (binding.kind == 'attribute') // Attribute binding
    inst._valueToNodeAttribute(node, value, binding.target);
    else {
        // Property binding
        let prop = binding.target;
        if (node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
            if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
                if (node._setPendingProperty(prop, value)) inst._enqueueClient(node);
            }
        } else // In legacy no-batching mode, bindings applied before dataReady are
        // equivalent to the "apply config" phase, which only set managed props
        inst._setUnmanagedPropertyToNode(node, prop, value);
    }
}
/**
 * Transforms an "binding" effect value based on compound & negation
 * effect metadata, as well as handling for special-case properties
 *
 * @param {Node} node Node the value will be set to
 * @param {*} value Value to set
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @return {*} Transformed value to set
 * @private
 */ function computeBindingValue(node, value, binding, part) {
    if (binding.isCompound) {
        let storage = node.__dataCompoundStorage[binding.target];
        storage[part.compoundIndex] = value;
        value = storage.join('');
    }
    if (binding.kind !== 'attribute') // Some browsers serialize `undefined` to `"undefined"`
    {
        if (binding.target === 'textContent' || binding.target === 'value' && (node.localName === 'input' || node.localName === 'textarea')) value = value == undefined ? '' : value;
    }
    return value;
}
/**
 * Returns true if a binding's metadata meets all the requirements to allow
 * 2-way binding, and therefore a `<property>-changed` event listener should be
 * added:
 * - used curly braces
 * - is a property (not attribute) binding
 * - is not a textContent binding
 * - is not compound
 *
 * @param {!Binding} binding Binding metadata
 * @return {boolean} True if 2-way listener should be added
 * @private
 */ function shouldAddListener(binding) {
    return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';
}
/**
 * Setup compound binding storage structures, notify listeners, and dataHost
 * references onto the bound nodeList.
 *
 * @param {!Polymer_PropertyEffects} inst Instance that bas been previously
 *     bound
 * @param {TemplateInfo} templateInfo Template metadata
 * @return {void}
 * @private
 */ function setupBindings(inst, templateInfo) {
    // Setup compound storage, dataHost, and notify listeners
    let { nodeList , nodeInfoList  } = templateInfo;
    if (nodeInfoList.length) for(let i = 0; i < nodeInfoList.length; i++){
        let info = nodeInfoList[i];
        let node = nodeList[i];
        let bindings = info.bindings;
        if (bindings) for(let i = 0; i < bindings.length; i++){
            let binding = bindings[i];
            setupCompoundStorage(node, binding);
            addNotifyListener(node, inst, binding);
        }
        // This ensures all bound elements have a host set, regardless
        // of whether they upgrade synchronous to creation
        node.__dataHost = inst;
    }
}
/**
 * Initializes `__dataCompoundStorage` local storage on a bound node with
 * initial literal data for compound bindings, and sets the joined
 * literal parts to the bound property.
 *
 * When changes to compound parts occur, they are first set into the compound
 * storage array for that property, and then the array is joined to result in
 * the final value set to the property/attribute.
 *
 * @param {Node} node Bound node to initialize
 * @param {Binding} binding Binding metadata
 * @return {void}
 * @private
 */ function setupCompoundStorage(node, binding) {
    if (binding.isCompound) {
        // Create compound storage map
        let storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {
        });
        let parts = binding.parts;
        // Copy literals from parts into storage for this binding
        let literals = new Array(parts.length);
        for(let j = 0; j < parts.length; j++)literals[j] = parts[j].literal;
        let target = binding.target;
        storage[target] = literals;
        // Configure properties with their literal parts
        if (binding.literal && binding.kind == 'property') {
            // Note, className needs style scoping so this needs wrapping.
            // We may also want to consider doing this for `textContent` and
            // `innerHTML`.
            if (target === 'className') node = _wrapJs.wrap(node);
            node[target] = binding.literal;
        }
    }
}
/**
 * Adds a 2-way binding notification event listener to the node specified
 *
 * @param {Object} node Child element to add listener to
 * @param {!Polymer_PropertyEffects} inst Host element instance to handle
 *     notification event
 * @param {Binding} binding Binding metadata
 * @return {void}
 * @private
 */ function addNotifyListener(node, inst, binding) {
    if (binding.listenerEvent) {
        let part = binding.parts[0];
        node.addEventListener(binding.listenerEvent, function(e) {
            handleNotification(e, inst, binding.target, part.source, part.negate);
        });
    }
}
// -- for method-based effects (complexObserver & computed) --------------
/**
 * Adds property effects for each argument in the method signature (and
 * optionally, for the method name if `dynamic` is true) that calls the
 * provided effect function.
 *
 * @param {Element | Object} model Prototype or instance
 * @param {!MethodSignature} sig Method signature metadata
 * @param {string} type Type of property effect to add
 * @param {Function} effectFn Function to run when arguments change
 * @param {*=} methodInfo Effect-specific information to be included in
 *   method effect metadata
 * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
 *   method names should be included as a dependency to the effect. Note,
 *   defaults to true if the signature is static (sig.static is true).
 * @return {!Object} Effect metadata for this method effect
 * @private
 */ function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
    dynamicFn = sig.static || dynamicFn && (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]);
    let info = {
        methodName: sig.methodName,
        args: sig.args,
        methodInfo,
        dynamicFn
    };
    for(let i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++)if (!arg.literal) model._addPropertyEffect(arg.rootProperty, type, {
        fn: effectFn,
        info: info,
        trigger: arg
    });
    if (dynamicFn) model._addPropertyEffect(sig.methodName, type, {
        fn: effectFn,
        info: info
    });
    return info;
}
/**
 * Calls a method with arguments marshaled from properties on the instance
 * based on the method signature contained in the effect metadata.
 *
 * Multi-property observers, computed properties, and inline computing
 * functions call this function to invoke the method, then use the return
 * value accordingly.
 *
 * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {*} Returns the return value from the method invocation
 * @private
 */ function runMethodEffect(inst, property, props, oldProps, info) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    let context = inst._methodHost || inst;
    let fn = context[info.methodName];
    if (fn) {
        let args = inst._marshalArgs(info.args, property, props);
        return args === NOOP ? NOOP : fn.apply(context, args);
    } else if (!info.dynamicFn) console.warn('method `' + info.methodName + '` not defined');
}
const emptyArray = [];
// Regular expressions used for binding
const IDENT = "(?:[a-zA-Z_$][\\w.:$\\-*]*)";
const NUMBER = "(?:[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?)";
const SQUOTE_STRING = "(?:'(?:[^'\\\\]|\\\\.)*')";
const DQUOTE_STRING = "(?:\"(?:[^\"\\\\]|\\\\.)*\")";
const STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
const ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\s*' + ')';
const ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
const ARGUMENT_LIST = "(?:\\(\\s*(?:" + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
const BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
const OPEN_BRACKET = "(\\[\\[|{{)\\s*";
const CLOSE_BRACKET = '(?:]]|}})';
const NEGATE = '(?:(!)\\s*)?'; // Group 2
const EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
const bindingRegex = new RegExp(EXPRESSION, "g");
/**
 * Create a string from binding parts of all the literal parts
 *
 * @param {!Array<BindingPart>} parts All parts to stringify
 * @return {string} String made from the literal parts
 */ function literalFromParts(parts) {
    let s = '';
    for(let i = 0; i < parts.length; i++){
        let literal = parts[i].literal;
        s += literal || '';
    }
    return s;
}
/**
 * Parses an expression string for a method signature, and returns a metadata
 * describing the method in terms of `methodName`, `static` (whether all the
 * arguments are literals), and an array of `args`
 *
 * @param {string} expression The expression to parse
 * @return {?MethodSignature} The method metadata object if a method expression was
 *   found, otherwise `undefined`
 * @private
 */ function parseMethod(expression) {
    // tries to match valid javascript property names
    let m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
    if (m) {
        let methodName = m[1];
        let sig = {
            methodName,
            static: true,
            args: emptyArray
        };
        if (m[2].trim()) {
            // replace escaped commas with comma entity, split on un-escaped commas
            let args = m[2].replace(/\\,/g, '&comma;').split(',');
            return parseArgs(args, sig);
        } else return sig;
    }
    return null;
}
/**
 * Parses an array of arguments and sets the `args` property of the supplied
 * signature metadata object. Sets the `static` property to false if any
 * argument is a non-literal.
 *
 * @param {!Array<string>} argList Array of argument names
 * @param {!MethodSignature} sig Method signature metadata object
 * @return {!MethodSignature} The updated signature metadata object
 * @private
 */ function parseArgs(argList, sig) {
    sig.args = argList.map(function(rawArg) {
        let arg = parseArg(rawArg);
        if (!arg.literal) sig.static = false;
        return arg;
    }, this);
    return sig;
}
/**
 * Parses an individual argument, and returns an argument metadata object
 * with the following fields:
 *
 *   {
 *     value: 'prop',        // property/path or literal value
 *     literal: false,       // whether argument is a literal
 *     structured: false,    // whether the property is a path
 *     rootProperty: 'prop', // the root property of the path
 *     wildcard: false       // whether the argument was a wildcard '.*' path
 *   }
 *
 * @param {string} rawArg The string value of the argument
 * @return {!MethodArg} Argument metadata object
 * @private
 */ function parseArg(rawArg) {
    // clean up whitespace
    let arg = rawArg.trim()// replace comma entity with comma
    .replace(/&comma;/g, ',')// repair extra escape sequences; note only commas strictly need
    // escaping, but we allow any other char to be escaped since its
    // likely users will do this
    .replace(/\\(.)/g, '$1');
    // basic argument descriptor
    let a = {
        name: arg,
        value: '',
        literal: false
    };
    // detect literal value (must be String or Number)
    let fc = arg[0];
    if (fc === '-') fc = arg[1];
    if (fc >= '0' && fc <= '9') fc = '#';
    switch(fc){
        case "'":
        case '"':
            a.value = arg.slice(1, -1);
            a.literal = true;
            break;
        case '#':
            a.value = Number(arg);
            a.literal = true;
            break;
    }
    // if not literal, look for structured path
    if (!a.literal) {
        a.rootProperty = _pathJs.root(arg);
        // detect structured path (has dots)
        a.structured = _pathJs.isPath(arg);
        if (a.structured) {
            a.wildcard = arg.slice(-2) == '.*';
            if (a.wildcard) a.name = arg.slice(0, -2);
        }
    }
    return a;
}
function getArgValue(data, props, path) {
    let value = _pathJs.get(data, path);
    // when data is not stored e.g. `splices`, get the value from changedProps
    // TODO(kschaaf): Note, this can cause a rare issue where the wildcard
    // info.value could pull a stale value out of changedProps during a reentrant
    // change that sets the value back to undefined.
    // https://github.com/Polymer/polymer/issues/5479
    if (value === undefined) value = props[path];
    return value;
}
// data api
/**
 * Sends array splice notifications (`.splices` and `.length`)
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!Polymer_PropertyEffects} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {Array} splices Array of splice records
 * @return {void}
 * @private
 */ function notifySplices(inst, array, path, splices) {
    const splicesData = {
        indexSplices: splices
    };
    // Legacy behavior stored splices in `__data__` so it was *not* ephemeral.
    // To match this behavior, we store splices directly on the array.
    if (_settingsJs.legacyUndefined && !inst._overrideLegacyUndefined) array.splices = splicesData;
    inst.notifyPath(path + '.splices', splicesData);
    inst.notifyPath(path + '.length', array.length);
    // Clear splice data only when it's stored on the array.
    if (_settingsJs.legacyUndefined && !inst._overrideLegacyUndefined) splicesData.indexSplices = [];
}
/**
 * Creates a splice record and sends an array splice notification for
 * the described mutation
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!Polymer_PropertyEffects} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {number} index Index at which the array mutation occurred
 * @param {number} addedCount Number of added items
 * @param {Array} removed Array of removed items
 * @return {void}
 * @private
 */ function notifySplice(inst, array, path, index, addedCount, removed) {
    notifySplices(inst, array, path, [
        {
            index: index,
            addedCount: addedCount,
            removed: removed,
            object: array,
            type: 'splice'
        }
    ]);
}
/**
 * Returns an upper-cased version of the string.
 *
 * @param {string} name String to uppercase
 * @return {string} Uppercased string
 * @private
 */ function upper(name) {
    return name[0].toUpperCase() + name.substring(1);
}
const PropertyEffects = _mixinJs.dedupingMixin((superClass)=>{
    /**
   * @constructor
   * @implements {Polymer_PropertyAccessors}
   * @implements {Polymer_TemplateStamp}
   * @unrestricted
   * @private
   */ const propertyEffectsBase = _templateStampJs.TemplateStamp(_propertyAccessorsJs.PropertyAccessors(superClass));
    /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyEffects}
   * @extends {propertyEffectsBase}
   * @unrestricted
   */ class PropertyEffects1 extends propertyEffectsBase {
        constructor(){
            super();
            /** @type {boolean} */ // Used to identify users of this mixin, ala instanceof
            this.__isPropertyEffectsClient = true;
            /** @type {boolean} */ this.__dataClientsReady;
            /** @type {Array} */ this.__dataPendingClients;
            /** @type {Object} */ this.__dataToNotify;
            /** @type {Object} */ this.__dataLinkedPaths;
            /** @type {boolean} */ this.__dataHasPaths;
            /** @type {Object} */ this.__dataCompoundStorage;
            /** @type {Polymer_PropertyEffects} */ this.__dataHost;
            /** @type {!Object} */ this.__dataTemp;
            /** @type {boolean} */ this.__dataClientsInitialized;
            /** @type {!Object} */ this.__data;
            /** @type {!Object|null} */ this.__dataPending;
            /** @type {!Object} */ this.__dataOld;
            /** @type {Object} */ this.__computeEffects;
            /** @type {Object} */ this.__computeInfo;
            /** @type {Object} */ this.__reflectEffects;
            /** @type {Object} */ this.__notifyEffects;
            /** @type {Object} */ this.__propagateEffects;
            /** @type {Object} */ this.__observeEffects;
            /** @type {Object} */ this.__readOnly;
            /** @type {!TemplateInfo} */ this.__templateInfo;
            /** @type {boolean} */ this._overrideLegacyUndefined;
        }
        get PROPERTY_EFFECT_TYPES() {
            return TYPES;
        }
        /**
     * @override
     * @return {void}
     */ _initializeProperties() {
            super._initializeProperties();
            this._registerHost();
            this.__dataClientsReady = false;
            this.__dataPendingClients = null;
            this.__dataToNotify = null;
            this.__dataLinkedPaths = null;
            this.__dataHasPaths = false;
            // May be set on instance prior to upgrade
            this.__dataCompoundStorage = this.__dataCompoundStorage || null;
            this.__dataHost = this.__dataHost || null;
            this.__dataTemp = {
            };
            this.__dataClientsInitialized = false;
        }
        _registerHost() {
            if (hostStack.length) {
                let host = hostStack[hostStack.length - 1];
                host._enqueueClient(this);
                // This ensures even non-bound elements have a host set, as
                // long as they upgrade synchronously
                this.__dataHost = host;
            }
        }
        /**
     * Overrides `PropertyAccessors` implementation to provide a
     * more efficient implementation of initializing properties from
     * the prototype on the instance.
     *
     * @override
     * @param {Object} props Properties to initialize on the prototype
     * @return {void}
     */ _initializeProtoProperties(props) {
            this.__data = Object.create(props);
            this.__dataPending = Object.create(props);
            this.__dataOld = {
            };
        }
        /**
     * Overrides `PropertyAccessors` implementation to avoid setting
     * `_setProperty`'s `shouldNotify: true`.
     *
     * @override
     * @param {Object} props Properties to initialize on the instance
     * @return {void}
     */ _initializeInstanceProperties(props) {
            let readOnly = this[TYPES.READ_ONLY];
            for(let prop in props)if (!readOnly || !readOnly[prop]) {
                this.__dataPending = this.__dataPending || {
                };
                this.__dataOld = this.__dataOld || {
                };
                this.__data[prop] = this.__dataPending[prop] = props[prop];
            }
        }
        // Prototype setup ----------------------------------------
        /**
     * Equivalent to static `addPropertyEffect` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     */ _addPropertyEffect(property, type, effect) {
            this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
            // effects are accumulated into arrays per property based on type
            let effects = ensureOwnEffectMap(this, type, true)[property];
            if (!effects) effects = this[type][property] = [];
            effects.push(effect);
        }
        /**
     * Removes the given property effect.
     *
     * @override
     * @param {string} property Property the effect was associated with
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object to remove
     * @return {void}
     */ _removePropertyEffect(property, type, effect) {
            let effects = ensureOwnEffectMap(this, type, true)[property];
            let idx = effects.indexOf(effect);
            if (idx >= 0) effects.splice(idx, 1);
        }
        /**
     * Returns whether the current prototype/instance has a property effect
     * of a certain type.
     *
     * @override
     * @param {string} property Property name
     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */ _hasPropertyEffect(property, type) {
            let effects = this[type];
            return Boolean(effects && effects[property]);
        }
        /**
     * Returns whether the current prototype/instance has a "read only"
     * accessor for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */ _hasReadOnlyEffect(property) {
            return this._hasPropertyEffect(property, TYPES.READ_ONLY);
        }
        /**
     * Returns whether the current prototype/instance has a "notify"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */ _hasNotifyEffect(property) {
            return this._hasPropertyEffect(property, TYPES.NOTIFY);
        }
        /**
     * Returns whether the current prototype/instance has a "reflect to
     * attribute" property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */ _hasReflectEffect(property) {
            return this._hasPropertyEffect(property, TYPES.REFLECT);
        }
        /**
     * Returns whether the current prototype/instance has a "computed"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */ _hasComputedEffect(property) {
            return this._hasPropertyEffect(property, TYPES.COMPUTE);
        }
        // Runtime ----------------------------------------
        /**
     * Sets a pending property or path.  If the root property of the path in
     * question had no accessor, the path is set, otherwise it is enqueued
     * via `_setPendingProperty`.
     *
     * This function isolates relatively expensive functionality necessary
     * for the public API (`set`, `setProperties`, `notifyPath`, and property
     * change listeners via {{...}} bindings), such that it is only done
     * when paths enter the system, and not at every propagation step.  It
     * also sets a `__dataHasPaths` flag on the instance which is used to
     * fast-path slower path-matching code in the property effects host paths.
     *
     * `path` can be a path string or array of path parts as accepted by the
     * public API.
     *
     * @override
     * @param {string | !Array<number|string>} path Path to set
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify Set to true if this change should
     *  cause a property notification event dispatch
     * @param {boolean=} isPathNotification If the path being set is a path
     *   notification of an already changed value, as opposed to a request
     *   to set and notify the change.  In the latter `false` case, a dirty
     *   check is performed and then the value is set to the path before
     *   enqueuing the pending property change.
     * @return {boolean} Returns true if the property/path was enqueued in
     *   the pending changes bag.
     * @protected
     */ _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
            if (isPathNotification || _pathJs.root(Array.isArray(path) ? path[0] : path) !== path) {
                // Dirty check changes being set to a path against the actual object,
                // since this is the entry point for paths into the system; from here
                // the only dirty checks are against the `__dataTemp` cache to prevent
                // duplicate work in the same turn only. Note, if this was a notification
                // of a change already set to a path (isPathNotification: true),
                // we always let the change through and skip the `set` since it was
                // already dirty checked at the point of entry and the underlying
                // object has already been updated
                if (!isPathNotification) {
                    let old = _pathJs.get(this, path);
                    path = _pathJs.set(this, path, value);
                    // Use property-accessor's simpler dirty check
                    if (!path || !super._shouldPropertyChange(path, value, old)) return false;
                }
                this.__dataHasPaths = true;
                if (this._setPendingProperty(path, value, shouldNotify)) {
                    computeLinkedPaths(this, path, value);
                    return true;
                }
            } else {
                if (this.__dataHasAccessor && this.__dataHasAccessor[path]) return this._setPendingProperty(path, value, shouldNotify);
                else this[path] = value;
            }
            return false;
        }
        /**
     * Applies a value to a non-Polymer element/node's property.
     *
     * The implementation makes a best-effort at binding interop:
     * Some native element properties have side-effects when
     * re-setting the same value (e.g. setting `<input>.value` resets the
     * cursor position), so we do a dirty-check before setting the value.
     * However, for better interop with non-Polymer custom elements that
     * accept objects, we explicitly re-set object changes coming from the
     * Polymer world (which may include deep object changes without the
     * top reference changing), erring on the side of providing more
     * information.
     *
     * Users may override this method to provide alternate approaches.
     *
     * @override
     * @param {!Node} node The node to set a property on
     * @param {string} prop The property to set
     * @param {*} value The value to set
     * @return {void}
     * @protected
     */ _setUnmanagedPropertyToNode(node, prop, value) {
            // It is a judgment call that resetting primitives is
            // "bad" and resettings objects is also "good"; alternatively we could
            // implement a whitelist of tag & property values that should never
            // be reset (e.g. <input>.value && <select>.value)
            if (value !== node[prop] || typeof value == 'object') {
                // Note, className needs style scoping so this needs wrapping.
                if (prop === 'className') node = _wrapJs.wrap(node);
                node[prop] = value;
            }
        }
        /**
     * Overrides the `PropertiesChanged` implementation to introduce special
     * dirty check logic depending on the property & value being set:
     *
     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
     * 2. Object set to simple property (e.g. 'prop': {...})
     *    Stored in `__dataTemp` and `__data`, dirty checked against
     *    `__dataTemp` by default implementation of `_shouldPropertyChange`
     * 3. Primitive value set to simple property (e.g. 'prop': 42)
     *    Stored in `__data`, dirty checked against `__data`
     *
     * The dirty-check is important to prevent cycles due to two-way
     * notification, but paths and objects are only dirty checked against any
     * previous value set during this turn via a "temporary cache" that is
     * cleared when the last `_propertiesChanged` exits. This is so:
     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
     *    due to array mutations like shift/unshift/splice; this is fine
     *    since path changes are dirty-checked at user entry points like `set`
     * b. dirty-checking for objects only lasts one turn to allow the user
     *    to mutate the object in-place and re-set it with the same identity
     *    and have all sub-properties re-propagated in a subsequent turn.
     *
     * The temp cache is not necessarily sufficient to prevent invalid array
     * paths, since a splice can happen during the same turn (with pathological
     * user code); we could introduce a "fixup" for temporarily cached array
     * paths if needed: https://github.com/Polymer/polymer/issues/4227
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify True if property should fire notification
     *   event (applies only for `notify: true` properties)
     * @return {boolean} Returns true if the property changed
     */ _setPendingProperty(property, value, shouldNotify) {
            let propIsPath = this.__dataHasPaths && _pathJs.isPath(property);
            let prevProps = propIsPath ? this.__dataTemp : this.__data;
            if (this._shouldPropertyChange(property, value, prevProps[property])) {
                if (!this.__dataPending) {
                    this.__dataPending = {
                    };
                    this.__dataOld = {
                    };
                }
                // Ensure old is captured from the last turn
                if (!(property in this.__dataOld)) this.__dataOld[property] = this.__data[property];
                // Paths are stored in temporary cache (cleared at end of turn),
                // which is used for dirty-checking, all others stored in __data
                if (propIsPath) this.__dataTemp[property] = value;
                else this.__data[property] = value;
                // All changes go into pending property bag, passed to _propertiesChanged
                this.__dataPending[property] = value;
                // Track properties that should notify separately
                if (propIsPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {
                    this.__dataToNotify = this.__dataToNotify || {
                    };
                    this.__dataToNotify[property] = shouldNotify;
                }
                return true;
            }
            return false;
        }
        /**
     * Overrides base implementation to ensure all accessors set `shouldNotify`
     * to true, for per-property notification tracking.
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {void}
     */ _setProperty(property, value) {
            if (this._setPendingProperty(property, value, true)) this._invalidateProperties();
        }
        /**
     * Overrides `PropertyAccessor`'s default async queuing of
     * `_propertiesChanged`: if `__dataReady` is false (has not yet been
     * manually flushed), the function no-ops; otherwise flushes
     * `_propertiesChanged` synchronously.
     *
     * @override
     * @return {void}
     */ _invalidateProperties() {
            if (this.__dataReady) this._flushProperties();
        }
        /**
     * Enqueues the given client on a list of pending clients, whose
     * pending property changes can later be flushed via a call to
     * `_flushClients`.
     *
     * @override
     * @param {Object} client PropertyEffects client to enqueue
     * @return {void}
     * @protected
     */ _enqueueClient(client) {
            this.__dataPendingClients = this.__dataPendingClients || [];
            if (client !== this) this.__dataPendingClients.push(client);
        }
        /**
     * Flushes any clients previously enqueued via `_enqueueClient`, causing
     * their `_flushProperties` method to run.
     *
     * @override
     * @return {void}
     * @protected
     */ _flushClients() {
            if (!this.__dataClientsReady) {
                this.__dataClientsReady = true;
                this._readyClients();
                // Override point where accessors are turned on; importantly,
                // this is after clients have fully readied, providing a guarantee
                // that any property effects occur only after all clients are ready.
                this.__dataReady = true;
            } else this.__enableOrFlushClients();
        }
        // NOTE: We ensure clients either enable or flush as appropriate. This
        // handles two corner cases:
        // (1) clients flush properly when connected/enabled before the host
        // enables; e.g.
        //   (a) Templatize stamps with no properties and does not flush and
        //   (b) the instance is inserted into dom and
        //   (c) then the instance flushes.
        // (2) clients enable properly when not connected/enabled when the host
        // flushes; e.g.
        //   (a) a template is runtime stamped and not yet connected/enabled
        //   (b) a host sets a property, causing stamped dom to flush
        //   (c) the stamped dom enables.
        __enableOrFlushClients() {
            let clients = this.__dataPendingClients;
            if (clients) {
                this.__dataPendingClients = null;
                for(let i = 0; i < clients.length; i++){
                    let client = clients[i];
                    if (!client.__dataEnabled) client._enableProperties();
                    else if (client.__dataPending) client._flushProperties();
                }
            }
        }
        /**
     * Perform any initial setup on client dom. Called before the first
     * `_flushProperties` call on client dom and before any element
     * observers are called.
     *
     * @override
     * @return {void}
     * @protected
     */ _readyClients() {
            this.__enableOrFlushClients();
        }
        /**
     * Sets a bag of property changes to this instance, and
     * synchronously processes all effects of the properties as a batch.
     *
     * Property names must be simple properties, not paths.  Batched
     * path propagation is not supported.
     *
     * @override
     * @param {Object} props Bag of one or more key-value pairs whose key is
     *   a property and value is the new value to set for that property.
     * @param {boolean=} setReadOnly When true, any private values set in
     *   `props` will be set. By default, `setProperties` will not set
     *   `readOnly: true` root properties.
     * @return {void}
     * @public
     */ setProperties(props, setReadOnly) {
            for(let path in props)if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) //TODO(kschaaf): explicitly disallow paths in setProperty?
            // wildcard observers currently only pass the first changed path
            // in the `info` object, and you could do some odd things batching
            // paths, e.g. {'foo.bar': {...}, 'foo': null}
            this._setPendingPropertyOrPath(path, props[path], true);
            this._invalidateProperties();
        }
        /**
     * Overrides `PropertyAccessors` so that property accessor
     * side effects are not enabled until after client dom is fully ready.
     * Also calls `_flushClients` callback to ensure client dom is enabled
     * that was not enabled as a result of flushing properties.
     *
     * @override
     * @return {void}
     */ ready() {
            // It is important that `super.ready()` is not called here as it
            // immediately turns on accessors. Instead, we wait until `readyClients`
            // to enable accessors to provide a guarantee that clients are ready
            // before processing any accessors side effects.
            this._flushProperties();
            // If no data was pending, `_flushProperties` will not `flushClients`
            // so ensure this is done.
            if (!this.__dataClientsReady) this._flushClients();
            // Before ready, client notifications do not trigger _flushProperties.
            // Therefore a flush is necessary here if data has been set.
            if (this.__dataPending) this._flushProperties();
        }
        /**
     * Implements `PropertyAccessors`'s properties changed callback.
     *
     * Runs each class of effects for the batch of changed properties in
     * a specific order (compute, propagate, reflect, observe, notify).
     *
     * @override
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {void}
     */ _propertiesChanged(currentProps, changedProps, oldProps) {
            // ----------------------------
            // let c = Object.getOwnPropertyNames(changedProps || {});
            // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
            // if (window.debug) { debugger; }
            // ----------------------------
            let hasPaths = this.__dataHasPaths;
            this.__dataHasPaths = false;
            let notifyProps;
            // Compute properties
            runComputedEffects(this, changedProps, oldProps, hasPaths);
            // Clear notify properties prior to possible reentry (propagate, observe),
            // but after computing effects have a chance to add to them
            notifyProps = this.__dataToNotify;
            this.__dataToNotify = null;
            // Propagate properties to clients
            this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
            // Flush clients
            this._flushClients();
            // Reflect properties
            runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
            // Observe properties
            runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
            // Notify properties to host
            if (notifyProps) runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
            // Clear temporary cache at end of turn
            if (this.__dataCounter == 1) this.__dataTemp = {
            };
        // ----------------------------
        // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
        // ----------------------------
        }
        /**
     * Called to propagate any property changes to stamped template nodes
     * managed by this element.
     *
     * @override
     * @param {Object} changedProps Bag of changed properties
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {void}
     * @protected
     */ _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
            if (this[TYPES.PROPAGATE]) runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
            if (this.__templateInfo) this._runEffectsForTemplate(this.__templateInfo, changedProps, oldProps, hasPaths);
        }
        _runEffectsForTemplate(templateInfo, changedProps1, oldProps, hasPaths1) {
            const baseRunEffects = (changedProps, hasPaths)=>{
                runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);
                for(let info = templateInfo.firstChild; info; info = info.nextSibling)this._runEffectsForTemplate(info, changedProps, oldProps, hasPaths);
            };
            if (templateInfo.runEffects) templateInfo.runEffects(baseRunEffects, changedProps1, hasPaths1);
            else baseRunEffects(changedProps1, hasPaths1);
        }
        /**
     * Aliases one data path as another, such that path notifications from one
     * are routed to the other.
     *
     * @override
     * @param {string | !Array<string|number>} to Target path to link.
     * @param {string | !Array<string|number>} from Source path to link.
     * @return {void}
     * @public
     */ linkPaths(to, from) {
            to = _pathJs.normalize(to);
            from = _pathJs.normalize(from);
            this.__dataLinkedPaths = this.__dataLinkedPaths || {
            };
            this.__dataLinkedPaths[to] = from;
        }
        /**
     * Removes a data path alias previously established with `_linkPaths`.
     *
     * Note, the path to unlink should be the target (`to`) used when
     * linking the paths.
     *
     * @override
     * @param {string | !Array<string|number>} path Target path to unlink.
     * @return {void}
     * @public
     */ unlinkPaths(path) {
            path = _pathJs.normalize(path);
            if (this.__dataLinkedPaths) delete this.__dataLinkedPaths[path];
        }
        /**
     * Notify that an array has changed.
     *
     * Example:
     *
     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
     *     ...
     *     this.items.splice(1, 1, {name: 'Sam'});
     *     this.items.push({name: 'Bob'});
     *     this.notifySplices('items', [
     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,
     *         object: this.items, type: 'splice' },
     *       { index: 3, removed: [], addedCount: 1,
     *         object: this.items, type: 'splice'}
     *     ]);
     *
     * @param {string} path Path that should be notified.
     * @param {Array} splices Array of splice records indicating ordered
     *   changes that occurred to the array. Each record should have the
     *   following fields:
     *    * index: index at which the change occurred
     *    * removed: array of items that were removed from this index
     *    * addedCount: number of new items added at this index
     *    * object: a reference to the array in question
     *    * type: the string literal 'splice'
     *
     *   Note that splice records _must_ be normalized such that they are
     *   reported in index order (raw results from `Object.observe` are not
     *   ordered and must be normalized/merged before notifying).
     *
     * @override
     * @return {void}
     * @public
     */ notifySplices(path, splices) {
            let info = {
                path: ''
            };
            let array = _pathJs.get(this, path, info);
            notifySplices(this, array, info.path, splices);
        }
        /**
     * Convenience method for reading a value from a path.
     *
     * Note, if any part in the path is undefined, this method returns
     * `undefined` (this method does not throw when dereferencing undefined
     * paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `users.12.name` or `['users', 12, 'name']`).
     * @param {Object=} root Root object from which the path is evaluated.
     * @return {*} Value at the path, or `undefined` if any part of the path
     *   is undefined.
     * @public
     */ get(path, root) {
            return _pathJs.get(root || this, path);
        }
        /**
     * Convenience method for setting a value to a path and notifying any
     * elements bound to the same path.
     *
     * Note, if any part in the path except for the last is undefined,
     * this method does nothing (this method does not throw when
     * dereferencing undefined paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
     * @param {*} value Value to set at the specified path.
     * @param {Object=} root Root object from which the path is evaluated.
     *   When specified, no notification will occur.
     * @return {void}
     * @public
     */ set(path, value, root) {
            if (root) _pathJs.set(root, path, value);
            else {
                if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
                    if (this._setPendingPropertyOrPath(path, value, true)) this._invalidateProperties();
                }
            }
        }
        /**
     * Adds items onto the end of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to push onto array
     * @return {number} New length of the array.
     * @public
     */ push(path, ...items) {
            let info = {
                path: ''
            };
            let array = _pathJs.get(this, path, info);
            let len = array.length;
            let ret = array.push(...items);
            if (items.length) notifySplice(this, array, info.path, len, items.length, []);
            return ret;
        }
        /**
     * Removes an item from the end of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */ pop(path) {
            let info = {
                path: ''
            };
            let array = _pathJs.get(this, path, info);
            let hadLength = Boolean(array.length);
            let ret = array.pop();
            if (hadLength) notifySplice(this, array, info.path, array.length, 0, [
                ret
            ]);
            return ret;
        }
        /**
     * Starting from the start index specified, removes 0 or more items
     * from the array and inserts 0 or more new items in their place.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.splice`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {number} start Index from which to start removing/inserting.
     * @param {number=} deleteCount Number of items to remove.
     * @param {...*} items Items to insert into array.
     * @return {!Array} Array of removed items.
     * @public
     */ splice(path, start, deleteCount, ...items) {
            let info = {
                path: ''
            };
            let array = _pathJs.get(this, path, info);
            // Normalize fancy native splice handling of crazy start values
            if (start < 0) start = array.length - Math.floor(-start);
            else if (start) start = Math.floor(start);
            // array.splice does different things based on the number of arguments
            // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)
            // do different things. In the former, the whole array is cleared. In the
            // latter, no items are removed.
            // This means that we need to detect whether 1. one of the arguments
            // is actually passed in and then 2. determine how many arguments
            // we should pass on to the native array.splice
            //
            let ret;
            // Omit any additional arguments if they were not passed in
            if (arguments.length === 2) ret = array.splice(start);
            else ret = array.splice(start, deleteCount, ...items);
            // At the end, check whether any items were passed in (e.g. insertions)
            // or if the return array contains items (e.g. deletions).
            // Only notify if items were added or deleted.
            if (items.length || ret.length) notifySplice(this, array, info.path, start, items.length, ret);
            return ret;
        }
        /**
     * Removes an item from the beginning of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */ shift(path) {
            let info = {
                path: ''
            };
            let array = _pathJs.get(this, path, info);
            let hadLength = Boolean(array.length);
            let ret = array.shift();
            if (hadLength) notifySplice(this, array, info.path, 0, 0, [
                ret
            ]);
            return ret;
        }
        /**
     * Adds items onto the beginning of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to insert info array
     * @return {number} New length of the array.
     * @public
     */ unshift(path, ...items) {
            let info = {
                path: ''
            };
            let array = _pathJs.get(this, path, info);
            let ret = array.unshift(...items);
            if (items.length) notifySplice(this, array, info.path, 0, items.length, []);
            return ret;
        }
        /**
     * Notify that a path has changed.
     *
     * Example:
     *
     *     this.item.user.name = 'Bob';
     *     this.notifyPath('item.user.name');
     *
     * @override
     * @param {string} path Path that should be notified.
     * @param {*=} value Value at the path (optional).
     * @return {void}
     * @public
     */ notifyPath(path, value) {
            /** @type {string} */ let propPath;
            if (arguments.length == 1) {
                // Get value if not supplied
                let info = {
                    path: ''
                };
                value = _pathJs.get(this, path, info);
                propPath = info.path;
            } else if (Array.isArray(path)) // Normalize path if needed
            propPath = _pathJs.normalize(path);
            else propPath = path;
            if (this._setPendingPropertyOrPath(propPath, value, true, true)) this._invalidateProperties();
        }
        /**
     * Equivalent to static `createReadOnlyProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     */ _createReadOnlyProperty(property, protectedSetter) {
            this._addPropertyEffect(property, TYPES.READ_ONLY);
            if (protectedSetter) this['_set' + upper(property)] = /** @this {PropertyEffects} */ function(value) {
                this._setProperty(property, value);
            };
        }
        /**
     * Equivalent to static `createPropertyObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method
     *     to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     */ _createPropertyObserver(property, method, dynamicFn) {
            let info = {
                property,
                method,
                dynamicFn: Boolean(dynamicFn)
            };
            this._addPropertyEffect(property, TYPES.OBSERVE, {
                fn: runObserverEffect,
                info,
                trigger: {
                    name: property
                }
            });
            if (dynamicFn) this._addPropertyEffect(method, TYPES.OBSERVE, {
                fn: runObserverEffect,
                info,
                trigger: {
                    name: method
                }
            });
        }
        /**
     * Equivalent to static `createMethodObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */ _createMethodObserver(expression, dynamicFn) {
            let sig = parseMethod(expression);
            if (!sig) throw new Error("Malformed observer expression '" + expression + "'");
            createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
        }
        /**
     * Equivalent to static `createNotifyingProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     */ _createNotifyingProperty(property) {
            this._addPropertyEffect(property, TYPES.NOTIFY, {
                fn: runNotifyEffect,
                info: {
                    eventName: _caseMapJs.camelToDashCase(property) + '-changed',
                    property: property
                }
            });
        }
        /**
     * Equivalent to static `createReflectedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */ _createReflectedProperty(property) {
            let attr = this.constructor.attributeNameForProperty(property);
            if (attr[0] === '-') console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');
            else this._addPropertyEffect(property, TYPES.REFLECT, {
                fn: runReflectEffect,
                info: {
                    attrName: attr
                }
            });
        }
        /**
     * Equivalent to static `createComputedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */ _createComputedProperty(property, expression, dynamicFn) {
            let sig = parseMethod(expression);
            if (!sig) throw new Error("Malformed computed expression '" + expression + "'");
            const info = createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
            // Effects are normally stored as map of dependency->effect, but for
            // ordered computation, we also need tree of computedProp->dependencies
            ensureOwnEffectMap(this, COMPUTE_INFO)[property] = info;
        }
        /**
     * Gather the argument values for a method specified in the provided array
     * of argument metadata.
     *
     * The `path` and `value` arguments are used to fill in wildcard descriptor
     * when the method is being called as a result of a path notification.
     *
     * @param {!Array<!MethodArg>} args Array of argument metadata
     * @param {string} path Property/path name that triggered the method effect
     * @param {Object} props Bag of current property changes
     * @return {!Array<*>} Array of argument values
     * @private
     */ _marshalArgs(args, path, props) {
            const data = this.__data;
            const values = [];
            for(let i = 0, l = args.length; i < l; i++){
                let { name , structured , wildcard , value , literal  } = args[i];
                if (!literal) {
                    if (wildcard) {
                        const matches = _pathJs.isDescendant(name, path);
                        const pathValue = getArgValue(data, props, matches ? path : name);
                        value = {
                            path: matches ? path : name,
                            value: pathValue,
                            base: matches ? _pathJs.get(data, name) : pathValue
                        };
                    } else value = structured ? getArgValue(data, props, name) : data[name];
                }
                // When the `legacyUndefined` flag is enabled, pass a no-op value
                // so that the observer, computed property, or compound binding is aborted.
                if (_settingsJs.legacyUndefined && !this._overrideLegacyUndefined && value === undefined && args.length > 1) return NOOP;
                values[i] = value;
            }
            return values;
        }
        // -- static class methods ------------
        /**
     * Ensures an accessor exists for the specified property, and adds
     * to a list of "property effects" that will run when the accessor for
     * the specified property is set.  Effects are grouped by "type", which
     * roughly corresponds to a phase in effect processing.  The effect
     * metadata should be in the following form:
     *
     *     {
     *       fn: effectFunction, // Reference to function to call to perform effect
     *       info: { ... }       // Effect metadata passed to function
     *       trigger: {          // Optional triggering metadata; if not provided
     *         name: string      // the property is treated as a wildcard
     *         structured: boolean
     *         wildcard: boolean
     *       }
     *     }
     *
     * Effects are called from `_propertiesChanged` in the following order by
     * type:
     *
     * 1. COMPUTE
     * 2. PROPAGATE
     * 3. REFLECT
     * 4. OBSERVE
     * 5. NOTIFY
     *
     * Effect functions are called with the following signature:
     *
     *     effectFunction(inst, path, props, oldProps, info, hasPaths)
     *
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @nocollapse
     */ static addPropertyEffect(property, type, effect) {
            this.prototype._addPropertyEffect(property, type, effect);
        }
        /**
     * Creates a single-property observer for the given property.
     *
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     * @nocollapse
     */ static createPropertyObserver(property, method, dynamicFn) {
            this.prototype._createPropertyObserver(property, method, dynamicFn);
        }
        /**
     * Creates a multi-property "method observer" based on the provided
     * expression, which should be a string in the form of a normal JavaScript
     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
     * should correspond to a property or path in the context of this
     * prototype (or instance), or may be a literal string or number.
     *
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     * @return {void}
     *   whether method names should be included as a dependency to the effect.
     * @protected
     * @nocollapse
     */ static createMethodObserver(expression, dynamicFn) {
            this.prototype._createMethodObserver(expression, dynamicFn);
        }
        /**
     * Causes the setter for the given property to dispatch `<property>-changed`
     * events to notify of changes to the property.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @nocollapse
     */ static createNotifyingProperty(property) {
            this.prototype._createNotifyingProperty(property);
        }
        /**
     * Creates a read-only accessor for the given property.
     *
     * To set the property, use the protected `_setProperty` API.
     * To create a custom protected setter (e.g. `_setMyProp()` for
     * property `myProp`), pass `true` for `protectedSetter`.
     *
     * Note, if the property will have other property effects, this method
     * should be called first, before adding other effects.
     *
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     * @nocollapse
     */ static createReadOnlyProperty(property, protectedSetter) {
            this.prototype._createReadOnlyProperty(property, protectedSetter);
        }
        /**
     * Causes the setter for the given property to reflect the property value
     * to a (dash-cased) attribute of the same name.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @nocollapse
     */ static createReflectedProperty(property) {
            this.prototype._createReflectedProperty(property);
        }
        /**
     * Creates a computed property whose value is set to the result of the
     * method described by the given `expression` each time one or more
     * arguments to the method changes.  The expression should be a string
     * in the form of a normal JavaScript function signature:
     * `'methodName(arg1, [..., argn])'`
     *
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
     *   method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     * @nocollapse
     */ static createComputedProperty(property, expression, dynamicFn) {
            this.prototype._createComputedProperty(property, expression, dynamicFn);
        }
        /**
     * Parses the provided template to ensure binding effects are created
     * for them, and then ensures property accessors are created for any
     * dependent properties in the template.  Binding effects for bound
     * templates are stored in a linked list on the instance so that
     * templates can be efficiently stamped and unstamped.
     *
     * @param {!HTMLTemplateElement} template Template containing binding
     *   bindings
     * @return {!TemplateInfo} Template metadata object
     * @protected
     * @nocollapse
     */ static bindTemplate(template) {
            return this.prototype._bindTemplate(template);
        }
        // -- binding ----------------------------------------------
        /*
     * Overview of binding flow:
     *
     * During finalization (`instanceBinding==false`, `wasPreBound==false`):
     *  `_bindTemplate(t, false)` called directly during finalization - parses
     *  the template (for the first time), and then assigns that _prototypical_
     *  template info to `__preboundTemplateInfo` _on the prototype_; note in
     *  this case `wasPreBound` is false; this is the first time we're binding
     *  it, thus we create accessors.
     *
     * During first stamping (`instanceBinding==true`, `wasPreBound==true`):
     *   `_stampTemplate` calls `_bindTemplate(t, true)`: the `templateInfo`
     *   returned matches the prebound one, and so this is `wasPreBound == true`
     *   state; thus we _skip_ creating accessors, but _do_ create an instance
     *   of the template info to serve as the start of our linked list (needs to
     *   be an instance, not the prototypical one, so that we can add `nodeList`
     *   to it to contain the `nodeInfo`-ordered list of instance nodes for
     *   bindings, and so we can chain runtime-stamped template infos off of
     *   it). At this point, the call to `_stampTemplate` calls
     *   `applyTemplateInfo` for each nested `<template>` found during parsing
     *   to hand prototypical `_templateInfo` to them; we also pass the _parent_
     *   `templateInfo` to the `<template>` so that we have the instance-time
     *   parent to link the `templateInfo` under in the case it was
     *   runtime-stamped.
     *
     * During subsequent runtime stamping (`instanceBinding==true`,
     *   `wasPreBound==false`): `_stampTemplate` calls `_bindTemplate(t, true)`
     *   - here `templateInfo` is guaranteed to _not_ match the prebound one,
     *   because it was either a different template altogether, or even if it
     *   was the same template, the step above created a instance of the info;
     *   in this case `wasPreBound == false`, so we _do_ create accessors, _and_
     *   link a instance into the linked list.
     */ /**
     * Equivalent to static `bindTemplate` API but can be called on an instance
     * to add effects at runtime.  See that method for full API docs.
     *
     * This method may be called on the prototype (for prototypical template
     * binding, to avoid creating accessors every instance) once per prototype,
     * and will be called with `runtimeBinding: true` by `_stampTemplate` to
     * create and link an instance of the template metadata associated with a
     * particular stamping.
     *
     * @override
     * @param {!HTMLTemplateElement} template Template containing binding
     * bindings
     * @param {boolean=} instanceBinding When false (default), performs
     * "prototypical" binding of the template and overwrites any previously
     * bound template for the class. When true (as passed from
     * `_stampTemplate`), the template info is instanced and linked into the
     * list of bound templates.
     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
     * this is an instance of the prototypical template info
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */ _bindTemplate(template, instanceBinding) {
            let templateInfo = this.constructor._parseTemplate(template);
            let wasPreBound = this.__preBoundTemplateInfo == templateInfo;
            // Optimization: since this is called twice for proto-bound templates,
            // don't attempt to recreate accessors if this template was pre-bound
            if (!wasPreBound) for(let prop in templateInfo.propertyEffects)this._createPropertyAccessor(prop);
            if (instanceBinding) {
                // For instance-time binding, create instance of template metadata
                // and link into tree of templates if necessary
                templateInfo = Object.create(templateInfo);
                templateInfo.wasPreBound = wasPreBound;
                if (!this.__templateInfo) // Set the info to the root of the tree
                this.__templateInfo = templateInfo;
                else {
                    // Append this template info onto the end of its parent template's
                    // list, which will determine the tree structure via which property
                    // effects are run; if this template was not nested in another
                    // template, use the root template (the first stamped one) as the
                    // parent. Note, `parent` is the `templateInfo` instance for this
                    // template's parent (containing) template, which was set up in
                    // `applyTemplateInfo`.  While a given template's `parent` is set
                    // apriori, it is only added to the parent's child list at the point
                    // that it is being bound, since a template may or may not ever be
                    // stamped, and may be stamped more than once (in which case instances
                    // of the template info will be in the tree under its parent more than
                    // once).
                    const parent = template._parentTemplateInfo || this.__templateInfo;
                    const previous = parent.lastChild;
                    templateInfo.parent = parent;
                    parent.lastChild = templateInfo;
                    templateInfo.previousSibling = previous;
                    if (previous) previous.nextSibling = templateInfo;
                    else parent.firstChild = templateInfo;
                }
            } else this.__preBoundTemplateInfo = templateInfo;
            return templateInfo;
        }
        /**
     * Adds a property effect to the given template metadata, which is run
     * at the "propagate" stage of `_propertiesChanged` when the template
     * has been bound to the element via `_bindTemplate`.
     *
     * The `effect` object should match the format in `_addPropertyEffect`.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @nocollapse
     */ static _addTemplatePropertyEffect(templateInfo, prop, effect) {
            let hostProps = templateInfo.hostProps = templateInfo.hostProps || {
            };
            hostProps[prop] = true;
            let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {
            };
            let propEffects = effects[prop] = effects[prop] || [];
            propEffects.push(effect);
        }
        /**
     * Stamps the provided template and performs instance-time setup for
     * Polymer template features, including data bindings, declarative event
     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
     * is returned containing the stamped DOM, ready for insertion into the
     * DOM.
     *
     * This method may be called more than once; however note that due to
     * `shadycss` polyfill limitations, only styles from templates prepared
     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
     * to the shadow root and support CSS custom properties), and note that
     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
     * any styles required by in runtime-stamped templates must be included
     * in the main element template.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @param {TemplateInfo=} templateInfo Optional bound template info associated
     *   with the template to be stamped; if omitted the template will be
     *   automatically bound.
     * @return {!StampedTemplate} Cloned template content
     * @override
     * @protected
     */ _stampTemplate(template, templateInfo) {
            templateInfo = templateInfo || this._bindTemplate(template, true);
            // Ensures that created dom is `_enqueueClient`'d to this element so
            // that it can be flushed on next call to `_flushProperties`
            hostStack.push(this);
            let dom = super._stampTemplate(template, templateInfo);
            hostStack.pop();
            // Add template-instance-specific data to instanced templateInfo
            templateInfo.nodeList = dom.nodeList;
            // Capture child nodes to allow unstamping of non-prototypical templates
            if (!templateInfo.wasPreBound) {
                let nodes = templateInfo.childNodes = [];
                for(let n = dom.firstChild; n; n = n.nextSibling)nodes.push(n);
            }
            dom.templateInfo = templateInfo;
            // Setup compound storage, 2-way listeners, and dataHost for bindings
            setupBindings(this, templateInfo);
            // Flush properties into template nodes; the check on `__dataClientsReady`
            // ensures we don't needlessly run effects for an element's initial
            // prototypical template stamping since they will happen as a part of the
            // first call to `_propertiesChanged`. This flag is set to true
            // after running the initial propagate effects, and immediately before
            // flushing clients. Since downstream clients could cause stamping on
            // this host (e.g. a fastDomIf `dom-if` being forced to render
            // synchronously), this flag ensures effects for runtime-stamped templates
            // are run at this point during the initial element boot-up.
            if (this.__dataClientsReady) {
                this._runEffectsForTemplate(templateInfo, this.__data, null, false);
                this._flushClients();
            }
            return dom;
        }
        /**
     * Removes and unbinds the nodes previously contained in the provided
     * DocumentFragment returned from `_stampTemplate`.
     *
     * @override
     * @param {!StampedTemplate} dom DocumentFragment previously returned
     *   from `_stampTemplate` associated with the nodes to be removed
     * @return {void}
     * @protected
     */ _removeBoundDom(dom) {
            // Unlink template info; Note that while the child is unlinked from its
            // parent list, a template's `parent` reference is never removed, since
            // this is is determined by the tree structure and applied at
            // `applyTemplateInfo` time.
            const templateInfo = dom.templateInfo;
            const { previousSibling , nextSibling , parent  } = templateInfo;
            if (previousSibling) previousSibling.nextSibling = nextSibling;
            else if (parent) parent.firstChild = nextSibling;
            if (nextSibling) nextSibling.previousSibling = previousSibling;
            else if (parent) parent.lastChild = previousSibling;
            templateInfo.nextSibling = templateInfo.previousSibling = null;
            // Remove stamped nodes
            let nodes = templateInfo.childNodes;
            for(let i = 0; i < nodes.length; i++){
                let node = nodes[i];
                _wrapJs.wrap(_wrapJs.wrap(node).parentNode).removeChild(node);
            }
        }
        /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */ static _parseTemplateNode(node, templateInfo, nodeInfo) {
            // TODO(https://github.com/google/closure-compiler/issues/3240):
            //     Change back to just super.methodCall()
            let noted = propertyEffectsBase._parseTemplateNode.call(this, node, templateInfo, nodeInfo);
            if (node.nodeType === Node.TEXT_NODE) {
                let parts = this._parseBindings(node.textContent, templateInfo);
                if (parts) {
                    // Initialize the textContent with any literal parts
                    // NOTE: default to a space here so the textNode remains; some browsers
                    // (IE) omit an empty textNode following cloneNode/importNode.
                    node.textContent = literalFromParts(parts) || ' ';
                    addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
                    noted = true;
                }
            }
            return noted;
        }
        /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from attributes.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @param {string} name Attribute name
     * @param {string} value Attribute value
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */ static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
            let parts = this._parseBindings(value, templateInfo);
            if (parts) {
                // Attribute or property
                let origName = name;
                let kind = 'property';
                // The only way we see a capital letter here is if the attr has
                // a capital letter in it per spec. In this case, to make sure
                // this binding works, we go ahead and make the binding to the attribute.
                if (capitalAttributeRegex.test(name)) kind = 'attribute';
                else if (name[name.length - 1] == '$') {
                    name = name.slice(0, -1);
                    kind = 'attribute';
                }
                // Initialize attribute bindings with any literal parts
                let literal = literalFromParts(parts);
                if (literal && kind == 'attribute') {
                    // Ensure a ShadyCSS template scoped style is not removed
                    // when a class$ binding's initial literal value is set.
                    if (name == 'class' && node.hasAttribute('class')) literal += ' ' + node.getAttribute(name);
                    node.setAttribute(name, literal);
                }
                // support disable-upgrade
                if (kind == 'attribute' && origName == 'disable-upgrade$') node.setAttribute(name, '');
                // Clear attribute before removing, since IE won't allow removing
                // `value` attribute if it previously had a value (can't
                // unconditionally set '' before removing since attributes with `$`
                // can't be set using setAttribute)
                if (node.localName === 'input' && origName === 'value') node.setAttribute(origName, '');
                // Remove annotation
                node.removeAttribute(origName);
                // Case hackery: attributes are lower-case, but bind targets
                // (properties) are case sensitive. Gambit is to map dash-case to
                // camel-case: `foo-bar` becomes `fooBar`.
                // Attribute bindings are excepted.
                if (kind === 'property') name = _caseMapJs.dashToCamelCase(name);
                addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
                return true;
            } else // TODO(https://github.com/google/closure-compiler/issues/3240):
            //     Change back to just super.methodCall()
            return propertyEffectsBase._parseTemplateNodeAttribute.call(this, node, templateInfo, nodeInfo, name, value);
        }
        /**
     * Overrides default `TemplateStamp` implementation to add support for
     * binding the properties that a nested template depends on to the template
     * as `_host_<property>`.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */ static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
            // TODO(https://github.com/google/closure-compiler/issues/3240):
            //     Change back to just super.methodCall()
            let noted = propertyEffectsBase._parseTemplateNestedTemplate.call(this, node, templateInfo, nodeInfo);
            const parent = node.parentNode;
            const nestedTemplateInfo = nodeInfo.templateInfo;
            const isDomIf = parent.localName === 'dom-if';
            const isDomRepeat = parent.localName === 'dom-repeat';
            // Remove nested template and redirect its host bindings & templateInfo
            // onto the parent (dom-if/repeat element)'s nodeInfo
            if (_settingsJs.removeNestedTemplates && (isDomIf || isDomRepeat)) {
                parent.removeChild(node);
                // Use the parent's nodeInfo (for the dom-if/repeat) to record the
                // templateInfo, and use that for any host property bindings below
                nodeInfo = nodeInfo.parentInfo;
                nodeInfo.templateInfo = nestedTemplateInfo;
                // Ensure the parent dom-if/repeat is noted since it now may have host
                // bindings; it may not have been if it did not have its own bindings
                nodeInfo.noted = true;
                noted = false;
            }
            // Merge host props into outer template and add bindings
            let hostProps = nestedTemplateInfo.hostProps;
            if (_settingsJs.fastDomIf && isDomIf) // `fastDomIf` mode uses runtime-template stamping to add accessors/
            // effects to properties used in its template; as such we don't need to
            // tax the host element with `_host_` bindings for the `dom-if`.
            // However, in the event it is nested in a `dom-repeat`, it is still
            // important that its host properties are added to the
            // TemplateInstance's `hostProps` so that they are forwarded to the
            // TemplateInstance.
            {
                if (hostProps) {
                    templateInfo.hostProps = Object.assign(templateInfo.hostProps || {
                    }, hostProps);
                    // Ensure the dom-if is noted so that it has a __dataHost, since
                    // `fastDomIf` uses the host for runtime template stamping; note this
                    // was already ensured above in the `removeNestedTemplates` case
                    if (!_settingsJs.removeNestedTemplates) nodeInfo.parentInfo.noted = true;
                }
            } else {
                let mode = '{';
                for(let source in hostProps){
                    let parts = [
                        {
                            mode,
                            source,
                            dependencies: [
                                source
                            ],
                            hostProp: true
                        }
                    ];
                    addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
                }
            }
            return noted;
        }
        /**
     * Called to parse text in a template (either attribute values or
     * textContent) into binding metadata.
     *
     * Any overrides of this method should return an array of binding part
     * metadata  representing one or more bindings found in the provided text
     * and any "literal" text in between.  Any non-literal parts will be passed
     * to `_evaluateBinding` when any dependencies change.  The only required
     * fields of each "part" in the returned array are as follows:
     *
     * - `dependencies` - Array containing trigger metadata for each property
     *   that should trigger the binding to update
     * - `literal` - String containing text if the part represents a literal;
     *   in this case no `dependencies` are needed
     *
     * Additional metadata for use by `_evaluateBinding` may be provided in
     * each part object as needed.
     *
     * The default implementation handles the following types of bindings
     * (one or more may be intermixed with literal strings):
     * - Property binding: `[[prop]]`
     * - Path binding: `[[object.prop]]`
     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
     * - Two-way property or path bindings (supports negation):
     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
     * - Inline computed method (supports negation):
     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
     *
     * The default implementation uses a regular expression for best
     * performance. However, the regular expression uses a white-list of
     * allowed characters in a data-binding, which causes problems for
     * data-bindings that do use characters not in this white-list.
     *
     * Instead of updating the white-list with all allowed characters,
     * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)
     * that uses a state machine instead. This state machine is able to handle
     * all characters. However, it is slightly less performant, therefore we
     * extracted it into a separate optional mixin.
     *
     * @param {string} text Text to parse from attribute or textContent
     * @param {Object} templateInfo Current template metadata
     * @return {Array<!BindingPart>} Array of binding part metadata
     * @protected
     * @nocollapse
     */ static _parseBindings(text, templateInfo) {
            let parts = [];
            let lastIndex = 0;
            let m;
            // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
            // Regex matches:
            //        Iteration 1:  Iteration 2:
            // m[1]: '{{'          '[['
            // m[2]: ''            '!'
            // m[3]: 'prop'        'compute(foo,bar)'
            while((m = bindingRegex.exec(text)) !== null){
                // Add literal part
                if (m.index > lastIndex) parts.push({
                    literal: text.slice(lastIndex, m.index)
                });
                // Add binding part
                let mode = m[1][0];
                let negate = Boolean(m[2]);
                let source = m[3].trim();
                let customEvent = false, notifyEvent = '', colon = -1;
                if (mode == '{' && (colon = source.indexOf('::')) > 0) {
                    notifyEvent = source.substring(colon + 2);
                    source = source.substring(0, colon);
                    customEvent = true;
                }
                let signature = parseMethod(source);
                let dependencies = [];
                if (signature) {
                    // Inline computed function
                    let { args , methodName  } = signature;
                    for(let i = 0; i < args.length; i++){
                        let arg = args[i];
                        if (!arg.literal) dependencies.push(arg);
                    }
                    let dynamicFns = templateInfo.dynamicFns;
                    if (dynamicFns && dynamicFns[methodName] || signature.static) {
                        dependencies.push(methodName);
                        signature.dynamicFn = true;
                    }
                } else // Property or path
                dependencies.push(source);
                parts.push({
                    source,
                    mode,
                    negate,
                    customEvent,
                    signature,
                    dependencies,
                    event: notifyEvent
                });
                lastIndex = bindingRegex.lastIndex;
            }
            // Add a final literal part
            if (lastIndex && lastIndex < text.length) {
                let literal = text.substring(lastIndex);
                if (literal) parts.push({
                    literal: literal
                });
            }
            if (parts.length) return parts;
            else return null;
        }
        /**
     * Called to evaluate a previously parsed binding part based on a set of
     * one or more changed dependencies.
     *
     * @param {!Polymer_PropertyEffects} inst Element that should be used as
     *     scope for binding dependencies
     * @param {BindingPart} part Binding part metadata
     * @param {string} path Property/path that triggered this effect
     * @param {Object} props Bag of current property changes
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {*} Value the binding part evaluated to
     * @protected
     * @nocollapse
     */ static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
            let value;
            if (part.signature) value = runMethodEffect(inst, path, props, oldProps, part.signature);
            else if (path != part.source) value = _pathJs.get(inst, part.source);
            else if (hasPaths && _pathJs.isPath(path)) value = _pathJs.get(inst, path);
            else value = inst.__data[path];
            if (part.negate) value = !value;
            return value;
        }
    }
    return PropertyEffects1;
});
/**
 * Stack for enqueuing client dom created by a host element.
 *
 * By default elements are flushed via `_flushProperties` when
 * `connectedCallback` is called. Elements attach their client dom to
 * themselves at `ready` time which results from this first flush.
 * This provides an ordering guarantee that the client dom an element
 * creates is flushed before the element itself (i.e. client `ready`
 * fires before host `ready`).
 *
 * However, if `_flushProperties` is called *before* an element is connected,
 * as for example `Templatize` does, this ordering guarantee cannot be
 * satisfied because no elements are connected. (Note: Bound elements that
 * receive data do become enqueued clients and are properly ordered but
 * unbound elements are not.)
 *
 * To maintain the desired "client before host" ordering guarantee for this
 * case we rely on the "host stack. Client nodes registers themselves with
 * the creating host element when created. This ensures that all client dom
 * is readied in the proper order, maintaining the desired guarantee.
 *
 * @private
 */ const hostStack = [];

},{"../utils/boot.js":"gVNgb","../utils/wrap.js":"cQBlD","../utils/mixin.js":"488pD","../utils/path.js":"fr2Rw","../utils/case-map.js":"TAE8x","./property-accessors.js":"3DFbV","./template-stamp.js":"jth3L","../utils/settings.js":"44bo5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cQBlD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "wrap", ()=>wrap
);
const wrap = window['ShadyDOM'] && window['ShadyDOM']['noPatch'] && window['ShadyDOM']['wrap'] ? window['ShadyDOM']['wrap'] : window['ShadyDOM'] ? (n)=>ShadyDOM['patch'](n)
 : (n)=>n
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fr2Rw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Module with utilities for manipulating structured data path strings.
 *
 * @summary Module with utilities for manipulating structured data path strings.
 */ /**
 * Returns true if the given string is a structured data path (has dots).
 *
 * Example:
 *
 * ```
 * isPath('foo.bar.baz') // true
 * isPath('foo')         // false
 * ```
 *
 * @param {string} path Path string
 * @return {boolean} True if the string contained one or more dots
 */ parcelHelpers.export(exports, "isPath", ()=>isPath
);
/**
 * Returns the root property name for the given path.
 *
 * Example:
 *
 * ```
 * root('foo.bar.baz') // 'foo'
 * root('foo')         // 'foo'
 * ```
 *
 * @param {string} path Path string
 * @return {string} Root property name
 */ parcelHelpers.export(exports, "root", ()=>root
);
/**
 * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not
 * Returns true if the given path is an ancestor of the base path.
 *
 * Example:
 *
 * ```
 * isAncestor('foo.bar', 'foo')         // true
 * isAncestor('foo.bar', 'foo.bar')     // false
 * isAncestor('foo.bar', 'foo.bar.baz') // false
 * ```
 *
 * @param {string} base Path string to test against.
 * @param {string} path Path string to test.
 * @return {boolean} True if `path` is an ancestor of `base`.
 */ parcelHelpers.export(exports, "isAncestor", ()=>isAncestor
);
/**
 * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant
 *
 * Example:
 *
 * ```
 * isDescendant('foo.bar', 'foo.bar.baz') // true
 * isDescendant('foo.bar', 'foo.bar')     // false
 * isDescendant('foo.bar', 'foo')         // false
 * ```
 *
 * @param {string} base Path string to test against.
 * @param {string} path Path string to test.
 * @return {boolean} True if `path` is a descendant of `base`.
 */ parcelHelpers.export(exports, "isDescendant", ()=>isDescendant
);
/**
 * Replaces a previous base path with a new base path, preserving the
 * remainder of the path.
 *
 * User must ensure `path` has a prefix of `base`.
 *
 * Example:
 *
 * ```
 * translate('foo.bar', 'zot', 'foo.bar.baz') // 'zot.baz'
 * ```
 *
 * @param {string} base Current base string to remove
 * @param {string} newBase New base string to replace with
 * @param {string} path Path to translate
 * @return {string} Translated string
 */ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * @param {string} base Path string to test against
 * @param {string} path Path string to test
 * @return {boolean} True if `path` is equal to `base`
 */ parcelHelpers.export(exports, "matches", ()=>matches
);
/**
 * Converts array-based paths to flattened path.  String-based paths
 * are returned as-is.
 *
 * Example:
 *
 * ```
 * normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'
 * normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'
 * ```
 *
 * @param {string | !Array<string|number>} path Input path
 * @return {string} Flattened path
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * Splits a path into an array of property names. Accepts either arrays
 * of path parts or strings.
 *
 * Example:
 *
 * ```
 * split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']
 * split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']
 * ```
 *
 * @param {string | !Array<string|number>} path Input path
 * @return {!Array<string>} Array of path parts
 * @suppress {checkTypes}
 */ parcelHelpers.export(exports, "split", ()=>split
);
/**
 * Reads a value from a path.  If any sub-property in the path is `undefined`,
 * this method returns `undefined` (will never throw.
 *
 * @param {Object} root Object from which to dereference path from
 * @param {string | !Array<string|number>} path Path to read
 * @param {Object=} info If an object is provided to `info`, the normalized
 *  (flattened) path will be set to `info.path`.
 * @return {*} Value at path, or `undefined` if the path could not be
 *  fully dereferenced.
 */ parcelHelpers.export(exports, "get", ()=>get
);
/**
 * Sets a value to a path.  If any sub-property in the path is `undefined`,
 * this method will no-op.
 *
 * @param {Object} root Object from which to dereference path from
 * @param {string | !Array<string|number>} path Path to set
 * @param {*} value Value to set to path
 * @return {string | undefined} The normalized version of the input path
 */ parcelHelpers.export(exports, "set", ()=>set
);
parcelHelpers.export(exports, "isDeep", ()=>isDeep
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("./boot.js");
function isPath(path) {
    return path.indexOf('.') >= 0;
}
function root(path) {
    let dotIndex = path.indexOf('.');
    if (dotIndex === -1) return path;
    return path.slice(0, dotIndex);
}
function isAncestor(base, path) {
    //     base.startsWith(path + '.');
    return base.indexOf(path + '.') === 0;
}
function isDescendant(base, path) {
    //     path.startsWith(base + '.');
    return path.indexOf(base + '.') === 0;
}
function translate(base, newBase, path) {
    return newBase + path.slice(base.length);
}
function matches(base, path) {
    return base === path || isAncestor(base, path) || isDescendant(base, path);
}
function normalize(path) {
    if (Array.isArray(path)) {
        let parts = [];
        for(let i = 0; i < path.length; i++){
            let args = path[i].toString().split('.');
            for(let j = 0; j < args.length; j++)parts.push(args[j]);
        }
        return parts.join('.');
    } else return path;
}
function split(path) {
    if (Array.isArray(path)) return normalize(path).split('.');
    return path.toString().split('.');
}
function get(root1, path, info) {
    let prop = root1;
    let parts = split(path);
    // Loop over path parts[0..n-1] and dereference
    for(let i = 0; i < parts.length; i++){
        if (!prop) return;
        let part = parts[i];
        prop = prop[part];
    }
    if (info) info.path = parts.join('.');
    return prop;
}
function set(root2, path, value) {
    let prop = root2;
    let parts = split(path);
    let last = parts[parts.length - 1];
    if (parts.length > 1) {
        // Loop over path parts[0..n-2] and dereference
        for(let i = 0; i < parts.length - 1; i++){
            let part = parts[i];
            prop = prop[part];
            if (!prop) return;
        }
        // Set value to object at end of path
        prop[last] = value;
    } else // Simple property set
    prop[path] = value;
    return parts.join('.');
}
const isDeep = isPath;

},{"./boot.js":"gVNgb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"TAE8x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @fileoverview Module with utilities for converting between "dash-case" and
 * "camelCase" identifiers.
 */ /**
 * Converts "dash-case" identifier (e.g. `foo-bar-baz`) to "camelCase"
 * (e.g. `fooBarBaz`).
 *
 * @param {string} dash Dash-case identifier
 * @return {string} Camel-case representation of the identifier
 */ parcelHelpers.export(exports, "dashToCamelCase", ()=>dashToCamelCase
);
/**
 * Converts "camelCase" identifier (e.g. `fooBarBaz`) to "dash-case"
 * (e.g. `foo-bar-baz`).
 *
 * @param {string} camel Camel-case identifier
 * @return {string} Dash-case representation of the identifier
 */ parcelHelpers.export(exports, "camelToDashCase", ()=>camelToDashCase
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("./boot.js");
const caseMap = {
};
const DASH_TO_CAMEL = /-[a-z]/g;
const CAMEL_TO_DASH = /([A-Z])/g;
function dashToCamelCase(dash) {
    return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, (m)=>m[1].toUpperCase()
    ));
}
function camelToDashCase(camel) {
    return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());
}

},{"./boot.js":"gVNgb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3DFbV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PropertyAccessors", ()=>PropertyAccessors
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("../utils/boot.js");
var _mixinJs = require("../utils/mixin.js");
var _caseMapJs = require("../utils/case-map.js");
var _propertiesChangedJs = require("./properties-changed.js");
// Save map of native properties; this forms a blacklist or properties
// that won't have their values "saved" by `saveAccessorValue`, since
// reading from an HTMLElement accessor from the context of a prototype throws
const nativeProperties = {
};
let proto = HTMLElement.prototype;
while(proto){
    let props = Object.getOwnPropertyNames(proto);
    for(let i = 0; i < props.length; i++)nativeProperties[props[i]] = true;
    proto = Object.getPrototypeOf(proto);
}
const isTrustedType = (()=>{
    if (!window.trustedTypes) return ()=>false
    ;
    return (val)=>trustedTypes.isHTML(val) || trustedTypes.isScript(val) || trustedTypes.isScriptURL(val)
    ;
})();
/**
 * Used to save the value of a property that will be overridden with
 * an accessor. If the `model` is a prototype, the values will be saved
 * in `__dataProto`, and it's up to the user (or downstream mixin) to
 * decide how/when to set these values back into the accessors.
 * If `model` is already an instance (it has a `__data` property), then
 * the value will be set as a pending property, meaning the user should
 * call `_invalidateProperties` or `_flushProperties` to take effect
 *
 * @param {Object} model Prototype or instance
 * @param {string} property Name of property
 * @return {void}
 * @private
 */ function saveAccessorValue(model, property) {
    // Don't read/store value for any native properties since they could throw
    if (!nativeProperties[property]) {
        let value = model[property];
        if (value !== undefined) {
            if (model.__data) // Adding accessor to instance; update the property
            // It is the user's responsibility to call _flushProperties
            model._setPendingProperty(property, value);
            else {
                // Adding accessor to proto; save proto's value for instance-time use
                if (!model.__dataProto) model.__dataProto = {
                };
                else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) model.__dataProto = Object.create(model.__dataProto);
                model.__dataProto[property] = value;
            }
        }
    }
}
const PropertyAccessors = _mixinJs.dedupingMixin((superClass)=>{
    /**
   * @constructor
   * @implements {Polymer_PropertiesChanged}
   * @unrestricted
   * @private
   */ const base = _propertiesChangedJs.PropertiesChanged(superClass);
    /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyAccessors}
   * @extends {base}
   * @unrestricted
   */ class PropertyAccessors1 extends base {
        /**
     * Generates property accessors for all attributes in the standard
     * static `observedAttributes` array.
     *
     * Attribute names are mapped to property names using the `dash-case` to
     * `camelCase` convention
     *
     * @return {void}
     * @nocollapse
     */ static createPropertiesForAttributes() {
            let a$ = /** @type {?} */ this.observedAttributes;
            for(let i = 0; i < a$.length; i++)this.prototype._createPropertyAccessor(_caseMapJs.dashToCamelCase(a$[i]));
        }
        /**
     * Returns an attribute name that corresponds to the given property.
     * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.
     * @param {string} property Property to convert
     * @return {string} Attribute name corresponding to the given property.
     *
     * @protected
     * @nocollapse
     */ static attributeNameForProperty(property) {
            return _caseMapJs.camelToDashCase(property);
        }
        /**
     * Overrides PropertiesChanged implementation to initialize values for
     * accessors created for values that already existed on the element
     * prototype.
     *
     * @return {void}
     * @protected
     * @override
     */ _initializeProperties() {
            if (this.__dataProto) {
                this._initializeProtoProperties(this.__dataProto);
                this.__dataProto = null;
            }
            super._initializeProperties();
        }
        /**
     * Called at instance time with bag of properties that were overwritten
     * by accessors on the prototype when accessors were created.
     *
     * The default implementation sets these properties back into the
     * setter at instance time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @return {void}
     * @protected
     * @override
     */ _initializeProtoProperties(props) {
            for(let p in props)this._setProperty(p, props[p]);
        }
        /**
     * Ensures the element has the given attribute. If it does not,
     * assigns the given value to the attribute.
     *
     * @suppress {invalidCasts} Closure can't figure out `this` is infact an
     *     element
     *
     * @param {string} attribute Name of attribute to ensure is set.
     * @param {string} value of the attribute.
     * @return {void}
     * @override
     */ _ensureAttribute(attribute, value) {
            const el = this;
            if (!el.hasAttribute(attribute)) this._valueToNodeAttribute(el, value, attribute);
        }
        /**
     * Overrides PropertiesChanged implemention to serialize objects as JSON.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided property
     *     value.
     * @override
     */ _serializeValue(value) {
            /* eslint-disable no-fallthrough */ switch(typeof value){
                case 'object':
                    if (value instanceof Date) return value.toString();
                    else if (value) {
                        if (isTrustedType(value)) /**
               * Here `value` isn't actually a string, but it should be
               * passed into APIs that normally expect a string, like
               * elem.setAttribute.
               */ return value;
                        try {
                            return JSON.stringify(value);
                        } catch (x) {
                            return '';
                        }
                    }
                default:
                    return super._serializeValue(value);
            }
        }
        /**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called by Polymer when reading HTML attribute values to
     * JS properties.  Users may override this method on Polymer element
     * prototypes to provide deserialization for custom `type`s.  Note,
     * the `type` argument is the value of the `type` field provided in the
     * `properties` configuration object for a given property, and is
     * by convention the constructor for the type to deserialize.
     *
     *
     * @param {?string} value Attribute value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     * @override
     */ _deserializeValue(value, type) {
            /**
       * @type {*}
       */ let outValue;
            switch(type){
                case Object:
                    try {
                        outValue = JSON.parse(value);
                    } catch (x) {
                        // allow non-JSON literals like Strings and Numbers
                        outValue = value;
                    }
                    break;
                case Array:
                    try {
                        outValue = JSON.parse(value);
                    } catch (x1) {
                        outValue = null;
                        console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);
                    }
                    break;
                case Date:
                    outValue = isNaN(value) ? String(value) : Number(value);
                    outValue = new Date(outValue);
                    break;
                default:
                    outValue = super._deserializeValue(value, type);
                    break;
            }
            return outValue;
        }
        /* eslint-enable no-fallthrough */ /**
     * Overrides PropertiesChanged implementation to save existing prototype
     * property value so that it can be reset.
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created
     *
     * When calling on a prototype, any overwritten values are saved in
     * `__dataProto`, and it is up to the subclasser to decide how/when
     * to set those properties back into the accessor.  When calling on an
     * instance, the overwritten value is set via `_setPendingProperty`,
     * and the user should call `_invalidateProperties` or `_flushProperties`
     * for the values to take effect.
     * @protected
     * @return {void}
     * @override
     */ _definePropertyAccessor(property, readOnly) {
            saveAccessorValue(this, property);
            super._definePropertyAccessor(property, readOnly);
        }
        /**
     * Returns true if this library created an accessor for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if an accessor was created
     * @override
     */ _hasAccessor(property) {
            return this.__dataHasAccessor && this.__dataHasAccessor[property];
        }
        /**
     * Returns true if the specified property has a pending change.
     *
     * @param {string} prop Property name
     * @return {boolean} True if property has a pending change
     * @protected
     * @override
     */ _isPropertyPending(prop) {
            return Boolean(this.__dataPending && prop in this.__dataPending);
        }
    }
    return PropertyAccessors1;
});

},{"../utils/boot.js":"gVNgb","../utils/mixin.js":"488pD","../utils/case-map.js":"TAE8x","./properties-changed.js":"9P4ox","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9P4ox":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PropertiesChanged", ()=>PropertiesChanged
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("../utils/boot.js");
var _mixinJs = require("../utils/mixin.js");
var _asyncJs = require("../utils/async.js");
var _wrapJs = require("../utils/wrap.js");
/** @const {!AsyncInterface} */ const microtask = _asyncJs.microTask;
const PropertiesChanged = _mixinJs.dedupingMixin(/**
     * @template T
     * @param {function(new:T)} superClass Class to apply mixin to.
     * @return {function(new:T)} superClass with mixin applied.
     */ (superClass)=>{
    /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertiesChanged}
   * @unrestricted
   */ class PropertiesChanged1 extends superClass {
        /**
     * Creates property accessors for the given property names.
     * @param {!Object} props Object whose keys are names of accessors.
     * @return {void}
     * @protected
     * @nocollapse
     */ static createProperties(props) {
            const proto = this.prototype;
            for(let prop in props)// don't stomp an existing accessor
            if (!(prop in proto)) proto._createPropertyAccessor(prop);
        }
        /**
     * Returns an attribute name that corresponds to the given property.
     * The attribute name is the lowercased property name. Override to
     * customize this mapping.
     * @param {string} property Property to convert
     * @return {string} Attribute name corresponding to the given property.
     *
     * @protected
     * @nocollapse
     */ static attributeNameForProperty(property) {
            return property.toLowerCase();
        }
        /**
     * Override point to provide a type to which to deserialize a value to
     * a given property.
     * @param {string} name Name of property
     *
     * @protected
     * @nocollapse
     */ static typeForProperty(name) {
        }
        /**
     * Creates a setter/getter pair for the named property with its own
     * local storage.  The getter returns the value in the local storage,
     * and the setter calls `_setProperty`, which updates the local storage
     * for the property and enqueues a `_propertiesChanged` callback.
     *
     * This method may be called on a prototype or an instance.  Calling
     * this method may overwrite a property value that already exists on
     * the prototype/instance by creating the accessor.
     *
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created; the
     *   protected `_setProperty` function must be used to set the property
     * @return {void}
     * @protected
     * @override
     */ _createPropertyAccessor(property, readOnly) {
            this._addPropertyToAttributeMap(property);
            if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataHasAccessor', this))) this.__dataHasAccessor = Object.assign({
            }, this.__dataHasAccessor);
            if (!this.__dataHasAccessor[property]) {
                this.__dataHasAccessor[property] = true;
                this._definePropertyAccessor(property, readOnly);
            }
        }
        /**
     * Adds the given `property` to a map matching attribute names
     * to property names, using `attributeNameForProperty`. This map is
     * used when deserializing attribute values to properties.
     *
     * @param {string} property Name of the property
     * @override
     */ _addPropertyToAttributeMap(property) {
            if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataAttributes', this))) this.__dataAttributes = Object.assign({
            }, this.__dataAttributes);
            // This check is technically not correct; it's an optimization that
            // assumes that if a _property_ name is already in the map (note this is
            // an attr->property map), the property mapped directly to the attribute
            // and it has already been mapped.  This would fail if
            // `attributeNameForProperty` were overridden such that this was not the
            // case.
            let attr = this.__dataAttributes[property];
            if (!attr) {
                attr = this.constructor.attributeNameForProperty(property);
                this.__dataAttributes[attr] = property;
            }
            return attr;
        }
        /**
     * Defines a property accessor for the given property.
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created
     * @return {void}
     * @override
     */ _definePropertyAccessor(property, readOnly) {
            Object.defineProperty(this, property, {
                /* eslint-disable valid-jsdoc */ /** @this {PropertiesChanged} */ get () {
                    // Inline for perf instead of using `_getProperty`
                    return this.__data[property];
                },
                /** @this {PropertiesChanged} */ set: readOnly ? function() {
                } : function(value) {
                    // Inline for perf instead of using `_setProperty`
                    if (this._setPendingProperty(property, value, true)) this._invalidateProperties();
                }
            });
        }
        constructor(){
            super();
            /** @type {boolean} */ this.__dataEnabled = false;
            this.__dataReady = false;
            this.__dataInvalid = false;
            this.__data = {
            };
            this.__dataPending = null;
            this.__dataOld = null;
            this.__dataInstanceProps = null;
            /** @type {number} */ // NOTE: used to track re-entrant calls to `_flushProperties`
            this.__dataCounter = 0;
            this.__serializing = false;
            this._initializeProperties();
        }
        /**
     * Lifecycle callback called when properties are enabled via
     * `_enableProperties`.
     *
     * Users may override this function to implement behavior that is
     * dependent on the element having its property data initialized, e.g.
     * from defaults (initialized from `constructor`, `_initializeProperties`),
     * `attributeChangedCallback`, or values propagated from host e.g. via
     * bindings.  `super.ready()` must be called to ensure the data system
     * becomes enabled.
     *
     * @return {void}
     * @public
     * @override
     */ ready() {
            this.__dataReady = true;
            this._flushProperties();
        }
        /**
     * Initializes the local storage for property accessors.
     *
     * Provided as an override point for performing any setup work prior
     * to initializing the property accessor system.
     *
     * @return {void}
     * @protected
     * @override
     */ _initializeProperties() {
            // Capture instance properties; these will be set into accessors
            // during first flush. Don't set them here, since we want
            // these to overwrite defaults/constructor assignments
            for(let p in this.__dataHasAccessor)if (this.hasOwnProperty(p)) {
                this.__dataInstanceProps = this.__dataInstanceProps || {
                };
                this.__dataInstanceProps[p] = this[p];
                delete this[p];
            }
        }
        /**
     * Called at ready time with bag of instance properties that overwrote
     * accessors when the element upgraded.
     *
     * The default implementation sets these properties back into the
     * setter at ready time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @return {void}
     * @protected
     * @override
     */ _initializeInstanceProperties(props) {
            Object.assign(this, props);
        }
        /**
     * Updates the local storage for a property (via `_setPendingProperty`)
     * and enqueues a `_proeprtiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {void}
     * @protected
     * @override
     */ _setProperty(property, value) {
            if (this._setPendingProperty(property, value)) this._invalidateProperties();
        }
        /**
     * Returns the value for the given property.
     * @param {string} property Name of property
     * @return {*} Value for the given property
     * @protected
     * @override
     */ _getProperty(property) {
            return this.__data[property];
        }
        /* eslint-disable no-unused-vars */ /**
     * Updates the local storage for a property, records the previous value,
     * and adds it to the set of "pending changes" that will be passed to the
     * `_propertiesChanged` callback.  This method does not enqueue the
     * `_propertiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} ext Not used here; affordance for closure
     * @return {boolean} Returns true if the property changed
     * @protected
     * @override
     */ _setPendingProperty(property, value, ext) {
            let old = this.__data[property];
            let changed = this._shouldPropertyChange(property, value, old);
            if (changed) {
                if (!this.__dataPending) {
                    this.__dataPending = {
                    };
                    this.__dataOld = {
                    };
                }
                // Ensure old is captured from the last turn
                if (this.__dataOld && !(property in this.__dataOld)) this.__dataOld[property] = old;
                this.__data[property] = value;
                this.__dataPending[property] = value;
            }
            return changed;
        }
        /* eslint-enable */ /**
     * @param {string} property Name of the property
     * @return {boolean} Returns true if the property is pending.
     */ _isPropertyPending(property) {
            return !!(this.__dataPending && this.__dataPending.hasOwnProperty(property));
        }
        /**
     * Marks the properties as invalid, and enqueues an async
     * `_propertiesChanged` callback.
     *
     * @return {void}
     * @protected
     * @override
     */ _invalidateProperties() {
            if (!this.__dataInvalid && this.__dataReady) {
                this.__dataInvalid = true;
                microtask.run(()=>{
                    if (this.__dataInvalid) {
                        this.__dataInvalid = false;
                        this._flushProperties();
                    }
                });
            }
        }
        /**
     * Call to enable property accessor processing. Before this method is
     * called accessor values will be set but side effects are
     * queued. When called, any pending side effects occur immediately.
     * For elements, generally `connectedCallback` is a normal spot to do so.
     * It is safe to call this method multiple times as it only turns on
     * property accessors once.
     *
     * @return {void}
     * @protected
     * @override
     */ _enableProperties() {
            if (!this.__dataEnabled) {
                this.__dataEnabled = true;
                if (this.__dataInstanceProps) {
                    this._initializeInstanceProperties(this.__dataInstanceProps);
                    this.__dataInstanceProps = null;
                }
                this.ready();
            }
        }
        /**
     * Calls the `_propertiesChanged` callback with the current set of
     * pending changes (and old values recorded when pending changes were
     * set), and resets the pending set of changes. Generally, this method
     * should not be called in user code.
     *
     * @return {void}
     * @protected
     * @override
     */ _flushProperties() {
            this.__dataCounter++;
            const props = this.__data;
            const changedProps = this.__dataPending;
            const old = this.__dataOld;
            if (this._shouldPropertiesChange(props, changedProps, old)) {
                this.__dataPending = null;
                this.__dataOld = null;
                this._propertiesChanged(props, changedProps, old);
            }
            this.__dataCounter--;
        }
        /**
     * Called in `_flushProperties` to determine if `_propertiesChanged`
     * should be called. The default implementation returns true if
     * properties are pending. Override to customize when
     * `_propertiesChanged` is called.
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {boolean} true if changedProps is truthy
     * @override
     */ _shouldPropertiesChange(currentProps, changedProps, oldProps) {
            return Boolean(changedProps);
        }
        /**
     * Callback called when any properties with accessors created via
     * `_createPropertyAccessor` have been set.
     *
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {void}
     * @protected
     * @override
     */ _propertiesChanged(currentProps, changedProps, oldProps) {
        }
        /**
     * Method called to determine whether a property value should be
     * considered as a change and cause the `_propertiesChanged` callback
     * to be enqueued.
     *
     * The default implementation returns `true` if a strict equality
     * check fails. The method always returns false for `NaN`.
     *
     * Override this method to e.g. provide stricter checking for
     * Objects/Arrays when using immutable patterns.
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     *   and enqueue a `_proeprtiesChanged` callback
     * @protected
     * @override
     */ _shouldPropertyChange(property, value, old) {
            return old !== value && (old === old || value === value);
        }
        /**
     * Implements native Custom Elements `attributeChangedCallback` to
     * set an attribute value to a property via `_attributeToProperty`.
     *
     * @param {string} name Name of attribute that changed
     * @param {?string} old Old attribute value
     * @param {?string} value New attribute value
     * @param {?string} namespace Attribute namespace.
     * @return {void}
     * @suppress {missingProperties} Super may or may not implement the callback
     * @override
     */ attributeChangedCallback(name, old, value, namespace) {
            if (old !== value) this._attributeToProperty(name, value);
            if (super.attributeChangedCallback) super.attributeChangedCallback(name, old, value, namespace);
        }
        /**
     * Deserializes an attribute to its associated property.
     *
     * This method calls the `_deserializeValue` method to convert the string to
     * a typed value.
     *
     * @param {string} attribute Name of attribute to deserialize.
     * @param {?string} value of the attribute.
     * @param {*=} type type to deserialize to, defaults to the value
     * returned from `typeForProperty`
     * @return {void}
     * @override
     */ _attributeToProperty(attribute, value, type) {
            if (!this.__serializing) {
                const map = this.__dataAttributes;
                const property = map && map[attribute] || attribute;
                this[property] = this._deserializeValue(value, type || this.constructor.typeForProperty(property));
            }
        }
        /**
     * Serializes a property to its associated attribute.
     *
     * @suppress {invalidCasts} Closure can't figure out `this` is an element.
     *
     * @param {string} property Property name to reflect.
     * @param {string=} attribute Attribute name to reflect to.
     * @param {*=} value Property value to refect.
     * @return {void}
     * @override
     */ _propertyToAttribute(property, attribute, value) {
            this.__serializing = true;
            value = arguments.length < 3 ? this[property] : value;
            this._valueToNodeAttribute(this, value, attribute || this.constructor.attributeNameForProperty(property));
            this.__serializing = false;
        }
        /**
     * Sets a typed value to an HTML attribute on a node.
     *
     * This method calls the `_serializeValue` method to convert the typed
     * value to a string.  If the `_serializeValue` method returns `undefined`,
     * the attribute will be removed (this is the default for boolean
     * type `false`).
     *
     * @param {Element} node Element to set attribute to.
     * @param {*} value Value to serialize.
     * @param {string} attribute Attribute name to serialize to.
     * @return {void}
     * @override
     */ _valueToNodeAttribute(node, value, attribute) {
            const str = this._serializeValue(value);
            if (attribute === 'class' || attribute === 'name' || attribute === 'slot') node = _wrapJs.wrap(node);
            if (str === undefined) node.removeAttribute(attribute);
            else node.setAttribute(attribute, // Closure's type for `setAttribute`'s second parameter incorrectly
            // excludes `TrustedScript`.
            str === '' && window.trustedTypes ? window.trustedTypes.emptyScript : str);
        }
        /**
     * Converts a typed JavaScript value to a string.
     *
     * This method is called when setting JS property values to
     * HTML attributes.  Users may override this method to provide
     * serialization for custom types.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided
     * property  value.
     * @override
     */ _serializeValue(value) {
            switch(typeof value){
                case 'boolean':
                    return value ? '' : undefined;
                default:
                    return value != null ? value.toString() : undefined;
            }
        }
        /**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called when reading HTML attribute values to
     * JS properties.  Users may override this method to provide
     * deserialization for custom `type`s. Types for `Boolean`, `String`,
     * and `Number` convert attributes to the expected types.
     *
     * @param {?string} value Value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     * @override
     */ _deserializeValue(value, type) {
            switch(type){
                case Boolean:
                    return value !== null;
                case Number:
                    return Number(value);
                default:
                    return value;
            }
        }
    }
    return PropertiesChanged1;
});

},{"../utils/boot.js":"gVNgb","../utils/mixin.js":"488pD","../utils/async.js":"knspW","../utils/wrap.js":"cQBlD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"knspW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timeOut", ()=>timeOut
);
parcelHelpers.export(exports, "animationFrame", ()=>animationFrame
);
parcelHelpers.export(exports, "idlePeriod", ()=>idlePeriod
);
parcelHelpers.export(exports, "microTask", ()=>microTask
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ /**
 * @fileoverview
 *
 * This module provides a number of strategies for enqueuing asynchronous
 * tasks. Each sub-module provides a standard `run(fn)` interface that returns a
 * handle, and a `cancel(handle)` interface for canceling async tasks before
 * they run.
 *
 * @summary Module that provides a number of strategies for enqueuing
 * asynchronous tasks.
 */ var _bootJs = require("./boot.js");
// Microtask implemented using Mutation Observer
let microtaskCurrHandle = 0;
let microtaskLastHandle = 0;
let microtaskCallbacks = [];
let microtaskNodeContent = 0;
let microtaskScheduled = false;
let microtaskNode = document.createTextNode('');
new window.MutationObserver(microtaskFlush).observe(microtaskNode, {
    characterData: true
});
function microtaskFlush() {
    microtaskScheduled = false;
    const len = microtaskCallbacks.length;
    for(let i = 0; i < len; i++){
        let cb = microtaskCallbacks[i];
        if (cb) try {
            cb();
        } catch (e) {
            setTimeout(()=>{
                throw e;
            });
        }
    }
    microtaskCallbacks.splice(0, len);
    microtaskLastHandle += len;
}
/**
 * Async interface wrapper around `setTimeout`.
 *
 * @namespace
 * @summary Async interface wrapper around `setTimeout`.
 */ const timeOut = {
    /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof timeOut
   * @param {number=} delay Time to wait before calling callbacks in ms
   * @return {!AsyncInterface} An async timeout interface
   */ after (delay) {
        return {
            run (fn) {
                return window.setTimeout(fn, delay);
            },
            cancel (handle) {
                window.clearTimeout(handle);
            }
        };
    },
    /**
   * Enqueues a function called in the next task.
   *
   * @memberof timeOut
   * @param {!Function} fn Callback to run
   * @param {number=} delay Delay in milliseconds
   * @return {number} Handle used for canceling task
   */ run (fn, delay) {
        return window.setTimeout(fn, delay);
    },
    /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */ cancel (handle) {
        window.clearTimeout(handle);
    }
};
/**
 * Async interface wrapper around `requestAnimationFrame`.
 *
 * @namespace
 * @summary Async interface wrapper around `requestAnimationFrame`.
 */ const animationFrame = {
    /**
   * Enqueues a function called at `requestAnimationFrame` timing.
   *
   * @memberof animationFrame
   * @param {function(number):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */ run (fn) {
        return window.requestAnimationFrame(fn);
    },
    /**
   * Cancels a previously enqueued `animationFrame` callback.
   *
   * @memberof animationFrame
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */ cancel (handle) {
        window.cancelAnimationFrame(handle);
    }
};
/**
 * Async interface wrapper around `requestIdleCallback`.  Falls back to
 * `setTimeout` on browsers that do not support `requestIdleCallback`.
 *
 * @namespace
 * @summary Async interface wrapper around `requestIdleCallback`.
 */ const idlePeriod = {
    /**
   * Enqueues a function called at `requestIdleCallback` timing.
   *
   * @memberof idlePeriod
   * @param {function(!IdleDeadline):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */ run (fn) {
        return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);
    },
    /**
   * Cancels a previously enqueued `idlePeriod` callback.
   *
   * @memberof idlePeriod
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */ cancel (handle) {
        window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);
    }
};
/**
 * Async interface for enqueuing callbacks that run at microtask timing.
 *
 * Note that microtask timing is achieved via a single `MutationObserver`,
 * and thus callbacks enqueued with this API will all run in a single
 * batch, and not interleaved with other microtasks such as promises.
 * Promises are avoided as an implementation choice for the time being
 * due to Safari bugs that cause Promises to lack microtask guarantees.
 *
 * @namespace
 * @summary Async interface for enqueuing callbacks that run at microtask
 *   timing.
 */ const microTask = {
    /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof microTask
   * @param {!Function=} callback Callback to run
   * @return {number} Handle used for canceling task
   */ run (callback) {
        if (!microtaskScheduled) {
            microtaskScheduled = true;
            microtaskNode.textContent = microtaskNodeContent++;
        }
        microtaskCallbacks.push(callback);
        return microtaskCurrHandle++;
    },
    /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */ cancel (handle) {
        const idx = handle - microtaskLastHandle;
        if (idx >= 0) {
            if (!microtaskCallbacks[idx]) throw new Error('invalid async handle: ' + handle);
            microtaskCallbacks[idx] = null;
        }
    }
};

},{"./boot.js":"gVNgb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jth3L":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TemplateStamp", ()=>TemplateStamp
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("../utils/boot.js");
var _mixinJs = require("../utils/mixin.js");
// 1.x backwards-compatible auto-wrapper for template type extensions
// This is a clear layering violation and gives favored-nation status to
// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
// a.) to ease 1.x backwards-compatibility due to loss of `is`, and
// b.) to maintain if/repeat capability in parser-constrained elements
//     (e.g. table, select) in lieu of native CE type extensions without
//     massive new invention in this space (e.g. directive system)
const templateExtensions = {
    'dom-if': true,
    'dom-repeat': true
};
let placeholderBugDetect = false;
let placeholderBug = false;
function hasPlaceholderBug() {
    if (!placeholderBugDetect) {
        placeholderBugDetect = true;
        const t = document.createElement('textarea');
        t.placeholder = 'a';
        placeholderBug = t.placeholder === t.textContent;
    }
    return placeholderBug;
}
/**
 * Some browsers have a bug with textarea, where placeholder text is copied as
 * a textnode child of the textarea.
 *
 * If the placeholder is a binding, this can break template stamping in two
 * ways.
 *
 * One issue is that when the `placeholder` attribute is removed when the
 * binding is processed, the textnode child of the textarea is deleted, and the
 * template info tries to bind into that node.
 *
 * With `legacyOptimizations` in use, when the template is stamped and the
 * `textarea.textContent` binding is processed, no corresponding node is found
 * because it was removed during parsing. An exception is generated when this
 * binding is updated.
 *
 * With `legacyOptimizations` not in use, the template is cloned before
 * processing and this changes the above behavior. The cloned template also has
 * a value property set to the placeholder and textContent. This prevents the
 * removal of the textContent when the placeholder attribute is removed.
 * Therefore the exception does not occur. However, there is an extra
 * unnecessary binding.
 *
 * @param {!Node} node Check node for placeholder bug
 * @return {void}
 */ function fixPlaceholder(node) {
    if (hasPlaceholderBug() && node.localName === 'textarea' && node.placeholder && node.placeholder === node.textContent) node.textContent = null;
}
/**
 * Copies an attribute from one element to another, converting the value to a
 * `TrustedScript` if it is named like a Polymer template event listener.
 *
 * @param {!Element} dest The element to set the attribute on
 * @param {!Element} src The element to read the attribute from
 * @param {string} name The name of the attribute
 */ const copyAttributeWithTemplateEventPolicy = (()=>{
    /**
   * This `TrustedTypePolicy` is used to work around a Chrome bug in the Trusted
   * Types API where any attribute that starts with `on` may only be set to a
   * `TrustedScript` value, even if that attribute would not cause an event
   * listener to be created. (See https://crbug.com/993268 for details.)
   *
   * Polymer's template system allows `<dom-if>` and `<dom-repeat>` to be
   * written using the `<template is="...">` syntax, even if there is no UA
   * support for custom element extensions of built-in elements. In doing so, it
   * copies attributes from the original `<template>` to a newly created
   * `<dom-if>` or `<dom-repeat>`, which can trigger the bug mentioned above if
   * any of those attributes uses Polymer's `on-` syntax for event listeners.
   * (Note, the value of these `on-` listeners is not evaluated as script: it is
   * the name of a member function of a component that will be used as the event
   * listener.)
   *
   * @type {!TrustedTypePolicy|undefined}
   */ const polymerTemplateEventAttributePolicy = window.trustedTypes && window.trustedTypes.createPolicy('polymer-template-event-attribute-policy', {
        createScript: (x)=>x
    });
    return (dest, src, name)=>{
        const value = src.getAttribute(name);
        if (polymerTemplateEventAttributePolicy && name.startsWith('on-')) {
            dest.setAttribute(name, polymerTemplateEventAttributePolicy.createScript(value, name));
            return;
        }
        dest.setAttribute(name, value);
    };
})();
function wrapTemplateExtension(node) {
    let is = node.getAttribute('is');
    if (is && templateExtensions[is]) {
        let t = node;
        t.removeAttribute('is');
        node = t.ownerDocument.createElement(is);
        t.parentNode.replaceChild(node, t);
        node.appendChild(t);
        while(t.attributes.length){
            const { name  } = t.attributes[0];
            copyAttributeWithTemplateEventPolicy(node, t, name);
            t.removeAttribute(name);
        }
    }
    return node;
}
function findTemplateNode(root, nodeInfo) {
    // recursively ascend tree until we hit root
    let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);
    // unwind the stack, returning the indexed node at each level
    if (parent) // note: marginally faster than indexing via childNodes
    // (http://jsperf.com/childnodes-lookup)
    for(let n = parent.firstChild, i = 0; n; n = n.nextSibling){
        if (nodeInfo.parentIndex === i++) return n;
    }
    else return root;
}
// construct `$` map (from id annotations)
function applyIdToMap(inst, map, node, nodeInfo) {
    if (nodeInfo.id) map[nodeInfo.id] = node;
}
// install event listeners (from event annotations)
function applyEventListener(inst, node, nodeInfo) {
    if (nodeInfo.events && nodeInfo.events.length) for(let j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++)inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
}
// push configuration references at configure time
function applyTemplateInfo(inst, node, nodeInfo, parentTemplateInfo) {
    if (nodeInfo.templateInfo) {
        // Give the node an instance of this templateInfo and set its parent
        node._templateInfo = nodeInfo.templateInfo;
        node._parentTemplateInfo = parentTemplateInfo;
    }
}
function createNodeEventHandler(context, eventName, methodName) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    context = context._methodHost || context;
    let handler = function(e) {
        if (context[methodName]) context[methodName](e, e.detail);
        else console.warn('listener method `' + methodName + '` not defined');
    };
    return handler;
}
const TemplateStamp = _mixinJs.dedupingMixin(/**
     * @template T
     * @param {function(new:T)} superClass Class to apply mixin to.
     * @return {function(new:T)} superClass with mixin applied.
     */ (superClass)=>{
    /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_TemplateStamp}
   */ class TemplateStamp1 extends superClass {
        /**
     * Scans a template to produce template metadata.
     *
     * Template-specific metadata are stored in the object returned, and node-
     * specific metadata are stored in objects in its flattened `nodeInfoList`
     * array.  Only nodes in the template that were parsed as nodes of
     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
     * contains an `index` (`childNodes` index in parent) and optionally
     * `parent`, which points to node info of its parent (including its index).
     *
     * The template metadata object returned from this method has the following
     * structure (many fields optional):
     *
     * ```js
     *   {
     *     // Flattened list of node metadata (for nodes that generated metadata)
     *     nodeInfoList: [
     *       {
     *         // `id` attribute for any nodes with id's for generating `$` map
     *         id: {string},
     *         // `on-event="handler"` metadata
     *         events: [
     *           {
     *             name: {string},   // event name
     *             value: {string},  // handler method name
     *           }, ...
     *         ],
     *         // Notes when the template contained a `<slot>` for shady DOM
     *         // optimization purposes
     *         hasInsertionPoint: {boolean},
     *         // For nested `<template>`` nodes, nested template metadata
     *         templateInfo: {object}, // nested template metadata
     *         // Metadata to allow efficient retrieval of instanced node
     *         // corresponding to this metadata
     *         parentInfo: {number},   // reference to parent nodeInfo>
     *         parentIndex: {number},  // index in parent's `childNodes` collection
     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
     *       },
     *       ...
     *     ],
     *     // When true, the template had the `strip-whitespace` attribute
     *     // or was nested in a template with that setting
     *     stripWhitespace: {boolean},
     *     // For nested templates, nested template content is moved into
     *     // a document fragment stored here; this is an optimization to
     *     // avoid the cost of nested template cloning
     *     content: {DocumentFragment}
     *   }
     * ```
     *
     * This method kicks off a recursive treewalk as follows:
     *
     * ```
     *    _parseTemplate <---------------------+
     *      _parseTemplateContent              |
     *        _parseTemplateNode  <------------|--+
     *          _parseTemplateNestedTemplate --+  |
     *          _parseTemplateChildNodes ---------+
     *          _parseTemplateNodeAttributes
     *            _parseTemplateNodeAttribute
     *
     * ```
     *
     * These methods may be overridden to add custom metadata about templates
     * to either `templateInfo` or `nodeInfo`.
     *
     * Note that this method may be destructive to the template, in that
     * e.g. event annotations may be removed after being noted in the
     * template metadata.
     *
     * @param {!HTMLTemplateElement} template Template to parse
     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
     *   template, for parsing nested templates
     * @return {!TemplateInfo} Parsed template metadata
     * @nocollapse
     */ static _parseTemplate(template, outerTemplateInfo) {
            // since a template may be re-used, memo-ize metadata
            if (!template._templateInfo) {
                // TODO(rictic): fix typing
                let /** ? */ templateInfo = template._templateInfo = {
                };
                templateInfo.nodeInfoList = [];
                templateInfo.nestedTemplate = Boolean(outerTemplateInfo);
                templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute && template.hasAttribute('strip-whitespace');
                // TODO(rictic): fix typing
                this._parseTemplateContent(template, templateInfo, {
                    parent: null
                });
            }
            return template._templateInfo;
        }
        /**
     * See docs for _parseTemplateNode.
     *
     * @param {!HTMLTemplateElement} template .
     * @param {!TemplateInfo} templateInfo .
     * @param {!NodeInfo} nodeInfo .
     * @return {boolean} .
     * @nocollapse
     */ static _parseTemplateContent(template, templateInfo, nodeInfo) {
            return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
        }
        /**
     * Parses template node and adds template and node metadata based on
     * the current node, and its `childNodes` and `attributes`.
     *
     * This method may be overridden to add custom node or template specific
     * metadata based on this node.
     *
     * @param {Node} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @nocollapse
     */ static _parseTemplateNode(node, templateInfo, nodeInfo) {
            let noted = false;
            let element = node;
            if (element.localName == 'template' && !element.hasAttribute('preserve-content')) noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
            else if (element.localName === 'slot') // For ShadyDom optimization, indicating there is an insertion point
            templateInfo.hasInsertionPoint = true;
            fixPlaceholder(element);
            if (element.firstChild) this._parseTemplateChildNodes(element, templateInfo, nodeInfo);
            if (element.hasAttributes && element.hasAttributes()) noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
            // Checking `nodeInfo.noted` allows a child node of this node (who gets
            // access to `parentInfo`) to cause the parent to be noted, which
            // otherwise has no return path via `_parseTemplateChildNodes` (used by
            // some optimizations)
            return noted || nodeInfo.noted;
        }
        /**
     * Parses template child nodes for the given root node.
     *
     * This method also wraps whitelisted legacy template extensions
     * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
     * wrappers, collapses text nodes, and strips whitespace from the template
     * if the `templateInfo.stripWhitespace` setting was provided.
     *
     * @param {Node} root Root node whose `childNodes` will be parsed
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {void}
     */ static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
            if (root.localName === 'script' || root.localName === 'style') return;
            for(let node = root.firstChild, parentIndex = 0, next; node; node = next){
                // Wrap templates
                if (node.localName == 'template') node = wrapTemplateExtension(node);
                // collapse adjacent textNodes: fixes an IE issue that can cause
                // text nodes to be inexplicably split =(
                // note that root.normalize() should work but does not so we do this
                // manually.
                next = node.nextSibling;
                if (node.nodeType === Node.TEXT_NODE) {
                    let /** Node */ n = next;
                    while(n && n.nodeType === Node.TEXT_NODE){
                        node.textContent += n.textContent;
                        next = n.nextSibling;
                        root.removeChild(n);
                        n = next;
                    }
                    // optionally strip whitespace
                    if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
                        root.removeChild(node);
                        continue;
                    }
                }
                let childInfo = {
                    parentIndex,
                    parentInfo: nodeInfo
                };
                if (this._parseTemplateNode(node, templateInfo, childInfo)) childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;
                // Increment if not removed
                if (node.parentNode) parentIndex++;
            }
        }
        /**
     * Parses template content for the given nested `<template>`.
     *
     * Nested template info is stored as `templateInfo` in the current node's
     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
     * It will then be the responsibility of the host to set it back to the
     * template and for users stamping nested templates to use the
     * `_contentForTemplate` method to retrieve the content for this template
     * (an optimization to avoid the cost of cloning nested template content).
     *
     * @param {HTMLTemplateElement} node Node to parse (a <template>)
     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
     *   that includes the template `node`
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @nocollapse
     */ static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
            // TODO(rictic): the type of node should be non-null
            let element = node;
            let templateInfo = this._parseTemplate(element, outerTemplateInfo);
            let content = templateInfo.content = element.content.ownerDocument.createDocumentFragment();
            content.appendChild(element.content);
            nodeInfo.templateInfo = templateInfo;
            return true;
        }
        /**
     * Parses template node attributes and adds node metadata to `nodeInfo`
     * for nodes of interest.
     *
     * @param {Element} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current
     *     template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @nocollapse
     */ static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
            // Make copy of original attribute list, since the order may change
            // as attributes are added and removed
            let noted = false;
            let attrs = Array.from(node.attributes);
            for(let i = attrs.length - 1, a; a = attrs[i]; i--)noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
            return noted;
        }
        /**
     * Parses a single template node attribute and adds node metadata to
     * `nodeInfo` for attributes of interest.
     *
     * This implementation adds metadata for `on-event="handler"` attributes
     * and `id` attributes.
     *
     * @param {Element} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @param {string} name Attribute name
     * @param {string} value Attribute value
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @nocollapse
     */ static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
            // events (on-*)
            if (name.slice(0, 3) === 'on-') {
                node.removeAttribute(name);
                nodeInfo.events = nodeInfo.events || [];
                nodeInfo.events.push({
                    name: name.slice(3),
                    value
                });
                return true;
            } else if (name === 'id') {
                nodeInfo.id = value;
                return true;
            }
            return false;
        }
        /**
     * Returns the `content` document fragment for a given template.
     *
     * For nested templates, Polymer performs an optimization to cache nested
     * template content to avoid the cost of cloning deeply nested templates.
     * This method retrieves the cached content for a given template.
     *
     * @param {HTMLTemplateElement} template Template to retrieve `content` for
     * @return {DocumentFragment} Content fragment
     * @nocollapse
     */ static _contentForTemplate(template) {
            let templateInfo = /** @type {HTMLTemplateElementWithInfo} */ template._templateInfo;
            return templateInfo && templateInfo.content || template.content;
        }
        /**
     * Clones the provided template content and returns a document fragment
     * containing the cloned dom.
     *
     * The template is parsed (once and memoized) using this library's
     * template parsing features, and provides the following value-added
     * features:
     * * Adds declarative event listeners for `on-event="handler"` attributes
     * * Generates an "id map" for all nodes with id's under `$` on returned
     *   document fragment
     * * Passes template info including `content` back to templates as
     *   `_templateInfo` (a performance optimization to avoid deep template
     *   cloning)
     *
     * Note that the memoized template parsing process is destructive to the
     * template: attributes for bindings and declarative event listeners are
     * removed after being noted in notes, and any nested `<template>.content`
     * is removed and stored in notes as well.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @param {TemplateInfo=} templateInfo Optional template info associated
     *   with the template to be stamped; if omitted the template will be
     *   automatically parsed.
     * @return {!StampedTemplate} Cloned template content
     * @override
     */ _stampTemplate(template, templateInfo) {
            // Polyfill support: bootstrap the template if it has not already been
            if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) HTMLTemplateElement.decorate(template);
            // Accepting the `templateInfo` via an argument allows for creating
            // instances of the `templateInfo` by the caller, useful for adding
            // instance-time information to the prototypical data
            templateInfo = templateInfo || this.constructor._parseTemplate(template);
            let nodeInfo = templateInfo.nodeInfoList;
            let content = templateInfo.content || template.content;
            let dom = document.importNode(content, true);
            // NOTE: ShadyDom optimization indicating there is an insertion point
            dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
            let nodes = dom.nodeList = new Array(nodeInfo.length);
            dom.$ = {
            };
            for(let i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++){
                let node = nodes[i] = findTemplateNode(dom, info);
                applyIdToMap(this, dom.$, node, info);
                applyTemplateInfo(this, node, info, templateInfo);
                applyEventListener(this, node, info);
            }
            return dom;
        }
        /**
     * Adds an event listener by method name for the event provided.
     *
     * This method generates a handler function that looks up the method
     * name at handling time.
     *
     * @param {!EventTarget} node Node to add listener on
     * @param {string} eventName Name of event
     * @param {string} methodName Name of method
     * @param {*=} context Context the method will be called on (defaults
     *   to `node`)
     * @return {Function} Generated handler function
     * @override
     */ _addMethodEventListenerToNode(node, eventName, methodName, context) {
            context = context || node;
            let handler = createNodeEventHandler(context, eventName, methodName);
            this._addEventListenerToNode(node, eventName, handler);
            return handler;
        }
        /**
     * Override point for adding custom or simulated event handling.
     *
     * @param {!EventTarget} node Node to add event listener to
     * @param {string} eventName Name of event
     * @param {function(!Event):void} handler Listener function to add
     * @return {void}
     * @override
     */ _addEventListenerToNode(node, eventName, handler) {
            node.addEventListener(eventName, handler);
        }
        /**
     * Override point for adding custom or simulated event handling.
     *
     * @param {!EventTarget} node Node to remove event listener from
     * @param {string} eventName Name of event
     * @param {function(!Event):void} handler Listener function to remove
     * @return {void}
     * @override
     */ _removeEventListenerFromNode(node, eventName, handler) {
            node.removeEventListener(eventName, handler);
        }
    }
    return TemplateStamp1;
});

},{"../utils/boot.js":"gVNgb","../utils/mixin.js":"488pD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fLiQd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PropertiesMixin", ()=>PropertiesMixin
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("../utils/boot.js");
var _mixinJs = require("../utils/mixin.js");
var _telemetryJs = require("../utils/telemetry.js");
var _propertiesChangedJs = require("./properties-changed.js");
/**
 * Creates a copy of `props` with each property normalized such that
 * upgraded it is an object with at least a type property { type: Type}.
 *
 * @param {!Object} props Properties to normalize
 * @return {!Object} Copy of input `props` with normalized properties that
 * are in the form {type: Type}
 * @private
 */ function normalizeProperties(props) {
    const output = {
    };
    for(let p in props){
        const o = props[p];
        output[p] = typeof o === 'function' ? {
            type: o
        } : o;
    }
    return output;
}
const PropertiesMixin = _mixinJs.dedupingMixin((superClass)=>{
    /**
  * @constructor
  * @implements {Polymer_PropertiesChanged}
  * @private
  */ const base = _propertiesChangedJs.PropertiesChanged(superClass);
    /**
  * Returns the super class constructor for the given class, if it is an
  * instance of the PropertiesMixin.
  *
  * @param {!PropertiesMixinConstructor} constructor PropertiesMixin constructor
  * @return {?PropertiesMixinConstructor} Super class constructor
  */ function superPropertiesClass(constructor) {
        const superCtor = Object.getPrototypeOf(constructor);
        // Note, the `PropertiesMixin` class below only refers to the class
        // generated by this call to the mixin; the instanceof test only works
        // because the mixin is deduped and guaranteed only to apply once, hence
        // all constructors in a proto chain will see the same `PropertiesMixin`
        return superCtor.prototype instanceof PropertiesMixin1 ? superCtor : null;
    }
    /**
  * Returns a memoized version of the `properties` object for the
  * given class. Properties not in object format are converted to at
  * least {type}.
  *
  * @param {PropertiesMixinConstructor} constructor PropertiesMixin constructor
  * @return {Object} Memoized properties object
  */ function ownProperties(constructor) {
        if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', constructor))) {
            let props = null;
            if (constructor.hasOwnProperty(JSCompiler_renameProperty('properties', constructor))) {
                const properties = constructor.properties;
                if (properties) props = normalizeProperties(properties);
            }
            constructor.__ownProperties = props;
        }
        return constructor.__ownProperties;
    }
    /**
  * @polymer
  * @mixinClass
  * @extends {base}
  * @implements {Polymer_PropertiesMixin}
  * @unrestricted
  */ class PropertiesMixin1 extends base {
        /**
    * Implements standard custom elements getter to observes the attributes
    * listed in `properties`.
    * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
    * @nocollapse
    */ static get observedAttributes() {
            if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
                _telemetryJs.register(this.prototype);
                const props = this._properties;
                this.__observedAttributes = props ? Object.keys(props).map((p)=>this.prototype._addPropertyToAttributeMap(p)
                ) : [];
            }
            return this.__observedAttributes;
        }
        /**
    * Finalizes an element definition, including ensuring any super classes
    * are also finalized. This includes ensuring property
    * accessors exist on the element prototype. This method calls
    * `_finalizeClass` to finalize each constructor in the prototype chain.
    * @return {void}
    * @nocollapse
    */ static finalize() {
            if (!this.hasOwnProperty(JSCompiler_renameProperty('__finalized', this))) {
                const superCtor = superPropertiesClass(this);
                if (superCtor) superCtor.finalize();
                this.__finalized = true;
                this._finalizeClass();
            }
        }
        /**
    * Finalize an element class. This includes ensuring property
    * accessors exist on the element prototype. This method is called by
    * `finalize` and finalizes the class constructor.
    *
    * @protected
    * @nocollapse
    */ static _finalizeClass() {
            const props = ownProperties(this);
            if (props) /** @type {?} */ this.createProperties(props);
        }
        /**
    * Returns a memoized version of all properties, including those inherited
    * from super classes. Properties not in object format are converted to
    * at least {type}.
    *
    * @return {Object} Object containing properties for this class
    * @protected
    * @nocollapse
    */ static get _properties() {
            if (!this.hasOwnProperty(JSCompiler_renameProperty('__properties', this))) {
                const superCtor = superPropertiesClass(this);
                this.__properties = Object.assign({
                }, superCtor && superCtor._properties, ownProperties(this));
            }
            return this.__properties;
        }
        /**
    * Overrides `PropertiesChanged` method to return type specified in the
    * static `properties` object for the given property.
    * @param {string} name Name of property
    * @return {*} Type to which to deserialize attribute
    *
    * @protected
    * @nocollapse
    */ static typeForProperty(name) {
            const info = this._properties[name];
            return info && info.type;
        }
        /**
    * Overrides `PropertiesChanged` method and adds a call to
    * `finalize` which lazily configures the element's property accessors.
    * @override
    * @return {void}
    */ _initializeProperties() {
            _telemetryJs.incrementInstanceCount();
            this.constructor.finalize();
            super._initializeProperties();
        }
        /**
    * Called when the element is added to a document.
    * Calls `_enableProperties` to turn on property system from
    * `PropertiesChanged`.
    * @suppress {missingProperties} Super may or may not implement the callback
    * @return {void}
    * @override
    */ connectedCallback() {
            if (super.connectedCallback) super.connectedCallback();
            this._enableProperties();
        }
        /**
    * Called when the element is removed from a document
    * @suppress {missingProperties} Super may or may not implement the callback
    * @return {void}
    * @override
    */ disconnectedCallback() {
            if (super.disconnectedCallback) super.disconnectedCallback();
        }
    }
    return PropertiesMixin1;
});

},{"../utils/boot.js":"gVNgb","../utils/mixin.js":"488pD","../utils/telemetry.js":"fTowj","./properties-changed.js":"9P4ox","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fTowj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "instanceCount", ()=>instanceCount
);
parcelHelpers.export(exports, "incrementInstanceCount", ()=>incrementInstanceCount
);
parcelHelpers.export(exports, "registrations", ()=>registrations
);
/**
 * Registers a class prototype for telemetry purposes.
 * @param {!PolymerElementConstructor} prototype Element prototype to register
 * @protected
 */ parcelHelpers.export(exports, "register", ()=>register
);
/**
 * Logs all elements registered with an `is` to the console.
 * @public
 */ parcelHelpers.export(exports, "dumpRegistrations", ()=>dumpRegistrations
);
let instanceCount = 0;
function incrementInstanceCount() {
    instanceCount++;
}
const registrations = [];
/**
 * @param {!PolymerElementConstructor} prototype Element prototype to log
 * @private
 */ function _regLog(prototype) {
    console.log('[' + /** @type {?} */ prototype.is + ']: registered');
}
function register(prototype) {
    registrations.push(prototype);
}
function dumpRegistrations() {
    registrations.forEach(_regLog);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fN0Ep":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GestureEventListeners", ()=>GestureEventListeners
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("../utils/boot.js");
var _mixinJs = require("../utils/mixin.js");
var _gesturesJs = require("../utils/gestures.js");
const GestureEventListeners = _mixinJs.dedupingMixin((superClass)=>{
    /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_GestureEventListeners}
   */ class GestureEventListeners1 extends superClass {
        /**
     * Add the event listener to the node if it is a gestures event.
     *
     * @param {!EventTarget} node Node to add event listener to
     * @param {string} eventName Name of event
     * @param {function(!Event):void} handler Listener function to add
     * @return {void}
     * @override
     */ _addEventListenerToNode(node, eventName, handler) {
            if (!_gesturesJs.addListener(node, eventName, handler)) super._addEventListenerToNode(node, eventName, handler);
        }
        /**
     * Remove the event listener to the node if it is a gestures event.
     *
     * @param {!EventTarget} node Node to remove event listener from
     * @param {string} eventName Name of event
     * @param {function(!Event):void} handler Listener function to remove
     * @return {void}
     * @override
     */ _removeEventListenerFromNode(node, eventName, handler) {
            if (!_gesturesJs.removeListener(node, eventName, handler)) super._removeEventListenerFromNode(node, eventName, handler);
        }
    }
    return GestureEventListeners1;
});

},{"../utils/boot.js":"gVNgb","../utils/mixin.js":"488pD","../utils/gestures.js":"aS7Zd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aS7Zd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "gestures", ()=>gestures
);
parcelHelpers.export(exports, "recognizers", ()=>recognizers
);
/**
 * Finds the element rendered on the screen at the provided coordinates.
 *
 * Similar to `document.elementFromPoint`, but pierces through
 * shadow roots.
 *
 * @param {number} x Horizontal pixel coordinate
 * @param {number} y Vertical pixel coordinate
 * @return {Element} Returns the deepest shadowRoot inclusive element
 * found at the screen position given.
 */ parcelHelpers.export(exports, "deepTargetFind", ()=>deepTargetFind
);
/**
 * Adds an event listener to a node for the given gesture type.
 *
 * @param {!EventTarget} node Node to add listener on
 * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
 * @param {!function(!Event):void} handler Event listener function to call
 * @return {boolean} Returns true if a gesture event listener was added.
 */ parcelHelpers.export(exports, "addListener", ()=>addListener
);
/**
 * Removes an event listener from a node for the given gesture type.
 *
 * @param {!EventTarget} node Node to remove listener from
 * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
 * @param {!function(!Event):void} handler Event listener function previously passed to
 *  `addListener`.
 * @return {boolean} Returns true if a gesture event listener was removed.
 */ parcelHelpers.export(exports, "removeListener", ()=>removeListener
);
/**
 * Registers a new gesture event recognizer for adding new custom
 * gesture event types.
 *
 * @param {!GestureRecognizer} recog Gesture recognizer descriptor
 * @return {void}
 */ parcelHelpers.export(exports, "register", ()=>register
);
/**
 * Sets scrolling direction on node.
 *
 * This value is checked on first move, thus it should be called prior to
 * adding event listeners.
 *
 * @param {!EventTarget} node Node to set touch action setting on
 * @param {string} value Touch action value
 * @return {void}
 */ parcelHelpers.export(exports, "setTouchAction", ()=>setTouchAction
);
/**
 * Prevents the dispatch and default action of the given event name.
 *
 * @param {string} evName Event name.
 * @return {void}
 */ parcelHelpers.export(exports, "prevent", ()=>prevent
);
/**
 * Reset the 2500ms timeout on processing mouse input after detecting touch input.
 *
 * Touch inputs create synthesized mouse inputs anywhere from 0 to 2000ms after the touch.
 * This method should only be called during testing with simulated touch inputs.
 * Calling this method in production may cause duplicate taps or other Gestures.
 *
 * @return {void}
 */ parcelHelpers.export(exports, "resetMouseCanceller", ()=>resetMouseCanceller
);
parcelHelpers.export(exports, "findOriginalTarget", ()=>findOriginalTarget
);
parcelHelpers.export(exports, "add", ()=>add
);
parcelHelpers.export(exports, "remove", ()=>remove
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ /**
 * @fileoverview
 *
 * Module for adding listeners to a node for the following normalized
 * cross-platform "gesture" events:
 * - `down` - mouse or touch went down
 * - `up` - mouse or touch went up
 * - `tap` - mouse click or finger tap
 * - `track` - mouse drag or touch move
 *
 * @summary Module for adding cross-platform gesture event listeners.
 */ var _bootJs = require("./boot.js");
var _asyncJs = require("./async.js");
var _debounceJs = require("./debounce.js");
var _settingsJs = require("./settings.js");
var _wrapJs = require("./wrap.js");
// detect native touch action support
let HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
let GESTURE_KEY = '__polymerGestures';
let HANDLED_OBJ = '__polymerGesturesHandled';
let TOUCH_ACTION = '__polymerGesturesTouchAction';
// radius for tap and track
let TAP_DISTANCE = 25;
let TRACK_DISTANCE = 5;
// number of last N track positions to keep
let TRACK_LENGTH = 2;
// Disabling "mouse" handlers for 2500ms is enough
let MOUSE_TIMEOUT = 2500;
let MOUSE_EVENTS = [
    'mousedown',
    'mousemove',
    'mouseup',
    'click'
];
// an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons
let MOUSE_WHICH_TO_BUTTONS = [
    0,
    1,
    4,
    2
];
let MOUSE_HAS_BUTTONS = function() {
    try {
        return new MouseEvent('test', {
            buttons: 1
        }).buttons === 1;
    } catch (e) {
        return false;
    }
}();
/**
 * @param {string} name Possible mouse event name
 * @return {boolean} true if mouse event, false if not
 */ function isMouseEvent(name) {
    return MOUSE_EVENTS.indexOf(name) > -1;
}
/* eslint no-empty: ["error", { "allowEmptyCatch": true }] */ // check for passive event listeners
let supportsPassive = false;
(function() {
    try {
        let opts = Object.defineProperty({
        }, 'passive', {
            get () {
                supportsPassive = true;
            }
        });
        window.addEventListener('test', null, opts);
        window.removeEventListener('test', null, opts);
    } catch (e) {
    }
})();
/**
 * Generate settings for event listeners, dependant on `passiveTouchGestures`
 *
 * @param {string} eventName Event name to determine if `{passive}` option is
 *   needed
 * @return {{passive: boolean} | undefined} Options to use for addEventListener
 *   and removeEventListener
 */ function PASSIVE_TOUCH(eventName) {
    if (isMouseEvent(eventName) || eventName === 'touchend') return;
    if (HAS_NATIVE_TA && supportsPassive && _settingsJs.passiveTouchGestures) return {
        passive: true
    };
    else return;
}
// Check for touch-only devices
let IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
// keep track of any labels hit by the mouseCanceller
/** @type {!Array<!HTMLLabelElement>} */ const clickedLabels = [];
/** @type {!Object<boolean>} */ const labellable = {
    'button': true,
    'input': true,
    'keygen': true,
    'meter': true,
    'output': true,
    'textarea': true,
    'progress': true,
    'select': true
};
// Defined at https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#enabling-and-disabling-form-controls:-the-disabled-attribute
/** @type {!Object<boolean>} */ const canBeDisabled = {
    'button': true,
    'command': true,
    'fieldset': true,
    'input': true,
    'keygen': true,
    'optgroup': true,
    'option': true,
    'select': true,
    'textarea': true
};
/**
 * @param {HTMLElement} el Element to check labelling status
 * @return {boolean} element can have labels
 */ function canBeLabelled(el) {
    return labellable[el.localName] || false;
}
/**
 * @param {HTMLElement} el Element that may be labelled.
 * @return {!Array<!HTMLLabelElement>} Relevant label for `el`
 */ function matchingLabels(el) {
    let labels = Array.prototype.slice.call(/** @type {HTMLInputElement} */ el.labels || []);
    // IE doesn't have `labels` and Safari doesn't populate `labels`
    // if element is in a shadowroot.
    // In this instance, finding the non-ancestor labels is enough,
    // as the mouseCancellor code will handle ancstor labels
    if (!labels.length) {
        labels = [];
        try {
            let root = el.getRootNode();
            // if there is an id on `el`, check for all labels with a matching `for` attribute
            if (el.id) {
                let matching = root.querySelectorAll(`label[for = '${el.id}']`);
                for(let i = 0; i < matching.length; i++)labels.push(matching[i]);
            }
        } catch (e) {
        // Either:
        // 1. el.getRootNode() failed.
        // 2. el.id cannot be used in `querySelectorAll`
        // In both cases, do nothing.
        }
    }
    return labels;
}
// touch will make synthetic mouse events
// `preventDefault` on touchend will cancel them,
// but this breaks `<input>` focus and link clicks
// disable mouse handlers for MOUSE_TIMEOUT ms after
// a touchend to ignore synthetic mouse events
let mouseCanceller = function(mouseEvent) {
    // Check for sourceCapabilities, used to distinguish synthetic events
    // if mouseEvent did not come from a device that fires touch events,
    // it was made by a real mouse and should be counted
    // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
    let sc = mouseEvent.sourceCapabilities;
    if (sc && !sc.firesTouchEvents) return;
    // skip synthetic mouse events
    mouseEvent[HANDLED_OBJ] = {
        skip: true
    };
    // disable "ghost clicks"
    if (mouseEvent.type === 'click') {
        let clickFromLabel = false;
        let path = getComposedPath(mouseEvent);
        for(let i = 0; i < path.length; i++){
            if (path[i].nodeType === Node.ELEMENT_NODE) {
                if (path[i].localName === 'label') clickedLabels.push(path[i]);
                else if (canBeLabelled(path[i])) {
                    let ownerLabels = matchingLabels(path[i]);
                    // check if one of the clicked labels is labelling this element
                    for(let j = 0; j < ownerLabels.length; j++)clickFromLabel = clickFromLabel || clickedLabels.indexOf(ownerLabels[j]) > -1;
                }
            }
            if (path[i] === POINTERSTATE.mouse.target) return;
        }
        // if one of the clicked labels was labelling the target element,
        // this is not a ghost click
        if (clickFromLabel) return;
        mouseEvent.preventDefault();
        mouseEvent.stopPropagation();
    }
};
/**
 * @param {boolean=} setup True to add, false to remove.
 * @return {void}
 */ function setupTeardownMouseCanceller(setup) {
    let events = IS_TOUCH_ONLY ? [
        'click'
    ] : MOUSE_EVENTS;
    for(let i = 0, en; i < events.length; i++){
        en = events[i];
        if (setup) {
            // reset clickLabels array
            clickedLabels.length = 0;
            document.addEventListener(en, mouseCanceller, true);
        } else document.removeEventListener(en, mouseCanceller, true);
    }
}
function ignoreMouse(e) {
    if (!_settingsJs.cancelSyntheticClickEvents) return;
    if (!POINTERSTATE.mouse.mouseIgnoreJob) setupTeardownMouseCanceller(true);
    let unset = function() {
        setupTeardownMouseCanceller();
        POINTERSTATE.mouse.target = null;
        POINTERSTATE.mouse.mouseIgnoreJob = null;
    };
    POINTERSTATE.mouse.target = getComposedPath(e)[0];
    POINTERSTATE.mouse.mouseIgnoreJob = _debounceJs.Debouncer.debounce(POINTERSTATE.mouse.mouseIgnoreJob, _asyncJs.timeOut.after(MOUSE_TIMEOUT), unset);
}
/**
 * @param {MouseEvent} ev event to test for left mouse button down
 * @return {boolean} has left mouse button down
 */ function hasLeftMouseButton(ev) {
    let type = ev.type;
    // exit early if the event is not a mouse event
    if (!isMouseEvent(type)) return false;
    // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
    // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)
    if (type === 'mousemove') {
        // allow undefined for testing events
        let buttons = ev.buttons === undefined ? 1 : ev.buttons;
        if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
        // buttons is a bitmask, check that the left button bit is set (1)
        return Boolean(buttons & 1);
    } else {
        // allow undefined for testing events
        let button = ev.button === undefined ? 0 : ev.button;
        // ev.button is 0 in mousedown/mouseup/click for left button activation
        return button === 0;
    }
}
function isSyntheticClick(ev) {
    if (ev.type === 'click') {
        // ev.detail is 0 for HTMLElement.click in most browsers
        if (ev.detail === 0) return true;
        // in the worst case, check that the x/y position of the click is within
        // the bounding box of the target of the event
        // Thanks IE 10 >:(
        let t = _findOriginalTarget(ev);
        // make sure the target of the event is an element so we can use getBoundingClientRect,
        // if not, just assume it is a synthetic click
        if (!t.nodeType || /** @type {Element} */ t.nodeType !== Node.ELEMENT_NODE) return true;
        let bcr = /** @type {Element} */ t.getBoundingClientRect();
        // use page x/y to account for scrolling
        let x = ev.pageX, y = ev.pageY;
        // ev is a synthetic click if the position is outside the bounding box of the target
        return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);
    }
    return false;
}
let POINTERSTATE = {
    mouse: {
        target: null,
        mouseIgnoreJob: null
    },
    touch: {
        x: 0,
        y: 0,
        id: -1,
        scrollDecided: false
    }
};
function firstTouchAction(ev) {
    let ta = 'auto';
    let path = getComposedPath(ev);
    for(let i = 0, n; i < path.length; i++){
        n = path[i];
        if (n[TOUCH_ACTION]) {
            ta = n[TOUCH_ACTION];
            break;
        }
    }
    return ta;
}
function trackDocument(stateObj, movefn, upfn) {
    stateObj.movefn = movefn;
    stateObj.upfn = upfn;
    document.addEventListener('mousemove', movefn);
    document.addEventListener('mouseup', upfn);
}
function untrackDocument(stateObj) {
    document.removeEventListener('mousemove', stateObj.movefn);
    document.removeEventListener('mouseup', stateObj.upfn);
    stateObj.movefn = null;
    stateObj.upfn = null;
}
if (_settingsJs.cancelSyntheticClickEvents) // use a document-wide touchend listener to start the ghost-click prevention mechanism
// Use passive event listeners, if supported, to not affect scrolling performance
document.addEventListener('touchend', ignoreMouse, supportsPassive ? {
    passive: true
} : false);
/**
 * Returns the composedPath for the given event.
 * @param {Event} event to process
 * @return {!Array<!EventTarget>} Path of the event
 */ const getComposedPath = window.ShadyDOM && window.ShadyDOM.noPatch ? window.ShadyDOM.composedPath : (event)=>event.composedPath && event.composedPath() || []
;
const gestures = {
};
const recognizers = [];
function deepTargetFind(x, y) {
    let node = document.elementFromPoint(x, y);
    let next = node;
    // this code path is only taken when native ShadowDOM is used
    // if there is a shadowroot, it may have a node at x/y
    // if there is not a shadowroot, exit the loop
    while(next && next.shadowRoot && !window.ShadyDOM){
        // if there is a node at x/y in the shadowroot, look deeper
        let oldNext = next;
        next = next.shadowRoot.elementFromPoint(x, y);
        // on Safari, elementFromPoint may return the shadowRoot host
        if (oldNext === next) break;
        if (next) node = next;
    }
    return node;
}
/**
 * a cheaper check than ev.composedPath()[0];
 *
 * @private
 * @param {Event|Touch} ev Event.
 * @return {EventTarget} Returns the event target.
 */ function _findOriginalTarget(ev) {
    const path = getComposedPath(ev);
    // It shouldn't be, but sometimes path is empty (window on Safari).
    return path.length > 0 ? path[0] : ev.target;
}
/**
 * @private
 * @param {Event} ev Event.
 * @return {void}
 */ function _handleNative(ev) {
    let handled;
    let type = ev.type;
    let node = ev.currentTarget;
    let gobj = node[GESTURE_KEY];
    if (!gobj) return;
    let gs = gobj[type];
    if (!gs) return;
    if (!ev[HANDLED_OBJ]) {
        ev[HANDLED_OBJ] = {
        };
        if (type.slice(0, 5) === 'touch') {
            let t = ev.changedTouches[0];
            if (type === 'touchstart') // only handle the first finger
            {
                if (ev.touches.length === 1) POINTERSTATE.touch.id = t.identifier;
            }
            if (POINTERSTATE.touch.id !== t.identifier) return;
            if (!HAS_NATIVE_TA) {
                if (type === 'touchstart' || type === 'touchmove') _handleTouchAction(ev);
            }
        }
    }
    handled = ev[HANDLED_OBJ];
    // used to ignore synthetic mouse events
    if (handled.skip) return;
    // reset recognizer state
    for(let i = 0, r; i < recognizers.length; i++){
        r = recognizers[i];
        if (gs[r.name] && !handled[r.name]) {
            if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) r.reset();
        }
    }
    // enforce gesture recognizer order
    for(let i1 = 0, r1; i1 < recognizers.length; i1++){
        r1 = recognizers[i1];
        if (gs[r1.name] && !handled[r1.name]) {
            handled[r1.name] = true;
            r1[type](ev);
        }
    }
}
/**
 * @private
 * @param {TouchEvent} ev Event.
 * @return {void}
 */ function _handleTouchAction(ev) {
    let t = ev.changedTouches[0];
    let type = ev.type;
    if (type === 'touchstart') {
        POINTERSTATE.touch.x = t.clientX;
        POINTERSTATE.touch.y = t.clientY;
        POINTERSTATE.touch.scrollDecided = false;
    } else if (type === 'touchmove') {
        if (POINTERSTATE.touch.scrollDecided) return;
        POINTERSTATE.touch.scrollDecided = true;
        let ta = firstTouchAction(ev);
        let shouldPrevent = false;
        let dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
        let dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
        if (!ev.cancelable) ;
        else if (ta === 'none') shouldPrevent = true;
        else if (ta === 'pan-x') shouldPrevent = dy > dx;
        else if (ta === 'pan-y') shouldPrevent = dx > dy;
        if (shouldPrevent) ev.preventDefault();
        else prevent('track');
    }
}
function addListener(node, evType, handler) {
    if (gestures[evType]) {
        _add(node, evType, handler);
        return true;
    }
    return false;
}
function removeListener(node, evType, handler) {
    if (gestures[evType]) {
        _remove(node, evType, handler);
        return true;
    }
    return false;
}
/**
 * automate the event listeners for the native events
 *
 * @private
 * @param {!EventTarget} node Node on which to add the event.
 * @param {string} evType Event type to add.
 * @param {function(!Event)} handler Event handler function.
 * @return {void}
 */ function _add(node, evType, handler) {
    let recognizer = gestures[evType];
    let deps = recognizer.deps;
    let name = recognizer.name;
    let gobj = node[GESTURE_KEY];
    if (!gobj) node[GESTURE_KEY] = gobj = {
    };
    for(let i = 0, dep, gd; i < deps.length; i++){
        dep = deps[i];
        // don't add mouse handlers on iOS because they cause gray selection overlays
        if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') continue;
        gd = gobj[dep];
        if (!gd) gobj[dep] = gd = {
            _count: 0
        };
        if (gd._count === 0) node.addEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));
        gd[name] = (gd[name] || 0) + 1;
        gd._count = (gd._count || 0) + 1;
    }
    node.addEventListener(evType, handler);
    if (recognizer.touchAction) setTouchAction(node, recognizer.touchAction);
}
/**
 * automate event listener removal for native events
 *
 * @private
 * @param {!EventTarget} node Node on which to remove the event.
 * @param {string} evType Event type to remove.
 * @param {function(!Event): void} handler Event handler function.
 * @return {void}
 */ function _remove(node, evType, handler) {
    let recognizer = gestures[evType];
    let deps = recognizer.deps;
    let name = recognizer.name;
    let gobj = node[GESTURE_KEY];
    if (gobj) for(let i = 0, dep, gd; i < deps.length; i++){
        dep = deps[i];
        gd = gobj[dep];
        if (gd && gd[name]) {
            gd[name] = (gd[name] || 1) - 1;
            gd._count = (gd._count || 1) - 1;
            if (gd._count === 0) node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));
        }
    }
    node.removeEventListener(evType, handler);
}
function register(recog) {
    recognizers.push(recog);
    for(let i = 0; i < recog.emits.length; i++)gestures[recog.emits[i]] = recog;
}
/**
 * @private
 * @param {string} evName Event name.
 * @return {Object} Returns the gesture for the given event name.
 */ function _findRecognizerByEvent(evName) {
    for(let i = 0, r; i < recognizers.length; i++){
        r = recognizers[i];
        for(let j = 0, n; j < r.emits.length; j++){
            n = r.emits[j];
            if (n === evName) return r;
        }
    }
    return null;
}
function setTouchAction(node, value) {
    if (HAS_NATIVE_TA && node instanceof HTMLElement) // NOTE: add touchAction async so that events can be added in
    // custom element constructors. Otherwise we run afoul of custom
    // elements restriction against settings attributes (style) in the
    // constructor.
    _asyncJs.microTask.run(()=>{
        node.style.touchAction = value;
    });
    node[TOUCH_ACTION] = value;
}
/**
 * Dispatches an event on the `target` element of `type` with the given
 * `detail`.
 * @private
 * @param {!EventTarget} target The element on which to fire an event.
 * @param {string} type The type of event to fire.
 * @param {!Object=} detail The detail object to populate on the event.
 * @return {void}
 */ function _fire(target, type, detail) {
    let ev = new Event(type, {
        bubbles: true,
        cancelable: true,
        composed: true
    });
    ev.detail = detail;
    _wrapJs.wrap(target).dispatchEvent(ev);
    // forward `preventDefault` in a clean way
    if (ev.defaultPrevented) {
        let preventer = detail.preventer || detail.sourceEvent;
        if (preventer && preventer.preventDefault) preventer.preventDefault();
    }
}
function prevent(evName) {
    let recognizer = _findRecognizerByEvent(evName);
    if (recognizer.info) recognizer.info.prevent = true;
}
function resetMouseCanceller() {
    if (POINTERSTATE.mouse.mouseIgnoreJob) POINTERSTATE.mouse.mouseIgnoreJob.flush();
}
/* eslint-disable valid-jsdoc */ register({
    name: 'downup',
    deps: [
        'mousedown',
        'touchstart',
        'touchend'
    ],
    flow: {
        start: [
            'mousedown',
            'touchstart'
        ],
        end: [
            'mouseup',
            'touchend'
        ]
    },
    emits: [
        'down',
        'up'
    ],
    info: {
        movefn: null,
        upfn: null
    },
    /**
   * @this {GestureRecognizer}
   * @return {void}
   */ reset: function() {
        untrackDocument(this.info);
    },
    /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */ mousedown: function(e1) {
        if (!hasLeftMouseButton(e1)) return;
        let t = _findOriginalTarget(e1);
        let self = this;
        let movefn = function movefn(e) {
            if (!hasLeftMouseButton(e)) {
                downupFire('up', t, e);
                untrackDocument(self.info);
            }
        };
        let upfn = function upfn(e) {
            if (hasLeftMouseButton(e)) downupFire('up', t, e);
            untrackDocument(self.info);
        };
        trackDocument(this.info, movefn, upfn);
        downupFire('down', t, e1);
    },
    /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */ touchstart: function(e) {
        downupFire('down', _findOriginalTarget(e), e.changedTouches[0], e);
    },
    /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */ touchend: function(e) {
        downupFire('up', _findOriginalTarget(e), e.changedTouches[0], e);
    }
});
/**
 * @param {string} type
 * @param {EventTarget} target
 * @param {Event|Touch} event
 * @param {Event=} preventer
 * @return {void}
 */ function downupFire(type, target, event, preventer) {
    if (!target) return;
    _fire(target, type, {
        x: event.clientX,
        y: event.clientY,
        sourceEvent: event,
        preventer: preventer,
        prevent: function(e) {
            return prevent(e);
        }
    });
}
register({
    name: 'track',
    touchAction: 'none',
    deps: [
        'mousedown',
        'touchstart',
        'touchmove',
        'touchend'
    ],
    flow: {
        start: [
            'mousedown',
            'touchstart'
        ],
        end: [
            'mouseup',
            'touchend'
        ]
    },
    emits: [
        'track'
    ],
    info: {
        x: 0,
        y: 0,
        state: 'start',
        started: false,
        moves: [],
        /** @this {GestureInfo} */ addMove: function(move) {
            if (this.moves.length > TRACK_LENGTH) this.moves.shift();
            this.moves.push(move);
        },
        movefn: null,
        upfn: null,
        prevent: false
    },
    /**
   * @this {GestureRecognizer}
   * @return {void}
   */ reset: function() {
        this.info.state = 'start';
        this.info.started = false;
        this.info.moves = [];
        this.info.x = 0;
        this.info.y = 0;
        this.info.prevent = false;
        untrackDocument(this.info);
    },
    /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */ mousedown: function(e2) {
        if (!hasLeftMouseButton(e2)) return;
        let t = _findOriginalTarget(e2);
        let self = this;
        let movefn = function movefn(e) {
            let x = e.clientX, y = e.clientY;
            if (trackHasMovedEnough(self.info, x, y)) {
                // first move is 'start', subsequent moves are 'move', mouseup is 'end'
                self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
                if (self.info.state === 'start') // if and only if tracking, always prevent tap
                prevent('tap');
                self.info.addMove({
                    x: x,
                    y: y
                });
                if (!hasLeftMouseButton(e)) {
                    // always fire "end"
                    self.info.state = 'end';
                    untrackDocument(self.info);
                }
                if (t) trackFire(self.info, t, e);
                self.info.started = true;
            }
        };
        let upfn = function upfn(e) {
            if (self.info.started) movefn(e);
            // remove the temporary listeners
            untrackDocument(self.info);
        };
        // add temporary document listeners as mouse retargets
        trackDocument(this.info, movefn, upfn);
        this.info.x = e2.clientX;
        this.info.y = e2.clientY;
    },
    /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */ touchstart: function(e) {
        let ct = e.changedTouches[0];
        this.info.x = ct.clientX;
        this.info.y = ct.clientY;
    },
    /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */ touchmove: function(e) {
        let t = _findOriginalTarget(e);
        let ct = e.changedTouches[0];
        let x = ct.clientX, y = ct.clientY;
        if (trackHasMovedEnough(this.info, x, y)) {
            if (this.info.state === 'start') // if and only if tracking, always prevent tap
            prevent('tap');
            this.info.addMove({
                x: x,
                y: y
            });
            trackFire(this.info, t, ct);
            this.info.state = 'track';
            this.info.started = true;
        }
    },
    /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */ touchend: function(e) {
        let t = _findOriginalTarget(e);
        let ct = e.changedTouches[0];
        // only trackend if track was started and not aborted
        if (this.info.started) {
            // reset started state on up
            this.info.state = 'end';
            this.info.addMove({
                x: ct.clientX,
                y: ct.clientY
            });
            trackFire(this.info, t, ct);
        }
    }
});
/**
 * @param {!GestureInfo} info
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */ function trackHasMovedEnough(info, x, y) {
    if (info.prevent) return false;
    if (info.started) return true;
    let dx = Math.abs(info.x - x);
    let dy = Math.abs(info.y - y);
    return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
}
/**
 * @param {!GestureInfo} info
 * @param {?EventTarget} target
 * @param {Touch} touch
 * @return {void}
 */ function trackFire(info, target, touch) {
    if (!target) return;
    let secondlast = info.moves[info.moves.length - 2];
    let lastmove = info.moves[info.moves.length - 1];
    let dx = lastmove.x - info.x;
    let dy = lastmove.y - info.y;
    let ddx, ddy = 0;
    if (secondlast) {
        ddx = lastmove.x - secondlast.x;
        ddy = lastmove.y - secondlast.y;
    }
    _fire(target, 'track', {
        state: info.state,
        x: touch.clientX,
        y: touch.clientY,
        dx: dx,
        dy: dy,
        ddx: ddx,
        ddy: ddy,
        sourceEvent: touch,
        hover: function() {
            return deepTargetFind(touch.clientX, touch.clientY);
        }
    });
}
register({
    name: 'tap',
    deps: [
        'mousedown',
        'click',
        'touchstart',
        'touchend'
    ],
    flow: {
        start: [
            'mousedown',
            'touchstart'
        ],
        end: [
            'click',
            'touchend'
        ]
    },
    emits: [
        'tap'
    ],
    info: {
        x: NaN,
        y: NaN,
        prevent: false
    },
    /**
   * @this {GestureRecognizer}
   * @return {void}
   */ reset: function() {
        this.info.x = NaN;
        this.info.y = NaN;
        this.info.prevent = false;
    },
    /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */ mousedown: function(e) {
        if (hasLeftMouseButton(e)) {
            this.info.x = e.clientX;
            this.info.y = e.clientY;
        }
    },
    /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */ click: function(e) {
        if (hasLeftMouseButton(e)) trackForward(this.info, e);
    },
    /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */ touchstart: function(e) {
        const touch = e.changedTouches[0];
        this.info.x = touch.clientX;
        this.info.y = touch.clientY;
    },
    /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */ touchend: function(e) {
        trackForward(this.info, e.changedTouches[0], e);
    }
});
/**
 * @param {!GestureInfo} info
 * @param {Event | Touch} e
 * @param {Event=} preventer
 * @return {void}
 */ function trackForward(info, e, preventer) {
    let dx = Math.abs(e.clientX - info.x);
    let dy = Math.abs(e.clientY - info.y);
    // find original target from `preventer` for TouchEvents, or `e` for MouseEvents
    let t = _findOriginalTarget(preventer || e);
    if (!t || canBeDisabled[/** @type {!HTMLElement} */ t.localName] && t.hasAttribute('disabled')) return;
    // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`
    if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) // prevent taps from being generated if an event has canceled them
    {
        if (!info.prevent) _fire(t, 'tap', {
            x: e.clientX,
            y: e.clientY,
            sourceEvent: e,
            preventer: preventer
        });
    }
}
const findOriginalTarget = _findOriginalTarget;
const add = addListener;
const remove = removeListener;

},{"./boot.js":"gVNgb","./async.js":"knspW","./debounce.js":"hbgki","./settings.js":"44bo5","./wrap.js":"cQBlD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hbgki":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @summary Collapse multiple callbacks into one invocation after a timer.
 */ parcelHelpers.export(exports, "Debouncer", ()=>Debouncer
);
parcelHelpers.export(exports, "enqueueDebouncer", ()=>enqueueDebouncer
);
parcelHelpers.export(exports, "flushDebouncers", ()=>flushDebouncers
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("./boot.js");
var _mixinJs = require("./mixin.js");
var _asyncJs = require("./async.js");
class Debouncer {
    constructor(){
        this._asyncModule = null;
        this._callback = null;
        this._timer = null;
    }
    /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncInterface} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   * @return {void}
   */ setConfig(asyncModule, callback) {
        this._asyncModule = asyncModule;
        this._callback = callback;
        this._timer = this._asyncModule.run(()=>{
            this._timer = null;
            debouncerQueue.delete(this);
            this._callback();
        });
    }
    /**
   * Cancels an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */ cancel() {
        if (this.isActive()) {
            this._cancelAsync();
            // Canceling a debouncer removes its spot from the flush queue,
            // so if a debouncer is manually canceled and re-debounced, it
            // will reset its flush order (this is a very minor difference from 1.x)
            // Re-debouncing via the `debounce` API retains the 1.x FIFO flush order
            debouncerQueue.delete(this);
        }
    }
    /**
   * Cancels a debouncer's async callback.
   *
   * @return {void}
   */ _cancelAsync() {
        if (this.isActive()) {
            this._asyncModule.cancel(this._timer);
            this._timer = null;
        }
    }
    /**
   * Flushes an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */ flush() {
        if (this.isActive()) {
            this.cancel();
            this._callback();
        }
    }
    /**
   * Returns true if the debouncer is active.
   *
   * @return {boolean} True if active.
   */ isActive() {
        return this._timer != null;
    }
    /**
   * Creates a debouncer if no debouncer is passed as a parameter
   * or it cancels an active debouncer otherwise. The following
   * example shows how a debouncer can be called multiple times within a
   * microtask and "debounced" such that the provided callback function is
   * called once. Add this method to a custom element:
   *
   * ```js
   * import {microTask} from '@polymer/polymer/lib/utils/async.js';
   * import {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';
   * // ...
   *
   * _debounceWork() {
   *   this._debounceJob = Debouncer.debounce(this._debounceJob,
   *       microTask, () => this._doWork());
   * }
   * ```
   *
   * If the `_debounceWork` method is called multiple times within the same
   * microtask, the `_doWork` function will be called only once at the next
   * microtask checkpoint.
   *
   * Note: In testing it is often convenient to avoid asynchrony. To accomplish
   * this with a debouncer, you can use `enqueueDebouncer` and
   * `flush`. For example, extend the above example by adding
   * `enqueueDebouncer(this._debounceJob)` at the end of the
   * `_debounceWork` method. Then in a test, call `flush` to ensure
   * the debouncer has completed.
   *
   * @param {Debouncer?} debouncer Debouncer object.
   * @param {!AsyncInterface} asyncModule Object with Async interface
   * @param {function()} callback Callback to run.
   * @return {!Debouncer} Returns a debouncer object.
   */ static debounce(debouncer, asyncModule, callback) {
        if (debouncer instanceof Debouncer) // Cancel the async callback, but leave in debouncerQueue if it was
        // enqueued, to maintain 1.x flush order
        debouncer._cancelAsync();
        else debouncer = new Debouncer();
        debouncer.setConfig(asyncModule, callback);
        return debouncer;
    }
}
let debouncerQueue = new Set();
const enqueueDebouncer = function(debouncer) {
    debouncerQueue.add(debouncer);
};
const flushDebouncers = function() {
    const didFlush = Boolean(debouncerQueue.size);
    // If new debouncers are added while flushing, Set.forEach will ensure
    // newly added ones are also flushed
    debouncerQueue.forEach((debouncer)=>{
        try {
            debouncer.flush();
        } catch (e) {
            setTimeout(()=>{
                throw e;
            });
        }
    });
    return didFlush;
};

},{"./boot.js":"gVNgb","./mixin.js":"488pD","./async.js":"knspW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Tpi0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DirMixin", ()=>DirMixin
);
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */ var _propertyAccessorsJs = require("./property-accessors.js");
var _mixinJs = require("../utils/mixin.js");
const HOST_DIR = /:host\(:dir\((ltr|rtl)\)\)/g;
const HOST_DIR_REPLACMENT = ':host([dir="$1"])';
const EL_DIR = /([\s\w-#\.\[\]\*]*):dir\((ltr|rtl)\)/g;
const EL_DIR_REPLACMENT = ':host([dir="$2"]) $1';
const DIR_CHECK = /:dir\((?:ltr|rtl)\)/;
const SHIM_SHADOW = Boolean(window['ShadyDOM'] && window['ShadyDOM']['inUse']);
/**
 * @type {!Array<!Polymer_DirMixin>}
 */ const DIR_INSTANCES = [];
/** @type {?MutationObserver} */ let observer = null;
let documentDir = '';
function getRTL() {
    documentDir = document.documentElement.getAttribute('dir');
}
/**
 * @param {!Polymer_DirMixin} instance Instance to set RTL status on
 */ function setRTL(instance) {
    if (!instance.__autoDirOptOut) {
        const el = instance;
        el.setAttribute('dir', documentDir);
    }
}
function updateDirection() {
    getRTL();
    documentDir = document.documentElement.getAttribute('dir');
    for(let i = 0; i < DIR_INSTANCES.length; i++)setRTL(DIR_INSTANCES[i]);
}
function takeRecords() {
    if (observer && observer.takeRecords().length) updateDirection();
}
const DirMixin = _mixinJs.dedupingMixin((base)=>{
    if (!SHIM_SHADOW) {
        if (!observer) {
            getRTL();
            observer = new MutationObserver(updateDirection);
            observer.observe(document.documentElement, {
                attributes: true,
                attributeFilter: [
                    'dir'
                ]
            });
        }
    }
    /**
   * @constructor
   * @implements {Polymer_PropertyAccessors}
   * @private
   */ const elementBase = _propertyAccessorsJs.PropertyAccessors(base);
    /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_DirMixin}
   */ class Dir extends elementBase {
        /**
     * @param {string} cssText .
     * @param {string} baseURI .
     * @return {string} .
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */ static _processStyleText(cssText, baseURI) {
            // TODO(https://github.com/google/closure-compiler/issues/3240):
            //     Change back to just super.methodCall()
            cssText = elementBase._processStyleText.call(this, cssText, baseURI);
            if (!SHIM_SHADOW && DIR_CHECK.test(cssText)) {
                cssText = this._replaceDirInCssText(cssText);
                this.__activateDir = true;
            }
            return cssText;
        }
        /**
     * Replace `:dir` in the given CSS text
     *
     * @param {string} text CSS text to replace DIR
     * @return {string} Modified CSS
     * @nocollapse
     */ static _replaceDirInCssText(text) {
            let replacedText = text;
            replacedText = replacedText.replace(HOST_DIR, HOST_DIR_REPLACMENT);
            replacedText = replacedText.replace(EL_DIR, EL_DIR_REPLACMENT);
            return replacedText;
        }
        constructor(){
            super();
            /** @type {boolean} */ this.__autoDirOptOut = false;
        }
        /**
     * @override
     * @suppress {invalidCasts} Closure doesn't understand that `this` is an
     *     HTMLElement
     * @return {void}
     */ ready() {
            super.ready();
            this.__autoDirOptOut = /** @type {!HTMLElement} */ this.hasAttribute('dir');
        }
        /**
     * @override
     * @suppress {missingProperties} If it exists on elementBase, it can be
     *   super'd
     * @return {void}
     */ connectedCallback() {
            if (elementBase.prototype.connectedCallback) super.connectedCallback();
            if (this.constructor.__activateDir) {
                takeRecords();
                DIR_INSTANCES.push(this);
                setRTL(this);
            }
        }
        /**
     * @override
     * @suppress {missingProperties} If it exists on elementBase, it can be
     *   super'd
     * @return {void}
     */ disconnectedCallback() {
            if (elementBase.prototype.disconnectedCallback) super.disconnectedCallback();
            if (this.constructor.__activateDir) {
                const idx = DIR_INSTANCES.indexOf(this);
                if (idx > -1) DIR_INSTANCES.splice(idx, 1);
            }
        }
    }
    Dir.__activateDir = false;
    return Dir;
});

},{"./property-accessors.js":"3DFbV","../utils/mixin.js":"488pD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eDHaR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Flushes all `beforeNextRender` tasks, followed by all `afterNextRender`
 * tasks.
 *
 * @return {void}
 */ parcelHelpers.export(exports, "flush", ()=>flush
);
/**
 * Enqueues a callback which will be run before the next render, at
 * `requestAnimationFrame` timing.
 *
 * This method is useful for enqueuing work that requires DOM measurement,
 * since measurement may not be reliable in custom element callbacks before
 * the first render, as well as for batching measurement tasks in general.
 *
 * Tasks in this queue may be flushed by calling `flush()`.
 *
 * @param {*} context Context object the callback function will be bound to
 * @param {function(...*):void} callback Callback function
 * @param {!Array=} args An array of arguments to call the callback function with
 * @return {void}
 */ parcelHelpers.export(exports, "beforeNextRender", ()=>beforeNextRender
);
/**
 * Enqueues a callback which will be run after the next render, equivalent
 * to one task (`setTimeout`) after the next `requestAnimationFrame`.
 *
 * This method is useful for tuning the first-render performance of an
 * element or application by deferring non-critical work until after the
 * first paint.  Typical non-render-critical work may include adding UI
 * event listeners and aria attributes.
 *
 * @param {*} context Context object the callback function will be bound to
 * @param {function(...*):void} callback Callback function
 * @param {!Array=} args An array of arguments to call the callback function with
 * @return {void}
 */ parcelHelpers.export(exports, "afterNextRender", ()=>afterNextRender
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ /**
 * Module for scheduling flushable pre-render and post-render tasks.
 *
 * @summary Module for scheduling flushable pre-render and post-render tasks.
 */ var _bootJs = require("./boot.js");
let scheduled = false;
let beforeRenderQueue = [];
let afterRenderQueue = [];
function schedule() {
    scheduled = true;
    // before next render
    requestAnimationFrame(function() {
        scheduled = false;
        flushQueue(beforeRenderQueue);
        // after the render
        setTimeout(function() {
            runQueue(afterRenderQueue);
        });
    });
}
function flushQueue(queue) {
    while(queue.length)callMethod(queue.shift());
}
function runQueue(queue) {
    for(let i = 0, l = queue.length; i < l; i++)callMethod(queue.shift());
}
function callMethod(info) {
    const context = info[0];
    const callback = info[1];
    const args = info[2];
    try {
        callback.apply(context, args);
    } catch (e) {
        setTimeout(()=>{
            throw e;
        });
    }
}
function flush() {
    while(beforeRenderQueue.length || afterRenderQueue.length){
        flushQueue(beforeRenderQueue);
        flushQueue(afterRenderQueue);
    }
    scheduled = false;
}
function beforeNextRender(context, callback, args) {
    if (!scheduled) schedule();
    beforeRenderQueue.push([
        context,
        callback,
        args
    ]);
}
function afterNextRender(context, callback, args) {
    if (!scheduled) schedule();
    afterRenderQueue.push([
        context,
        callback,
        args
    ]);
}

},{"./boot.js":"gVNgb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"91wkM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ function resolve() {
    document.body.removeAttribute('unresolved');
}
if (document.readyState === 'interactive' || document.readyState === 'complete') resolve();
else window.addEventListener('DOMContentLoaded', resolve);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jrPMz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "flush", ()=>_flushJs.flush
);
parcelHelpers.export(exports, "addDebouncer", ()=>_flushJs.enqueueDebouncer
);
parcelHelpers.export(exports, "matchesSelector", ()=>matchesSelector
);
/**
 * Event API wrapper class returned from `dom.(target)` when
 * `target` is an `Event`.
 */ parcelHelpers.export(exports, "EventApi", ()=>EventApi
);
parcelHelpers.export(exports, "DomApi", ()=>DomApi
);
parcelHelpers.export(exports, "dom", ()=>dom
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("../utils/boot.js");
var _wrapJs = require("../utils/wrap.js");
var _settingsJs = require("../utils/settings.js");
var _flattenedNodesObserverJs = require("../utils/flattened-nodes-observer.js");
/* eslint-disable no-unused-vars */ var _debounceJs = require("../utils/debounce.js"); // used in type annotations
var _flushJs = require("../utils/flush.js");
/* eslint-enable no-unused-vars */ const p = Element.prototype;
/**
 * @const {function(this:Node, string): boolean}
 */ const normalizedMatchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
const matchesSelector = function(node, selector) {
    return normalizedMatchesSelector.call(node, selector);
};
/**
 * Node API wrapper class returned from `Polymer.dom.(target)` when
 * `target` is a `Node`.
 * @implements {PolymerDomApi}
 * @unrestricted
 */ class DomApiNative {
    /**
   * @param {!Node} node Node for which to create a Polymer.dom helper object.
   */ constructor(node){
        if (window['ShadyDOM'] && window['ShadyDOM']['inUse']) window['ShadyDOM']['patch'](node);
        this.node = node;
    }
    /**
   * Returns an instance of `FlattenedNodesObserver` that
   * listens for node changes on this element.
   *
   * @param {function(this:HTMLElement, { target: !HTMLElement, addedNodes: !Array<!Element>, removedNodes: !Array<!Element> }):void} callback Called when direct or distributed children
   *   of this element changes
   * @return {!PolymerDomApi.ObserveHandle} Observer instance
   * @override
   */ observeNodes(callback) {
        return new _flattenedNodesObserverJs.FlattenedNodesObserver(this.node, callback);
    }
    /**
   * Disconnects an observer previously created via `observeNodes`
   *
   * @param {!PolymerDomApi.ObserveHandle} observerHandle Observer instance
   *   to disconnect.
   * @return {void}
   * @override
   */ unobserveNodes(observerHandle) {
        observerHandle.disconnect();
    }
    /**
   * Provided as a backwards-compatible API only.  This method does nothing.
   * @return {void}
   */ notifyObserver() {
    }
    /**
   * Returns true if the provided node is contained with this element's
   * light-DOM children or shadow root, including any nested shadow roots
   * of children therein.
   *
   * @param {Node} node Node to test
   * @return {boolean} Returns true if the given `node` is contained within
   *   this element's light or shadow DOM.
   * @override
   */ deepContains(node) {
        if (_wrapJs.wrap(this.node).contains(node)) return true;
        let n = node;
        let doc = node.ownerDocument;
        // walk from node to `this` or `document`
        while(n && n !== doc && n !== this.node)// use logical parentnode, or native ShadowRoot host
        n = _wrapJs.wrap(n).parentNode || _wrapJs.wrap(n).host;
        return n === this.node;
    }
    /**
   * Returns the root node of this node.  Equivalent to `getRootNode()`.
   *
   * @return {!Node} Top most element in the dom tree in which the node
   * exists. If the node is connected to a document this is either a
   * shadowRoot or the document; otherwise, it may be the node
   * itself or a node or document fragment containing it.
   * @override
   */ getOwnerRoot() {
        return _wrapJs.wrap(this.node).getRootNode();
    }
    /**
   * For slot elements, returns the nodes assigned to the slot; otherwise
   * an empty array. It is equivalent to `<slot>.addignedNodes({flatten:true})`.
   *
   * @return {!Array<!Node>} Array of assigned nodes
   * @override
   */ getDistributedNodes() {
        return this.node.localName === 'slot' ? _wrapJs.wrap(this.node).assignedNodes({
            flatten: true
        }) : [];
    }
    /**
   * Returns an array of all slots this element was distributed to.
   *
   * @return {!Array<!HTMLSlotElement>} Description
   * @override
   */ getDestinationInsertionPoints() {
        let ip$ = [];
        let n = _wrapJs.wrap(this.node).assignedSlot;
        while(n){
            ip$.push(n);
            n = _wrapJs.wrap(n).assignedSlot;
        }
        return ip$;
    }
    /**
   * Calls `importNode` on the `ownerDocument` for this node.
   *
   * @param {!Node} node Node to import
   * @param {boolean} deep True if the node should be cloned deeply during
   *   import
   * @return {Node} Clone of given node imported to this owner document
   */ importNode(node, deep) {
        let doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
        return _wrapJs.wrap(doc).importNode(node, deep);
    }
    /**
   * @return {!Array<!Node>} Returns a flattened list of all child nodes and
   * nodes assigned to child slots.
   * @override
   */ getEffectiveChildNodes() {
        return _flattenedNodesObserverJs.FlattenedNodesObserver.getFlattenedNodes(this.node);
    }
    /**
   * Returns a filtered list of flattened child elements for this element based
   * on the given selector.
   *
   * @param {string} selector Selector to filter nodes against
   * @return {!Array<!HTMLElement>} List of flattened child elements
   * @override
   */ queryDistributedElements(selector) {
        let c$ = this.getEffectiveChildNodes();
        let list = [];
        for(let i = 0, l = c$.length, c; i < l && (c = c$[i]); i++)if (c.nodeType === Node.ELEMENT_NODE && matchesSelector(c, selector)) list.push(c);
        return list;
    }
    /**
   * For shadow roots, returns the currently focused element within this
   * shadow root.
   *
   * return {Node|undefined} Currently focused element
   * @override
   */ get activeElement() {
        let node = this.node;
        return node._activeElement !== undefined ? node._activeElement : node.activeElement;
    }
}
function forwardMethods(proto, methods) {
    for(let i = 0; i < methods.length; i++){
        let method = methods[i];
        /* eslint-disable valid-jsdoc */ proto[method] = /** @this {DomApiNative} */ function() {
            return this.node[method].apply(this.node, arguments);
        };
    /* eslint-enable */ }
}
function forwardReadOnlyProperties(proto, properties) {
    for(let i = 0; i < properties.length; i++){
        let name = properties[i];
        Object.defineProperty(proto, name, {
            get: function() {
                const domApi = this;
                return domApi.node[name];
            },
            configurable: true
        });
    }
}
function forwardProperties(proto, properties) {
    for(let i = 0; i < properties.length; i++){
        let name = properties[i];
        Object.defineProperty(proto, name, {
            /**
       * @this {DomApiNative}
       * @return {*} .
       */ get: function() {
                return this.node[name];
            },
            /**
       * @this {DomApiNative}
       * @param {*} value .
       */ set: function(value) {
                this.node[name] = value;
            },
            configurable: true
        });
    }
}
class EventApi {
    constructor(event){
        this.event = event;
    }
    /**
   * Returns the first node on the `composedPath` of this event.
   *
   * @return {!EventTarget} The node this event was dispatched to
   */ get rootTarget() {
        return this.path[0];
    }
    /**
   * Returns the local (re-targeted) target for this event.
   *
   * @return {!EventTarget} The local (re-targeted) target for this event.
   */ get localTarget() {
        return this.event.target;
    }
    /**
   * Returns the `composedPath` for this event.
   * @return {!Array<!EventTarget>} The nodes this event propagated through
   */ get path() {
        return this.event.composedPath();
    }
}
/**
 * @function
 * @param {boolean=} deep
 * @return {!Node}
 */ DomApiNative.prototype.cloneNode;
/**
 * @function
 * @param {!Node} node
 * @return {!Node}
 */ DomApiNative.prototype.appendChild;
/**
 * @function
 * @param {!Node} newChild
 * @param {Node} refChild
 * @return {!Node}
 */ DomApiNative.prototype.insertBefore;
/**
 * @function
 * @param {!Node} node
 * @return {!Node}
 */ DomApiNative.prototype.removeChild;
/**
 * @function
 * @param {!Node} oldChild
 * @param {!Node} newChild
 * @return {!Node}
 */ DomApiNative.prototype.replaceChild;
/**
 * @function
 * @param {string} name
 * @param {string} value
 * @return {void}
 */ DomApiNative.prototype.setAttribute;
/**
 * @function
 * @param {string} name
 * @return {void}
 */ DomApiNative.prototype.removeAttribute;
/**
 * @function
 * @param {string} selector
 * @return {?Element}
 */ DomApiNative.prototype.querySelector;
/**
 * @function
 * @param {string} selector
 * @return {!NodeList<!Element>}
 */ DomApiNative.prototype.querySelectorAll;
/** @type {?Node} */ DomApiNative.prototype.parentNode;
/** @type {?Node} */ DomApiNative.prototype.firstChild;
/** @type {?Node} */ DomApiNative.prototype.lastChild;
/** @type {?Node} */ DomApiNative.prototype.nextSibling;
/** @type {?Node} */ DomApiNative.prototype.previousSibling;
/** @type {?HTMLElement} */ DomApiNative.prototype.firstElementChild;
/** @type {?HTMLElement} */ DomApiNative.prototype.lastElementChild;
/** @type {?HTMLElement} */ DomApiNative.prototype.nextElementSibling;
/** @type {?HTMLElement} */ DomApiNative.prototype.previousElementSibling;
/** @type {!Array<!Node>} */ DomApiNative.prototype.childNodes;
/** @type {!Array<!HTMLElement>} */ DomApiNative.prototype.children;
/** @type {?DOMTokenList} */ DomApiNative.prototype.classList;
/** @type {string} */ DomApiNative.prototype.textContent;
/** @type {string} */ DomApiNative.prototype.innerHTML;
let DomApiImpl = DomApiNative;
if (window['ShadyDOM'] && window['ShadyDOM']['inUse'] && window['ShadyDOM']['noPatch'] && window['ShadyDOM']['Wrapper']) {
    /**
   * @private
   * @extends {HTMLElement}
   */ class Wrapper extends window['ShadyDOM']['Wrapper'] {
    }
    // copy bespoke API onto wrapper
    Object.getOwnPropertyNames(DomApiNative.prototype).forEach((prop)=>{
        if (prop != 'activeElement') Wrapper.prototype[prop] = DomApiNative.prototype[prop];
    });
    // Note, `classList` is here only for legacy compatibility since it does not
    // trigger distribution in v1 Shadow DOM.
    forwardReadOnlyProperties(Wrapper.prototype, [
        'classList'
    ]);
    DomApiImpl = Wrapper;
    Object.defineProperties(EventApi.prototype, {
        // Returns the "lowest" node in the same root as the event's currentTarget.
        // When in `noPatch` mode, this must be calculated by walking the event's
        // path.
        localTarget: {
            get () {
                const current = this.event.currentTarget;
                const currentRoot = current && dom(current).getOwnerRoot();
                const p$ = this.path;
                for(let i = 0; i < p$.length; i++){
                    const e = p$[i];
                    if (dom(e).getOwnerRoot() === currentRoot) return e;
                }
            },
            configurable: true
        },
        path: {
            get () {
                return window['ShadyDOM']['composedPath'](this.event);
            },
            configurable: true
        }
    });
} else {
    // Methods that can provoke distribution or must return the logical, not
    // composed tree.
    forwardMethods(DomApiNative.prototype, [
        'cloneNode',
        'appendChild',
        'insertBefore',
        'removeChild',
        'replaceChild',
        'setAttribute',
        'removeAttribute',
        'querySelector',
        'querySelectorAll',
        'attachShadow'
    ]);
    // Properties that should return the logical, not composed tree. Note, `classList`
    // is here only for legacy compatibility since it does not trigger distribution
    // in v1 Shadow DOM.
    forwardReadOnlyProperties(DomApiNative.prototype, [
        'parentNode',
        'firstChild',
        'lastChild',
        'nextSibling',
        'previousSibling',
        'firstElementChild',
        'lastElementChild',
        'nextElementSibling',
        'previousElementSibling',
        'childNodes',
        'children',
        'classList',
        'shadowRoot'
    ]);
    forwardProperties(DomApiNative.prototype, [
        'textContent',
        'innerHTML',
        'className'
    ]);
}
const DomApi = DomApiImpl;
const dom = function(obj) {
    obj = obj || document;
    if (obj instanceof DomApiImpl) return obj;
    if (obj instanceof EventApi) return obj;
    let helper = obj['__domApi'];
    if (!helper) {
        if (obj instanceof Event) helper = new EventApi(obj);
        else helper = new DomApiImpl(obj);
        obj['__domApi'] = helper;
    }
    return helper;
};

},{"../utils/boot.js":"gVNgb","../utils/wrap.js":"cQBlD","../utils/settings.js":"44bo5","../utils/flattened-nodes-observer.js":"6QMDE","../utils/debounce.js":"hbgki","../utils/flush.js":"33N4S","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6QMDE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FlattenedNodesObserver", ()=>FlattenedNodesObserver
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("./boot.js");
var _arraySpliceJs = require("./array-splice.js");
var _asyncJs = require("./async.js");
var _wrapJs = require("./wrap.js");
/**
 * Returns true if `node` is a slot element
 * @param {!Node} node Node to test.
 * @return {boolean} Returns true if the given `node` is a slot
 * @private
 */ function isSlot(node) {
    return node.localName === 'slot';
}
let FlattenedNodesObserver = class {
    /**
   * Returns the list of flattened nodes for the given `node`.
   * This list consists of a node's children and, for any children
   * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
   * For example, if the observed node has children `<a></a><slot></slot><b></b>`
   * and the `<slot>` has one `<div>` assigned to it, then the flattened
   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
   * `<slot>` elements assigned to it, these are flattened as well.
   *
   * @param {!HTMLElement|!HTMLSlotElement} node The node for which to
   *      return the list of flattened nodes.
   * @return {!Array<!Node>} The list of flattened nodes for the given `node`.
   * @nocollapse See https://github.com/google/closure-compiler/issues/2763
   */ // eslint-disable-next-line
    static getFlattenedNodes(node1) {
        const wrapped = _wrapJs.wrap(node1);
        if (isSlot(node1)) return wrapped.assignedNodes({
            flatten: true
        });
        else return Array.from(wrapped.childNodes).map((node)=>{
            if (isSlot(node)) return _wrapJs.wrap(node).assignedNodes({
                flatten: true
            });
            else return [
                node
            ];
        }).reduce((a, b)=>a.concat(b)
        , []);
    }
    /**
   * @param {!HTMLElement} target Node on which to listen for changes.
   * @param {?function(this: Element, { target: !HTMLElement, addedNodes: !Array<!Element>, removedNodes: !Array<!Element> }):void} callback Function called when there are additions
   * or removals from the target's list of flattened nodes.
   */ // eslint-disable-next-line
    constructor(target, callback){
        /**
     * @type {MutationObserver}
     * @private
     */ this._shadyChildrenObserver = null;
        /**
     * @type {MutationObserver}
     * @private
     */ this._nativeChildrenObserver = null;
        this._connected = false;
        /**
     * @type {!HTMLElement}
     * @private
     */ this._target = target;
        this.callback = callback;
        this._effectiveNodes = [];
        this._observer = null;
        this._scheduled = false;
        /**
     * @type {function()}
     * @private
     */ this._boundSchedule = ()=>{
            this._schedule();
        };
        this.connect();
        this._schedule();
    }
    /**
   * Activates an observer. This method is automatically called when
   * a `FlattenedNodesObserver` is created. It should only be called to
   * re-activate an observer that has been deactivated via the `disconnect` method.
   *
   * @return {void}
   */ connect() {
        if (isSlot(this._target)) this._listenSlots([
            this._target
        ]);
        else if (_wrapJs.wrap(this._target).children) {
            this._listenSlots(_wrapJs.wrap(this._target).children);
            if (window.ShadyDOM) this._shadyChildrenObserver = window.ShadyDOM.observeChildren(this._target, (mutations)=>{
                this._processMutations(mutations);
            });
            else {
                this._nativeChildrenObserver = new MutationObserver((mutations)=>{
                    this._processMutations(mutations);
                });
                this._nativeChildrenObserver.observe(this._target, {
                    childList: true
                });
            }
        }
        this._connected = true;
    }
    /**
   * Deactivates the flattened nodes observer. After calling this method
   * the observer callback will not be called when changes to flattened nodes
   * occur. The `connect` method may be subsequently called to reactivate
   * the observer.
   *
   * @return {void}
   * @override
   */ disconnect() {
        if (isSlot(this._target)) this._unlistenSlots([
            this._target
        ]);
        else if (_wrapJs.wrap(this._target).children) {
            this._unlistenSlots(_wrapJs.wrap(this._target).children);
            if (window.ShadyDOM && this._shadyChildrenObserver) {
                window.ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
                this._shadyChildrenObserver = null;
            } else if (this._nativeChildrenObserver) {
                this._nativeChildrenObserver.disconnect();
                this._nativeChildrenObserver = null;
            }
        }
        this._connected = false;
    }
    /**
   * @return {void}
   * @private
   */ _schedule() {
        if (!this._scheduled) {
            this._scheduled = true;
            _asyncJs.microTask.run(()=>this.flush()
            );
        }
    }
    /**
   * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer
   * @return {void}
   * @private
   */ _processMutations(mutations) {
        this._processSlotMutations(mutations);
        this.flush();
    }
    /**
   * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer
   * @return {void}
   * @private
   */ _processSlotMutations(mutations) {
        if (mutations) for(let i = 0; i < mutations.length; i++){
            let mutation = mutations[i];
            if (mutation.addedNodes) this._listenSlots(mutation.addedNodes);
            if (mutation.removedNodes) this._unlistenSlots(mutation.removedNodes);
        }
    }
    /**
   * Flushes the observer causing any pending changes to be immediately
   * delivered the observer callback. By default these changes are delivered
   * asynchronously at the next microtask checkpoint.
   *
   * @return {boolean} Returns true if any pending changes caused the observer
   * callback to run.
   */ flush() {
        if (!this._connected) return false;
        if (window.ShadyDOM) ShadyDOM.flush();
        if (this._nativeChildrenObserver) this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
        else if (this._shadyChildrenObserver) this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
        this._scheduled = false;
        let info = {
            target: this._target,
            addedNodes: [],
            removedNodes: []
        };
        let newNodes = this.constructor.getFlattenedNodes(this._target);
        let splices = _arraySpliceJs.calculateSplices(newNodes, this._effectiveNodes);
        // process removals
        for(let i = 0, s; i < splices.length && (s = splices[i]); i++)for(let j = 0, n; j < s.removed.length && (n = s.removed[j]); j++)info.removedNodes.push(n);
        // process adds
        for(let i1 = 0, s1; i1 < splices.length && (s1 = splices[i1]); i1++)for(let j1 = s1.index; j1 < s1.index + s1.addedCount; j1++)info.addedNodes.push(newNodes[j1]);
        // update cache
        this._effectiveNodes = newNodes;
        let didFlush = false;
        if (info.addedNodes.length || info.removedNodes.length) {
            didFlush = true;
            this.callback.call(this._target, info);
        }
        return didFlush;
    }
    /**
   * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change
   * @return {void}
   * @private
   */ _listenSlots(nodeList) {
        for(let i = 0; i < nodeList.length; i++){
            let n = nodeList[i];
            if (isSlot(n)) n.addEventListener('slotchange', this._boundSchedule);
        }
    }
    /**
   * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change
   * @return {void}
   * @private
   */ _unlistenSlots(nodeList) {
        for(let i = 0; i < nodeList.length; i++){
            let n = nodeList[i];
            if (isSlot(n)) n.removeEventListener('slotchange', this._boundSchedule);
        }
    }
};

},{"./boot.js":"gVNgb","./array-splice.js":"7lRsx","./async.js":"knspW","./wrap.js":"cQBlD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7lRsx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns an array of splice records indicating the minimum edits required
 * to transform the `previous` array into the `current` array.
 *
 * Splice records are ordered by index and contain the following fields:
 * - `index`: index where edit started
 * - `removed`: array of removed items from this index
 * - `addedCount`: number of items added at this index
 *
 * This function is based on the Levenshtein "minimum edit distance"
 * algorithm. Note that updates are treated as removal followed by addition.
 *
 * The worst-case time complexity of this algorithm is `O(l * p)`
 *   l: The length of the current array
 *   p: The length of the previous array
 *
 * However, the worst-case complexity is reduced by an `O(n)` optimization
 * to detect any shared prefix & suffix between the two arrays and only
 * perform the more expensive minimum edit distance calculation over the
 * non-shared portions of the arrays.
 *
 * @function
 * @param {!Array} current The "changed" array for which splices will be
 * calculated.
 * @param {!Array} previous The "unchanged" original array to compare
 * `current` against to determine the splices.
 * @return {!Array} Returns an array of splice record objects. Each of these
 * contains: `index` the location where the splice occurred; `removed`
 * the array of removed items from this location; `addedCount` the number
 * of items added at this location.
 */ parcelHelpers.export(exports, "calculateSplices", ()=>calculateSplices
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("./boot.js");
function newSplice(index, removed, addedCount) {
    return {
        index: index,
        removed: removed,
        addedCount: addedCount
    };
}
const EDIT_LEAVE = 0;
const EDIT_UPDATE = 1;
const EDIT_ADD = 2;
const EDIT_DELETE = 3;
// Note: This function is *based* on the computation of the Levenshtein
// "edit" distance. The one change is that "updates" are treated as two
// edits - not one. With Array splices, an update is really a delete
// followed by an add. By retaining this, we optimize for "keeping" the
// maximum array items in the original array. For example:
//
//   'xxxx123' -> '123yyyy'
//
// With 1-edit updates, the shortest path would be just to update all seven
// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
// leaves the substring '123' intact.
function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    // "Deletion" columns
    let rowCount = oldEnd - oldStart + 1;
    let columnCount = currentEnd - currentStart + 1;
    let distances = new Array(rowCount);
    // "Addition" rows. Initialize null column.
    for(let i = 0; i < rowCount; i++){
        distances[i] = new Array(columnCount);
        distances[i][0] = i;
    }
    // Initialize null row
    for(let j = 0; j < columnCount; j++)distances[0][j] = j;
    for(let i1 = 1; i1 < rowCount; i1++){
        for(let j = 1; j < columnCount; j++)if (equals(current[currentStart + j - 1], old[oldStart + i1 - 1])) distances[i1][j] = distances[i1 - 1][j - 1];
        else {
            let north = distances[i1 - 1][j] + 1;
            let west = distances[i1][j - 1] + 1;
            distances[i1][j] = north < west ? north : west;
        }
    }
    return distances;
}
// This starts at the final weight, and walks "backward" by finding
// the minimum previous weight recursively until the origin of the weight
// matrix.
function spliceOperationsFromEditDistances(distances) {
    let i = distances.length - 1;
    let j = distances[0].length - 1;
    let current = distances[i][j];
    let edits = [];
    while(i > 0 || j > 0){
        if (i == 0) {
            edits.push(EDIT_ADD);
            j--;
            continue;
        }
        if (j == 0) {
            edits.push(EDIT_DELETE);
            i--;
            continue;
        }
        let northWest = distances[i - 1][j - 1];
        let west = distances[i - 1][j];
        let north = distances[i][j - 1];
        let min;
        if (west < north) min = west < northWest ? west : northWest;
        else min = north < northWest ? north : northWest;
        if (min == northWest) {
            if (northWest == current) edits.push(EDIT_LEAVE);
            else {
                edits.push(EDIT_UPDATE);
                current = northWest;
            }
            i--;
            j--;
        } else if (min == west) {
            edits.push(EDIT_DELETE);
            i--;
            current = west;
        } else {
            edits.push(EDIT_ADD);
            j--;
            current = north;
        }
    }
    edits.reverse();
    return edits;
}
/**
 * Splice Projection functions:
 *
 * A splice map is a representation of how a previous array of items
 * was transformed into a new array of items. Conceptually it is a list of
 * tuples of
 *
 *   <index, removed, addedCount>
 *
 * which are kept in ascending index order of. The tuple represents that at
 * the |index|, |removed| sequence of items were removed, and counting forward
 * from |index|, |addedCount| items were added.
 */ /**
 * Lacking individual splice mutation information, the minimal set of
 * splices can be synthesized given the previous state and final state of an
 * array. The basic approach is to calculate the edit distance matrix and
 * choose the shortest path through it.
 *
 * Complexity: O(l * p)
 *   l: The length of the current array
 *   p: The length of the old array
 *
 * @param {!Array} current The current "changed" array for which to
 * calculate splices.
 * @param {number} currentStart Starting index in the `current` array for
 * which splices are calculated.
 * @param {number} currentEnd Ending index in the `current` array for
 * which splices are calculated.
 * @param {!Array} old The original "unchanged" array to compare `current`
 * against to determine splices.
 * @param {number} oldStart Starting index in the `old` array for
 * which splices are calculated.
 * @param {number} oldEnd Ending index in the `old` array for
 * which splices are calculated.
 * @return {!Array} Returns an array of splice record objects. Each of these
 * contains: `index` the location where the splice occurred; `removed`
 * the array of removed items from this location; `addedCount` the number
 * of items added at this location.
 */ function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    let prefixCount = 0;
    let suffixCount = 0;
    let splice;
    let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
    if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);
    if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);
    currentStart += prefixCount;
    oldStart += prefixCount;
    currentEnd -= suffixCount;
    oldEnd -= suffixCount;
    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];
    if (currentStart == currentEnd) {
        splice = newSplice(currentStart, [], 0);
        while(oldStart < oldEnd)splice.removed.push(old[oldStart++]);
        return [
            splice
        ];
    } else if (oldStart == oldEnd) return [
        newSplice(currentStart, [], currentEnd - currentStart)
    ];
    let ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
    splice = undefined;
    let splices = [];
    let index = currentStart;
    let oldIndex = oldStart;
    for(let i = 0; i < ops.length; i++)switch(ops[i]){
        case EDIT_LEAVE:
            if (splice) {
                splices.push(splice);
                splice = undefined;
            }
            index++;
            oldIndex++;
            break;
        case EDIT_UPDATE:
            if (!splice) splice = newSplice(index, [], 0);
            splice.addedCount++;
            index++;
            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
        case EDIT_ADD:
            if (!splice) splice = newSplice(index, [], 0);
            splice.addedCount++;
            index++;
            break;
        case EDIT_DELETE:
            if (!splice) splice = newSplice(index, [], 0);
            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
    }
    if (splice) splices.push(splice);
    return splices;
}
function sharedPrefix(current, old, searchLength) {
    for(let i = 0; i < searchLength; i++)if (!equals(current[i], old[i])) return i;
    return searchLength;
}
function sharedSuffix(current, old, searchLength) {
    let index1 = current.length;
    let index2 = old.length;
    let count = 0;
    while(count < searchLength && equals(current[--index1], old[--index2]))count++;
    return count;
}
function calculateSplices(current, previous) {
    return calcSplices(current, 0, current.length, previous, 0, previous.length);
}
function equals(currentValue, previousValue) {
    return currentValue === previousValue;
}

},{"./boot.js":"gVNgb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"33N4S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "enqueueDebouncer", ()=>_debounceJs.enqueueDebouncer
);
parcelHelpers.export(exports, "flush", ()=>flush
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("./boot.js");
var _debounceJs = require("../utils/debounce.js");
const flush = function() {
    let shadyDOM, debouncers;
    do {
        shadyDOM = window.ShadyDOM && ShadyDOM.flush();
        if (window.ShadyCSS && window.ShadyCSS.ScopingShim) window.ShadyCSS.ScopingShim.flush();
        debouncers = _debounceJs.flushDebouncers();
    }while (shadyDOM || debouncers)
};

},{"./boot.js":"gVNgb","../utils/debounce.js":"hbgki","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gdzC5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Ensure that elements in a ShadowDOM container are scoped correctly.
 * This function is only needed when ShadyDOM is used and unpatched DOM APIs are used in third party code.
 * This can happen in noPatch mode or when specialized APIs like ranges or tables are used to mutate DOM.
 *
 * @param  {!Element} container Container element to scope
 * @param  {boolean=} shouldObserve if true, start a mutation observer for added nodes to the container
 * @return {?MutationObserver} Returns a new MutationObserver on `container` if `shouldObserve` is true.
 */ parcelHelpers.export(exports, "scopeSubtree", ()=>scopeSubtree
);
/**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("./boot.js");
var _wrapJs = require("./wrap.js");
const ShadyDOM = window.ShadyDOM;
const ShadyCSS = window.ShadyCSS;
/**
 * Return true if node scope is correct.
 *
 * @param {!Element} node Node to check scope
 * @param {!Node} scope Scope reference
 * @return {boolean} True if node is in scope
 */ function sameScope(node, scope) {
    return _wrapJs.wrap(node).getRootNode() === scope;
}
function scopeSubtree(container, shouldObserve = false) {
    // If using native ShadowDOM, abort
    if (!ShadyDOM || !ShadyCSS) return null;
    // ShadyCSS handles DOM mutations when ShadyDOM does not handle scoping itself
    if (!ShadyDOM['handlesDynamicScoping']) return null;
    const ScopingShim = ShadyCSS['ScopingShim'];
    // if ScopingShim is not available, abort
    if (!ScopingShim) return null;
    // capture correct scope for container
    const containerScope = ScopingShim['scopeForNode'](container);
    const root = _wrapJs.wrap(container).getRootNode();
    const scopify = (node)=>{
        if (!sameScope(node, root)) return;
        // NOTE: native qSA does not honor scoped DOM, but it is faster, and the same behavior as Polymer v1
        const elements = Array.from(ShadyDOM['nativeMethods']['querySelectorAll'].call(node, '*'));
        elements.push(node);
        for(let i = 0; i < elements.length; i++){
            const el = elements[i];
            if (!sameScope(el, root)) continue;
            const currentScope = ScopingShim['currentScopeForNode'](el);
            if (currentScope !== containerScope) {
                if (currentScope !== '') ScopingShim['unscopeNode'](el, currentScope);
                ScopingShim['scopeNode'](el, containerScope);
            }
        }
    };
    // scope everything in container
    scopify(container);
    if (shouldObserve) {
        const mo = new MutationObserver((mxns)=>{
            for(let i = 0; i < mxns.length; i++){
                const mxn = mxns[i];
                for(let j = 0; j < mxn.addedNodes.length; j++){
                    const addedNode = mxn.addedNodes[j];
                    if (addedNode.nodeType === Node.ELEMENT_NODE) scopify(addedNode);
                }
            }
        });
        mo.observe(container, {
            childList: true,
            subtree: true
        });
        return mo;
    } else return null;
}

},{"./boot.js":"gVNgb","./wrap.js":"cQBlD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fXYPk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "findObservedAttributesGetter", ()=>findObservedAttributesGetter
);
parcelHelpers.export(exports, "DisableUpgradeMixin", ()=>DisableUpgradeMixin
);
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */ var _elementMixinJs = require("./element-mixin.js");
var _mixinJs = require("../utils/mixin.js");
var _wrapJs = require("../utils/wrap.js");
const DISABLED_ATTR = 'disable-upgrade';
const findObservedAttributesGetter = (ctor)=>{
    while(ctor){
        const desc = Object.getOwnPropertyDescriptor(ctor, 'observedAttributes');
        if (desc) return desc.get;
        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }
    return ()=>[]
    ;
};
const DisableUpgradeMixin = _mixinJs.dedupingMixin((base)=>{
    /**
   * @constructor
   * @implements {Polymer_ElementMixin}
   * @extends {HTMLElement}
   * @private
   */ const superClass = _elementMixinJs.ElementMixin(base);
    // Work around for closure bug #126934458. Using `super` in a property
    // getter does not work so instead we search the Base prototype for an
    // implementation of observedAttributes so that we can override and call
    // the `super` getter. Note, this is done one time ever because we assume
    // that `Base` is always comes from `Polymer.LegacyElementMixn`.
    let observedAttributesGetter = findObservedAttributesGetter(superClass);
    /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_DisableUpgradeMixin}
   */ class DisableUpgradeClass extends superClass {
        constructor(){
            super();
            /** @type {boolean|undefined} */ this.__isUpgradeDisabled;
        }
        static get observedAttributes() {
            return observedAttributesGetter.call(this).concat(DISABLED_ATTR);
        }
        // Prevent element from initializing properties when it's upgrade disabled.
        /** @override */ _initializeProperties() {
            if (this.hasAttribute(DISABLED_ATTR)) this.__isUpgradeDisabled = true;
            else super._initializeProperties();
        }
        // Prevent element from enabling properties when it's upgrade disabled.
        // Normally overriding connectedCallback would be enough, but dom-* elements
        /** @override */ _enableProperties() {
            if (!this.__isUpgradeDisabled) super._enableProperties();
        }
        // If the element starts upgrade-disabled and a property is set for
        // which an accessor exists, the default should not be applied.
        // This additional check is needed because defaults are applied via
        // `_initializeProperties` which is called after initial properties
        // have been set when the element starts upgrade-disabled.
        /** @override */ _canApplyPropertyDefault(property) {
            return super._canApplyPropertyDefault(property) && !(this.__isUpgradeDisabled && this._isPropertyPending(property));
        }
        /**
     * @override
     * @param {string} name Attribute name.
     * @param {?string} old The previous value for the attribute.
     * @param {?string} value The new value for the attribute.
     * @param {?string} namespace The XML namespace for the attribute.
     * @return {void}
     */ attributeChangedCallback(name, old, value, namespace) {
            if (name == DISABLED_ATTR) // When disable-upgrade is removed, initialize properties and
            // provoke connectedCallback if the element is already connected.
            {
                if (this.__isUpgradeDisabled && value == null) {
                    super._initializeProperties();
                    this.__isUpgradeDisabled = false;
                    if (_wrapJs.wrap(this).isConnected) super.connectedCallback();
                }
            } else super.attributeChangedCallback(name, old, value, namespace);
        }
        // Prevent element from connecting when it's upgrade disabled.
        // This prevents user code in `attached` from being called.
        /** @override */ connectedCallback() {
            if (!this.__isUpgradeDisabled) super.connectedCallback();
        }
        // Prevent element from disconnecting when it's upgrade disabled.
        // This avoids allowing user code `detached` from being called without a
        // paired call to `attached`.
        /** @override */ disconnectedCallback() {
            if (!this.__isUpgradeDisabled) super.disconnectedCallback();
        }
    }
    return DisableUpgradeClass;
});

},{"./element-mixin.js":"52pSj","../utils/mixin.js":"488pD","../utils/wrap.js":"cQBlD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kIpx3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Templatizer", ()=>Templatizer
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _templatizeJs = require("../utils/templatize.js"); // eslint-disable-line no-unused-vars
/**
 * @typedef {{
 *   _templatizerTemplate: HTMLTemplateElement,
 *   _parentModel: boolean,
 *   _instanceProps: Object,
 *   _forwardHostPropV2: Function,
 *   _notifyInstancePropV2: Function,
 *   ctor: function(new:TemplateInstanceBase, Object=)
 * }}
 */ let TemplatizerUser; // eslint-disable-line
const Templatizer = {
    /**
   * Generates an anonymous `TemplateInstance` class (stored as `this.ctor`)
   * for the provided template.  This method should be called once per
   * template to prepare an element for stamping the template, followed
   * by `stamp` to create new instances of the template.
   *
   * @param {!HTMLTemplateElement} template Template to prepare
   * @param {boolean=} mutableData When `true`, the generated class will skip
   *   strict dirty-checking for objects and arrays (always consider them to
   *   be "dirty"). Defaults to false.
   * @return {void}
   * @this {TemplatizerUser}
   */ templatize (template, mutableData) {
        this._templatizerTemplate = template;
        this.ctor = _templatizeJs.templatize(template, this, {
            mutableData: Boolean(mutableData),
            parentModel: this._parentModel,
            instanceProps: this._instanceProps,
            forwardHostProp: this._forwardHostPropV2,
            notifyInstanceProp: this._notifyInstancePropV2
        });
    },
    /**
   * Creates an instance of the template prepared by `templatize`.  The object
   * returned is an instance of the anonymous class generated by `templatize`
   * whose `root` property is a document fragment containing newly cloned
   * template content, and which has property accessors corresponding to
   * properties referenced in template bindings.
   *
   * @param {Object=} model Object containing initial property values to
   *   populate into the template bindings.
   * @return {TemplateInstanceBase} Returns the created instance of
   * the template prepared by `templatize`.
   * @this {TemplatizerUser}
   */ stamp (model) {
        return new this.ctor(model);
    },
    /**
   * Returns the template "model" (`TemplateInstance`) associated with
   * a given element, which serves as the binding scope for the template
   * instance the element is contained in.  A template model should be used
   * to manipulate data associated with this template instance.
   *
   * @param {HTMLElement} el Element for which to return a template model.
   * @return {TemplateInstanceBase} Model representing the binding scope for
   *   the element.
   * @this {TemplatizerUser}
   */ modelForElement (el) {
        return _templatizeJs.modelForElement(this._templatizerTemplate, el);
    }
};

},{"../utils/templatize.js":"6QnfM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6QnfM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showHideChildren", ()=>showHideChildren
);
/**
 * Returns an anonymous `PropertyEffects` class bound to the
 * `<template>` provided.  Instancing the class will result in the
 * template being stamped into a document fragment stored as the instance's
 * `root` property, after which it can be appended to the DOM.
 *
 * Templates may utilize all Polymer data-binding features as well as
 * declarative event listeners.  Event listeners and inline computing
 * functions in the template will be called on the host of the template.
 *
 * The constructor returned takes a single argument dictionary of initial
 * property values to propagate into template bindings.  Additionally
 * host properties can be forwarded in, and instance properties can be
 * notified out by providing optional callbacks in the `options` dictionary.
 *
 * Valid configuration in `options` are as follows:
 *
 * - `forwardHostProp(property, value)`: Called when a property referenced
 *   in the template changed on the template's host. As this library does
 *   not retain references to templates instanced by the user, it is the
 *   templatize owner's responsibility to forward host property changes into
 *   user-stamped instances.  The `instance.forwardHostProp(property, value)`
 *    method on the generated class should be called to forward host
 *   properties into the template to prevent unnecessary property-changed
 *   notifications. Any properties referenced in the template that are not
 *   defined in `instanceProps` will be notified up to the template's host
 *   automatically.
 * - `instanceProps`: Dictionary of property names that will be added
 *   to the instance by the templatize owner.  These properties shadow any
 *   host properties, and changes within the template to these properties
 *   will result in `notifyInstanceProp` being called.
 * - `mutableData`: When `true`, the generated class will skip strict
 *   dirty-checking for objects and arrays (always consider them to be
 *   "dirty").
 * - `notifyInstanceProp(instance, property, value)`: Called when
 *   an instance property changes.  Users may choose to call `notifyPath`
 *   on e.g. the owner to notify the change.
 * - `parentModel`: When `true`, events handled by declarative event listeners
 *   (`on-event="handler"`) will be decorated with a `model` property pointing
 *   to the template instance that stamped it.  It will also be returned
 *   from `instance.parentModel` in cases where template instance nesting
 *   causes an inner model to shadow an outer model.
 *
 * All callbacks are called bound to the `owner`. Any context
 * needed for the callbacks (such as references to `instances` stamped)
 * should be stored on the `owner` such that they can be retrieved via
 * `this`.
 *
 * When `options.forwardHostProp` is declared as an option, any properties
 * referenced in the template will be automatically forwarded from the host of
 * the `<template>` to instances, with the exception of any properties listed in
 * the `options.instanceProps` object.  `instanceProps` are assumed to be
 * managed by the owner of the instances, either passed into the constructor
 * or set after the fact.  Note, any properties passed into the constructor will
 * always be set to the instance (regardless of whether they would normally
 * be forwarded from the host).
 *
 * Note that `templatize()` can be run only once for a given `<template>`.
 * Further calls will result in an error. Also, there is a special
 * behavior if the template was duplicated through a mechanism such as
 * `<dom-repeat>` or `<test-fixture>`. In this case, all calls to
 * `templatize()` return the same class for all duplicates of a template.
 * The class returned from `templatize()` is generated only once using
 * the `options` from the first call. This means that any `options`
 * provided to subsequent calls will be ignored. Therefore, it is very
 * important not to close over any variables inside the callbacks. Also,
 * arrow functions must be avoided because they bind the outer `this`.
 * Inside the callbacks, any contextual information can be accessed
 * through `this`, which points to the `owner`.
 *
 * @param {!HTMLTemplateElement} template Template to templatize
 * @param {Polymer_PropertyEffects=} owner Owner of the template instances;
 *   any optional callbacks will be bound to this owner.
 * @param {Object=} options Options dictionary (see summary for details)
 * @return {function(new:TemplateInstanceBase, Object=)} Generated class bound
 *   to the template provided
 * @suppress {invalidCasts}
 */ parcelHelpers.export(exports, "templatize", ()=>templatize
);
/**
 * Returns the template "model" associated with a given element, which
 * serves as the binding scope for the template instance the element is
 * contained in. A template model is an instance of
 * `TemplateInstanceBase`, and should be used to manipulate data
 * associated with this template instance.
 *
 * Example:
 *
 *   let model = modelForElement(el);
 *   if (model.index < 10) {
 *     model.set('item.checked', true);
 *   }
 *
 * @param {HTMLElement} template The model will be returned for
 *   elements stamped from this template (accepts either an HTMLTemplateElement)
 *   or a `<dom-if>`/`<dom-repeat>` element when using `removeNestedTemplates`
 *   optimization.
 * @param {Node=} node Node for which to return a template model.
 * @return {TemplateInstanceBase} Template instance representing the
 *   binding scope for the element
 */ parcelHelpers.export(exports, "modelForElement", ()=>modelForElement
);
parcelHelpers.export(exports, "TemplateInstanceBase", ()=>TemplateInstanceBase
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ /**
 * Module for preparing and stamping instances of templates that utilize
 * Polymer's data-binding and declarative event listener features.
 *
 * Example:
 *
 *     // Get a template from somewhere, e.g. light DOM
 *     let template = this.querySelector('template');
 *     // Prepare the template
 *     let TemplateClass = Templatize.templatize(template);
 *     // Instance the template with an initial data model
 *     let instance = new TemplateClass({myProp: 'initial'});
 *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM
 *     this.shadowRoot.appendChild(instance.root);
 *     // Changing a property on the instance will propagate to bindings
 *     // in the template
 *     instance.myProp = 'new value';
 *
 * The `options` dictionary passed to `templatize` allows for customizing
 * features of the generated template class, including how outer-scope host
 * properties should be forwarded into template instances, how any instance
 * properties added into the template's scope should be notified out to
 * the host, and whether the instance should be decorated as a "parent model"
 * of any event handlers.
 *
 *     // Customize property forwarding and event model decoration
 *     let TemplateClass = Templatize.templatize(template, this, {
 *       parentModel: true,
 *       forwardHostProp(property, value) {...},
 *       instanceProps: {...},
 *       notifyInstanceProp(instance, property, value) {...},
 *     });
 *
 * @summary Module for preparing and stamping instances of templates
 *   utilizing Polymer templating features.
 */ var _bootJs = require("./boot.js");
var _propertyEffectsJs = require("../mixins/property-effects.js");
var _mutableDataJs = require("../mixins/mutable-data.js");
var _settingsJs = require("./settings.js");
var _wrapJs = require("./wrap.js");
// Base class for HTMLTemplateElement extension that has property effects
// machinery for propagating host properties to children. This is an ES5
// class only because Babel (incorrectly) requires super() in the class
// constructor even though no `this` is used and it returns an instance.
let newInstance = null;
/**
 * @constructor
 * @extends {HTMLTemplateElement}
 * @private
 */ function HTMLTemplateElementExtension() {
    return newInstance;
}
HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
    constructor: {
        value: HTMLTemplateElementExtension,
        writable: true
    }
});
/**
 * @constructor
 * @implements {Polymer_PropertyEffects}
 * @extends {HTMLTemplateElementExtension}
 * @private
 */ const DataTemplate = _propertyEffectsJs.PropertyEffects(HTMLTemplateElementExtension);
/**
 * @constructor
 * @implements {Polymer_MutableData}
 * @extends {DataTemplate}
 * @private
 */ const MutableDataTemplate = _mutableDataJs.MutableData(DataTemplate);
// Applies a DataTemplate subclass to a <template> instance
function upgradeTemplate(template, constructor) {
    newInstance = template;
    Object.setPrototypeOf(template, constructor.prototype);
    new constructor();
    newInstance = null;
}
/**
 * Base class for TemplateInstance.
 * @constructor
 * @extends {HTMLElement}
 * @implements {Polymer_PropertyEffects}
 * @private
 */ const templateInstanceBase = _propertyEffectsJs.PropertyEffects(class {
});
function showHideChildren(hide, children) {
    for(let i = 0; i < children.length; i++){
        let n = children[i];
        // Ignore non-changes
        if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
            // clear and restore text
            if (n.nodeType === Node.TEXT_NODE) {
                if (hide) {
                    n.__polymerTextContent__ = n.textContent;
                    n.textContent = '';
                } else n.textContent = n.__polymerTextContent__;
            } else if (n.localName === 'slot') {
                if (hide) {
                    n.__polymerReplaced__ = document.createComment('hidden-slot');
                    _wrapJs.wrap(_wrapJs.wrap(n).parentNode).replaceChild(n.__polymerReplaced__, n);
                } else {
                    const replace = n.__polymerReplaced__;
                    if (replace) _wrapJs.wrap(_wrapJs.wrap(replace).parentNode).replaceChild(n, replace);
                }
            } else if (n.style) {
                if (hide) {
                    n.__polymerDisplay__ = n.style.display;
                    n.style.display = 'none';
                } else n.style.display = n.__polymerDisplay__;
            }
        }
        n.__hideTemplateChildren__ = hide;
        if (n._showHideChildren) n._showHideChildren(hide);
    }
}
/**
 * @polymer
 * @customElement
 * @appliesMixin PropertyEffects
 * @unrestricted
 */ class TemplateInstanceBase extends templateInstanceBase {
    constructor(props){
        super();
        this._configureProperties(props);
        /** @type {!StampedTemplate} */ this.root = this._stampTemplate(this.__dataHost);
        // Save list of stamped children
        let children = [];
        /** @suppress {invalidCasts} */ this.children = children;
        // Polymer 1.x did not use `Polymer.dom` here so not bothering.
        for(let n = this.root.firstChild; n; n = n.nextSibling){
            children.push(n);
            n.__templatizeInstance = this;
        }
        if (this.__templatizeOwner && this.__templatizeOwner.__hideTemplateChildren__) this._showHideChildren(true);
        // Flush props only when props are passed if instance props exist
        // or when there isn't instance props.
        let options = this.__templatizeOptions;
        if (props && options.instanceProps || !options.instanceProps) this._enableProperties();
    }
    /**
   * Configure the given `props` by calling `_setPendingProperty`. Also
   * sets any properties stored in `__hostProps`.
   * @private
   * @param {Object} props Object of property name-value pairs to set.
   * @return {void}
   */ _configureProperties(props) {
        let options = this.__templatizeOptions;
        if (options.forwardHostProp) for(let hprop in this.__hostProps)this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
        // Any instance props passed in the constructor will overwrite host props;
        // normally this would be a user error but we don't specifically filter them
        for(let iprop in props)this._setPendingProperty(iprop, props[iprop]);
    }
    /**
   * Forwards a host property to this instance.  This method should be
   * called on instances from the `options.forwardHostProp` callback
   * to propagate changes of host properties to each instance.
   *
   * Note this method enqueues the change, which are flushed as a batch.
   *
   * @param {string} prop Property or path name
   * @param {*} value Value of the property to forward
   * @return {void}
   */ forwardHostProp(prop, value) {
        if (this._setPendingPropertyOrPath(prop, value, false, true)) this.__dataHost._enqueueClient(this);
    }
    /**
   * Override point for adding custom or simulated event handling.
   *
   * @override
   * @param {!Node} node Node to add event listener to
   * @param {string} eventName Name of event
   * @param {function(!Event):void} handler Listener function to add
   * @return {void}
   */ _addEventListenerToNode(node, eventName, handler) {
        if (this._methodHost && this.__templatizeOptions.parentModel) // If this instance should be considered a parent model, decorate
        // events this template instance as `model`
        this._methodHost._addEventListenerToNode(node, eventName, (e)=>{
            e.model = this;
            handler(e);
        });
        else {
            // Otherwise delegate to the template's host (which could be)
            // another template instance
            let templateHost = this.__dataHost.__dataHost;
            if (templateHost) templateHost._addEventListenerToNode(node, eventName, handler);
        }
    }
    /**
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   * @param {boolean} hide Set to true to hide the children;
   * set to false to show them.
   * @return {void}
   * @protected
   */ _showHideChildren(hide) {
        showHideChildren(hide, this.children);
    }
    /**
   * Overrides default property-effects implementation to intercept
   * textContent bindings while children are "hidden" and cache in
   * private storage for later retrieval.
   *
   * @override
   * @param {!Node} node The node to set a property on
   * @param {string} prop The property to set
   * @param {*} value The value to set
   * @return {void}
   * @protected
   */ _setUnmanagedPropertyToNode(node, prop, value) {
        if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') node.__polymerTextContent__ = value;
        else super._setUnmanagedPropertyToNode(node, prop, value);
    }
    /**
   * Find the parent model of this template instance.  The parent model
   * is either another templatize instance that had option `parentModel: true`,
   * or else the host element.
   *
   * @return {!Polymer_PropertyEffects} The parent model of this instance
   */ get parentModel() {
        let model = this.__parentModel;
        if (!model) {
            let options;
            model = this;
            do // A template instance's `__dataHost` is a <template>
            // `model.__dataHost.__dataHost` is the template's host
            model = model.__dataHost.__dataHost;
            while ((options = model.__templatizeOptions) && !options.parentModel)
            this.__parentModel = model;
        }
        return model;
    }
    /**
   * Stub of HTMLElement's `dispatchEvent`, so that effects that may
   * dispatch events safely no-op.
   *
   * @param {Event} event Event to dispatch
   * @return {boolean} Always true.
   * @override
   */ dispatchEvent(event) {
        return true;
    }
}
/** @type {!DataTemplate} */ TemplateInstanceBase.prototype.__dataHost;
/** @type {!TemplatizeOptions} */ TemplateInstanceBase.prototype.__templatizeOptions;
/** @type {!Polymer_PropertyEffects} */ TemplateInstanceBase.prototype._methodHost;
/** @type {!Object} */ TemplateInstanceBase.prototype.__templatizeOwner;
/** @type {!Object} */ TemplateInstanceBase.prototype.__hostProps;
/**
 * @constructor
 * @extends {TemplateInstanceBase}
 * @implements {Polymer_MutableData}
 * @private
 */ const MutableTemplateInstanceBase = _mutableDataJs.MutableData(TemplateInstanceBase);
function findMethodHost(template) {
    // Technically this should be the owner of the outermost template.
    // In shadow dom, this is always getRootNode().host, but we can
    // approximate this via cooperation with our dataHost always setting
    // `_methodHost` as long as there were bindings (or id's) on this
    // instance causing it to get a dataHost.
    let templateHost = template.__dataHost;
    return templateHost && templateHost._methodHost || templateHost;
}
/* eslint-disable valid-jsdoc */ /**
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */ function createTemplatizerClass(template, templateInfo, options) {
    /**
   * @constructor
   * @extends {TemplateInstanceBase}
   */ let templatizerBase = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase;
    // Affordance for global mixins onto TemplatizeInstance
    if (templatize.mixin) templatizerBase = templatize.mixin(templatizerBase);
    /**
   * Anonymous class created by the templatize
   * @constructor
   * @private
   */ let klass = class extends templatizerBase {
    };
    /** @override */ klass.prototype.__templatizeOptions = options;
    klass.prototype._bindTemplate(template);
    addNotifyEffects(klass, template, templateInfo, options);
    return klass;
}
/**
 * Adds propagate effects from the template to the template instance for
 * properties that the host binds to the template using the `_host_` prefix.
 *
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */ function addPropagateEffects(target, templateInfo, options, methodHost) {
    let userForwardHostProp = options.forwardHostProp;
    if (userForwardHostProp && templateInfo.hasHostProps) {
        // Under the `removeNestedTemplates` optimization, a custom element like
        // `dom-if` or `dom-repeat` can itself be treated as the "template"; this
        // flag is used to switch between upgrading a `<template>` to be a property
        // effects client vs. adding the effects directly to the custom element
        const isTemplate = target.localName == 'template';
        // Provide data API and property effects on memoized template class
        let klass = templateInfo.templatizeTemplateClass;
        if (!klass) {
            if (isTemplate) {
                /**
         * @constructor
         * @extends {DataTemplate}
         */ let templatizedBase = options.mutableData ? MutableDataTemplate : DataTemplate;
                // NOTE: due to https://github.com/google/closure-compiler/issues/2928,
                // combining the next two lines into one assignment causes a spurious
                // type error.
                /** @private */ class TemplatizedTemplate extends templatizedBase {
                }
                klass = templateInfo.templatizeTemplateClass = TemplatizedTemplate;
            } else {
                /**
         * @constructor
         * @extends {PolymerElement}
         */ const templatizedBase = target.constructor;
                // Create a cached subclass of the base custom element class onto which
                // to put the template-specific propagate effects
                // NOTE: due to https://github.com/google/closure-compiler/issues/2928,
                // combining the next two lines into one assignment causes a spurious
                // type error.
                /** @private */ class TemplatizedTemplateExtension extends templatizedBase {
                }
                klass = templateInfo.templatizeTemplateClass = TemplatizedTemplateExtension;
            }
            // Add template - >instances effects
            // and host <- template effects
            let hostProps = templateInfo.hostProps;
            for(let prop in hostProps){
                klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, {
                    fn: createForwardHostPropEffect(prop, userForwardHostProp)
                });
                klass.prototype._createNotifyingProperty('_host_' + prop);
            }
            if (_settingsJs.legacyWarnings && methodHost) warnOnUndeclaredProperties(templateInfo, options, methodHost);
        }
        // Mix any pre-bound data into __data; no need to flush this to
        // instances since they pull from the template at instance-time
        if (target.__dataProto) // Note, generally `__dataProto` could be chained, but it's guaranteed
        // to not be since this is a vanilla template we just added effects to
        Object.assign(target.__data, target.__dataProto);
        if (isTemplate) {
            upgradeTemplate(target, klass);
            // Clear any pending data for performance
            target.__dataTemp = {
            };
            target.__dataPending = null;
            target.__dataOld = null;
            target._enableProperties();
        } else {
            // Swizzle the cached subclass prototype onto the custom element
            Object.setPrototypeOf(target, klass.prototype);
            // Check for any pre-bound instance host properties, and do the
            // instance property delete/assign dance for those (directly into data;
            // not need to go through accessor since they are pulled at instance time)
            const hostProps = templateInfo.hostProps;
            for(let prop in hostProps){
                prop = '_host_' + prop;
                if (prop in target) {
                    const val = target[prop];
                    delete target[prop];
                    target.__data[prop] = val;
                }
            }
        }
    }
}
/* eslint-enable valid-jsdoc */ function createForwardHostPropEffect(hostProp, userForwardHostProp) {
    return function forwardHostProp(template, prop, props) {
        userForwardHostProp.call(template.__templatizeOwner, prop.substring(6), props[prop]);
    };
}
function addNotifyEffects(klass, template, templateInfo, options) {
    let hostProps = templateInfo.hostProps || {
    };
    for(let iprop in options.instanceProps){
        delete hostProps[iprop];
        let userNotifyInstanceProp = options.notifyInstanceProp;
        if (userNotifyInstanceProp) klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, {
            fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp)
        });
    }
    if (options.forwardHostProp && template.__dataHost) for(let hprop in hostProps){
        // As we're iterating hostProps in this function, note whether
        // there were any, for an optimization in addPropagateEffects
        if (!templateInfo.hasHostProps) templateInfo.hasHostProps = true;
        klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, {
            fn: createNotifyHostPropEffect()
        });
    }
}
function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
    return function notifyInstanceProp(inst, prop, props) {
        userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);
    };
}
function createNotifyHostPropEffect() {
    return function notifyHostProp(inst, prop, props) {
        inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
    };
}
function templatize(template, owner, options) {
    // Under strictTemplatePolicy, the templatized element must be owned
    // by a (trusted) Polymer element, indicated by existence of _methodHost;
    // e.g. for dom-if & dom-repeat in main document, _methodHost is null
    if (_settingsJs.strictTemplatePolicy && !findMethodHost(template)) throw new Error('strictTemplatePolicy: template owner not trusted');
    options = options || {
    };
    if (template.__templatizeOwner) throw new Error('A <template> can only be templatized once');
    template.__templatizeOwner = owner;
    const ctor = owner ? owner.constructor : TemplateInstanceBase;
    let templateInfo = ctor._parseTemplate(template);
    // Get memoized base class for the prototypical template, which
    // includes property effects for binding template & forwarding
    /**
   * @constructor
   * @extends {TemplateInstanceBase}
   */ let baseClass = templateInfo.templatizeInstanceClass;
    if (!baseClass) {
        baseClass = createTemplatizerClass(template, templateInfo, options);
        templateInfo.templatizeInstanceClass = baseClass;
    }
    const methodHost = findMethodHost(template);
    // Host property forwarding must be installed onto template instance
    addPropagateEffects(template, templateInfo, options, methodHost);
    // Subclass base class and add reference for this specific template
    /** @private */ let klass = class TemplateInstance extends baseClass {
    };
    /** @override */ klass.prototype._methodHost = methodHost;
    /** @override */ klass.prototype.__dataHost = template;
    /** @override */ klass.prototype.__templatizeOwner = owner;
    /** @override */ klass.prototype.__hostProps = templateInfo.hostProps;
    return klass;
}
function warnOnUndeclaredProperties(templateInfo, options, methodHost) {
    const declaredProps = methodHost.constructor._properties;
    const { propertyEffects  } = templateInfo;
    const { instanceProps  } = options;
    for(let prop in propertyEffects)// Ensure properties with template effects are declared on the outermost
    // host (`methodHost`), unless they are instance props or static functions
    if (!declaredProps[prop] && !(instanceProps && instanceProps[prop])) {
        const effects = propertyEffects[prop];
        for(let i = 0; i < effects.length; i++){
            const { part  } = effects[i].info;
            if (!(part.signature && part.signature.static)) {
                console.warn(`Property '${prop}' used in template but not ` + `declared in 'properties'; attribute will not be observed.`);
                break;
            }
        }
    }
}
function modelForElement(template, node) {
    let model;
    while(node)// An element with a __templatizeInstance marks the top boundary
    // of a scope; walk up until we find one, and then ensure that
    // its __dataHost matches `this`, meaning this dom-repeat stamped it
    if (model = node.__dataHost ? node : node.__templatizeInstance) {
        // Found an element stamped by another template; keep walking up
        // from its __dataHost
        if (model.__dataHost != template) node = model.__dataHost;
        else return model;
    } else // Still in a template scope, keep going up until
    // a __templatizeInstance is found
    node = _wrapJs.wrap(node).parentNode;
    return null;
}

},{"./boot.js":"gVNgb","../mixins/property-effects.js":"fKH56","../mixins/mutable-data.js":"2HzJg","./settings.js":"44bo5","./wrap.js":"cQBlD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2HzJg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MutableData", ()=>MutableData
);
parcelHelpers.export(exports, "OptionalMutableData", ()=>OptionalMutableData
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _mixinJs = require("../utils/mixin.js");
// Common implementation for mixin & behavior
function mutablePropertyChange(inst, property, value, old, mutableData) {
    let isObject;
    if (mutableData) {
        isObject = typeof value === 'object' && value !== null;
        // Pull `old` for Objects from temp cache, but treat `null` as a primitive
        if (isObject) old = inst.__dataTemp[property];
    }
    // Strict equality check, but return false for NaN===NaN
    let shouldChange = old !== value && (old === old || value === value);
    // Objects are stored in temporary cache (cleared at end of
    // turn), which is used for dirty-checking
    if (isObject && shouldChange) inst.__dataTemp[property] = value;
    return shouldChange;
}
const MutableData = _mixinJs.dedupingMixin((superClass)=>{
    /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_MutableData}
   */ class MutableData1 extends superClass {
        /**
     * Overrides `PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * This method pulls the value to dirty check against from the `__dataTemp`
     * cache (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */ _shouldPropertyChange(property, value, old) {
            return mutablePropertyChange(this, property, value, old, true);
        }
    }
    return MutableData1;
});
const OptionalMutableData = _mixinJs.dedupingMixin((superClass)=>{
    /**
   * @mixinClass
   * @polymer
   * @implements {Polymer_OptionalMutableData}
   */ class OptionalMutableData1 extends superClass {
        /** @nocollapse */ static get properties() {
            return {
                /**
         * Instance-level flag for configuring the dirty-checking strategy
         * for this element.  When true, Objects and Arrays will skip dirty
         * checking, otherwise strict equality checking will be used.
         */ mutableData: Boolean
            };
        }
        /**
     * Overrides `PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * When `this.mutableData` is true on this instance, this method
     * pulls the value to dirty check against from the `__dataTemp` cache
     * (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */ _shouldPropertyChange(property, value, old) {
            return mutablePropertyChange(this, property, value, old, this.mutableData);
        }
    }
    return OptionalMutableData1;
});
// Export for use by legacy behavior
MutableData._mutablePropertyChange = mutablePropertyChange;

},{"../utils/mixin.js":"488pD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cW7Ly":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Custom element to allow using Polymer's template features (data binding,
 * declarative event listeners, etc.) in the main document without defining
 * a new custom element.
 *
 * `<template>` tags utilizing bindings may be wrapped with the `<dom-bind>`
 * element, which will immediately stamp the wrapped template into the main
 * document and bind elements to the `dom-bind` element itself as the
 * binding scope.
 *
 * @polymer
 * @customElement
 * @appliesMixin PropertyEffects
 * @appliesMixin OptionalMutableData
 * @appliesMixin GestureEventListeners
 * @extends {domBindBase}
 * @summary Custom element to allow using Polymer's template features (data
 *   binding, declarative event listeners, etc.) in the main document.
 */ parcelHelpers.export(exports, "DomBind", ()=>DomBind
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("../utils/boot.js");
var _propertyEffectsJs = require("../mixins/property-effects.js");
var _mutableDataJs = require("../mixins/mutable-data.js");
var _gestureEventListenersJs = require("../mixins/gesture-event-listeners.js");
var _settingsJs = require("../utils/settings.js");
var _wrapJs = require("../utils/wrap.js");
var _hideTemplateControlsJs = require("../utils/hide-template-controls.js");
/**
 * @constructor
 * @extends {HTMLElement}
 * @implements {Polymer_PropertyEffects}
 * @implements {Polymer_OptionalMutableData}
 * @implements {Polymer_GestureEventListeners}
 * @private
 */ const domBindBase = _gestureEventListenersJs.GestureEventListeners(_mutableDataJs.OptionalMutableData(_propertyEffectsJs.PropertyEffects(HTMLElement)));
class DomBind extends domBindBase {
    static get observedAttributes() {
        return [
            'mutable-data'
        ];
    }
    constructor(){
        super();
        if (_settingsJs.strictTemplatePolicy) throw new Error(`strictTemplatePolicy: dom-bind not allowed`);
        this.root = null;
        this.$ = null;
        this.__children = null;
    }
    /* eslint-disable no-unused-vars */ /**
   * @override
   * @param {string} name Name of attribute that changed
   * @param {?string} old Old attribute value
   * @param {?string} value New attribute value
   * @param {?string} namespace Attribute namespace.
   * @return {void}
   */ attributeChangedCallback(name, old, value, namespace) {
        // assumes only one observed attribute
        this.mutableData = true;
    }
    /**
   * @override
   * @return {void}
   */ connectedCallback() {
        if (!_hideTemplateControlsJs.hideElementsGlobally()) this.style.display = 'none';
        this.render();
    }
    /**
   * @override
   * @return {void}
   */ disconnectedCallback() {
        this.__removeChildren();
    }
    __insertChildren() {
        _wrapJs.wrap(_wrapJs.wrap(this).parentNode).insertBefore(this.root, this);
    }
    __removeChildren() {
        if (this.__children) for(let i = 0; i < this.__children.length; i++)this.root.appendChild(this.__children[i]);
    }
    /**
   * Forces the element to render its content. This is typically only
   * necessary to call if HTMLImports with the async attribute are used.
   * @return {void}
   */ render() {
        let template;
        if (!this.__children) {
            template = template || this.querySelector('template');
            if (!template) {
                // Wait until childList changes and template should be there by then
                let observer = new MutationObserver(()=>{
                    template = this.querySelector('template');
                    if (template) {
                        observer.disconnect();
                        this.render();
                    } else throw new Error('dom-bind requires a <template> child');
                });
                observer.observe(this, {
                    childList: true
                });
                return;
            }
            this.root = this._stampTemplate(template);
            this.$ = this.root.$;
            this.__children = [];
            for(let n = this.root.firstChild; n; n = n.nextSibling)this.__children[this.__children.length] = n;
            this._enableProperties();
        }
        this.__insertChildren();
        this.dispatchEvent(new CustomEvent('dom-change', {
            bubbles: true,
            composed: true
        }));
    }
}
customElements.define('dom-bind', DomBind);

},{"../utils/boot.js":"gVNgb","../mixins/property-effects.js":"fKH56","../mixins/mutable-data.js":"2HzJg","../mixins/gesture-event-listeners.js":"fN0Ep","../utils/settings.js":"44bo5","../utils/wrap.js":"cQBlD","../utils/hide-template-controls.js":"a96Zj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a96Zj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @return {boolean} True if elements will be hidden globally
 */ parcelHelpers.export(exports, "hideElementsGlobally", ()=>hideElementsGlobally
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ /**
 * @fileoverview
 *
 * Module to hide `<dom-bind>`, `<dom-if>`, and `<dom-repeat>` elements
 * optimally in ShadyDOM
 */ var _settingsJs = require("./settings.js");
let elementsHidden = false;
function hideElementsGlobally() {
    if (_settingsJs.legacyOptimizations && !_settingsJs.useShadow) {
        if (!elementsHidden) {
            elementsHidden = true;
            const style = document.createElement('style');
            style.textContent = 'dom-bind,dom-if,dom-repeat{display:none;}';
            document.head.appendChild(style);
        }
        return true;
    }
    return false;
}

},{"./settings.js":"44bo5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g0rSr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The `<dom-repeat>` element will automatically stamp and binds one instance
 * of template content to each object in a user-provided array.
 * `dom-repeat` accepts an `items` property, and one instance of the template
 * is stamped for each item into the DOM at the location of the `dom-repeat`
 * element.  The `item` property will be set on each instance's binding
 * scope, thus templates should bind to sub-properties of `item`.
 *
 * Example:
 *
 * ```html
 * <dom-module id="employee-list">
 *
 *   <template>
 *
 *     <div> Employee list: </div>
 *     <dom-repeat items="{{employees}}">
 *       <template>
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *       </template>
 *     </dom-repeat>
 *
 *   </template>
 *
 * </dom-module>
 * ```
 *
 * With the following custom element definition:
 *
 * ```js
 * class EmployeeList extends PolymerElement {
 *   static get is() { return 'employee-list'; }
 *   static get properties() {
 *     return {
 *       employees: {
 *         value() {
 *           return [
 *             {first: 'Bob', last: 'Smith'},
 *             {first: 'Sally', last: 'Johnson'},
 *             ...
 *           ];
 *         }
 *       }
 *     };
 *   }
 * }
 * ```
 *
 * Notifications for changes to items sub-properties will be forwarded to template
 * instances, which will update via the normal structured data notification system.
 *
 * Mutations to the `items` array itself should be made using the Array
 * mutation API's on the PropertyEffects mixin (`push`, `pop`, `splice`,
 * `shift`, `unshift`), and template instances will be kept in sync with the
 * data in the array.
 *
 * Events caught by event handlers within the `dom-repeat` template will be
 * decorated with a `model` property, which represents the binding scope for
 * each template instance.  The model should be used to manipulate data on the
 * instance, for example `event.model.set('item.checked', true);`.
 *
 * Alternatively, the model for a template instance for an element stamped by
 * a `dom-repeat` can be obtained using the `modelForElement` API on the
 * `dom-repeat` that stamped it, for example
 * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.
 * This may be useful for manipulating instance data of event targets obtained
 * by event handlers on parents of the `dom-repeat` (event delegation).
 *
 * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a
 * `filter` and/or `sort` property.  This may be a string that names a function on
 * the host, or a function may be assigned to the property directly.  The functions
 * should implemented following the standard `Array` filter/sort API.
 *
 * In order to re-run the filter or sort functions based on changes to sub-fields
 * of `items`, the `observe` property may be set as a space-separated list of
 * `item` sub-fields that should cause a re-filter/sort when modified.  If
 * the filter or sort function depends on properties not contained in `items`,
 * the user should observe changes to those properties and call `render` to update
 * the view based on the dependency change.
 *
 * For example, for an `dom-repeat` with a filter of the following:
 *
 * ```js
 * isEngineer(item) {
 *   return item.type == 'engineer' || item.manager.type == 'engineer';
 * }
 * ```
 *
 * Then the `observe` property should be configured as follows:
 *
 * ```html
 * <dom-repeat items="{{employees}}" filter="isEngineer" observe="type manager.type">
 * ```
 *
 * @customElement
 * @polymer
 * @extends {domRepeatBase}
 * @appliesMixin OptionalMutableData
 * @summary Custom element for stamping instance of a template bound to
 *   items in an array.
 */ parcelHelpers.export(exports, "DomRepeat", ()=>DomRepeat
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _polymerElementJs = require("../../polymer-element.js");
var _templatizeJs = require("../utils/templatize.js"); // eslint-disable-line no-unused-vars
var _debounceJs = require("../utils/debounce.js");
var _flushJs = require("../utils/flush.js");
var _mutableDataJs = require("../mixins/mutable-data.js");
var _pathJs = require("../utils/path.js");
var _asyncJs = require("../utils/async.js");
var _wrapJs = require("../utils/wrap.js");
var _hideTemplateControlsJs = require("../utils/hide-template-controls.js");
var _settingsJs = require("../utils/settings.js");
/**
 * @constructor
 * @implements {Polymer_OptionalMutableData}
 * @extends {PolymerElement}
 * @private
 */ const domRepeatBase = _mutableDataJs.OptionalMutableData(_polymerElementJs.PolymerElement);
class DomRepeat extends domRepeatBase {
    // Not needed to find template; can be removed once the analyzer
    // can find the tag name from customElements.define call
    static get is() {
        return 'dom-repeat';
    }
    static get template() {
        return null;
    }
    static get properties() {
        /**
     * Fired whenever DOM is added or removed by this template (by
     * default, rendering occurs lazily).  To force immediate rendering, call
     * `render`.
     *
     * @event dom-change
     */ return {
            /**
       * An array containing items determining how many instances of the template
       * to stamp and that that each template instance should bind to.
       */ items: {
                type: Array
            },
            /**
       * The name of the variable to add to the binding scope for the array
       * element associated with a given template instance.
       */ as: {
                type: String,
                value: 'item'
            },
            /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the sorted and filtered list of rendered items.
       * Note, for the index in the `this.items` array, use the value of the
       * `itemsIndexAs` property.
       */ indexAs: {
                type: String,
                value: 'index'
            },
            /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the `this.items` array. Note, for the index of
       * this instance in the sorted and filtered list of rendered items,
       * use the value of the `indexAs` property.
       */ itemsIndexAs: {
                type: String,
                value: 'itemsIndex'
            },
            /**
       * A function that should determine the sort order of the items.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.sort`.
       * Using a sort function has no effect on the underlying `items` array.
       */ sort: {
                type: Function,
                observer: '__sortChanged'
            },
            /**
       * A function that can be used to filter items out of the view.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.filter`.
       * Using a filter function has no effect on the underlying `items` array.
       */ filter: {
                type: Function,
                observer: '__filterChanged'
            },
            /**
       * When using a `filter` or `sort` function, the `observe` property
       * should be set to a space-separated list of the names of item
       * sub-fields that should trigger a re-sort or re-filter when changed.
       * These should generally be fields of `item` that the sort or filter
       * function depends on.
       */ observe: {
                type: String,
                observer: '__observeChanged'
            },
            /**
       * When using a `filter` or `sort` function, the `delay` property
       * determines a debounce time in ms after a change to observed item
       * properties that must pass before the filter or sort is re-run.
       * This is useful in rate-limiting shuffling of the view when
       * item changes may be frequent.
       */ delay: Number,
            /**
       * Count of currently rendered items after `filter` (if any) has been applied.
       * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
       * set of template instances is rendered.
       *
       */ renderedItemCount: {
                type: Number,
                notify: !_settingsJs.suppressTemplateNotifications,
                readOnly: true
            },
            /**
       * When greater than zero, defines an initial count of template instances
       * to render after setting the `items` array, before the next paint, and
       * puts the `dom-repeat` into "chunking mode".  The remaining items (and
       * any future items as a result of pushing onto the array) will be created
       * and rendered incrementally at each animation frame thereof until all
       * instances have been rendered.
       */ initialCount: {
                type: Number
            },
            /**
       * When `initialCount` is used, this property defines a frame rate (in
       * fps) to target by throttling the number of instances rendered each
       * frame to not exceed the budget for the target frame rate.  The
       * framerate is effectively the number of `requestAnimationFrame`s that
       * it tries to allow to actually fire in a given second. It does this
       * by measuring the time between `rAF`s and continuously adjusting the
       * number of items created each `rAF` to maintain the target framerate.
       * Setting this to a higher number allows lower latency and higher
       * throughput for event handlers and other tasks, but results in a
       * longer time for the remaining items to complete rendering.
       */ targetFramerate: {
                type: Number,
                value: 20
            },
            _targetFrameTime: {
                type: Number,
                computed: '__computeFrameTime(targetFramerate)'
            },
            /**
       * When the global `suppressTemplateNotifications` setting is used, setting
       * `notifyDomChange: true` will enable firing `dom-change` events on this
       * element.
       */ notifyDomChange: {
                type: Boolean
            },
            /**
       * When chunking is enabled via `initialCount` and the `items` array is
       * set to a new array, this flag controls whether the previously rendered
       * instances are reused or not.
       *
       * When `true`, any previously rendered template instances are updated in
       * place to their new item values synchronously in one shot, and then any
       * further items (if any) are chunked out.  When `false`, the list is
       * returned back to its `initialCount` (any instances over the initial
       * count are discarded) and the remainder of the list is chunked back in.
       * Set this to `true` to avoid re-creating the list and losing scroll
       * position, although note that when changing the list to completely
       * different data the render thread will be blocked until all existing
       * instances are updated to their new data.
       */ reuseChunkedInstances: {
                type: Boolean
            }
        };
    }
    static get observers() {
        return [
            '__itemsChanged(items.*)'
        ];
    }
    constructor(){
        super();
        this.__instances = [];
        this.__renderDebouncer = null;
        this.__itemsIdxToInstIdx = {
        };
        this.__chunkCount = null;
        this.__renderStartTime = null;
        this.__itemsArrayChanged = false;
        this.__shouldMeasureChunk = false;
        this.__shouldContinueChunking = false;
        this.__chunkingId = 0;
        this.__sortFn = null;
        this.__filterFn = null;
        this.__observePaths = null;
        /** @type {?function(new:TemplateInstanceBase, Object=)} */ this.__ctor = null;
        this.__isDetached = true;
        this.template = null;
        /** @type {TemplateInfo} */ this._templateInfo;
    }
    /**
   * @override
   * @return {void}
   */ disconnectedCallback() {
        super.disconnectedCallback();
        this.__isDetached = true;
        for(let i = 0; i < this.__instances.length; i++)this.__detachInstance(i);
        // Stop chunking if one was in progress
        if (this.__chunkingId) cancelAnimationFrame(this.__chunkingId);
    }
    /**
   * @override
   * @return {void}
   */ connectedCallback() {
        super.connectedCallback();
        if (!_hideTemplateControlsJs.hideElementsGlobally()) this.style.display = 'none';
        // only perform attachment if the element was previously detached.
        if (this.__isDetached) {
            this.__isDetached = false;
            let wrappedParent = _wrapJs.wrap(_wrapJs.wrap(this).parentNode);
            for(let i = 0; i < this.__instances.length; i++)this.__attachInstance(i, wrappedParent);
            // Restart chunking if one was in progress when disconnected
            if (this.__chunkingId) this.__render();
        }
    }
    __ensureTemplatized() {
        // Templatizing (generating the instance constructor) needs to wait
        // until ready, since won't have its template content handed back to
        // it until then
        if (!this.__ctor) {
            // When `removeNestedTemplates` is true, the "template" is the element
            // itself, which has been given a `_templateInfo` property
            const thisAsTemplate = this;
            let template = this.template = thisAsTemplate._templateInfo ? thisAsTemplate : this.querySelector('template');
            if (!template) {
                // Wait until childList changes and template should be there by then
                let observer = new MutationObserver(()=>{
                    if (this.querySelector('template')) {
                        observer.disconnect();
                        this.__render();
                    } else throw new Error('dom-repeat requires a <template> child');
                });
                observer.observe(this, {
                    childList: true
                });
                return false;
            }
            // Template instance props that should be excluded from forwarding
            let instanceProps = {
            };
            instanceProps[this.as] = true;
            instanceProps[this.indexAs] = true;
            instanceProps[this.itemsIndexAs] = true;
            this.__ctor = _templatizeJs.templatize(template, this, {
                mutableData: this.mutableData,
                parentModel: true,
                instanceProps: instanceProps,
                /**
         * @this {DomRepeat}
         * @param {string} prop Property to set
         * @param {*} value Value to set property to
         */ forwardHostProp: function(prop, value) {
                    let i$ = this.__instances;
                    for(let i = 0, inst; i < i$.length && (inst = i$[i]); i++)inst.forwardHostProp(prop, value);
                },
                /**
         * @this {DomRepeat}
         * @param {Object} inst Instance to notify
         * @param {string} prop Property to notify
         * @param {*} value Value to notify
         */ notifyInstanceProp: function(inst, prop, value) {
                    if (_pathJs.matches(this.as, prop)) {
                        let idx = inst[this.itemsIndexAs];
                        if (prop == this.as) this.items[idx] = value;
                        let path = _pathJs.translate(this.as, `${JSCompiler_renameProperty('items', this)}.${idx}`, prop);
                        this.notifyPath(path, value);
                    }
                }
            });
        }
        return true;
    }
    __getMethodHost() {
        // Technically this should be the owner of the outermost template.
        // In shadow dom, this is always getRootNode().host, but we can
        // approximate this via cooperation with our dataHost always setting
        // `_methodHost` as long as there were bindings (or id's) on this
        // instance causing it to get a dataHost.
        return this.__dataHost._methodHost || this.__dataHost;
    }
    __functionFromPropertyValue(functionOrMethodName) {
        if (typeof functionOrMethodName === 'string') {
            let methodName = functionOrMethodName;
            let obj = this.__getMethodHost();
            return function() {
                return obj[methodName].apply(obj, arguments);
            };
        }
        return functionOrMethodName;
    }
    __sortChanged(sort) {
        this.__sortFn = this.__functionFromPropertyValue(sort);
        if (this.items) this.__debounceRender(this.__render);
    }
    __filterChanged(filter) {
        this.__filterFn = this.__functionFromPropertyValue(filter);
        if (this.items) this.__debounceRender(this.__render);
    }
    __computeFrameTime(rate) {
        return Math.ceil(1000 / rate);
    }
    __observeChanged() {
        this.__observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
    }
    __handleObservedPaths(path) {
        // Handle cases where path changes should cause a re-sort/filter
        if (this.__sortFn || this.__filterFn) {
            if (!path) // Always re-render if the item itself changed
            this.__debounceRender(this.__render, this.delay);
            else if (this.__observePaths) {
                // Otherwise, re-render if the path changed matches an observed path
                let paths = this.__observePaths;
                for(let i = 0; i < paths.length; i++)if (path.indexOf(paths[i]) === 0) this.__debounceRender(this.__render, this.delay);
            }
        }
    }
    __itemsChanged(change) {
        if (this.items && !Array.isArray(this.items)) console.warn('dom-repeat expected array for `items`, found', this.items);
        // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the
        // path to that instance synchronously (returns false for non-item paths)
        if (!this.__handleItemPath(change.path, change.value)) {
            // Otherwise, the array was reset ('items') or spliced ('items.splices'),
            // so queue a render.  Restart chunking when the items changed (for
            // backward compatibility), unless `reuseChunkedInstances` option is set
            if (change.path === 'items') this.__itemsArrayChanged = true;
            this.__debounceRender(this.__render);
        }
    }
    /**
   * @param {function(this:DomRepeat)} fn Function to debounce.
   * @param {number=} delay Delay in ms to debounce by.
   */ __debounceRender(fn, delay = 0) {
        this.__renderDebouncer = _debounceJs.Debouncer.debounce(this.__renderDebouncer, delay > 0 ? _asyncJs.timeOut.after(delay) : _asyncJs.microTask, fn.bind(this));
        _flushJs.enqueueDebouncer(this.__renderDebouncer);
    }
    /**
   * Forces the element to render its content. Normally rendering is
   * asynchronous to a provoking change. This is done for efficiency so
   * that multiple changes trigger only a single render. The render method
   * should be called if, for example, template rendering is required to
   * validate application state.
   * @return {void}
   */ render() {
        // Queue this repeater, then flush all in order
        this.__debounceRender(this.__render);
        _flushJs.flush();
    }
    __render() {
        if (!this.__ensureTemplatized()) // No template found yet
        return;
        let items = this.items || [];
        // Sort and filter the items into a mapping array from instance->item
        const isntIdxToItemsIdx = this.__sortAndFilterItems(items);
        // If we're chunking, increase the limit if there are new instances to
        // create and schedule the next chunk
        const limit = this.__calculateLimit(isntIdxToItemsIdx.length);
        // Create, update, and/or remove instances
        this.__updateInstances(items, limit, isntIdxToItemsIdx);
        // If we're chunking, schedule a rAF task to measure/continue chunking.     
        // Do this before any notifying events (renderedItemCount & dom-change)
        // since those could modify items and enqueue a new full render which will
        // pre-empt this measurement.
        if (this.initialCount && (this.__shouldMeasureChunk || this.__shouldContinueChunking)) {
            cancelAnimationFrame(this.__chunkingId);
            this.__chunkingId = requestAnimationFrame(()=>{
                this.__chunkingId = null;
                this.__continueChunking();
            });
        }
        // Set rendered item count
        this._setRenderedItemCount(this.__instances.length);
        // Notify users
        if (!_settingsJs.suppressTemplateNotifications || this.notifyDomChange) this.dispatchEvent(new CustomEvent('dom-change', {
            bubbles: true,
            composed: true
        }));
    }
    __sortAndFilterItems(items) {
        // Generate array maping the instance index to the items array index
        let isntIdxToItemsIdx = new Array(items.length);
        for(let i = 0; i < items.length; i++)isntIdxToItemsIdx[i] = i;
        // Apply user filter
        if (this.__filterFn) isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i, idx, array)=>this.__filterFn(items[i], idx, array)
        );
        // Apply user sort
        if (this.__sortFn) isntIdxToItemsIdx.sort((a, b)=>this.__sortFn(items[a], items[b])
        );
        return isntIdxToItemsIdx;
    }
    __calculateLimit(filteredItemCount) {
        let limit = filteredItemCount;
        const currentCount = this.__instances.length;
        // When chunking, we increase the limit from the currently rendered count
        // by the chunk count that is re-calculated after each rAF (with special
        // cases for resetting the limit to initialCount after changing items)
        if (this.initialCount) {
            let newCount;
            if (!this.__chunkCount || this.__itemsArrayChanged && !this.reuseChunkedInstances) {
                // Limit next render to the initial count
                limit = Math.min(filteredItemCount, this.initialCount);
                // Subtract off any existing instances to determine the number of
                // instances that will be created
                newCount = Math.max(limit - currentCount, 0);
                // Initialize the chunk size with how many items we're creating
                this.__chunkCount = newCount || 1;
            } else {
                // The number of new instances that will be created is based on the
                // existing instances, the new list size, and the chunk size
                newCount = Math.min(Math.max(filteredItemCount - currentCount, 0), this.__chunkCount);
                // Update the limit based on how many new items we're making, limited
                // buy the total size of the list
                limit = Math.min(currentCount + newCount, filteredItemCount);
            }
            // Record some state about chunking for use in `__continueChunking`
            this.__shouldMeasureChunk = newCount === this.__chunkCount;
            this.__shouldContinueChunking = limit < filteredItemCount;
            this.__renderStartTime = performance.now();
        }
        this.__itemsArrayChanged = false;
        return limit;
    }
    __continueChunking() {
        // Simple auto chunkSize throttling algorithm based on feedback loop:
        // measure actual time between frames and scale chunk count by ratio of
        // target/actual frame time.  Only modify chunk size if our measurement
        // reflects the cost of a creating a full chunk's worth of instances; this
        // avoids scaling up the chunk size if we e.g. quickly re-rendered instances
        // in place
        if (this.__shouldMeasureChunk) {
            const renderTime = performance.now() - this.__renderStartTime;
            const ratio = this._targetFrameTime / renderTime;
            this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
        }
        // Enqueue a new render if we haven't reached the full size of the list
        if (this.__shouldContinueChunking) this.__debounceRender(this.__render);
    }
    __updateInstances(items, limit, isntIdxToItemsIdx) {
        // items->inst map kept for item path forwarding
        const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {
        };
        let instIdx;
        // Generate instances and assign items
        for(instIdx = 0; instIdx < limit; instIdx++){
            let inst = this.__instances[instIdx];
            let itemIdx = isntIdxToItemsIdx[instIdx];
            let item = items[itemIdx];
            itemsIdxToInstIdx[itemIdx] = instIdx;
            if (inst) {
                inst._setPendingProperty(this.as, item);
                inst._setPendingProperty(this.indexAs, instIdx);
                inst._setPendingProperty(this.itemsIndexAs, itemIdx);
                inst._flushProperties();
            } else this.__insertInstance(item, instIdx, itemIdx);
        }
        // Remove any extra instances from previous state
        for(let i = this.__instances.length - 1; i >= instIdx; i--)this.__detachAndRemoveInstance(i);
    }
    __detachInstance(idx) {
        let inst = this.__instances[idx];
        const wrappedRoot = _wrapJs.wrap(inst.root);
        for(let i = 0; i < inst.children.length; i++){
            let el = inst.children[i];
            wrappedRoot.appendChild(el);
        }
        return inst;
    }
    __attachInstance(idx, parent) {
        let inst = this.__instances[idx];
        // Note, this is pre-wrapped as an optimization
        parent.insertBefore(inst.root, this);
    }
    __detachAndRemoveInstance(idx) {
        this.__detachInstance(idx);
        this.__instances.splice(idx, 1);
    }
    __stampInstance(item, instIdx, itemIdx) {
        let model = {
        };
        model[this.as] = item;
        model[this.indexAs] = instIdx;
        model[this.itemsIndexAs] = itemIdx;
        return new this.__ctor(model);
    }
    __insertInstance(item, instIdx, itemIdx) {
        const inst = this.__stampInstance(item, instIdx, itemIdx);
        let beforeRow = this.__instances[instIdx + 1];
        let beforeNode = beforeRow ? beforeRow.children[0] : this;
        _wrapJs.wrap(_wrapJs.wrap(this).parentNode).insertBefore(inst.root, beforeNode);
        this.__instances[instIdx] = inst;
        return inst;
    }
    // Implements extension point from Templatize mixin
    /**
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   * @param {boolean} hidden Set to true to hide the children;
   * set to false to show them.
   * @return {void}
   * @protected
   */ _showHideChildren(hidden) {
        for(let i = 0; i < this.__instances.length; i++)this.__instances[i]._showHideChildren(hidden);
    }
    // Called as a side effect of a host items.<key>.<path> path change,
    // responsible for notifying item.<path> changes to inst for key
    __handleItemPath(path, value) {
        let itemsPath = path.slice(6); // 'items.'.length == 6
        let dot = itemsPath.indexOf('.');
        let itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
        // If path was index into array...
        if (itemsIdx == parseInt(itemsIdx, 10)) {
            let itemSubPath = dot < 0 ? '' : itemsPath.substring(dot + 1);
            // If the path is observed, it will trigger a full refresh
            this.__handleObservedPaths(itemSubPath);
            // Note, even if a rull refresh is triggered, always do the path
            // notification because unless mutableData is used for dom-repeat
            // and all elements in the instance subtree, a full refresh may
            // not trigger the proper update.
            let instIdx = this.__itemsIdxToInstIdx[itemsIdx];
            let inst = this.__instances[instIdx];
            if (inst) {
                let itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');
                // This is effectively `notifyPath`, but avoids some of the overhead
                // of the public API
                inst._setPendingPropertyOrPath(itemPath, value, false, true);
                inst._flushProperties();
            }
            return true;
        }
    }
    /**
   * Returns the item associated with a given element stamped by
   * this `dom-repeat`.
   *
   * Note, to modify sub-properties of the item,
   * `modelForElement(el).set('item.<sub-prop>', value)`
   * should be used.
   *
   * @param {!HTMLElement} el Element for which to return the item.
   * @return {*} Item associated with the element.
   */ itemForElement(el) {
        let instance = this.modelForElement(el);
        return instance && instance[this.as];
    }
    /**
   * Returns the inst index for a given element stamped by this `dom-repeat`.
   * If `sort` is provided, the index will reflect the sorted order (rather
   * than the original array order).
   *
   * @param {!HTMLElement} el Element for which to return the index.
   * @return {?number} Row index associated with the element (note this may
   *   not correspond to the array index if a user `sort` is applied).
   */ indexForElement(el) {
        let instance = this.modelForElement(el);
        return instance && instance[this.indexAs];
    }
    /**
   * Returns the template "model" associated with a given element, which
   * serves as the binding scope for the template instance the element is
   * contained in. A template model
   * should be used to manipulate data associated with this template instance.
   *
   * Example:
   *
   *   let model = modelForElement(el);
   *   if (model.index < 10) {
   *     model.set('item.checked', true);
   *   }
   *
   * @param {!HTMLElement} el Element for which to return a template model.
   * @return {TemplateInstanceBase} Model representing the binding scope for
   *   the element.
   */ modelForElement(el) {
        return _templatizeJs.modelForElement(this.template, el);
    }
}
customElements.define(DomRepeat.is, DomRepeat);

},{"../../polymer-element.js":"896Hh","../utils/templatize.js":"6QnfM","../utils/debounce.js":"hbgki","../utils/flush.js":"33N4S","../mixins/mutable-data.js":"2HzJg","../utils/path.js":"fr2Rw","../utils/async.js":"knspW","../utils/wrap.js":"cQBlD","../utils/hide-template-controls.js":"a96Zj","../utils/settings.js":"44bo5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"896Hh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "html", ()=>_htmlTagJs.html
);
parcelHelpers.export(exports, "version", ()=>_elementMixinJs.version
);
parcelHelpers.export(exports, "PolymerElement", ()=>PolymerElement
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _elementMixinJs = require("./lib/mixins/element-mixin.js");
var _htmlTagJs = require("./lib/utils/html-tag.js");
const PolymerElement = _elementMixinJs.ElementMixin(HTMLElement);

},{"./lib/mixins/element-mixin.js":"52pSj","./lib/utils/html-tag.js":"2ZOZT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2ZOZT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "html", ()=>html
);
parcelHelpers.export(exports, "htmlLiteral", ()=>htmlLiteral
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _bootJs = require("./boot.js");
/**
 * Our TrustedTypePolicy for HTML which is declared using the Polymer html
 * template tag function.
 *
 * That HTML is a developer-authored constant, and is parsed with innerHTML
 * before any untrusted expressions have been mixed in. Therefor it is
 * considered safe by construction.
 *
 * @type {!TrustedTypePolicy|undefined}
 */ const policy = window.trustedTypes && trustedTypes.createPolicy('polymer-html-literal', {
    createHTML: (s)=>s
});
/**
 * Class representing a static string value which can be used to filter
 * strings by asseting that they have been created via this class. The
 * `value` property returns the string passed to the constructor.
 */ class LiteralString {
    /**
   * @param {!ITemplateArray} strings Constant parts of tagged template literal
   * @param {!Array<*>} values Variable parts of tagged template literal
   */ constructor(strings, values){
        assertValidTemplateStringParameters(strings, values);
        const string = values.reduce((acc, v, idx)=>acc + literalValue(v) + strings[idx + 1]
        , strings[0]);
        /** @type {string} */ this.value = string.toString();
    }
    /**
   * @return {string} LiteralString string value
   * @override
   */ toString() {
        return this.value;
    }
}
/**
 * @param {*} value Object to stringify into HTML
 * @return {string} HTML stringified form of `obj`
 */ function literalValue(value) {
    if (value instanceof LiteralString) return(/** @type {!LiteralString} */ value.value);
    else throw new Error(`non-literal value passed to Polymer's htmlLiteral function: ${value}`);
}
/**
 * @param {*} value Object to stringify into HTML
 * @return {string} HTML stringified form of `obj`
 */ function htmlValue(value) {
    if (value instanceof HTMLTemplateElement) // This might be an mXSS risk  mainly in the case where this template
    // contains untrusted content that was believed to be sanitized.
    // However we can't just use the XMLSerializer here because it misencodes
    // `>` characters inside style tags.
    // For an example of an actual case that hit this encoding issue,
    // see b/198592167
    return(/** @type {!HTMLTemplateElement } */ value.innerHTML);
    else if (value instanceof LiteralString) return literalValue(value);
    else throw new Error(`non-template value passed to Polymer's html function: ${value}`);
}
const html = function html(strings, ...values) {
    assertValidTemplateStringParameters(strings, values);
    const template = document.createElement('template');
    let value = values.reduce((acc, v, idx)=>acc + htmlValue(v) + strings[idx + 1]
    , strings[0]);
    if (policy) value = policy.createHTML(value);
    template.innerHTML = value;
    return template;
};
/**
 * @param {!ITemplateArray} strings Constant parts of tagged template literal
 * @param {!Array<*>} values Array of values from quasis
 */ const assertValidTemplateStringParameters = (strings, values)=>{
    // Note: if/when https://github.com/tc39/proposal-array-is-template-object
    // is standardized, use that instead when available, as it can perform an
    // unforgable check (though of course, the function itself can be forged).
    if (!Array.isArray(strings) || !Array.isArray(strings.raw) || values.length !== strings.length - 1) // This is either caused by a browser bug, a compiler bug, or someone
    // calling the html template tag function as a regular function.
    //
    throw new TypeError('Invalid call to the html template tag');
};
const htmlLiteral = function(strings, ...values) {
    return new LiteralString(strings, values);
};

},{"./boot.js":"gVNgb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l26Yf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DomIf", ()=>DomIf
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _polymerElementJs = require("../../polymer-element.js");
var _debounceJs = require("../utils/debounce.js");
var _flushJs = require("../utils/flush.js");
var _asyncJs = require("../utils/async.js");
var _pathJs = require("../utils/path.js");
var _wrapJs = require("../utils/wrap.js");
var _hideTemplateControlsJs = require("../utils/hide-template-controls.js");
var _settingsJs = require("../utils/settings.js");
var _templatizeJs = require("../utils/templatize.js");
/**
 * @customElement
 * @polymer
 * @extends PolymerElement
 * @summary Base class for dom-if element; subclassed into concrete
 *   implementation.
 */ class DomIfBase extends _polymerElementJs.PolymerElement {
    // Not needed to find template; can be removed once the analyzer
    // can find the tag name from customElements.define call
    static get is() {
        return 'dom-if';
    }
    static get template() {
        return null;
    }
    static get properties() {
        return {
            /**
       * Fired whenever DOM is added or removed/hidden by this template (by
       * default, rendering occurs lazily).  To force immediate rendering, call
       * `render`.
       *
       * @event dom-change
       */ /**
       * A boolean indicating whether this template should stamp.
       */ if: {
                type: Boolean,
                observer: '__debounceRender'
            },
            /**
       * When true, elements will be removed from DOM and discarded when `if`
       * becomes false and re-created and added back to the DOM when `if`
       * becomes true.  By default, stamped elements will be hidden but left
       * in the DOM when `if` becomes false, which is generally results
       * in better performance.
       */ restamp: {
                type: Boolean,
                observer: '__debounceRender'
            },
            /**
       * When the global `suppressTemplateNotifications` setting is used, setting
       * `notifyDomChange: true` will enable firing `dom-change` events on this
       * element.
       */ notifyDomChange: {
                type: Boolean
            }
        };
    }
    constructor(){
        super();
        this.__renderDebouncer = null;
        this._lastIf = false;
        this.__hideTemplateChildren__ = false;
        /** @type {!HTMLTemplateElement|undefined} */ this.__template;
        /** @type {!TemplateInfo|undefined} */ this._templateInfo;
    }
    __debounceRender() {
        // Render is async for 2 reasons:
        // 1. To eliminate dom creation trashing if user code thrashes `if` in the
        //    same turn. This was more common in 1.x where a compound computed
        //    property could result in the result changing multiple times, but is
        //    mitigated to a large extent by batched property processing in 2.x.
        // 2. To avoid double object propagation when a bag including values bound
        //    to the `if` property as well as one or more hostProps could enqueue
        //    the <dom-if> to flush before the <template>'s host property
        //    forwarding. In that scenario creating an instance would result in
        //    the host props being set once, and then the enqueued changes on the
        //    template would set properties a second time, potentially causing an
        //    object to be set to an instance more than once.  Creating the
        //    instance async from flushing data ensures this doesn't happen. If
        //    we wanted a sync option in the future, simply having <dom-if> flush
        //    (or clear) its template's pending host properties before creating
        //    the instance would also avoid the problem.
        this.__renderDebouncer = _debounceJs.Debouncer.debounce(this.__renderDebouncer, _asyncJs.microTask, ()=>this.__render()
        );
        _flushJs.enqueueDebouncer(this.__renderDebouncer);
    }
    /**
   * @override
   * @return {void}
   */ disconnectedCallback() {
        super.disconnectedCallback();
        const parent = _wrapJs.wrap(this).parentNode;
        if (!parent || parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !_wrapJs.wrap(parent).host) this.__teardownInstance();
    }
    /**
   * @override
   * @return {void}
   */ connectedCallback() {
        super.connectedCallback();
        if (!_hideTemplateControlsJs.hideElementsGlobally()) this.style.display = 'none';
        if (this.if) this.__debounceRender();
    }
    /**
   * Ensures a template has been assigned to `this.__template`.  If it has not
   * yet been, it querySelectors for it in its children and if it does not yet
   * exist (e.g. in parser-generated case), opens a mutation observer and
   * waits for it to appear (returns false if it has not yet been found,
   * otherwise true).  In the `removeNestedTemplates` case, the "template" will
   * be the `dom-if` element itself.
   *
   * @return {boolean} True when a template has been found, false otherwise
   */ __ensureTemplate() {
        if (!this.__template) {
            // When `removeNestedTemplates` is true, the "template" is the element
            // itself, which has been given a `_templateInfo` property
            const thisAsTemplate = this;
            let template = thisAsTemplate._templateInfo ? thisAsTemplate : _wrapJs.wrap(thisAsTemplate).querySelector('template');
            if (!template) {
                // Wait until childList changes and template should be there by then
                let observer = new MutationObserver(()=>{
                    if (_wrapJs.wrap(this).querySelector('template')) {
                        observer.disconnect();
                        this.__render();
                    } else throw new Error('dom-if requires a <template> child');
                });
                observer.observe(this, {
                    childList: true
                });
                return false;
            }
            this.__template = template;
        }
        return true;
    }
    /**
   * Ensures a an instance of the template has been created and inserted. This
   * method may return false if the template has not yet been found or if
   * there is no `parentNode` to insert the template into (in either case,
   * connection or the template-finding mutation observer firing will queue
   * another render, causing this method to be called again at a more
   * appropriate time).
   *
   * Subclasses should implement the following methods called here:
   * - `__hasInstance`
   * - `__createAndInsertInstance`
   * - `__getInstanceNodes`
   *
   * @return {boolean} True if the instance was created, false otherwise.
   */ __ensureInstance() {
        let parentNode = _wrapJs.wrap(this).parentNode;
        if (!this.__hasInstance()) {
            // Guard against element being detached while render was queued
            if (!parentNode) return false;
            // Find the template (when false, there was no template yet)
            if (!this.__ensureTemplate()) return false;
            this.__createAndInsertInstance(parentNode);
        } else {
            // Move instance children if necessary
            let children = this.__getInstanceNodes();
            if (children && children.length) {
                // Detect case where dom-if was re-attached in new position
                let lastChild = _wrapJs.wrap(this).previousSibling;
                if (lastChild !== children[children.length - 1]) for(let i = 0, n; i < children.length && (n = children[i]); i++)_wrapJs.wrap(parentNode).insertBefore(n, this);
            }
        }
        return true;
    }
    /**
   * Forces the element to render its content. Normally rendering is
   * asynchronous to a provoking change. This is done for efficiency so
   * that multiple changes trigger only a single render. The render method
   * should be called if, for example, template rendering is required to
   * validate application state.
   *
   * @return {void}
   */ render() {
        _flushJs.flush();
    }
    /**
   * Performs the key rendering steps:
   * 1. Ensure a template instance has been stamped (when true)
   * 2. Remove the template instance (when false and restamp:true)
   * 3. Sync the hidden state of the instance nodes with the if/restamp state
   * 4. Fires the `dom-change` event when necessary
   *
   * @return {void}
   */ __render() {
        if (this.if) {
            if (!this.__ensureInstance()) // No template found yet
            return;
        } else if (this.restamp) this.__teardownInstance();
        this._showHideChildren();
        if ((!_settingsJs.suppressTemplateNotifications || this.notifyDomChange) && this.if != this._lastIf) {
            this.dispatchEvent(new CustomEvent('dom-change', {
                bubbles: true,
                composed: true
            }));
            this._lastIf = this.if;
        }
    }
    // Ideally these would be annotated as abstract methods in an abstract class,
    // but closure compiler is finnicky
    /* eslint-disable valid-jsdoc */ /**
   * Abstract API to be implemented by subclass: Returns true if a template
   * instance has been created and inserted.
   *
   * @protected
   * @return {boolean} True when an instance has been created.
   */ __hasInstance() {
    }
    /**
   * Abstract API to be implemented by subclass: Returns the child nodes stamped
   * from a template instance.
   *
   * @protected
   * @return {Array<Node>} Array of child nodes stamped from the template
   * instance.
   */ __getInstanceNodes() {
    }
    /**
   * Abstract API to be implemented by subclass: Creates an instance of the
   * template and inserts it into the given parent node.
   *
   * @protected
   * @param {Node} parentNode The parent node to insert the instance into
   * @return {void}
   */ __createAndInsertInstance(parentNode) {
    }
    /**
   * Abstract API to be implemented by subclass: Removes nodes created by an
   * instance of a template and any associated cleanup.
   *
   * @protected
   * @return {void}
   */ __teardownInstance() {
    }
    /**
   * Abstract API to be implemented by subclass: Shows or hides any template
   * instance childNodes based on the `if` state of the element and its
   * `__hideTemplateChildren__` property.
   *
   * @protected
   * @return {void}
   */ _showHideChildren() {
    }
}
/**
 * The version of DomIf used when `fastDomIf` setting is in use, which is
 * optimized for first-render (but adds a tax to all subsequent property updates
 * on the host, whether they were used in a given `dom-if` or not).
 *
 * This implementation avoids use of `Templatizer`, which introduces a new scope
 * (a non-element PropertyEffects instance), which is not strictly necessary
 * since `dom-if` never introduces new properties to its scope (unlike
 * `dom-repeat`). Taking advantage of this fact, the `dom-if` reaches up to its
 * `__dataHost` and stamps the template directly from the host using the host's
 * runtime `_stampTemplate` API, which binds the property effects of the
 * template directly to the host. This both avoids the intermediary
 * `Templatizer` instance, but also avoids the need to bind host properties to
 * the `<template>` element and forward those into the template instance.
 *
 * In this version of `dom-if`, the `this.__instance` method is the
 * `DocumentFragment` returned from `_stampTemplate`, which also serves as the
 * handle for later removing it using the `_removeBoundDom` method.
 */ class DomIfFast extends DomIfBase {
    constructor(){
        super();
        this.__instance = null;
        this.__syncInfo = null;
    }
    /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * @override
   * @return {boolean} True when an instance has been created.
   */ __hasInstance() {
        return Boolean(this.__instance);
    }
    /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * @override
   * @return {Array<Node>} Array of child nodes stamped from the template
   * instance.
   */ __getInstanceNodes() {
        return this.__instance.templateInfo.childNodes;
    }
    /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Stamps the template by calling `_stampTemplate` on the `__dataHost` of this
   * element and then inserts the resulting nodes into the given `parentNode`.
   *
   * @override
   * @param {Node} parentNode The parent node to insert the instance into
   * @return {void}
   */ __createAndInsertInstance(parentNode) {
        const host = this.__dataHost || this;
        if (_settingsJs.strictTemplatePolicy) {
            if (!this.__dataHost) throw new Error('strictTemplatePolicy: template owner not trusted');
        }
        // Pre-bind and link the template into the effects system
        const templateInfo = host._bindTemplate(this.__template, true);
        // Install runEffects hook that prevents running property effects
        // (and any nested template effects) when the `if` is false
        templateInfo.runEffects = (runEffects, changedProps, hasPaths)=>{
            let syncInfo = this.__syncInfo;
            if (this.if) {
                // Mix any props that changed while the `if` was false into `changedProps`
                if (syncInfo) {
                    // If there were properties received while the `if` was false, it is
                    // important to sync the hidden state with the element _first_, so that
                    // new bindings to e.g. `textContent` do not get stomped on by
                    // pre-hidden values if `_showHideChildren` were to be called later at
                    // the next render. Clearing `__invalidProps` here ensures
                    // `_showHideChildren`'s call to `__syncHostProperties` no-ops, so
                    // that we don't call `runEffects` more often than necessary.
                    this.__syncInfo = null;
                    this._showHideChildren();
                    changedProps = Object.assign(syncInfo.changedProps, changedProps);
                }
                runEffects(changedProps, hasPaths);
            } else // Accumulate any values changed while `if` was false, along with the
            // runEffects method to sync them, so that we can replay them once `if`
            // becomes true
            if (this.__instance) {
                if (!syncInfo) syncInfo = this.__syncInfo = {
                    runEffects,
                    changedProps: {
                    }
                };
                if (hasPaths) // Store root object of any paths; this will ensure direct bindings
                // like [[obj.foo]] bindings run after a `set('obj.foo', v)`, but
                // note that path notifications like `set('obj.foo.bar', v)` will
                // not propagate. Since batched path notifications are not
                // supported, we cannot simply accumulate path notifications. This
                // is equivalent to the non-fastDomIf case, which stores root(p) in
                // __invalidProps.
                for(const p in changedProps){
                    const rootProp = _pathJs.root(p);
                    syncInfo.changedProps[rootProp] = this.__dataHost[rootProp];
                }
                else Object.assign(syncInfo.changedProps, changedProps);
            }
        };
        // Stamp the template, and set its DocumentFragment to the "instance"
        this.__instance = host._stampTemplate(this.__template, templateInfo);
        _wrapJs.wrap(parentNode).insertBefore(this.__instance, this);
    }
    /**
   * Run effects for any properties that changed while the `if` was false.
   *
   * @return {void}
   */ __syncHostProperties() {
        const syncInfo = this.__syncInfo;
        if (syncInfo) {
            this.__syncInfo = null;
            syncInfo.runEffects(syncInfo.changedProps, false);
        }
    }
    /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Remove the instance and any nodes it created.  Uses the `__dataHost`'s
   * runtime `_removeBoundDom` method.
   *
   * @override
   * @return {void}
   */ __teardownInstance() {
        const host = this.__dataHost || this;
        if (this.__instance) {
            host._removeBoundDom(this.__instance);
            this.__instance = null;
            this.__syncInfo = null;
        }
    }
    /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Shows or hides the template instance top level child nodes. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   *
   * @override
   * @return {void}
   * @protected
   * @suppress {visibility}
   */ _showHideChildren() {
        const hidden = this.__hideTemplateChildren__ || !this.if;
        if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {
            this.__instance.__hidden = hidden;
            _templatizeJs.showHideChildren(hidden, this.__instance.templateInfo.childNodes);
        }
        if (!hidden) this.__syncHostProperties();
    }
}
/**
 * The "legacy" implementation of `dom-if`, implemented using `Templatizer`.
 *
 * In this version, `this.__instance` is the `TemplateInstance` returned
 * from the templatized constructor.
 */ class DomIfLegacy extends DomIfBase {
    constructor(){
        super();
        this.__ctor = null;
        this.__instance = null;
        this.__invalidProps = null;
    }
    /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * @override
   * @return {boolean} True when an instance has been created.
   */ __hasInstance() {
        return Boolean(this.__instance);
    }
    /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * @override
   * @return {Array<Node>} Array of child nodes stamped from the template
   * instance.
   */ __getInstanceNodes() {
        return this.__instance.children;
    }
    /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Stamps the template by creating a new instance of the templatized
   * constructor (which is created lazily if it does not yet exist), and then
   * inserts its resulting `root` doc fragment into the given `parentNode`.
   *
   * @override
   * @param {Node} parentNode The parent node to insert the instance into
   * @return {void}
   */ __createAndInsertInstance(parentNode) {
        // Ensure we have an instance constructor
        if (!this.__ctor) this.__ctor = _templatizeJs.templatize(this.__template, this, {
            // dom-if templatizer instances require `mutable: true`, as
            // `__syncHostProperties` relies on that behavior to sync objects
            mutableData: true,
            /**
             * @param {string} prop Property to forward
             * @param {*} value Value of property
             * @this {DomIfLegacy}
             */ forwardHostProp: function(prop, value) {
                if (this.__instance) {
                    if (this.if) this.__instance.forwardHostProp(prop, value);
                    else {
                        // If we have an instance but are squelching host property
                        // forwarding due to if being false, note the invalidated
                        // properties so `__syncHostProperties` can sync them the next
                        // time `if` becomes true
                        this.__invalidProps = this.__invalidProps || Object.create(null);
                        this.__invalidProps[_pathJs.root(prop)] = true;
                    }
                }
            }
        });
        // Create and insert the instance
        this.__instance = new this.__ctor();
        _wrapJs.wrap(parentNode).insertBefore(this.__instance.root, this);
    }
    /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Removes the instance and any nodes it created.
   *
   * @override
   * @return {void}
   */ __teardownInstance() {
        if (this.__instance) {
            let c$ = this.__instance.children;
            if (c$ && c$.length) {
                // use first child parent, for case when dom-if may have been detached
                let parent = _wrapJs.wrap(c$[0]).parentNode;
                // Instance children may be disconnected from parents when dom-if
                // detaches if a tree was innerHTML'ed
                if (parent) {
                    parent = _wrapJs.wrap(parent);
                    for(let i = 0, n; i < c$.length && (n = c$[i]); i++)parent.removeChild(n);
                }
            }
            this.__invalidProps = null;
            this.__instance = null;
        }
    }
    /**
   * Forwards any properties that changed while the `if` was false into the
   * template instance and flushes it.
   *
   * @return {void}
   */ __syncHostProperties() {
        let props = this.__invalidProps;
        if (props) {
            this.__invalidProps = null;
            for(let prop in props)this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
            this.__instance._flushProperties();
        }
    }
    /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   *
   * @override
   * @protected
   * @return {void}
   * @suppress {visibility}
   */ _showHideChildren() {
        const hidden = this.__hideTemplateChildren__ || !this.if;
        if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {
            this.__instance.__hidden = hidden;
            this.__instance._showHideChildren(hidden);
        }
        if (!hidden) this.__syncHostProperties();
    }
}
const DomIf = _settingsJs.fastDomIf ? DomIfFast : DomIfLegacy;
customElements.define(DomIf.is, DomIf);

},{"../../polymer-element.js":"896Hh","../utils/debounce.js":"hbgki","../utils/flush.js":"33N4S","../utils/async.js":"knspW","../utils/path.js":"fr2Rw","../utils/wrap.js":"cQBlD","../utils/hide-template-controls.js":"a96Zj","../utils/settings.js":"44bo5","../utils/templatize.js":"6QnfM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2xCnx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// export mixin
parcelHelpers.export(exports, "ArraySelectorMixin", ()=>ArraySelectorMixin
);
parcelHelpers.export(exports, "ArraySelector", ()=>ArraySelector
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _polymerElementJs = require("../../polymer-element.js");
var _mixinJs = require("../utils/mixin.js");
var _arraySpliceJs = require("../utils/array-splice.js");
var _elementMixinJs = require("../mixins/element-mixin.js");
/**
 * Element mixin for recording dynamic associations between item paths in a
 * master `items` array and a `selected` array such that path changes to the
 * master array (at the host) element or elsewhere via data-binding) are
 * correctly propagated to items in the selected array and vice-versa.
 *
 * The `items` property accepts an array of user data, and via the
 * `select(item)` and `deselect(item)` API, updates the `selected` property
 * which may be bound to other parts of the application, and any changes to
 * sub-fields of `selected` item(s) will be kept in sync with items in the
 * `items` array.  When `multi` is false, `selected` is a property
 * representing the last selected item.  When `multi` is true, `selected`
 * is an array of multiply selected items.
 *
 * @polymer
 * @mixinFunction
 * @appliesMixin ElementMixin
 * @summary Element mixin for recording dynamic associations between item paths in a
 * master `items` array and a `selected` array
 */ let ArraySelectorMixin = _mixinJs.dedupingMixin((superClass)=>{
    /**
   * @constructor
   * @implements {Polymer_ElementMixin}
   * @private
   */ let elementBase = _elementMixinJs.ElementMixin(superClass);
    /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_ArraySelectorMixin}
   * @unrestricted
   */ class ArraySelectorMixin1 extends elementBase {
        static get properties() {
            return {
                /**
         * An array containing items from which selection will be made.
         */ items: {
                    type: Array
                },
                /**
         * When `true`, multiple items may be selected at once (in this case,
         * `selected` is an array of currently selected items).  When `false`,
         * only one item may be selected at a time.
         */ multi: {
                    type: Boolean,
                    value: false
                },
                /**
         * When `multi` is true, this is an array that contains any selected.
         * When `multi` is false, this is the currently selected item, or `null`
         * if no item is selected.
         * @type {?Object|?Array<!Object>}
         */ selected: {
                    type: Object,
                    notify: true
                },
                /**
         * When `multi` is false, this is the currently selected item, or `null`
         * if no item is selected.
         * @type {?Object}
         */ selectedItem: {
                    type: Object,
                    notify: true
                },
                /**
         * When `true`, calling `select` on an item that is already selected
         * will deselect the item.
         */ toggle: {
                    type: Boolean,
                    value: false
                }
            };
        }
        static get observers() {
            return [
                '__updateSelection(multi, items.*)'
            ];
        }
        constructor(){
            super();
            this.__lastItems = null;
            this.__lastMulti = null;
            this.__selectedMap = null;
        }
        __updateSelection(multi, itemsInfo) {
            let path = itemsInfo.path;
            if (path == JSCompiler_renameProperty('items', this)) {
                // Case 1 - items array changed, so diff against previous array and
                // deselect any removed items and adjust selected indices
                let newItems = itemsInfo.base || [];
                let lastItems = this.__lastItems;
                let lastMulti = this.__lastMulti;
                if (multi !== lastMulti) this.clearSelection();
                if (lastItems) {
                    let splices = _arraySpliceJs.calculateSplices(newItems, lastItems);
                    this.__applySplices(splices);
                }
                this.__lastItems = newItems;
                this.__lastMulti = multi;
            } else if (itemsInfo.path == `${JSCompiler_renameProperty('items', this)}.splices`) // Case 2 - got specific splice information describing the array mutation:
            // deselect any removed items and adjust selected indices
            this.__applySplices(itemsInfo.value.indexSplices);
            else {
                // Case 3 - an array element was changed, so deselect the previous
                // item for that index if it was previously selected
                let part = path.slice(`${JSCompiler_renameProperty('items', this)}.`.length);
                let idx = parseInt(part, 10);
                if (part.indexOf('.') < 0 && part == idx) this.__deselectChangedIdx(idx);
            }
        }
        __applySplices(splices) {
            let selected = this.__selectedMap;
            // Adjust selected indices and mark removals
            for(let i = 0; i < splices.length; i++){
                let s = splices[i];
                selected.forEach((idx, item)=>{
                    if (idx < s.index) ;
                    else if (idx >= s.index + s.removed.length) // adjust index
                    selected.set(item, idx + s.addedCount - s.removed.length);
                    else // remove index
                    selected.set(item, -1);
                });
                for(let j = 0; j < s.addedCount; j++){
                    let idx = s.index + j;
                    if (selected.has(this.items[idx])) selected.set(this.items[idx], idx);
                }
            }
            // Update linked paths
            this.__updateLinks();
            // Remove selected items that were removed from the items array
            let sidx = 0;
            selected.forEach((idx, item)=>{
                if (idx < 0) {
                    if (this.multi) this.splice(JSCompiler_renameProperty('selected', this), sidx, 1);
                    else this.selected = this.selectedItem = null;
                    selected.delete(item);
                } else sidx++;
            });
        }
        __updateLinks() {
            this.__dataLinkedPaths = {
            };
            if (this.multi) {
                let sidx = 0;
                this.__selectedMap.forEach((idx)=>{
                    if (idx >= 0) this.linkPaths(`${JSCompiler_renameProperty('items', this)}.${idx}`, `${JSCompiler_renameProperty('selected', this)}.${sidx++}`);
                });
            } else this.__selectedMap.forEach((idx)=>{
                this.linkPaths(JSCompiler_renameProperty('selected', this), `${JSCompiler_renameProperty('items', this)}.${idx}`);
                this.linkPaths(JSCompiler_renameProperty('selectedItem', this), `${JSCompiler_renameProperty('items', this)}.${idx}`);
            });
        }
        /**
     * Clears the selection state.
     * @override
     * @return {void}
     */ clearSelection() {
            // Unbind previous selection
            this.__dataLinkedPaths = {
            };
            // The selected map stores 3 pieces of information:
            // key: items array object
            // value: items array index
            // order: selected array index
            this.__selectedMap = new Map();
            // Initialize selection
            this.selected = this.multi ? [] : null;
            this.selectedItem = null;
        }
        /**
     * Returns whether the item is currently selected.
     *
     * @override
     * @param {*} item Item from `items` array to test
     * @return {boolean} Whether the item is selected
     */ isSelected(item) {
            return this.__selectedMap.has(item);
        }
        /**
     * Returns whether the item is currently selected.
     *
     * @override
     * @param {number} idx Index from `items` array to test
     * @return {boolean} Whether the item is selected
     */ isIndexSelected(idx) {
            return this.isSelected(this.items[idx]);
        }
        __deselectChangedIdx(idx) {
            let sidx = this.__selectedIndexForItemIndex(idx);
            if (sidx >= 0) {
                let i = 0;
                this.__selectedMap.forEach((idx, item)=>{
                    if (sidx == i++) this.deselect(item);
                });
            }
        }
        __selectedIndexForItemIndex(idx) {
            let selected = this.__dataLinkedPaths[`${JSCompiler_renameProperty('items', this)}.${idx}`];
            if (selected) return parseInt(selected.slice(`${JSCompiler_renameProperty('selected', this)}.`.length), 10);
        }
        /**
     * Deselects the given item if it is already selected.
     *
     * @override
     * @param {*} item Item from `items` array to deselect
     * @return {void}
     */ deselect(item) {
            let idx = this.__selectedMap.get(item);
            if (idx >= 0) {
                this.__selectedMap.delete(item);
                let sidx;
                if (this.multi) sidx = this.__selectedIndexForItemIndex(idx);
                this.__updateLinks();
                if (this.multi) this.splice(JSCompiler_renameProperty('selected', this), sidx, 1);
                else this.selected = this.selectedItem = null;
            }
        }
        /**
     * Deselects the given index if it is already selected.
     *
     * @override
     * @param {number} idx Index from `items` array to deselect
     * @return {void}
     */ deselectIndex(idx) {
            this.deselect(this.items[idx]);
        }
        /**
     * Selects the given item.  When `toggle` is true, this will automatically
     * deselect the item if already selected.
     *
     * @override
     * @param {*} item Item from `items` array to select
     * @return {void}
     */ select(item) {
            this.selectIndex(this.items.indexOf(item));
        }
        /**
     * Selects the given index.  When `toggle` is true, this will automatically
     * deselect the item if already selected.
     *
     * @override
     * @param {number} idx Index from `items` array to select
     * @return {void}
     */ selectIndex(idx) {
            let item = this.items[idx];
            if (!this.isSelected(item)) {
                if (!this.multi) this.__selectedMap.clear();
                this.__selectedMap.set(item, idx);
                this.__updateLinks();
                if (this.multi) this.push(JSCompiler_renameProperty('selected', this), item);
                else this.selected = this.selectedItem = item;
            } else if (this.toggle) this.deselectIndex(idx);
        }
    }
    return ArraySelectorMixin1;
});
/**
 * @constructor
 * @extends {PolymerElement}
 * @implements {Polymer_ArraySelectorMixin}
 * @private
 */ let baseArraySelector = ArraySelectorMixin(_polymerElementJs.PolymerElement);
/**
 * Element implementing the `ArraySelector` mixin, which records
 * dynamic associations between item paths in a master `items` array and a
 * `selected` array such that path changes to the master array (at the host)
 * element or elsewhere via data-binding) are correctly propagated to items
 * in the selected array and vice-versa.
 *
 * The `items` property accepts an array of user data, and via the
 * `select(item)` and `deselect(item)` API, updates the `selected` property
 * which may be bound to other parts of the application, and any changes to
 * sub-fields of `selected` item(s) will be kept in sync with items in the
 * `items` array.  When `multi` is false, `selected` is a property
 * representing the last selected item.  When `multi` is true, `selected`
 * is an array of multiply selected items.
 *
 * Example:
 *
 * ```js
 * import {PolymerElement} from '@polymer/polymer';
 * import '@polymer/polymer/lib/elements/array-selector.js';
 *
 * class EmployeeList extends PolymerElement {
 *   static get _template() {
 *     return html`
 *         <div> Employee list: </div>
 *         <dom-repeat id="employeeList" items="{{employees}}">
 *           <template>
 *             <div>First name: <span>{{item.first}}</span></div>
 *               <div>Last name: <span>{{item.last}}</span></div>
 *               <button on-click="toggleSelection">Select</button>
 *           </template>
 *         </dom-repeat>
 *
 *         <array-selector id="selector"
 *                         items="{{employees}}"
 *                         selected="{{selected}}"
 *                         multi toggle></array-selector>
 *
 *         <div> Selected employees: </div>
 *         <dom-repeat items="{{selected}}">
 *           <template>
 *             <div>First name: <span>{{item.first}}</span></div>
 *             <div>Last name: <span>{{item.last}}</span></div>
 *           </template>
 *         </dom-repeat>`;
 *   }
 *   static get is() { return 'employee-list'; }
 *   static get properties() {
 *     return {
 *       employees: {
 *         value() {
 *           return [
 *             {first: 'Bob', last: 'Smith'},
 *             {first: 'Sally', last: 'Johnson'},
 *             ...
 *           ];
 *         }
 *       }
 *     };
 *   }
 *   toggleSelection(e) {
 *     const item = this.$.employeeList.itemForElement(e.target);
 *     this.$.selector.select(item);
 *   }
 * }
 * ```
 *
 * @polymer
 * @customElement
 * @extends {baseArraySelector}
 * @appliesMixin ArraySelectorMixin
 * @summary Custom element that links paths between an input `items` array and
 *   an output `selected` item or array based on calls to its selection API.
 */ class ArraySelector extends baseArraySelector {
    // Not needed to find template; can be removed once the analyzer
    // can find the tag name from customElements.define call
    static get is() {
        return 'array-selector';
    }
    static get template() {
        return null;
    }
}
customElements.define(ArraySelector.is, ArraySelector);

},{"../../polymer-element.js":"896Hh","../utils/mixin.js":"488pD","../utils/array-splice.js":"7lRsx","../mixins/element-mixin.js":"52pSj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kqK3F":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Custom element for defining styles in the main document that can take
 * advantage of [shady DOM](https://github.com/webcomponents/shadycss) shims
 * for style encapsulation, custom properties, and custom mixins.
 *
 * - Document styles defined in a `<custom-style>` are shimmed to ensure they
 *   do not leak into local DOM when running on browsers without native
 *   Shadow DOM.
 * - Custom properties can be defined in a `<custom-style>`. Use the `html` selector
 *   to define custom properties that apply to all custom elements.
 * - Custom mixins can be defined in a `<custom-style>`, if you import the optional
 *   [apply shim](https://github.com/webcomponents/shadycss#about-applyshim)
 *   (`shadycss/apply-shim.html`).
 *
 * To use:
 *
 * - Import `custom-style.html`.
 * - Place a `<custom-style>` element in the main document, wrapping an inline `<style>` tag that
 *   contains the CSS rules you want to shim.
 *
 * For example:
 *
 * ```html
 * <!-- import apply shim--only required if using mixins -->
 * <link rel="import" href="bower_components/shadycss/apply-shim.html">
 * <!-- import custom-style element -->
 * <link rel="import" href="bower_components/polymer/lib/elements/custom-style.html">
 *
 * <custom-style>
 *   <style>
 *     html {
 *       --custom-color: blue;
 *       --custom-mixin: {
 *         font-weight: bold;
 *         color: red;
 *       };
 *     }
 *   </style>
 * </custom-style>
 * ```
 *
 * @customElement
 * @extends HTMLElement
 * @summary Custom element for defining styles in the main document that can
 *   take advantage of Polymer's style scoping and custom properties shims.
 */ parcelHelpers.export(exports, "CustomStyle", ()=>CustomStyle
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _customStyleInterfaceJs = require("@webcomponents/shadycss/entrypoints/custom-style-interface.js");
var _styleGatherJs = require("../utils/style-gather.js");
const attr = 'include';
const CustomStyleInterface = window.ShadyCSS.CustomStyleInterface;
class CustomStyle extends HTMLElement {
    constructor(){
        super();
        this._style = null;
        CustomStyleInterface.addCustomStyle(this);
    }
    /**
   * Returns the light-DOM `<style>` child this element wraps.  Upon first
   * call any style modules referenced via the `include` attribute will be
   * concatenated to this element's `<style>`.
   *
   * @export
   * @return {HTMLStyleElement} This element's light-DOM `<style>`
   */ getStyle() {
        if (this._style) return this._style;
        const style = this.querySelector('style');
        if (!style) return null;
        this._style = style;
        const include = style.getAttribute(attr);
        if (include) {
            style.removeAttribute(attr);
            /** @suppress {deprecated} */ style.textContent = _styleGatherJs.cssFromModules(include) + style.textContent;
        }
        /*
    HTML Imports styling the main document are deprecated in Chrome
    https://crbug.com/523952

    If this element is not in the main document, then it must be in an HTML Import document.
    In that case, move the custom style to the main document.

    The ordering of `<custom-style>` should stay the same as when loaded by HTML Imports, but there may be odd
    cases of ordering w.r.t the main document styles.
    */ if (this.ownerDocument !== window.document) window.document.head.appendChild(this);
        return this._style;
    }
}
window.customElements.define('custom-style', CustomStyle);

},{"@webcomponents/shadycss/entrypoints/custom-style-interface.js":"6UCPh","../utils/style-gather.js":"6nhLC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6UCPh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _customStyleInterfaceJs = require("../src/custom-style-interface.js");
var _customStyleInterfaceJsDefault = parcelHelpers.interopDefault(_customStyleInterfaceJs);
// prettier-ignore
var _commonUtilsJs = require("../src/common-utils.js");
// prettier-ignore
var _styleSettingsJs = require("../src/style-settings.js");
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ 'use strict';
const customStyleInterface = new _customStyleInterfaceJsDefault.default();
if (!window.ShadyCSS) window.ShadyCSS = {
    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */ prepareTemplate (template, elementName, elementExtends) {
    },
    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     */ prepareTemplateDom (template, elementName) {
    },
    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */ prepareTemplateStyles (template, elementName, elementExtends) {
    },
    /**
     * @param {Element} element
     * @param {Object=} properties
     */ styleSubtree (element, properties) {
        customStyleInterface.processStyles();
        _commonUtilsJs.updateNativeProperties(element, properties);
    },
    /**
     * @param {Element} element
     */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    styleElement (element) {
        customStyleInterface.processStyles();
    },
    /**
     * @param {Object=} properties
     */ styleDocument (properties) {
        customStyleInterface.processStyles();
        _commonUtilsJs.updateNativeProperties(document.body, properties);
    },
    /**
     * @param {Element} element
     * @param {string} property
     * @return {string}
     */ getComputedStyleValue (element, property) {
        return _commonUtilsJs.getComputedStyleValue(element, property);
    },
    flushCustomStyles () {
    },
    nativeCss: _styleSettingsJs.nativeCssVariables,
    nativeShadow: _styleSettingsJs.nativeShadow,
    cssBuild: _styleSettingsJs.cssBuild,
    disableRuntime: _styleSettingsJs.disableRuntime
};
window.ShadyCSS.CustomStyleInterface = customStyleInterface;

},{"../src/custom-style-interface.js":"9kEPT","../src/common-utils.js":"6AJbp","../src/style-settings.js":"lUdAU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gDNo1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MutableDataBehavior", ()=>MutableDataBehavior
);
parcelHelpers.export(exports, "OptionalMutableDataBehavior", ()=>OptionalMutableDataBehavior
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _mutableDataJs = require("../mixins/mutable-data.js");
let mutablePropertyChange;
/** @suppress {missingProperties} */ (()=>{
    mutablePropertyChange = _mutableDataJs.MutableData._mutablePropertyChange;
})();
const MutableDataBehavior = {
    /**
   * Overrides `Polymer.PropertyEffects` to provide option for skipping
   * strict equality checking for Objects and Arrays.
   *
   * This method pulls the value to dirty check against from the `__dataTemp`
   * cache (rather than the normal `__data` cache) for Objects.  Since the temp
   * cache is cleared at the end of a turn, this implementation allows
   * side-effects of deep object changes to be processed by re-setting the
   * same object (using the temp cache as an in-turn backstop to prevent
   * cycles due to 2-way notification).
   *
   * @param {string} property Property name
   * @param {*} value New property value
   * @param {*} old Previous property value
   * @return {boolean} Whether the property should be considered a change
   * @protected
   * @override
   */ _shouldPropertyChange (property, value, old) {
        return mutablePropertyChange(this, property, value, old, true);
    }
};
const OptionalMutableDataBehavior = {
    properties: {
        /**
     * Instance-level flag for configuring the dirty-checking strategy
     * for this element.  When true, Objects and Arrays will skip dirty
     * checking, otherwise strict equality checking will be used.
     */ mutableData: Boolean
    },
    /**
   * Overrides `Polymer.PropertyEffects` to skip strict equality checking
   * for Objects and Arrays.
   *
   * Pulls the value to dirty check against from the `__dataTemp` cache
   * (rather than the normal `__data` cache) for Objects.  Since the temp
   * cache is cleared at the end of a turn, this implementation allows
   * side-effects of deep object changes to be processed by re-setting the
   * same object (using the temp cache as an in-turn backstop to prevent
   * cycles due to 2-way notification).
   *
   * @param {string} property Property name
   * @param {*} value New property value
   * @param {*} old Previous property value
   * @return {boolean} Whether the property should be considered a change
   * @protected
   * @override
   */ _shouldPropertyChange (property, value, old) {
        return mutablePropertyChange(this, property, value, old, this.mutableData);
    }
};

},{"../mixins/mutable-data.js":"2HzJg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6nJFW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Polymer", ()=>Polymer
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _classJs = require("./class.js");
var _bootJs = require("../utils/boot.js");
/**
 * Legacy class factory and registration helper for defining Polymer
 * elements.
 *
 * This method is equivalent to
 *
 *     import {Class} from '@polymer/polymer/lib/legacy/class.js';
 *     customElements.define(info.is, Class(info));
 *
 * See `Class` for details on valid legacy metadata format for `info`.
 *
 * @global
 * @override
 * @function
 * @param {!PolymerInit} info Object containing Polymer metadata and functions
 *   to become class methods.
 * @return {function(new: HTMLElement)} Generated class
 * @suppress {duplicate, invalidCasts, checkTypes}
 */ const Polymer = function(info) {
    // if input is a `class` (aka a function with a prototype), use the prototype
    // remember that the `constructor` will never be called
    let klass;
    if (typeof info === 'function') klass = info;
    else klass = Polymer.Class(info);
    // Copy opt out for `legacyNoObservedAttributes` from info object to class.
    if (info._legacyForceObservedAttributes) klass.prototype._legacyForceObservedAttributes = info._legacyForceObservedAttributes;
    customElements.define(klass.is, klass);
    return klass;
};
Polymer.Class = _classJs.Class;

},{"./class.js":"80R3f","../utils/boot.js":"gVNgb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"80R3f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Applies a "legacy" behavior or array of behaviors to the provided class.
 *
 * Note: this method will automatically also apply the `LegacyElementMixin`
 * to ensure that any legacy behaviors can rely on legacy Polymer API on
 * the underlying element.
 *
 * @function
 * @template T
 * @param {!Object|!Array<!Object>} behaviors Behavior object or array of behaviors.
 * @param {function(new:T)} klass Element class.
 * @return {?} Returns a new Element class extended by the
 * passed in `behaviors` and also by `LegacyElementMixin`.
 * @suppress {invalidCasts, checkTypes}
 */ parcelHelpers.export(exports, "mixinBehaviors", ()=>mixinBehaviors
);
parcelHelpers.export(exports, "Class", ()=>Class
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ var _legacyElementMixinJs = require("./legacy-element-mixin.js");
var _settingsJs = require("../utils/settings.js");
const lifecycleProps = {
    attached: true,
    detached: true,
    ready: true,
    created: true,
    beforeRegister: true,
    registered: true,
    attributeChanged: true,
    listeners: true,
    hostAttributes: true
};
const excludeOnInfo = {
    attached: true,
    detached: true,
    ready: true,
    created: true,
    beforeRegister: true,
    registered: true,
    attributeChanged: true,
    behaviors: true,
    _noAccessors: true
};
const excludeOnBehaviors = Object.assign({
    listeners: true,
    hostAttributes: true,
    properties: true,
    observers: true
}, excludeOnInfo);
function copyProperties(source, target, excludeProps) {
    const noAccessors = source._noAccessors;
    const propertyNames = Object.getOwnPropertyNames(source);
    for(let i = 0; i < propertyNames.length; i++){
        let p = propertyNames[i];
        if (p in excludeProps) continue;
        if (noAccessors) target[p] = source[p];
        else {
            let pd = Object.getOwnPropertyDescriptor(source, p);
            if (pd) {
                // ensure property is configurable so that a later behavior can
                // re-configure it.
                pd.configurable = true;
                Object.defineProperty(target, p, pd);
            }
        }
    }
}
function mixinBehaviors(behaviors, klass) {
    return GenerateClassFromInfo({
    }, _legacyElementMixinJs.LegacyElementMixin(klass), behaviors);
}
// NOTE:
// 1.x
// Behaviors were mixed in *in reverse order* and de-duped on the fly.
// The rule was that behavior properties were copied onto the element
// prototype if and only if the property did not already exist.
// Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:
// (1), B, (2), A, (3) C. This means prototype properties win over
// B properties win over A win over C. This mirrors what would happen
// with inheritance if element extended B extended A extended C.
//
// Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting
// `behaviors` array was [C, A, B].
// Behavior lifecycle methods were called in behavior array order
// followed by the element, e.g. (1) C.created, (2) A.created,
// (3) B.created, (4) element.created. There was no support for
// super, and "super-behavior" methods were callable only by name).
//
// 2.x
// Behaviors are made into proper mixins which live in the
// element's prototype chain. Behaviors are placed in the element prototype
// eldest to youngest and de-duped youngest to oldest:
// So, first [A, B, C, A, B] becomes [C, A, B] then,
// the element prototype becomes (oldest) (1) PolymerElement, (2) class(C),
// (3) class(A), (4) class(B), (5) class(Polymer({...})).
// Result:
// This means element properties win over B properties win over A win
// over C. (same as 1.x)
// If lifecycle is called (super then me), order is
// (1) C.created, (2) A.created, (3) B.created, (4) element.created
// (again same as 1.x)
function applyBehaviors(proto, behaviors, lifecycle) {
    for(let i = 0; i < behaviors.length; i++)applyInfo(proto, behaviors[i], lifecycle, excludeOnBehaviors);
}
function applyInfo(proto, info, lifecycle, excludeProps) {
    copyProperties(info, proto, excludeProps);
    for(let p in lifecycleProps)if (info[p]) {
        lifecycle[p] = lifecycle[p] || [];
        lifecycle[p].push(info[p]);
    }
}
/**
 * @param {Array} behaviors List of behaviors to flatten.
 * @param {Array=} list Target list to flatten behaviors into.
 * @param {Array=} exclude List of behaviors to exclude from the list.
 * @return {!Array} Returns the list of flattened behaviors.
 */ function flattenBehaviors(behaviors, list, exclude) {
    list = list || [];
    for(let i = behaviors.length - 1; i >= 0; i--){
        let b = behaviors[i];
        if (b) {
            if (Array.isArray(b)) flattenBehaviors(b, list);
            else // dedup
            if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) list.unshift(b);
        } else console.warn('behavior is null, check for missing or 404 import');
    }
    return list;
}
/**
 * Copies property descriptors from source to target, overwriting all fields
 * of any previous descriptor for a property *except* for `value`, which is
 * merged in from the target if it does not exist on the source.
 *
 * @param {*} target Target properties object
 * @param {*} source Source properties object
 */ function mergeProperties(target, source) {
    for(const p in source){
        const targetInfo = target[p];
        const sourceInfo = source[p];
        if (!('value' in sourceInfo) && targetInfo && 'value' in targetInfo) target[p] = Object.assign({
            value: targetInfo.value
        }, sourceInfo);
        else target[p] = sourceInfo;
    }
}
const LegacyElement = _legacyElementMixinJs.LegacyElementMixin(HTMLElement);
/* Note about construction and extension of legacy classes.
  [Changed in Q4 2018 to optimize performance.]

  When calling `Polymer` or `mixinBehaviors`, the generated class below is
  made. The list of behaviors was previously made into one generated class per
  behavior, but this is no longer the case as behaviors are now called
  manually. Note, there may *still* be multiple generated classes in the
  element's prototype chain if extension is used with `mixinBehaviors`.

  The generated class is directly tied to the info object and behaviors
  used to create it. That list of behaviors is filtered so it's only the
  behaviors not active on the superclass. In order to call through to the
  entire list of lifecycle methods, it's important to call `super`.

  The element's `properties` and `observers` are controlled via the finalization
  mechanism provided by `PropertiesMixin`. `Properties` and `observers` are
  collected by manually traversing the prototype chain and merging.

  To limit changes, the `_registered` method is called via `_initializeProperties`
  and not `_finalizeClass`.

*/ /**
 * @param {!PolymerInit} info Polymer info object
 * @param {function(new:HTMLElement)} Base base class to extend with info object
 * @param {Object=} behaviors behaviors to copy into the element
 * @return {function(new:HTMLElement)} Generated class
 * @suppress {checkTypes}
 * @private
 */ function GenerateClassFromInfo(info, Base, behaviors) {
    // manages behavior and lifecycle processing (filled in after class definition)
    let behaviorList;
    const lifecycle = {
    };
    /** @private */ class PolymerGenerated extends Base {
        // explicitly not calling super._finalizeClass
        /** @nocollapse */ static _finalizeClass() {
            // if calling via a subclass that hasn't been generated, pass through to super
            if (!this.hasOwnProperty(JSCompiler_renameProperty('generatedFrom', this))) // TODO(https://github.com/google/closure-compiler/issues/3240):
            //     Change back to just super.methodCall()
            Base._finalizeClass.call(this);
            else {
                // interleave properties and observers per behavior and `info`
                if (behaviorList) for(let i = 0, b; i < behaviorList.length; i++){
                    b = behaviorList[i];
                    if (b.properties) this.createProperties(b.properties);
                    if (b.observers) this.createObservers(b.observers, b.properties);
                }
                if (info.properties) this.createProperties(info.properties);
                if (info.observers) this.createObservers(info.observers, info.properties);
                // make sure to prepare the element template
                this._prepareTemplate();
            }
        }
        /** @nocollapse */ static get properties() {
            const properties = {
            };
            if (behaviorList) for(let i = 0; i < behaviorList.length; i++)mergeProperties(properties, behaviorList[i].properties);
            mergeProperties(properties, info.properties);
            return properties;
        }
        /** @nocollapse */ static get observers() {
            let observers = [];
            if (behaviorList) for(let i = 0, b; i < behaviorList.length; i++){
                b = behaviorList[i];
                if (b.observers) observers = observers.concat(b.observers);
            }
            if (info.observers) observers = observers.concat(info.observers);
            return observers;
        }
        /**
     * @return {void}
     */ created() {
            super.created();
            const list = lifecycle.created;
            if (list) for(let i = 0; i < list.length; i++)list[i].call(this);
        }
        /**
     * @return {void}
     */ _registered() {
            /* NOTE: `beforeRegister` is called here for bc, but the behavior
        is different than in 1.x. In 1.0, the method was called *after*
        mixing prototypes together but *before* processing of meta-objects.
        However, dynamic effects can still be set here and can be done either
        in `beforeRegister` or `registered`. It is no longer possible to set
        `is` in `beforeRegister` as you could in 1.x.
      */ // only proceed if the generated class' prototype has not been registered.
            const generatedProto = PolymerGenerated.prototype;
            if (!generatedProto.hasOwnProperty(JSCompiler_renameProperty('__hasRegisterFinished', generatedProto))) {
                generatedProto.__hasRegisterFinished = true;
                // ensure superclass is registered first.
                super._registered();
                // copy properties onto the generated class lazily if we're optimizing,
                if (_settingsJs.legacyOptimizations) copyPropertiesToProto(generatedProto);
                // make sure legacy lifecycle is called on the *element*'s prototype
                // and not the generated class prototype; if the element has been
                // extended, these are *not* the same.
                const proto = Object.getPrototypeOf(this);
                let list = lifecycle.beforeRegister;
                if (list) for(let i = 0; i < list.length; i++)list[i].call(proto);
                list = lifecycle.registered;
                if (list) for(let i1 = 0; i1 < list.length; i1++)list[i1].call(proto);
            }
        }
        /**
     * @return {void}
     */ _applyListeners() {
            super._applyListeners();
            const list = lifecycle.listeners;
            if (list) for(let i = 0; i < list.length; i++){
                const listeners = list[i];
                if (listeners) for(let l in listeners)this._addMethodEventListenerToNode(this, l, listeners[l]);
            }
        }
        // note: exception to "super then me" rule;
        // do work before calling super so that super attributes
        // only apply if not already set.
        /**
     * @return {void}
     */ _ensureAttributes() {
            const list = lifecycle.hostAttributes;
            if (list) for(let i = list.length - 1; i >= 0; i--){
                const hostAttributes = list[i];
                for(let a in hostAttributes)this._ensureAttribute(a, hostAttributes[a]);
            }
            super._ensureAttributes();
        }
        /**
     * @return {void}
     */ ready() {
            super.ready();
            let list = lifecycle.ready;
            if (list) for(let i = 0; i < list.length; i++)list[i].call(this);
        }
        /**
     * @return {void}
     */ attached() {
            super.attached();
            let list = lifecycle.attached;
            if (list) for(let i = 0; i < list.length; i++)list[i].call(this);
        }
        /**
     * @return {void}
     */ detached() {
            super.detached();
            let list = lifecycle.detached;
            if (list) for(let i = 0; i < list.length; i++)list[i].call(this);
        }
        /**
     * Implements native Custom Elements `attributeChangedCallback` to
     * set an attribute value to a property via `_attributeToProperty`.
     *
     * @param {string} name Name of attribute that changed
     * @param {?string} old Old attribute value
     * @param {?string} value New attribute value
     * @return {void}
     */ attributeChanged(name, old, value) {
            super.attributeChanged();
            let list = lifecycle.attributeChanged;
            if (list) for(let i = 0; i < list.length; i++)list[i].call(this, name, old, value);
        }
    }
    // apply behaviors, note actual copying is done lazily at first instance creation
    if (behaviors) {
        // NOTE: ensure the behavior is extending a class with
        // legacy element api. This is necessary since behaviors expect to be able
        // to access 1.x legacy api.
        if (!Array.isArray(behaviors)) behaviors = [
            behaviors
        ];
        let superBehaviors = Base.prototype.behaviors;
        // get flattened, deduped list of behaviors *not* already on super class
        behaviorList = flattenBehaviors(behaviors, null, superBehaviors);
        PolymerGenerated.prototype.behaviors = superBehaviors ? superBehaviors.concat(behaviors) : behaviorList;
    }
    const copyPropertiesToProto = (proto)=>{
        if (behaviorList) applyBehaviors(proto, behaviorList, lifecycle);
        applyInfo(proto, info, lifecycle, excludeOnInfo);
    };
    // copy properties if we're not optimizing
    if (!_settingsJs.legacyOptimizations) copyPropertiesToProto(PolymerGenerated.prototype);
    PolymerGenerated.generatedFrom = info;
    return PolymerGenerated;
}
const Class = function(info, mixin) {
    if (!info) console.warn('Polymer.Class requires `info` argument');
    let klass = mixin ? mixin(LegacyElement) : LegacyElement;
    klass = GenerateClassFromInfo(info, klass, info.behaviors);
    // decorate klass with registration info
    klass.is = klass.prototype.is = info.is;
    return klass;
};

},{"./legacy-element-mixin.js":"2mHGE","../utils/settings.js":"44bo5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cP0Rx":[function(require,module,exports) {
/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/ var _polymerLegacyJs = require("@polymer/polymer/polymer-legacy.js");
var _htmlTagJs = require("@polymer/polymer/lib/utils/html-tag.js");
const template = _htmlTagJs.html`
<custom-style>
  <style is="custom-style">
    html {

      /* Material Design color palette for Google products */

      --google-red-100: #f4c7c3;
      --google-red-300: #e67c73;
      --google-red-500: #db4437;
      --google-red-700: #c53929;

      --google-blue-100: #c6dafc;
      --google-blue-300: #7baaf7;
      --google-blue-500: #4285f4;
      --google-blue-700: #3367d6;

      --google-green-100: #b7e1cd;
      --google-green-300: #57bb8a;
      --google-green-500: #0f9d58;
      --google-green-700: #0b8043;

      --google-yellow-100: #fce8b2;
      --google-yellow-300: #f7cb4d;
      --google-yellow-500: #f4b400;
      --google-yellow-700: #f09300;

      --google-grey-100: #f5f5f5;
      --google-grey-300: #e0e0e0;
      --google-grey-500: #9e9e9e;
      --google-grey-700: #616161;

      /* Material Design color palette from online spec document */

      --paper-red-50: #ffebee;
      --paper-red-100: #ffcdd2;
      --paper-red-200: #ef9a9a;
      --paper-red-300: #e57373;
      --paper-red-400: #ef5350;
      --paper-red-500: #f44336;
      --paper-red-600: #e53935;
      --paper-red-700: #d32f2f;
      --paper-red-800: #c62828;
      --paper-red-900: #b71c1c;
      --paper-red-a100: #ff8a80;
      --paper-red-a200: #ff5252;
      --paper-red-a400: #ff1744;
      --paper-red-a700: #d50000;

      --paper-pink-50: #fce4ec;
      --paper-pink-100: #f8bbd0;
      --paper-pink-200: #f48fb1;
      --paper-pink-300: #f06292;
      --paper-pink-400: #ec407a;
      --paper-pink-500: #e91e63;
      --paper-pink-600: #d81b60;
      --paper-pink-700: #c2185b;
      --paper-pink-800: #ad1457;
      --paper-pink-900: #880e4f;
      --paper-pink-a100: #ff80ab;
      --paper-pink-a200: #ff4081;
      --paper-pink-a400: #f50057;
      --paper-pink-a700: #c51162;

      --paper-purple-50: #f3e5f5;
      --paper-purple-100: #e1bee7;
      --paper-purple-200: #ce93d8;
      --paper-purple-300: #ba68c8;
      --paper-purple-400: #ab47bc;
      --paper-purple-500: #9c27b0;
      --paper-purple-600: #8e24aa;
      --paper-purple-700: #7b1fa2;
      --paper-purple-800: #6a1b9a;
      --paper-purple-900: #4a148c;
      --paper-purple-a100: #ea80fc;
      --paper-purple-a200: #e040fb;
      --paper-purple-a400: #d500f9;
      --paper-purple-a700: #aa00ff;

      --paper-deep-purple-50: #ede7f6;
      --paper-deep-purple-100: #d1c4e9;
      --paper-deep-purple-200: #b39ddb;
      --paper-deep-purple-300: #9575cd;
      --paper-deep-purple-400: #7e57c2;
      --paper-deep-purple-500: #673ab7;
      --paper-deep-purple-600: #5e35b1;
      --paper-deep-purple-700: #512da8;
      --paper-deep-purple-800: #4527a0;
      --paper-deep-purple-900: #311b92;
      --paper-deep-purple-a100: #b388ff;
      --paper-deep-purple-a200: #7c4dff;
      --paper-deep-purple-a400: #651fff;
      --paper-deep-purple-a700: #6200ea;

      --paper-indigo-50: #e8eaf6;
      --paper-indigo-100: #c5cae9;
      --paper-indigo-200: #9fa8da;
      --paper-indigo-300: #7986cb;
      --paper-indigo-400: #5c6bc0;
      --paper-indigo-500: #3f51b5;
      --paper-indigo-600: #3949ab;
      --paper-indigo-700: #303f9f;
      --paper-indigo-800: #283593;
      --paper-indigo-900: #1a237e;
      --paper-indigo-a100: #8c9eff;
      --paper-indigo-a200: #536dfe;
      --paper-indigo-a400: #3d5afe;
      --paper-indigo-a700: #304ffe;

      --paper-blue-50: #e3f2fd;
      --paper-blue-100: #bbdefb;
      --paper-blue-200: #90caf9;
      --paper-blue-300: #64b5f6;
      --paper-blue-400: #42a5f5;
      --paper-blue-500: #2196f3;
      --paper-blue-600: #1e88e5;
      --paper-blue-700: #1976d2;
      --paper-blue-800: #1565c0;
      --paper-blue-900: #0d47a1;
      --paper-blue-a100: #82b1ff;
      --paper-blue-a200: #448aff;
      --paper-blue-a400: #2979ff;
      --paper-blue-a700: #2962ff;

      --paper-light-blue-50: #e1f5fe;
      --paper-light-blue-100: #b3e5fc;
      --paper-light-blue-200: #81d4fa;
      --paper-light-blue-300: #4fc3f7;
      --paper-light-blue-400: #29b6f6;
      --paper-light-blue-500: #03a9f4;
      --paper-light-blue-600: #039be5;
      --paper-light-blue-700: #0288d1;
      --paper-light-blue-800: #0277bd;
      --paper-light-blue-900: #01579b;
      --paper-light-blue-a100: #80d8ff;
      --paper-light-blue-a200: #40c4ff;
      --paper-light-blue-a400: #00b0ff;
      --paper-light-blue-a700: #0091ea;

      --paper-cyan-50: #e0f7fa;
      --paper-cyan-100: #b2ebf2;
      --paper-cyan-200: #80deea;
      --paper-cyan-300: #4dd0e1;
      --paper-cyan-400: #26c6da;
      --paper-cyan-500: #00bcd4;
      --paper-cyan-600: #00acc1;
      --paper-cyan-700: #0097a7;
      --paper-cyan-800: #00838f;
      --paper-cyan-900: #006064;
      --paper-cyan-a100: #84ffff;
      --paper-cyan-a200: #18ffff;
      --paper-cyan-a400: #00e5ff;
      --paper-cyan-a700: #00b8d4;

      --paper-teal-50: #e0f2f1;
      --paper-teal-100: #b2dfdb;
      --paper-teal-200: #80cbc4;
      --paper-teal-300: #4db6ac;
      --paper-teal-400: #26a69a;
      --paper-teal-500: #009688;
      --paper-teal-600: #00897b;
      --paper-teal-700: #00796b;
      --paper-teal-800: #00695c;
      --paper-teal-900: #004d40;
      --paper-teal-a100: #a7ffeb;
      --paper-teal-a200: #64ffda;
      --paper-teal-a400: #1de9b6;
      --paper-teal-a700: #00bfa5;

      --paper-green-50: #e8f5e9;
      --paper-green-100: #c8e6c9;
      --paper-green-200: #a5d6a7;
      --paper-green-300: #81c784;
      --paper-green-400: #66bb6a;
      --paper-green-500: #4caf50;
      --paper-green-600: #43a047;
      --paper-green-700: #388e3c;
      --paper-green-800: #2e7d32;
      --paper-green-900: #1b5e20;
      --paper-green-a100: #b9f6ca;
      --paper-green-a200: #69f0ae;
      --paper-green-a400: #00e676;
      --paper-green-a700: #00c853;

      --paper-light-green-50: #f1f8e9;
      --paper-light-green-100: #dcedc8;
      --paper-light-green-200: #c5e1a5;
      --paper-light-green-300: #aed581;
      --paper-light-green-400: #9ccc65;
      --paper-light-green-500: #8bc34a;
      --paper-light-green-600: #7cb342;
      --paper-light-green-700: #689f38;
      --paper-light-green-800: #558b2f;
      --paper-light-green-900: #33691e;
      --paper-light-green-a100: #ccff90;
      --paper-light-green-a200: #b2ff59;
      --paper-light-green-a400: #76ff03;
      --paper-light-green-a700: #64dd17;

      --paper-lime-50: #f9fbe7;
      --paper-lime-100: #f0f4c3;
      --paper-lime-200: #e6ee9c;
      --paper-lime-300: #dce775;
      --paper-lime-400: #d4e157;
      --paper-lime-500: #cddc39;
      --paper-lime-600: #c0ca33;
      --paper-lime-700: #afb42b;
      --paper-lime-800: #9e9d24;
      --paper-lime-900: #827717;
      --paper-lime-a100: #f4ff81;
      --paper-lime-a200: #eeff41;
      --paper-lime-a400: #c6ff00;
      --paper-lime-a700: #aeea00;

      --paper-yellow-50: #fffde7;
      --paper-yellow-100: #fff9c4;
      --paper-yellow-200: #fff59d;
      --paper-yellow-300: #fff176;
      --paper-yellow-400: #ffee58;
      --paper-yellow-500: #ffeb3b;
      --paper-yellow-600: #fdd835;
      --paper-yellow-700: #fbc02d;
      --paper-yellow-800: #f9a825;
      --paper-yellow-900: #f57f17;
      --paper-yellow-a100: #ffff8d;
      --paper-yellow-a200: #ffff00;
      --paper-yellow-a400: #ffea00;
      --paper-yellow-a700: #ffd600;

      --paper-amber-50: #fff8e1;
      --paper-amber-100: #ffecb3;
      --paper-amber-200: #ffe082;
      --paper-amber-300: #ffd54f;
      --paper-amber-400: #ffca28;
      --paper-amber-500: #ffc107;
      --paper-amber-600: #ffb300;
      --paper-amber-700: #ffa000;
      --paper-amber-800: #ff8f00;
      --paper-amber-900: #ff6f00;
      --paper-amber-a100: #ffe57f;
      --paper-amber-a200: #ffd740;
      --paper-amber-a400: #ffc400;
      --paper-amber-a700: #ffab00;

      --paper-orange-50: #fff3e0;
      --paper-orange-100: #ffe0b2;
      --paper-orange-200: #ffcc80;
      --paper-orange-300: #ffb74d;
      --paper-orange-400: #ffa726;
      --paper-orange-500: #ff9800;
      --paper-orange-600: #fb8c00;
      --paper-orange-700: #f57c00;
      --paper-orange-800: #ef6c00;
      --paper-orange-900: #e65100;
      --paper-orange-a100: #ffd180;
      --paper-orange-a200: #ffab40;
      --paper-orange-a400: #ff9100;
      --paper-orange-a700: #ff6500;

      --paper-deep-orange-50: #fbe9e7;
      --paper-deep-orange-100: #ffccbc;
      --paper-deep-orange-200: #ffab91;
      --paper-deep-orange-300: #ff8a65;
      --paper-deep-orange-400: #ff7043;
      --paper-deep-orange-500: #ff5722;
      --paper-deep-orange-600: #f4511e;
      --paper-deep-orange-700: #e64a19;
      --paper-deep-orange-800: #d84315;
      --paper-deep-orange-900: #bf360c;
      --paper-deep-orange-a100: #ff9e80;
      --paper-deep-orange-a200: #ff6e40;
      --paper-deep-orange-a400: #ff3d00;
      --paper-deep-orange-a700: #dd2c00;

      --paper-brown-50: #efebe9;
      --paper-brown-100: #d7ccc8;
      --paper-brown-200: #bcaaa4;
      --paper-brown-300: #a1887f;
      --paper-brown-400: #8d6e63;
      --paper-brown-500: #795548;
      --paper-brown-600: #6d4c41;
      --paper-brown-700: #5d4037;
      --paper-brown-800: #4e342e;
      --paper-brown-900: #3e2723;

      --paper-grey-50: #fafafa;
      --paper-grey-100: #f5f5f5;
      --paper-grey-200: #eeeeee;
      --paper-grey-300: #e0e0e0;
      --paper-grey-400: #bdbdbd;
      --paper-grey-500: #9e9e9e;
      --paper-grey-600: #757575;
      --paper-grey-700: #616161;
      --paper-grey-800: #424242;
      --paper-grey-900: #212121;

      --paper-blue-grey-50: #eceff1;
      --paper-blue-grey-100: #cfd8dc;
      --paper-blue-grey-200: #b0bec5;
      --paper-blue-grey-300: #90a4ae;
      --paper-blue-grey-400: #78909c;
      --paper-blue-grey-500: #607d8b;
      --paper-blue-grey-600: #546e7a;
      --paper-blue-grey-700: #455a64;
      --paper-blue-grey-800: #37474f;
      --paper-blue-grey-900: #263238;

      /* opacity for dark text on a light background */
      --dark-divider-opacity: 0.12;
      --dark-disabled-opacity: 0.38; /* or hint text or icon */
      --dark-secondary-opacity: 0.54;
      --dark-primary-opacity: 0.87;

      /* opacity for light text on a dark background */
      --light-divider-opacity: 0.12;
      --light-disabled-opacity: 0.3; /* or hint text or icon */
      --light-secondary-opacity: 0.7;
      --light-primary-opacity: 1.0;

    }

  </style>
</custom-style>
`;
template.setAttribute('style', 'display: none;');
document.head.appendChild(template.content);

},{"@polymer/polymer/polymer-legacy.js":"4rrHB","@polymer/polymer/lib/utils/html-tag.js":"2ZOZT"}],"ef69Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/ const $_documentContainer = document.createElement('template');
$_documentContainer.setAttribute('style', 'display: none;');
$_documentContainer.innerHTML = `<dom-module id="paper-spinner-styles">
  <template>
    <style>
      /*
      /**************************/
      /* STYLES FOR THE SPINNER */
      /**************************/

      /*
       * Constants:
       *      ARCSIZE     = 270 degrees (amount of circle the arc takes up)
       *      ARCTIME     = 1333ms (time it takes to expand and contract arc)
       *      ARCSTARTROT = 216 degrees (how much the start location of the arc
       *                                should rotate each time, 216 gives us a
       *                                5 pointed star shape (it's 360/5 * 3).
       *                                For a 7 pointed star, we might do
       *                                360/7 * 3 = 154.286)
       *      SHRINK_TIME = 400ms
       */

      :host {
        display: inline-block;
        position: relative;
        width: 28px;
        height: 28px;

        /* 360 * ARCTIME / (ARCSTARTROT + (360-ARCSIZE)) */
        --paper-spinner-container-rotation-duration: 1568ms;

        /* ARCTIME */
        --paper-spinner-expand-contract-duration: 1333ms;

        /* 4 * ARCTIME */
        --paper-spinner-full-cycle-duration: 5332ms;

        /* SHRINK_TIME */
        --paper-spinner-cooldown-duration: 400ms;
      }

      #spinnerContainer {
        width: 100%;
        height: 100%;

        /* The spinner does not have any contents that would have to be
         * flipped if the direction changes. Always use ltr so that the
         * style works out correctly in both cases. */
        direction: ltr;
      }

      #spinnerContainer.active {
        -webkit-animation: container-rotate var(--paper-spinner-container-rotation-duration) linear infinite;
        animation: container-rotate var(--paper-spinner-container-rotation-duration) linear infinite;
      }

      @-webkit-keyframes container-rotate {
        to { -webkit-transform: rotate(360deg) }
      }

      @keyframes container-rotate {
        to { transform: rotate(360deg) }
      }

      .spinner-layer {
        position: absolute;
        width: 100%;
        height: 100%;
        opacity: 0;
        white-space: nowrap;
        color: var(--paper-spinner-color, var(--google-blue-500));
      }

      .layer-1 {
        color: var(--paper-spinner-layer-1-color, var(--google-blue-500));
      }

      .layer-2 {
        color: var(--paper-spinner-layer-2-color, var(--google-red-500));
      }

      .layer-3 {
        color: var(--paper-spinner-layer-3-color, var(--google-yellow-500));
      }

      .layer-4 {
        color: var(--paper-spinner-layer-4-color, var(--google-green-500));
      }

      /**
       * IMPORTANT NOTE ABOUT CSS ANIMATION PROPERTIES (keanulee):
       *
       * iOS Safari (tested on iOS 8.1) does not handle animation-delay very well - it doesn't
       * guarantee that the animation will start _exactly_ after that value. So we avoid using
       * animation-delay and instead set custom keyframes for each color (as layer-2undant as it
       * seems).
       */
      .active .spinner-layer {
        -webkit-animation-name: fill-unfill-rotate;
        -webkit-animation-duration: var(--paper-spinner-full-cycle-duration);
        -webkit-animation-timing-function: cubic-bezier(0.4, 0.0, 0.2, 1);
        -webkit-animation-iteration-count: infinite;
        animation-name: fill-unfill-rotate;
        animation-duration: var(--paper-spinner-full-cycle-duration);
        animation-timing-function: cubic-bezier(0.4, 0.0, 0.2, 1);
        animation-iteration-count: infinite;
        opacity: 1;
      }

      .active .spinner-layer.layer-1 {
        -webkit-animation-name: fill-unfill-rotate, layer-1-fade-in-out;
        animation-name: fill-unfill-rotate, layer-1-fade-in-out;
      }

      .active .spinner-layer.layer-2 {
        -webkit-animation-name: fill-unfill-rotate, layer-2-fade-in-out;
        animation-name: fill-unfill-rotate, layer-2-fade-in-out;
      }

      .active .spinner-layer.layer-3 {
        -webkit-animation-name: fill-unfill-rotate, layer-3-fade-in-out;
        animation-name: fill-unfill-rotate, layer-3-fade-in-out;
      }

      .active .spinner-layer.layer-4 {
        -webkit-animation-name: fill-unfill-rotate, layer-4-fade-in-out;
        animation-name: fill-unfill-rotate, layer-4-fade-in-out;
      }

      @-webkit-keyframes fill-unfill-rotate {
        12.5% { -webkit-transform: rotate(135deg) } /* 0.5 * ARCSIZE */
        25%   { -webkit-transform: rotate(270deg) } /* 1   * ARCSIZE */
        37.5% { -webkit-transform: rotate(405deg) } /* 1.5 * ARCSIZE */
        50%   { -webkit-transform: rotate(540deg) } /* 2   * ARCSIZE */
        62.5% { -webkit-transform: rotate(675deg) } /* 2.5 * ARCSIZE */
        75%   { -webkit-transform: rotate(810deg) } /* 3   * ARCSIZE */
        87.5% { -webkit-transform: rotate(945deg) } /* 3.5 * ARCSIZE */
        to    { -webkit-transform: rotate(1080deg) } /* 4   * ARCSIZE */
      }

      @keyframes fill-unfill-rotate {
        12.5% { transform: rotate(135deg) } /* 0.5 * ARCSIZE */
        25%   { transform: rotate(270deg) } /* 1   * ARCSIZE */
        37.5% { transform: rotate(405deg) } /* 1.5 * ARCSIZE */
        50%   { transform: rotate(540deg) } /* 2   * ARCSIZE */
        62.5% { transform: rotate(675deg) } /* 2.5 * ARCSIZE */
        75%   { transform: rotate(810deg) } /* 3   * ARCSIZE */
        87.5% { transform: rotate(945deg) } /* 3.5 * ARCSIZE */
        to    { transform: rotate(1080deg) } /* 4   * ARCSIZE */
      }

      @-webkit-keyframes layer-1-fade-in-out {
        0% { opacity: 1 }
        25% { opacity: 1 }
        26% { opacity: 0 }
        89% { opacity: 0 }
        90% { opacity: 1 }
        to { opacity: 1 }
      }

      @keyframes layer-1-fade-in-out {
        0% { opacity: 1 }
        25% { opacity: 1 }
        26% { opacity: 0 }
        89% { opacity: 0 }
        90% { opacity: 1 }
        to { opacity: 1 }
      }

      @-webkit-keyframes layer-2-fade-in-out {
        0% { opacity: 0 }
        15% { opacity: 0 }
        25% { opacity: 1 }
        50% { opacity: 1 }
        51% { opacity: 0 }
        to { opacity: 0 }
      }

      @keyframes layer-2-fade-in-out {
        0% { opacity: 0 }
        15% { opacity: 0 }
        25% { opacity: 1 }
        50% { opacity: 1 }
        51% { opacity: 0 }
        to { opacity: 0 }
      }

      @-webkit-keyframes layer-3-fade-in-out {
        0% { opacity: 0 }
        40% { opacity: 0 }
        50% { opacity: 1 }
        75% { opacity: 1 }
        76% { opacity: 0 }
        to { opacity: 0 }
      }

      @keyframes layer-3-fade-in-out {
        0% { opacity: 0 }
        40% { opacity: 0 }
        50% { opacity: 1 }
        75% { opacity: 1 }
        76% { opacity: 0 }
        to { opacity: 0 }
      }

      @-webkit-keyframes layer-4-fade-in-out {
        0% { opacity: 0 }
        65% { opacity: 0 }
        75% { opacity: 1 }
        90% { opacity: 1 }
        to { opacity: 0 }
      }

      @keyframes layer-4-fade-in-out {
        0% { opacity: 0 }
        65% { opacity: 0 }
        75% { opacity: 1 }
        90% { opacity: 1 }
        to { opacity: 0 }
      }

      .circle-clipper {
        display: inline-block;
        position: relative;
        width: 50%;
        height: 100%;
        overflow: hidden;
      }

      /**
       * Patch the gap that appear between the two adjacent div.circle-clipper while the
       * spinner is rotating (appears on Chrome 50, Safari 9.1.1, and Edge).
       */
      .spinner-layer::after {
        content: '';
        left: 45%;
        width: 10%;
        border-top-style: solid;
      }

      .spinner-layer::after,
      .circle-clipper .circle {
        box-sizing: border-box;
        position: absolute;
        top: 0;
        border-width: var(--paper-spinner-stroke-width, 3px);
        border-radius: 50%;
      }

      .circle-clipper .circle {
        bottom: 0;
        width: 200%;
        border-style: solid;
        border-bottom-color: transparent !important;
      }

      .circle-clipper.left .circle {
        left: 0;
        border-right-color: transparent !important;
        -webkit-transform: rotate(129deg);
        transform: rotate(129deg);
      }

      .circle-clipper.right .circle {
        left: -100%;
        border-left-color: transparent !important;
        -webkit-transform: rotate(-129deg);
        transform: rotate(-129deg);
      }

      .active .gap-patch::after,
      .active .circle-clipper .circle {
        -webkit-animation-duration: var(--paper-spinner-expand-contract-duration);
        -webkit-animation-timing-function: cubic-bezier(0.4, 0.0, 0.2, 1);
        -webkit-animation-iteration-count: infinite;
        animation-duration: var(--paper-spinner-expand-contract-duration);
        animation-timing-function: cubic-bezier(0.4, 0.0, 0.2, 1);
        animation-iteration-count: infinite;
      }

      .active .circle-clipper.left .circle {
        -webkit-animation-name: left-spin;
        animation-name: left-spin;
      }

      .active .circle-clipper.right .circle {
        -webkit-animation-name: right-spin;
        animation-name: right-spin;
      }

      @-webkit-keyframes left-spin {
        0% { -webkit-transform: rotate(130deg) }
        50% { -webkit-transform: rotate(-5deg) }
        to { -webkit-transform: rotate(130deg) }
      }

      @keyframes left-spin {
        0% { transform: rotate(130deg) }
        50% { transform: rotate(-5deg) }
        to { transform: rotate(130deg) }
      }

      @-webkit-keyframes right-spin {
        0% { -webkit-transform: rotate(-130deg) }
        50% { -webkit-transform: rotate(5deg) }
        to { -webkit-transform: rotate(-130deg) }
      }

      @keyframes right-spin {
        0% { transform: rotate(-130deg) }
        50% { transform: rotate(5deg) }
        to { transform: rotate(-130deg) }
      }

      #spinnerContainer.cooldown {
        -webkit-animation: container-rotate var(--paper-spinner-container-rotation-duration) linear infinite, fade-out var(--paper-spinner-cooldown-duration) cubic-bezier(0.4, 0.0, 0.2, 1);
        animation: container-rotate var(--paper-spinner-container-rotation-duration) linear infinite, fade-out var(--paper-spinner-cooldown-duration) cubic-bezier(0.4, 0.0, 0.2, 1);
      }

      @-webkit-keyframes fade-out {
        0% { opacity: 1 }
        to { opacity: 0 }
      }

      @keyframes fade-out {
        0% { opacity: 1 }
        to { opacity: 0 }
      }
    </style>
  </template>
</dom-module>`;
document.head.appendChild($_documentContainer.content);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fXl8X":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PaperSpinnerBehavior", ()=>PaperSpinnerBehavior
);
/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/ var _polymerLegacyJs = require("@polymer/polymer/polymer-legacy.js");
const PaperSpinnerBehavior = {
    properties: {
        /**
     * Displays the spinner.
     */ active: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
            observer: '__activeChanged'
        },
        /**
     * Alternative text content for accessibility support.
     * If alt is present, it will add an aria-label whose content matches alt
     * when active. If alt is not present, it will default to 'loading' as the
     * alt value.
     */ alt: {
            type: String,
            value: 'loading',
            observer: '__altChanged'
        },
        __coolingDown: {
            type: Boolean,
            value: false
        }
    },
    __computeContainerClasses: function(active, coolingDown) {
        return [
            active || coolingDown ? 'active' : '',
            coolingDown ? 'cooldown' : ''
        ].join(' ');
    },
    __activeChanged: function(active, old) {
        this.__setAriaHidden(!active);
        this.__coolingDown = !active && old;
    },
    __altChanged: function(alt) {
        // user-provided `aria-label` takes precedence over prototype default
        if (alt === 'loading') this.alt = this.getAttribute('aria-label') || alt;
        else {
            this.__setAriaHidden(alt === '');
            this.setAttribute('aria-label', alt);
        }
    },
    __setAriaHidden: function(hidden) {
        var attr = 'aria-hidden';
        if (hidden) this.setAttribute(attr, 'true');
        else this.removeAttribute(attr);
    },
    __reset: function() {
        this.active = false;
        this.__coolingDown = false;
    }
};

},{"@polymer/polymer/polymer-legacy.js":"4rrHB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hGpP7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MulticastSource", ()=>MulticastSource
);
parcelHelpers.export(exports, "ap", ()=>ap$1
);
parcelHelpers.export(exports, "at", ()=>at
);
parcelHelpers.export(exports, "awaitPromises", ()=>awaitPromises
);
parcelHelpers.export(exports, "chain", ()=>chain$1
);
parcelHelpers.export(exports, "combine", ()=>combine$1
);
parcelHelpers.export(exports, "combineArray", ()=>combineArray$1
);
parcelHelpers.export(exports, "concatMap", ()=>concatMap$1
);
parcelHelpers.export(exports, "constant", ()=>constant$1
);
parcelHelpers.export(exports, "continueWith", ()=>continueWith$1
);
parcelHelpers.export(exports, "debounce", ()=>debounce$1
);
parcelHelpers.export(exports, "delay", ()=>delay$1
);
parcelHelpers.export(exports, "during", ()=>during$1
);
parcelHelpers.export(exports, "empty", ()=>empty
);
parcelHelpers.export(exports, "filter", ()=>filter$1
);
parcelHelpers.export(exports, "fromPromise", ()=>fromPromise
);
parcelHelpers.export(exports, "join", ()=>join
);
parcelHelpers.export(exports, "loop", ()=>loop$1
);
parcelHelpers.export(exports, "map", ()=>map$1
);
parcelHelpers.export(exports, "merge", ()=>merge$1
);
parcelHelpers.export(exports, "mergeArray", ()=>mergeArray
);
parcelHelpers.export(exports, "mergeConcurrently", ()=>mergeConcurrently$1
);
parcelHelpers.export(exports, "mergeMapConcurrently", ()=>mergeMapConcurrently$1
);
parcelHelpers.export(exports, "multicast", ()=>multicast
);
parcelHelpers.export(exports, "never", ()=>never
);
parcelHelpers.export(exports, "newStream", ()=>newStream
);
parcelHelpers.export(exports, "now", ()=>now
);
parcelHelpers.export(exports, "periodic", ()=>periodic
);
parcelHelpers.export(exports, "propagateEndTask", ()=>propagateEndTask
);
parcelHelpers.export(exports, "propagateErrorTask", ()=>propagateErrorTask$1
);
parcelHelpers.export(exports, "propagateEventTask", ()=>propagateEventTask$1
);
parcelHelpers.export(exports, "propagateTask", ()=>propagateTask$1
);
parcelHelpers.export(exports, "recoverWith", ()=>recoverWith$1
);
parcelHelpers.export(exports, "run", ()=>run$1
);
parcelHelpers.export(exports, "runEffects", ()=>runEffects
);
parcelHelpers.export(exports, "sample", ()=>sample$1
);
parcelHelpers.export(exports, "scan", ()=>scan$1
);
parcelHelpers.export(exports, "since", ()=>since$1
);
parcelHelpers.export(exports, "skip", ()=>skip$1
);
parcelHelpers.export(exports, "skipAfter", ()=>skipAfter$1
);
parcelHelpers.export(exports, "skipRepeats", ()=>skipRepeats
);
parcelHelpers.export(exports, "skipRepeatsWith", ()=>skipRepeatsWith$1
);
parcelHelpers.export(exports, "skipWhile", ()=>skipWhile$1
);
parcelHelpers.export(exports, "slice", ()=>slice$1
);
parcelHelpers.export(exports, "snapshot", ()=>snapshot$1
);
parcelHelpers.export(exports, "startWith", ()=>startWith$1
);
parcelHelpers.export(exports, "switchLatest", ()=>switchLatest
);
parcelHelpers.export(exports, "take", ()=>take$1
);
parcelHelpers.export(exports, "takeWhile", ()=>takeWhile$1
);
parcelHelpers.export(exports, "tap", ()=>tap$1
);
parcelHelpers.export(exports, "throttle", ()=>throttle$1
);
parcelHelpers.export(exports, "throwError", ()=>throwError
);
parcelHelpers.export(exports, "until", ()=>until$1
);
parcelHelpers.export(exports, "withItems", ()=>withItems$1
);
parcelHelpers.export(exports, "withLocalTime", ()=>withLocalTime$1
);
parcelHelpers.export(exports, "zip", ()=>zip$1
);
parcelHelpers.export(exports, "zipArray", ()=>zipArray$1
);
parcelHelpers.export(exports, "zipItems", ()=>zipItems$1
);
var _prelude = require("@most/prelude");
var _scheduler = require("@most/scheduler");
var _disposable = require("@most/disposable");
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d1, b1) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
    };
    return extendStatics(d1, b1);
};
function __extends(d, b) {
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
/** @license MIT License (c) copyright 2010-2016 original author or authors */ /** @author Brian Cavalier */ /** @author John Hann */ function fatalError(e) {
    setTimeout(rethrow, 0, e);
}
function rethrow(e) {
    throw e;
}
/** @license MIT License (c) copyright 2010-2016 original author or authors */ var propagateTask = function(run1, value, sink) {
    return new PropagateRunEventTask(run1, value, sink);
};
var propagateEventTask = function(value, sink) {
    return new PropagateEventTask(value, sink);
};
var propagateEndTask = function(sink) {
    return new PropagateEndTask(sink);
};
var propagateErrorTask = function(value, sink) {
    return new PropagateErrorTask(value, sink);
};
var PropagateTask = function() {
    function PropagateTask1(sink) {
        this.sink = sink;
        this.active = true;
    }
    PropagateTask1.prototype.dispose = function() {
        this.active = false;
    };
    PropagateTask1.prototype.run = function(t) {
        if (!this.active) return;
        this.runIfActive(t);
    };
    PropagateTask1.prototype.error = function(t, e) {
        // TODO: Remove this check and just do this.sink.error(t, e)?
        if (!this.active) return fatalError(e);
        this.sink.error(t, e);
    };
    return PropagateTask1;
}();
var PropagateRunEventTask = function(_super) {
    __extends(PropagateRunEventTask1, _super);
    function PropagateRunEventTask1(runEvent, value, sink) {
        var _this = _super.call(this, sink) || this;
        _this.runEvent = runEvent;
        _this.value = value;
        return _this;
    }
    PropagateRunEventTask1.prototype.runIfActive = function(t) {
        this.runEvent(t, this.value, this.sink);
    };
    return PropagateRunEventTask1;
}(PropagateTask);
var PropagateEventTask = function(_super) {
    __extends(PropagateEventTask1, _super);
    function PropagateEventTask1(value, sink) {
        var _this = _super.call(this, sink) || this;
        _this.value = value;
        return _this;
    }
    PropagateEventTask1.prototype.runIfActive = function(t) {
        this.sink.event(t, this.value);
    };
    return PropagateEventTask1;
}(PropagateTask);
var PropagateEndTask = function(_super) {
    __extends(PropagateEndTask1, _super);
    function PropagateEndTask1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PropagateEndTask1.prototype.runIfActive = function(t) {
        this.sink.end(t);
    };
    return PropagateEndTask1;
}(PropagateTask);
var PropagateErrorTask = function(_super) {
    __extends(PropagateErrorTask1, _super);
    function PropagateErrorTask1(value, sink) {
        var _this = _super.call(this, sink) || this;
        _this.value = value;
        return _this;
    }
    PropagateErrorTask1.prototype.runIfActive = function(t) {
        this.sink.error(t, this.value);
    };
    return PropagateErrorTask1;
}(PropagateTask);
/** @license MIT License (c) copyright 2010-2017 original author or authors */ var empty = function() {
    return EMPTY;
};
var isCanonicalEmpty = function(stream) {
    return stream === EMPTY;
};
var containsCanonicalEmpty = function(streams) {
    return streams.some(isCanonicalEmpty);
};
var Empty = function() {
    function Empty1() {
    }
    Empty1.prototype.run = function(sink, scheduler) {
        return _scheduler.asap(propagateEndTask(sink), scheduler);
    };
    return Empty1;
}();
var EMPTY = new Empty();
/** @license MIT License (c) copyright 2010-2017 original author or authors */ var never = function() {
    return NEVER;
};
var Never = function() {
    function Never1() {
    }
    Never1.prototype.run = function() {
        return _disposable.disposeNone();
    };
    return Never1;
}();
var NEVER = new Never();
/** @license MIT License (c) copyright 2010-2017 original author or authors */ var at = function(t, x) {
    return new At(t, x);
};
var At = function() {
    function At1(t, x) {
        this.time = t;
        this.value = x;
    }
    At1.prototype.run = function(sink, scheduler) {
        return _scheduler.delay(this.time, propagateTask(runAt, this.value, sink), scheduler);
    };
    return At1;
}();
function runAt(t, x, sink) {
    sink.event(t, x);
    sink.end(t);
}
/** @license MIT License (c) copyright 2010-2017 original author or authors */ var now = function(x) {
    return at(0, x);
};
/** @license MIT License (c) copyright 2010-2016 original author or authors */ /**
 * Create a stream of events that occur at a regular period
 * @param {Number} period periodicity of events
 * @returns {Stream} new stream of periodic events, the event value is undefined
 */ var periodic = function(period) {
    return new Periodic(period);
};
var Periodic = function() {
    function Periodic1(period) {
        this.period = period;
    }
    Periodic1.prototype.run = function(sink, scheduler) {
        return _scheduler.periodic(this.period, propagateEventTask(undefined, sink), scheduler);
    };
    return Periodic1;
}();
var newStream = function(run2) {
    return new StreamImpl(run2);
};
var StreamImpl = function() {
    function StreamImpl1(run3) {
        this.run = run3;
    }
    return StreamImpl1;
}();
var SettableDisposable = function() {
    function SettableDisposable1() {
        this.disposable = undefined;
        this.disposed = false;
    }
    SettableDisposable1.prototype.setDisposable = function(disposable) {
        if (this.disposable !== undefined) throw new Error('setDisposable called more than once');
        this.disposable = disposable;
        if (this.disposed) disposable.dispose();
    };
    SettableDisposable1.prototype.dispose = function() {
        if (this.disposed) return;
        this.disposed = true;
        if (this.disposable !== undefined) this.disposable.dispose();
    };
    return SettableDisposable1;
}();
/** @license MIT License (c) copyright 2010-2017 original author or authors */ var runEffects = _prelude.curry2(function(stream, scheduler) {
    return new Promise(function(resolve, reject) {
        return runStream(stream, scheduler, resolve, reject);
    });
});
function runStream(stream, scheduler, resolve, reject) {
    var disposable = new SettableDisposable();
    var observer = new RunEffectsSink(resolve, reject, disposable);
    disposable.setDisposable(stream.run(observer, scheduler));
}
var RunEffectsSink = function() {
    function RunEffectsSink1(end, error, disposable) {
        this._end = end;
        this._error = error;
        this._disposable = disposable;
        this.active = true;
    }
    RunEffectsSink1.prototype.event = function() {
    };
    RunEffectsSink1.prototype.end = function() {
        if (!this.active) return;
        this.dispose(this._error, this._end, undefined);
    };
    RunEffectsSink1.prototype.error = function(_t, e) {
        this.dispose(this._error, this._error, e);
    };
    RunEffectsSink1.prototype.dispose = function(error, end, x) {
        this.active = false;
        tryDispose(error, end, x, this._disposable);
    };
    return RunEffectsSink1;
}();
function tryDispose(error, end, x, disposable) {
    try {
        disposable.dispose();
    } catch (e) {
        error(e);
        return;
    }
    end(x);
}
/**
 * Run a Stream, sending all its events to the provided Sink.
 */ var run = function(sink, scheduler, stream) {
    return stream.run(sink, scheduler);
};
var RelativeSink = function() {
    function RelativeSink1(offset, sink) {
        this.sink = sink;
        this.offset = offset;
    }
    RelativeSink1.prototype.event = function(t, x) {
        this.sink.event(t + this.offset, x);
    };
    RelativeSink1.prototype.error = function(t, e) {
        this.sink.error(t + this.offset, e);
    };
    RelativeSink1.prototype.end = function(t) {
        this.sink.end(t + this.offset);
    };
    return RelativeSink1;
}();
/**
 * Create a stream with its own local clock
 * This transforms time from the provided scheduler's clock to a stream-local
 * clock (which starts at 0), and then *back* to the scheduler's clock before
 * propagating events to sink.  In other words, upstream sources will see local times,
 * and downstream sinks will see non-local (original) times.
 */ var withLocalTime = function(origin, stream) {
    return new WithLocalTime(origin, stream);
};
var WithLocalTime = function() {
    function WithLocalTime1(origin, source) {
        this.origin = origin;
        this.source = source;
    }
    WithLocalTime1.prototype.run = function(sink, scheduler) {
        return this.source.run(relativeSink(this.origin, sink), _scheduler.schedulerRelativeTo(this.origin, scheduler));
    };
    return WithLocalTime1;
}();
/**
 * Accumulate offsets instead of nesting RelativeSinks, which can happen
 * with higher-order stream and combinators like continueWith when they're
 * applied recursively.
 */ var relativeSink = function(origin, sink) {
    return sink instanceof RelativeSink ? new RelativeSink(origin + sink.offset, sink.sink) : new RelativeSink(origin, sink);
};
var Pipe = function() {
    function Pipe1(sink) {
        this.sink = sink;
    }
    Pipe1.prototype.end = function(t) {
        return this.sink.end(t);
    };
    Pipe1.prototype.error = function(t, e) {
        return this.sink.error(t, e);
    };
    return Pipe1;
}();
/** @license MIT License (c) copyright 2010 original author or authors */ /**
 * Generalized feedback loop. Call a stepper function for each event. The stepper
 * will be called with 2 params: the current seed and the an event value.  It must
 * return a new { seed, value } pair. The `seed` will be fed back into the next
 * invocation of stepper, and the `value` will be propagated as the event value.
 * @param stepper loop step function
 * @param seed initial seed value passed to first stepper call
 * @param stream event stream
 * @returns new stream whose values are the `value` field of the objects
 * returned by the stepper
 */ var loop = function(stepper, seed, stream) {
    return isCanonicalEmpty(stream) ? empty() : new Loop(stepper, seed, stream);
};
var Loop = function() {
    function Loop1(stepper, seed, source) {
        this.step = stepper;
        this.seed = seed;
        this.source = source;
    }
    Loop1.prototype.run = function(sink, scheduler) {
        return this.source.run(new LoopSink(this.step, this.seed, sink), scheduler);
    };
    return Loop1;
}();
var LoopSink = function(_super) {
    __extends(LoopSink1, _super);
    function LoopSink1(stepper, seed, sink) {
        var _this = _super.call(this, sink) || this;
        _this.step = stepper;
        _this.seed = seed;
        return _this;
    }
    LoopSink1.prototype.event = function(t, x) {
        var result = this.step(this.seed, x);
        this.seed = result.seed;
        this.sink.event(t, result.value);
    };
    return LoopSink1;
}(Pipe);
/** @license MIT License (c) copyright 2010-2016 original author or authors */ /**
 * Create a stream containing successive reduce results of applying f to
 * the previous reduce result and the current stream item.
 * @param f reducer function
 * @param initial initial value
 * @param stream stream to scan
 * @returns new stream containing successive reduce results
 */ var scan = function(f, initial, stream) {
    return new Scan(f, initial, stream);
};
var Scan = function() {
    function Scan1(f, z, source) {
        this.source = source;
        this.f = f;
        this.value = z;
    }
    Scan1.prototype.run = function(sink, scheduler) {
        var d1 = _scheduler.asap(propagateEventTask(this.value, sink), scheduler);
        var d2 = this.source.run(new ScanSink(this.f, this.value, sink), scheduler);
        return _disposable.disposeBoth(d1, d2);
    };
    return Scan1;
}();
var ScanSink = function(_super) {
    __extends(ScanSink1, _super);
    function ScanSink1(f, z, sink) {
        var _this = _super.call(this, sink) || this;
        _this.f = f;
        _this.value = z;
        return _this;
    }
    ScanSink1.prototype.event = function(t, x) {
        var f = this.f;
        this.value = f(this.value, x);
        this.sink.event(t, this.value);
    };
    return ScanSink1;
}(Pipe);
/** @license MIT License (c) copyright 2010-2016 original author or authors */ var continueWith = function(f, stream) {
    return new ContinueWith(f, stream);
};
var ContinueWith = function() {
    function ContinueWith1(f, source) {
        this.f = f;
        this.source = source;
    }
    ContinueWith1.prototype.run = function(sink, scheduler) {
        return new ContinueWithSink(this.f, this.source, sink, scheduler);
    };
    return ContinueWith1;
}();
var ContinueWithSink = function(_super) {
    __extends(ContinueWithSink1, _super);
    function ContinueWithSink1(f, source, sink, scheduler) {
        var _this = _super.call(this, sink) || this;
        _this.f = f;
        _this.scheduler = scheduler;
        _this.active = true;
        _this.disposable = _disposable.disposeOnce(source.run(_this, scheduler));
        return _this;
    }
    ContinueWithSink1.prototype.event = function(t, x) {
        if (!this.active) return;
        this.sink.event(t, x);
    };
    ContinueWithSink1.prototype.end = function(t) {
        if (!this.active) return;
        _disposable.tryDispose(t, this.disposable, this.sink);
        this.startNext(t, this.sink);
    };
    ContinueWithSink1.prototype.startNext = function(t, sink) {
        try {
            this.disposable = this.continue(this.f, t, sink);
        } catch (e) {
            sink.error(t, e);
        }
    };
    ContinueWithSink1.prototype.continue = function(f, t, sink) {
        return run(sink, this.scheduler, withLocalTime(t, f()));
    };
    ContinueWithSink1.prototype.dispose = function() {
        this.active = false;
        return this.disposable.dispose();
    };
    return ContinueWithSink1;
}(Pipe);
/** @license MIT License (c) copyright 2010-2017 original author or authors */ var startWith = function(x, stream) {
    return continueWith(function() {
        return stream;
    }, now(x));
};
/** @license MIT License (c) copyright 2010-2016 original author or authors */ var Filter = function() {
    function Filter1(p, source) {
        this.p = p;
        this.source = source;
    }
    Filter1.prototype.run = function(sink, scheduler) {
        return this.source.run(new FilterSink(this.p, sink), scheduler);
    };
    /**
     * Create a filtered source, fusing adjacent filter.filter if possible
     * @param {function(x:*):boolean} p filtering predicate
     * @param {{run:function}} source source to filter
     * @returns {Filter} filtered source
     */ Filter1.create = function(p, source) {
        if (isCanonicalEmpty(source)) return source;
        if (source instanceof Filter1) return new Filter1(and(source.p, p), source.source);
        return new Filter1(p, source);
    };
    return Filter1;
}();
var FilterSink = function(_super) {
    __extends(FilterSink1, _super);
    function FilterSink1(p, sink) {
        var _this = _super.call(this, sink) || this;
        _this.p = p;
        return _this;
    }
    FilterSink1.prototype.event = function(t, x) {
        var p = this.p;
        p(x) && this.sink.event(t, x);
    };
    return FilterSink1;
}(Pipe);
var and = function(p, q) {
    return function(x) {
        return p(x) && q(x);
    };
};
/** @license MIT License (c) copyright 2010-2016 original author or authors */ var FilterMap = function() {
    function FilterMap1(p, f, source) {
        this.p = p;
        this.f = f;
        this.source = source;
    }
    FilterMap1.prototype.run = function(sink, scheduler) {
        return this.source.run(new FilterMapSink(this.p, this.f, sink), scheduler);
    };
    return FilterMap1;
}();
var FilterMapSink = function(_super) {
    __extends(FilterMapSink1, _super);
    function FilterMapSink1(p, f, sink) {
        var _this = _super.call(this, sink) || this;
        _this.p = p;
        _this.f = f;
        return _this;
    }
    FilterMapSink1.prototype.event = function(t, x) {
        var f = this.f;
        var p = this.p;
        p(x) && this.sink.event(t, f(x));
    };
    return FilterMapSink1;
}(Pipe);
/** @license MIT License (c) copyright 2010-2016 original author or authors */ var Map = function() {
    function Map1(f, source) {
        this.f = f;
        this.source = source;
    }
    Map1.prototype.run = function(sink, scheduler) {
        return this.source.run(new MapSink(this.f, sink), scheduler);
    };
    /**
     * Create a mapped source, fusing adjacent map.map, filter.map,
     * and filter.map.map if possible
     * @param {function(*):*} f mapping function
     * @param {{run:function}} source source to map
     * @returns {Map|FilterMap} mapped source, possibly fused
     */ Map1.create = function(f, source) {
        if (isCanonicalEmpty(source)) return empty();
        if (source instanceof Map1) return new Map1(_prelude.compose(f, source.f), source.source);
        if (source instanceof Filter) return new FilterMap(source.p, f, source.source);
        return new Map1(f, source);
    };
    return Map1;
}();
var MapSink = function(_super) {
    __extends(MapSink1, _super);
    function MapSink1(f, sink) {
        var _this = _super.call(this, sink) || this;
        _this.f = f;
        return _this;
    }
    MapSink1.prototype.event = function(t, x) {
        var f = this.f;
        this.sink.event(t, f(x));
    };
    return MapSink1;
}(Pipe);
/** @license MIT License (c) copyright 2010-2016 original author or authors */ /**
 * Transform each value in the stream by applying f to each
 * @param f mapping function
 * @param stream stream to map
 * @returns stream containing items transformed by f
 */ var map = function(f, stream) {
    return Map.create(f, stream);
};
/**
* Replace each value in the stream with x
* @param x
* @param stream
* @returns stream containing items replaced with x
*/ var constant = function(x, stream) {
    return map(function() {
        return x;
    }, stream);
};
/**
* Perform a side effect for each item in the stream
* @param f side effect to execute for each item. The return value will be discarded.
* @param stream stream to tap
* @returns new stream containing the same items as this stream
*/ var tap = function(f, stream) {
    return new Tap(f, stream);
};
var Tap = function() {
    function Tap1(f, source) {
        this.source = source;
        this.f = f;
    }
    Tap1.prototype.run = function(sink, scheduler) {
        return this.source.run(new TapSink(this.f, sink), scheduler);
    };
    return Tap1;
}();
var TapSink = function(_super) {
    __extends(TapSink1, _super);
    function TapSink1(f, sink) {
        var _this = _super.call(this, sink) || this;
        _this.f = f;
        return _this;
    }
    TapSink1.prototype.event = function(t, x) {
        var f = this.f;
        f(x);
        this.sink.event(t, x);
    };
    return TapSink1;
}(Pipe);
/** @license MIT License (c) copyright 2010-2016 original author or authors */ var IndexSink = function(_super) {
    __extends(IndexSink1, _super);
    function IndexSink1(i, sink) {
        var _this = _super.call(this, sink) || this;
        _this.index = i;
        _this.active = true;
        _this.value = undefined;
        return _this;
    }
    IndexSink1.prototype.event = function(t, x) {
        if (!this.active) return;
        this.value = x;
        this.sink.event(t, this);
    };
    IndexSink1.prototype.end = function(t) {
        if (!this.active) return;
        this.active = false;
        this.sink.event(t, this);
    };
    return IndexSink1;
}(Pipe);
/** @license MIT License (c) copyright 2010-2016 original author or authors */ /** @author Brian Cavalier */ /** @author John Hann */ /**
 * TODO: find a better way (without `any`)
 */ function invoke(f, args) {
    /* eslint complexity: [2,7] */ switch(args.length){
        case 0:
            return f();
        case 1:
            return f(args[0]);
        case 2:
            return f(args[0], args[1]);
        case 3:
            return f(args[0], args[1], args[2]);
        case 4:
            return f(args[0], args[1], args[2], args[3]);
        case 5:
            return f(args[0], args[1], args[2], args[3], args[4]);
        default:
            return f.apply(undefined, args);
    }
}
/** @license MIT License (c) copyright 2010 original author or authors */ /**
 * Combine latest events from two streams
 * @param f function to combine most recent events
 * @param stream1
 * @param stream2
 * @returns stream containing the result of applying f to the most recent
 *  event of each input stream, whenever a new event arrives on any stream.
 */ var combine = function(f, stream1, stream2) {
    return combineArray(f, [
        stream1,
        stream2
    ]);
};
/**
* Combine latest events from all input streams
* @param f function to combine most recent events
* @param streams most recent events
* @returns stream containing the result of applying f to the most recent
*  event of each input stream, whenever a new event arrives on any stream.
*/ var combineArray = function(f, streams) {
    return streams.length === 0 || containsCanonicalEmpty(streams) ? empty() : streams.length === 1 ? map(f, streams[0]) : new Combine(f, streams);
};
var Combine = function() {
    function Combine1(f, sources) {
        this.f = f;
        this.sources = sources;
    }
    Combine1.prototype.run = function(sink, scheduler) {
        var l = this.sources.length;
        var disposables = new Array(l);
        var sinks = new Array(l);
        var mergeSink = new CombineSink(disposables, sinks.length, sink, this.f);
        for(var indexSink = void 0, i = 0; i < l; ++i){
            indexSink = sinks[i] = new IndexSink(i, mergeSink);
            disposables[i] = this.sources[i].run(indexSink, scheduler);
        }
        return _disposable.disposeAll(disposables);
    };
    return Combine1;
}();
var CombineSink = function(_super) {
    __extends(CombineSink1, _super);
    function CombineSink1(disposables, length, sink, f) {
        var _this = _super.call(this, sink) || this;
        _this.disposables = disposables;
        _this.f = f;
        _this.awaiting = length;
        _this.values = new Array(length);
        _this.hasValue = new Array(length).fill(false);
        _this.activeCount = length;
        return _this;
    }
    CombineSink1.prototype.event = function(t, indexedValue) {
        if (!indexedValue.active) {
            this.dispose(t, indexedValue.index);
            return;
        }
        var i = indexedValue.index;
        var awaiting = this.updateReady(i);
        this.values[i] = indexedValue.value;
        if (awaiting === 0) this.sink.event(t, invoke(this.f, this.values));
    };
    CombineSink1.prototype.updateReady = function(index) {
        if (this.awaiting > 0) {
            if (!this.hasValue[index]) {
                this.hasValue[index] = true;
                this.awaiting -= 1;
            }
        }
        return this.awaiting;
    };
    CombineSink1.prototype.dispose = function(t, index) {
        _disposable.tryDispose(t, this.disposables[index], this.sink);
        if (--this.activeCount === 0) this.sink.end(t);
    };
    return CombineSink1;
}(Pipe);
/** @license MIT License (c) copyright 2010-2016 original author or authors */ /**
 * Assume fs is a stream containing functions, and apply the latest function
 * in fs to the latest value in xs.
 * fs:         --f---------g--------h------>
 * xs:         -a-------b-------c-------d-->
 * ap(fs, xs): --fa-----fb-gb---gc--hc--hd->
 * @param {Stream} fs stream of functions to apply to the latest x
 * @param {Stream} xs stream of values to which to apply all the latest f
 * @returns {Stream} stream containing all the applications of fs to xs
 */ function ap(fs, xs) {
    return combine(_prelude.apply, fs, xs);
}
/** @license MIT License (c) copyright 2010 original author or authors */ var mergeConcurrently = function(concurrency, stream) {
    return mergeMapConcurrently(_prelude.id, concurrency, stream);
};
var mergeMapConcurrently = function(f, concurrency, stream) {
    return isCanonicalEmpty(stream) ? empty() : new MergeConcurrently(f, concurrency, stream);
};
var MergeConcurrently = function() {
    function MergeConcurrently1(f, concurrency, source) {
        this.f = f;
        this.concurrency = concurrency;
        this.source = source;
    }
    MergeConcurrently1.prototype.run = function(sink, scheduler) {
        return new Outer(this.f, this.concurrency, this.source, sink, scheduler);
    };
    return MergeConcurrently1;
}();
var isNonEmpty = function(array) {
    return array.length > 0;
};
var Outer = function() {
    function Outer1(f, concurrency, source, sink, scheduler) {
        this.f = f;
        this.concurrency = concurrency;
        this.sink = sink;
        this.scheduler = scheduler;
        this.pending = [];
        this.current = [];
        this.disposable = _disposable.disposeOnce(source.run(this, scheduler));
        this.active = true;
    }
    Outer1.prototype.event = function(t, x) {
        this.addInner(t, x);
    };
    Outer1.prototype.addInner = function(t, x) {
        if (this.current.length < this.concurrency) this.startInner(t, x);
        else this.pending.push(x);
    };
    Outer1.prototype.startInner = function(t, x) {
        try {
            this.initInner(t, x);
        } catch (e) {
            this.error(t, e);
        }
    };
    Outer1.prototype.initInner = function(t, x) {
        var innerSink = new Inner(t, this, this.sink);
        innerSink.disposable = mapAndRun(this.f, t, x, innerSink, this.scheduler);
        this.current.push(innerSink);
    };
    Outer1.prototype.end = function(t) {
        this.active = false;
        _disposable.tryDispose(t, this.disposable, this.sink);
        this.checkEnd(t);
    };
    Outer1.prototype.error = function(t, e) {
        this.active = false;
        this.sink.error(t, e);
    };
    Outer1.prototype.dispose = function() {
        this.active = false;
        this.pending.length = 0;
        this.disposable.dispose();
        _disposable.disposeAll(this.current).dispose();
    };
    Outer1.prototype.endInner = function(t, inner) {
        var i = this.current.indexOf(inner);
        if (i >= 0) this.current.splice(i, 1);
        _disposable.tryDispose(t, inner, this);
        var pending = this.pending;
        if (isNonEmpty(pending)) this.startInner(t, pending.shift());
        else this.checkEnd(t);
    };
    Outer1.prototype.checkEnd = function(t) {
        if (!this.active && this.current.length === 0) this.sink.end(t);
    };
    return Outer1;
}();
var mapAndRun = function(f, t, x, sink, scheduler) {
    return f(x).run(sink, _scheduler.schedulerRelativeTo(t, scheduler));
};
var Inner = function() {
    function Inner1(time, outer, sink) {
        this.time = time;
        this.outer = outer;
        this.sink = sink;
        this.disposable = _disposable.disposeNone();
    }
    Inner1.prototype.event = function(t, x) {
        this.sink.event(t + this.time, x);
    };
    Inner1.prototype.end = function(t) {
        this.outer.endInner(t + this.time, this);
    };
    Inner1.prototype.error = function(t, e) {
        this.outer.error(t + this.time, e);
    };
    Inner1.prototype.dispose = function() {
        return this.disposable.dispose();
    };
    return Inner1;
}();
/** @license MIT License (c) copyright 2010-2016 original author or authors */ /**
 * Map each value in the stream to a new stream, and merge it into the
 * returned outer stream. Event arrival times are preserved.
 * @param f chaining function, must return a Stream
 * @param stream
 * @returns new stream containing all events from each stream returned by f
 */ var chain = function(f, stream) {
    return mergeMapConcurrently(f, Infinity, stream);
};
/**
 * Monadic join. Flatten a Stream<Stream<X>> to Stream<X> by merging inner
 * streams to the outer. Event arrival times are preserved.
 * @param stream stream of streams
 * @returns new stream containing all events of all inner streams
 */ var join = function(stream) {
    return mergeConcurrently(Infinity, stream);
};
/** @license MIT License (c) copyright 2010-2016 original author or authors */ /**
 * Map each value in stream to a new stream, and concatenate them all
 * stream:              -a---b---cX
 * f(a):                 1-1-1-1X
 * f(b):                        -2-2-2-2X
 * f(c):                                -3-3-3-3X
 * stream.concatMap(f): -1-1-1-1-2-2-2-2-3-3-3-3X
 * @param f function to map each value to a stream
 * @param stream
 * @returns new stream containing all events from each stream returned by f
 */ var concatMap = function(f, stream) {
    return mergeMapConcurrently(f, 1, stream);
};
/** @license MIT License (c) copyright 2010-2016 original author or authors */ /**
 * @returns stream containing events from two streams in time order.
 * If two events are simultaneous they will be merged in arbitrary order.
 */ function merge(stream1, stream2) {
    return mergeArray([
        stream1,
        stream2
    ]);
}
/**
 * @param streams array of stream to merge
 * @returns stream containing events from all input observables
 * in time order.  If two events are simultaneous they will be merged in
 * arbitrary order.
 */ var mergeArray = function(streams) {
    return mergeStreams(withoutCanonicalEmpty(streams));
};
/**
 * This implements fusion/flattening for merge.  It will
 * fuse adjacent merge operations.  For example:
 * - a.merge(b).merge(c) effectively becomes merge(a, b, c)
 * - merge(a, merge(b, c)) effectively becomes merge(a, b, c)
 * It does this by concatenating the sources arrays of
 * any nested Merge sources, in effect "flattening" nested
 * merge operations into a single merge.
 * TODO: use {@link MergeArray}
 */ var mergeStreams = function(streams) {
    return streams.length === 0 ? empty() : streams.length === 1 ? streams[0] : new Merge(_prelude.reduce(appendSources, [], streams));
};
var withoutCanonicalEmpty = function(streams) {
    return streams.filter(isNotCanonicalEmpty);
};
var isNotCanonicalEmpty = function(stream) {
    return !isCanonicalEmpty(stream);
};
var appendSources = function(sources, stream) {
    return sources.concat(stream instanceof Merge ? stream.sources : stream);
};
var Merge = function() {
    function Merge1(sources) {
        this.sources = sources;
    }
    Merge1.prototype.run = function(sink, scheduler) {
        var l = this.sources.length;
        var disposables = new Array(l);
        var sinks = new Array(l);
        var mergeSink = new MergeSink(disposables, sinks, sink);
        for(var indexSink = void 0, i = 0; i < l; ++i){
            indexSink = sinks[i] = new IndexSink(i, mergeSink);
            disposables[i] = this.sources[i].run(indexSink, scheduler);
        }
        return _disposable.disposeAll(disposables);
    };
    return Merge1;
}();
var MergeSink = function(_super) {
    __extends(MergeSink1, _super);
    function MergeSink1(disposables, sinks, sink) {
        var _this = _super.call(this, sink) || this;
        _this.disposables = disposables;
        _this.activeCount = sinks.length;
        return _this;
    }
    MergeSink1.prototype.event = function(t, indexValue) {
        if (!indexValue.active) {
            this.dispose(t, indexValue.index);
            return;
        }
        this.sink.event(t, indexValue.value);
    };
    MergeSink1.prototype.dispose = function(t, index) {
        _disposable.tryDispose(t, this.disposables[index], this.sink);
        if (--this.activeCount === 0) this.sink.end(t);
    };
    return MergeSink1;
}(Pipe);
/** @license MIT License (c) copyright 2010 original author or authors */ var sample = function(values, sampler) {
    return snapshot(function(x) {
        return x;
    }, values, sampler);
};
var snapshot = function(f, values, sampler) {
    return isCanonicalEmpty(sampler) || isCanonicalEmpty(values) ? empty() : new Snapshot(f, values, sampler);
};
var Snapshot = function() {
    function Snapshot1(f, values, sampler) {
        this.f = f;
        this.values = values;
        this.sampler = sampler;
    }
    Snapshot1.prototype.run = function(sink, scheduler) {
        var sampleSink = new SnapshotSink(this.f, sink);
        var valuesDisposable = this.values.run(sampleSink.latest, scheduler);
        var samplerDisposable = this.sampler.run(sampleSink, scheduler);
        return _disposable.disposeBoth(samplerDisposable, valuesDisposable);
    };
    return Snapshot1;
}();
var SnapshotSink = function(_super) {
    __extends(SnapshotSink1, _super);
    function SnapshotSink1(f, sink) {
        var _this = _super.call(this, sink) || this;
        _this.f = f;
        _this.latest = new LatestValueSink(_this);
        return _this;
    }
    SnapshotSink1.prototype.event = function(t, x) {
        if (this.latest.hasValue) {
            var f = this.f;
            // TODO: value should be boxed to avoid ! bang
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.sink.event(t, f(this.latest.value, x));
        }
    };
    return SnapshotSink1;
}(Pipe);
var LatestValueSink = function(_super) {
    __extends(LatestValueSink1, _super);
    function LatestValueSink1(sink) {
        var _this = _super.call(this, sink) || this;
        _this.hasValue = false;
        return _this;
    }
    LatestValueSink1.prototype.event = function(_t, x) {
        this.value = x;
        this.hasValue = true;
    };
    LatestValueSink1.prototype.end = function() {
    };
    return LatestValueSink1;
}(Pipe);
/** @license MIT License (c) copyright 2010 original author or authors */ // Construct a constrained bounds
var boundsFrom = function(unsafeMin, unsafeMax) {
    var min = Math.max(0, unsafeMin);
    var max = Math.max(min, unsafeMax);
    return {
        min: min,
        max: max
    };
};
// Combine 2 bounds by narrowing min and max
var mergeBounds = function(b1, b2) {
    return boundsFrom(b1.min + b2.min, Math.min(b1.max, b1.min + b2.max));
};
// Nil bounds excludes all slice indices
var isNilBounds = function(b) {
    return b.min >= b.max;
};
// Infinite bounds includes all slice indices
var isInfiniteBounds = function(b) {
    return b.min <= 0 && b.max === Infinity;
};
// TODO: split into smaller files
/**
 * @param n
 * @param stream
 * @returns new stream containing only up to the first n items from stream
 */ var take = function(n, stream) {
    return slice(0, n, stream);
};
/**
 * @param n
 * @param stream
 * @returns new stream with the first n items removed
 */ var skip = function(n, stream) {
    return slice(n, Infinity, stream);
};
/**
 * Slice a stream by index. Negative start/end indexes are not supported
 * @param start
 * @param end
 * @param stream
 * @returns stream containing items where start <= index < end
 */ var slice = function(start, end, stream) {
    return sliceBounds(boundsFrom(start, end), stream);
};
var sliceBounds = function(bounds, stream) {
    return isSliceEmpty(bounds, stream) ? empty() : stream instanceof Map ? commuteMapSlice(bounds, stream) : stream instanceof Slice ? fuseSlice(bounds, stream) : createSlice(bounds, stream);
};
var isSliceEmpty = function(bounds, stream) {
    return isCanonicalEmpty(stream) || isNilBounds(bounds);
};
var createSlice = function(bounds, stream) {
    return isInfiniteBounds(bounds) ? stream : new Slice(bounds, stream);
};
var commuteMapSlice = function(bounds, mapStream) {
    return Map.create(mapStream.f, sliceBounds(bounds, mapStream.source));
};
var fuseSlice = function(bounds, sliceStream) {
    return sliceBounds(mergeBounds(sliceStream.bounds, bounds), sliceStream.source);
};
var Slice = function() {
    function Slice1(bounds, source) {
        this.source = source;
        this.bounds = bounds;
    }
    Slice1.prototype.run = function(sink, scheduler) {
        var disposable = new SettableDisposable();
        var sliceSink = new SliceSink(this.bounds.min, this.bounds.max - this.bounds.min, sink, disposable);
        disposable.setDisposable(this.source.run(sliceSink, scheduler));
        return disposable;
    };
    return Slice1;
}();
var SliceSink = function(_super) {
    __extends(SliceSink1, _super);
    function SliceSink1(skip1, take1, sink, disposable) {
        var _this = _super.call(this, sink) || this;
        _this.skip = skip1;
        _this.take = take1;
        _this.disposable = disposable;
        return _this;
    }
    SliceSink1.prototype.event = function(t, x) {
        /* eslint complexity: [1, 4] */ if (this.skip > 0) {
            this.skip -= 1;
            return;
        }
        if (this.take === 0) return;
        this.take -= 1;
        this.sink.event(t, x);
        if (this.take === 0) {
            this.disposable.dispose();
            this.sink.end(t);
        }
    };
    return SliceSink1;
}(Pipe);
var takeWhile = function(p, stream) {
    return isCanonicalEmpty(stream) ? empty() : new TakeWhile(p, stream);
};
var TakeWhile = function() {
    function TakeWhile1(p, source) {
        this.p = p;
        this.source = source;
    }
    TakeWhile1.prototype.run = function(sink, scheduler) {
        var disposable = new SettableDisposable();
        var takeWhileSink = new TakeWhileSink(this.p, sink, disposable);
        disposable.setDisposable(this.source.run(takeWhileSink, scheduler));
        return disposable;
    };
    return TakeWhile1;
}();
var TakeWhileSink = function(_super) {
    __extends(TakeWhileSink1, _super);
    function TakeWhileSink1(p, sink, disposable) {
        var _this = _super.call(this, sink) || this;
        _this.p = p;
        _this.active = true;
        _this.disposable = disposable;
        return _this;
    }
    TakeWhileSink1.prototype.event = function(t, x) {
        if (!this.active) return;
        var p = this.p;
        this.active = p(x);
        if (this.active) this.sink.event(t, x);
        else {
            this.disposable.dispose();
            this.sink.end(t);
        }
    };
    return TakeWhileSink1;
}(Pipe);
var skipWhile = function(p, stream) {
    return isCanonicalEmpty(stream) ? empty() : new SkipWhile(p, stream);
};
var SkipWhile = function() {
    function SkipWhile1(p, source) {
        this.p = p;
        this.source = source;
    }
    SkipWhile1.prototype.run = function(sink, scheduler) {
        return this.source.run(new SkipWhileSink(this.p, sink), scheduler);
    };
    return SkipWhile1;
}();
var SkipWhileSink = function(_super) {
    __extends(SkipWhileSink1, _super);
    function SkipWhileSink1(p, sink) {
        var _this = _super.call(this, sink) || this;
        _this.p = p;
        _this.skipping = true;
        return _this;
    }
    SkipWhileSink1.prototype.event = function(t, x) {
        if (this.skipping) {
            var p = this.p;
            this.skipping = p(x);
            if (this.skipping) return;
        }
        this.sink.event(t, x);
    };
    return SkipWhileSink1;
}(Pipe);
var skipAfter = function(p, stream) {
    return isCanonicalEmpty(stream) ? empty() : new SkipAfter(p, stream);
};
var SkipAfter = function() {
    function SkipAfter1(p, source) {
        this.p = p;
        this.source = source;
    }
    SkipAfter1.prototype.run = function(sink, scheduler) {
        return this.source.run(new SkipAfterSink(this.p, sink), scheduler);
    };
    return SkipAfter1;
}();
var SkipAfterSink = function(_super) {
    __extends(SkipAfterSink1, _super);
    function SkipAfterSink1(p, sink) {
        var _this = _super.call(this, sink) || this;
        _this.p = p;
        _this.skipping = false;
        return _this;
    }
    SkipAfterSink1.prototype.event = function(t, x) {
        if (this.skipping) return;
        var p = this.p;
        this.skipping = p(x);
        this.sink.event(t, x);
        if (this.skipping) this.sink.end(t);
    };
    return SkipAfterSink1;
}(Pipe);
/** @license MIT License (c) copyright 2017 original author or authors */ var withItems = function(items, stream) {
    return zipItems(keepLeft, items, stream);
};
var zipItems = function(f, items, stream) {
    return isCanonicalEmpty(stream) || items.length === 0 ? empty() : new ZipItems(f, items, take(items.length, stream));
};
var keepLeft = function(a) {
    return a;
};
var ZipItems = function() {
    function ZipItems1(f, items, source) {
        this.f = f;
        this.items = items;
        this.source = source;
    }
    ZipItems1.prototype.run = function(sink, scheduler) {
        return this.source.run(new ZipItemsSink(this.f, this.items, sink), scheduler);
    };
    return ZipItems1;
}();
var ZipItemsSink = function(_super) {
    __extends(ZipItemsSink1, _super);
    function ZipItemsSink1(f, items, sink) {
        var _this = _super.call(this, sink) || this;
        _this.f = f;
        _this.items = items;
        _this.index = 0;
        return _this;
    }
    ZipItemsSink1.prototype.event = function(t, b) {
        var f = this.f;
        this.sink.event(t, f(this.items[this.index], b));
        this.index += 1;
    };
    return ZipItemsSink1;
}(Pipe);
// Copied and modified from https://github.com/invertase/denque
// MIT License
// These constants were extracted directly from denque's shift()
// It's not clear exactly why the authors chose these particular
// values, but given denque's stated goals, it seems likely that
// they were chosen for speed/memory reasons.
// Max value of _head at which Queue is willing to shink
// its internal array
var HEAD_MAX_SHRINK = 2;
// Min value of _tail at which Queue is willing to shink
// its internal array
var TAIL_MIN_SHRINK = 10000;
var Queue = function() {
    function Queue1() {
        this.head = 0;
        this.tail = 0;
        this.capacityMask = 3;
        this.list = new Array(4);
    }
    Queue1.prototype.push = function(x) {
        var tail = this.tail;
        this.list[tail] = x;
        this.tail = tail + 1 & this.capacityMask;
        if (this.tail === this.head) this.growArray();
        if (this.head < this.tail) return this.tail - this.head;
        else return this.capacityMask + 1 - (this.head - this.tail);
    };
    Queue1.prototype.shift = function() {
        var head1 = this.head;
        if (head1 === this.tail) return undefined;
        var x = this.list[head1];
        this.list[head1] = undefined;
        this.head = head1 + 1 & this.capacityMask;
        if (head1 < HEAD_MAX_SHRINK && this.tail > TAIL_MIN_SHRINK && this.tail <= this.list.length >>> 2) this.shrinkArray();
        return x;
    };
    Queue1.prototype.isEmpty = function() {
        return this.head === this.tail;
    };
    Queue1.prototype.length = function() {
        if (this.head === this.tail) return 0;
        else if (this.head < this.tail) return this.tail - this.head;
        else return this.capacityMask + 1 - (this.head - this.tail);
    };
    Queue1.prototype.growArray = function() {
        if (this.head) {
            // copy existing data, head to end, then beginning to tail.
            this.list = this.copyArray();
            this.head = 0;
        }
        // head is at 0 and array is now full, safe to extend
        this.tail = this.list.length;
        this.list.length *= 2;
        this.capacityMask = this.capacityMask << 1 | 1;
    };
    Queue1.prototype.shrinkArray = function() {
        this.list.length >>>= 1;
        this.capacityMask >>>= 1;
    };
    Queue1.prototype.copyArray = function() {
        var newArray = [];
        var list = this.list;
        var len = list.length;
        var i;
        for(i = this.head; i < len; i++)newArray.push(list[i]);
        for(i = 0; i < this.tail; i++)newArray.push(list[i]);
        return newArray;
    };
    return Queue1;
}();
/** @license MIT License (c) copyright 2010 original author or authors */ /**
 * Combine two streams pairwise by index by applying f to values at corresponding
 * indices.  The returned stream ends when either of the input streams ends.
 * @param {function} f function to combine values
 * @returns {Stream} new stream with items at corresponding indices combined
 *  using f
 */ function zip(f, stream1, stream2) {
    return zipArray(f, [
        stream1,
        stream2
    ]);
}
/**
* Combine streams pairwise (or tuple-wise) by index by applying f to values
* at corresponding indices.  The returned stream ends when any of the input
* streams ends.
* @param {function} f function to combine values
* @param {[Stream]} streams streams to zip using f
* @returns {Stream} new stream with items at corresponding indices combined
*  using f
*/ var zipArray = function(f, streams) {
    return streams.length === 0 || containsCanonicalEmpty(streams) ? empty() : streams.length === 1 ? map(f, streams[0]) : new Zip(f, streams);
};
var Zip = function() {
    function Zip1(f, sources) {
        this.f = f;
        this.sources = sources;
    }
    Zip1.prototype.run = function(sink, scheduler) {
        var l = this.sources.length;
        var disposables = new Array(l);
        var sinks = new Array(l);
        var buffers = new Array(l);
        var zipSink = new ZipSink(this.f, buffers, sinks, sink);
        for(var indexSink = void 0, i = 0; i < l; ++i){
            buffers[i] = new Queue();
            indexSink = sinks[i] = new IndexSink(i, zipSink);
            disposables[i] = this.sources[i].run(indexSink, scheduler);
        }
        return _disposable.disposeAll(disposables);
    };
    return Zip1;
}();
var ZipSink = function(_super) {
    __extends(ZipSink1, _super);
    function ZipSink1(f, buffers, sinks, sink) {
        var _this = _super.call(this, sink) || this;
        _this.f = f;
        _this.sinks = sinks;
        _this.buffers = buffers;
        return _this;
    }
    ZipSink1.prototype.event = function(t, indexedValue) {
        /* eslint complexity: [1, 5] */ if (!indexedValue.active) {
            this.dispose(t, indexedValue.index);
            return;
        }
        var buffers = this.buffers;
        var buffer = buffers[indexedValue.index];
        buffer.push(indexedValue.value);
        if (buffer.length() === 1) {
            if (!ready(buffers)) return;
            emitZipped(this.f, t, buffers, this.sink);
            if (ended(this.buffers, this.sinks)) this.sink.end(t);
        }
    };
    ZipSink1.prototype.dispose = function(t, index) {
        var buffer = this.buffers[index];
        if (buffer.isEmpty()) this.sink.end(t);
    };
    return ZipSink1;
}(Pipe);
var emitZipped = function(f, t, buffers, sink) {
    return sink.event(t, invoke(f, _prelude.map(head, buffers)));
};
var head = function(buffer) {
    return buffer.shift();
};
function ended(buffers, sinks) {
    for(var i = 0, l = buffers.length; i < l; ++i){
        if (buffers[i].isEmpty() && !sinks[i].active) return true;
    }
    return false;
}
function ready(buffers) {
    for(var i = 0, l = buffers.length; i < l; ++i){
        if (buffers[i].isEmpty()) return false;
    }
    return true;
}
/** @license MIT License (c) copyright 2010-2016 original author or authors */ /**
 * Given a stream of streams, return a new stream that adopts the behavior
 * of the most recent inner stream.
 * @param stream of streams on which to switch
 * @returns switching stream
 */ var switchLatest = function(stream) {
    return isCanonicalEmpty(stream) ? empty() : new Switch(stream);
};
var Switch = function() {
    function Switch1(source) {
        this.source = source;
    }
    Switch1.prototype.run = function(sink, scheduler) {
        var switchSink = new SwitchSink(sink, scheduler);
        return _disposable.disposeBoth(switchSink, this.source.run(switchSink, scheduler));
    };
    return Switch1;
}();
var SwitchSink = function() {
    function SwitchSink1(sink, scheduler) {
        this.sink = sink;
        this.scheduler = scheduler;
        this.current = null;
        this.ended = false;
    }
    SwitchSink1.prototype.event = function(t, stream) {
        this.disposeCurrent(t);
        this.current = new Segment(stream, t, Infinity, this, this.sink, this.scheduler);
    };
    SwitchSink1.prototype.end = function(t) {
        this.ended = true;
        this.checkEnd(t);
    };
    SwitchSink1.prototype.error = function(t, e) {
        this.ended = true;
        this.sink.error(t, e);
    };
    SwitchSink1.prototype.dispose = function() {
        return this.disposeCurrent(_scheduler.currentTime(this.scheduler));
    };
    SwitchSink1.prototype.disposeCurrent = function(t) {
        if (this.current !== null) return this.current.dispose(t);
    };
    SwitchSink1.prototype.disposeInner = function(t, inner) {
        inner.dispose(t);
        if (inner === this.current) this.current = null;
    };
    SwitchSink1.prototype.checkEnd = function(t) {
        if (this.ended && this.current === null) this.sink.end(t);
    };
    SwitchSink1.prototype.endInner = function(t, inner) {
        this.disposeInner(t, inner);
        this.checkEnd(t);
    };
    SwitchSink1.prototype.errorInner = function(t, e, inner) {
        this.disposeInner(t, inner);
        this.sink.error(t, e);
    };
    return SwitchSink1;
}();
var Segment = function() {
    function Segment1(source, min, max, outer, sink, scheduler) {
        this.min = min;
        this.max = max;
        this.outer = outer;
        this.sink = sink;
        this.disposable = source.run(this, _scheduler.schedulerRelativeTo(min, scheduler));
    }
    Segment1.prototype.event = function(t, x) {
        var time = Math.max(0, t + this.min);
        if (time < this.max) this.sink.event(time, x);
    };
    Segment1.prototype.end = function(t) {
        this.outer.endInner(t + this.min, this);
    };
    Segment1.prototype.error = function(t, e) {
        this.outer.errorInner(t + this.min, e, this);
    };
    Segment1.prototype.dispose = function(t) {
        _disposable.tryDispose(t, this.disposable, this.sink);
    };
    return Segment1;
}();
/** @license MIT License (c) copyright 2010-2016 original author or authors */ function filter(p, stream) {
    return Filter.create(p, stream);
}
/**
 * Skip repeated events, using === to detect duplicates
 * @param stream stream from which to omit repeated events
 * @returns stream without repeated events
 */ var skipRepeats = function(stream) {
    return skipRepeatsWith(same, stream);
};
/**
 * Skip repeated events using the provided equals function to detect duplicates
 * @param equals optional function to compare items
 * @param stream stream from which to omit repeated events
 * @returns stream without repeated events
 */ var skipRepeatsWith = function(equals, stream) {
    return isCanonicalEmpty(stream) ? empty() : new SkipRepeats(equals, stream);
};
var SkipRepeats = function() {
    function SkipRepeats1(equals, source) {
        this.equals = equals;
        this.source = source;
    }
    SkipRepeats1.prototype.run = function(sink, scheduler) {
        return this.source.run(new SkipRepeatsSink(this.equals, sink), scheduler);
    };
    return SkipRepeats1;
}();
var SkipRepeatsSink = function(_super) {
    __extends(SkipRepeatsSink1, _super);
    function SkipRepeatsSink1(equals, sink) {
        var _this = _super.call(this, sink) || this;
        _this.equals = equals;
        _this.value = undefined;
        _this.init = true;
        return _this;
    }
    SkipRepeatsSink1.prototype.event = function(t, x) {
        if (this.init) {
            this.init = false;
            this.value = x;
            this.sink.event(t, x);
        // TODO: value should be boxed to avoid ! bang
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        } else if (!this.equals(this.value, x)) {
            this.value = x;
            this.sink.event(t, x);
        }
    };
    return SkipRepeatsSink1;
}(Pipe);
function same(a, b) {
    return a === b;
}
/** @license MIT License (c) copyright 2010-2016 original author or authors */ var until = function(signal, stream) {
    return new Until(signal, stream);
};
var since = function(signal, stream) {
    return new Since(signal, stream);
};
var during = function(timeWindow, stream) {
    return until(join(timeWindow), since(timeWindow, stream));
};
var Until = function() {
    function Until1(maxSignal, source) {
        this.maxSignal = maxSignal;
        this.source = source;
    }
    Until1.prototype.run = function(sink, scheduler) {
        var disposable = new SettableDisposable();
        var d1 = this.source.run(sink, scheduler);
        var d2 = this.maxSignal.run(new UntilSink(sink, disposable), scheduler);
        disposable.setDisposable(_disposable.disposeBoth(d1, d2));
        return disposable;
    };
    return Until1;
}();
var Since = function() {
    function Since1(minSignal, source) {
        this.minSignal = minSignal;
        this.source = source;
    }
    Since1.prototype.run = function(sink, scheduler) {
        var min = new LowerBoundSink(this.minSignal, sink, scheduler);
        var d = this.source.run(new SinceSink(min, sink), scheduler);
        return _disposable.disposeBoth(min, d);
    };
    return Since1;
}();
var SinceSink = function(_super) {
    __extends(SinceSink1, _super);
    function SinceSink1(min, sink) {
        var _this = _super.call(this, sink) || this;
        _this.min = min;
        return _this;
    }
    SinceSink1.prototype.event = function(t, x) {
        if (this.min.allow) this.sink.event(t, x);
    };
    return SinceSink1;
}(Pipe);
var LowerBoundSink = function(_super) {
    __extends(LowerBoundSink1, _super);
    function LowerBoundSink1(signal, sink, scheduler) {
        var _this = _super.call(this, sink) || this;
        _this.allow = false;
        _this.disposable = signal.run(_this, scheduler);
        return _this;
    }
    LowerBoundSink1.prototype.event = function() {
        this.allow = true;
        this.dispose();
    };
    LowerBoundSink1.prototype.end = function() {
    };
    LowerBoundSink1.prototype.dispose = function() {
        this.disposable.dispose();
    };
    return LowerBoundSink1;
}(Pipe);
var UntilSink = function(_super) {
    __extends(UntilSink1, _super);
    function UntilSink1(sink, disposable) {
        var _this = _super.call(this, sink) || this;
        _this.disposable = disposable;
        return _this;
    }
    UntilSink1.prototype.event = function(t) {
        this.disposable.dispose();
        this.sink.end(t);
    };
    UntilSink1.prototype.end = function() {
    };
    return UntilSink1;
}(Pipe);
/** @license MIT License (c) copyright 2010-2016 original author or authors */ /**
 * @param delayTime milliseconds to delay each item
 * @param stream
 * @returns new stream containing the same items, but delayed by ms
 */ var delay = function(delayTime, stream) {
    return delayTime <= 0 ? stream : new Delay(delayTime, stream);
};
var Delay = function() {
    function Delay1(dt, source) {
        this.dt = dt;
        this.source = source;
    }
    Delay1.prototype.run = function(sink, scheduler) {
        var delaySink = new DelaySink(this.dt, sink, scheduler);
        return _disposable.disposeBoth(delaySink, this.source.run(delaySink, scheduler));
    };
    return Delay1;
}();
var DelaySink = function(_super) {
    __extends(DelaySink1, _super);
    function DelaySink1(dt, sink, scheduler) {
        var _this = _super.call(this, sink) || this;
        _this.dt = dt;
        _this.scheduler = scheduler;
        _this.tasks = [];
        return _this;
    }
    DelaySink1.prototype.dispose = function() {
        this.tasks.forEach(_scheduler.cancelTask);
    };
    DelaySink1.prototype.event = function(_t, x) {
        this.tasks.push(_scheduler.delay(this.dt, propagateEventTask(x, this.sink), this.scheduler));
    };
    DelaySink1.prototype.end = function() {
        this.tasks.push(_scheduler.delay(this.dt, propagateEndTask(this.sink), this.scheduler));
    };
    return DelaySink1;
}(Pipe);
/** @license MIT License (c) copyright 2010-2017 original author or authors */ /**
 * Limit the rate of events by suppressing events that occur too often
 * @param period time to suppress events
 * @param stream
 */ var throttle = function(period, stream) {
    return isCanonicalEmpty(stream) ? empty() : stream instanceof Map ? commuteMapThrottle(period, stream) : stream instanceof Throttle ? fuseThrottle(period, stream) : new Throttle(period, stream);
};
var commuteMapThrottle = function(period, mapStream) {
    return Map.create(mapStream.f, throttle(period, mapStream.source));
};
var fuseThrottle = function(period, throttleStream) {
    return new Throttle(Math.max(period, throttleStream.period), throttleStream.source);
};
var Throttle = function() {
    function Throttle1(period, source) {
        this.period = period;
        this.source = source;
    }
    Throttle1.prototype.run = function(sink, scheduler) {
        return this.source.run(new ThrottleSink(this.period, sink), scheduler);
    };
    return Throttle1;
}();
var ThrottleSink = function(_super) {
    __extends(ThrottleSink1, _super);
    function ThrottleSink1(period, sink) {
        var _this = _super.call(this, sink) || this;
        _this.time = 0;
        _this.period = period;
        return _this;
    }
    ThrottleSink1.prototype.event = function(t, x) {
        if (t >= this.time) {
            this.time = t + this.period;
            this.sink.event(t, x);
        }
    };
    return ThrottleSink1;
}(Pipe);
/**
 * Wait for a burst of events to subside and emit only the last event in the burst
 * @param period events occuring more frequently than this will be suppressed
 * @param stream stream to debounce
 * @returns new debounced stream
 */ var debounce = function(period, stream) {
    return isCanonicalEmpty(stream) ? empty() : new Debounce(period, stream);
};
var Debounce = function() {
    function Debounce1(dt, source) {
        this.dt = dt;
        this.source = source;
    }
    Debounce1.prototype.run = function(sink, scheduler) {
        return new DebounceSink(this.dt, this.source, sink, scheduler);
    };
    return Debounce1;
}();
var DebounceSink = function() {
    function DebounceSink1(dt, source, sink, scheduler) {
        this.dt = dt;
        this.sink = sink;
        this.scheduler = scheduler;
        this.timer = null;
        this.disposable = source.run(this, scheduler);
    }
    DebounceSink1.prototype.event = function(_t, x) {
        this.clearTimer();
        this.value = x;
        this.timer = _scheduler.delay(this.dt, new DebounceTask(this, x), this.scheduler);
    };
    DebounceSink1.prototype.handleEventFromTask = function(t, x) {
        this.clearTimer();
        this.sink.event(t, x);
    };
    DebounceSink1.prototype.end = function(t) {
        if (this.clearTimer()) {
            // TODO: value should be boxed to avoid ! bang
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.sink.event(t, this.value);
            this.value = undefined;
        }
        this.sink.end(t);
    };
    DebounceSink1.prototype.error = function(t, x) {
        this.clearTimer();
        this.sink.error(t, x);
    };
    DebounceSink1.prototype.dispose = function() {
        this.clearTimer();
        this.disposable.dispose();
    };
    DebounceSink1.prototype.clearTimer = function() {
        if (this.timer === null) return false;
        this.timer.dispose();
        this.timer = null;
        return true;
    };
    return DebounceSink1;
}();
var DebounceTask = function() {
    function DebounceTask1(sink, value) {
        this.sink = sink;
        this.value = value;
    }
    DebounceTask1.prototype.run = function(t) {
        this.sink.handleEventFromTask(t, this.value);
    };
    DebounceTask1.prototype.error = function(t, e) {
        this.sink.error(t, e);
    };
    DebounceTask1.prototype.dispose = function() {
    };
    return DebounceTask1;
}();
/** @license MIT License (c) copyright 2010-2016 original author or authors */ /**
 * Turn a Stream<Promise<T>> into Stream<T> by awaiting each promise.
 * Event order is preserved. The stream will fail if any promise rejects.
 */ var awaitPromises = function(stream) {
    return isCanonicalEmpty(stream) ? empty() : new Await(stream);
};
/**
 * Create a stream containing only the promise's fulfillment
 * value at the time it fulfills.
 * @param promise
 * @return stream containing promise's fulfillment value.
 *  If the promise rejects, the stream will error
 */ var fromPromise = function(promise) {
    return awaitPromises(now(promise));
};
var Await = function() {
    function Await1(source) {
        this.source = source;
    }
    Await1.prototype.run = function(sink, scheduler) {
        return this.source.run(new AwaitSink(sink, scheduler), scheduler);
    };
    return Await1;
}();
var AwaitSink = function() {
    function AwaitSink1(sink, scheduler) {
        var _this = this;
        // Pre-create closures, to avoid creating them per event
        this.eventBound = function(x) {
            return _this.sink.event(_scheduler.currentTime(_this.scheduler), x);
        };
        this.endBound = function() {
            return _this.sink.end(_scheduler.currentTime(_this.scheduler));
        };
        this.errorBound = function(e) {
            return _this.sink.error(_scheduler.currentTime(_this.scheduler), e);
        };
        this.sink = sink;
        this.scheduler = scheduler;
        this.queue = Promise.resolve();
    }
    AwaitSink1.prototype.event = function(_t, promise) {
        var _this = this;
        this.queue = this.queue.then(function() {
            return _this.handlePromise(promise);
        }).catch(this.errorBound);
    };
    AwaitSink1.prototype.end = function() {
        this.queue = this.queue.then(this.endBound).catch(this.errorBound);
    };
    AwaitSink1.prototype.error = function(_t, e) {
        var _this = this;
        // Don't resolve error values, propagate directly
        this.queue = this.queue.then(function() {
            return _this.errorBound(e);
        }).catch(fatalError);
    };
    AwaitSink1.prototype.handlePromise = function(promise) {
        return promise.then(this.eventBound);
    };
    return AwaitSink1;
}();
var SafeSink = function() {
    function SafeSink1(sink) {
        this.sink = sink;
        this.active = true;
    }
    SafeSink1.prototype.event = function(t, x) {
        if (!this.active) return;
        this.sink.event(t, x);
    };
    SafeSink1.prototype.end = function(t) {
        if (!this.active) return;
        this.disable();
        this.sink.end(t);
    };
    SafeSink1.prototype.error = function(t, e) {
        this.disable();
        this.sink.error(t, e);
    };
    SafeSink1.prototype.disable = function() {
        this.active = false;
        return this.sink;
    };
    return SafeSink1;
}();
/** @license MIT License (c) copyright 2010-2016 original author or authors */ /** @author Brian Cavalier */ /** @author John Hann */ function tryEvent(t, x, sink) {
    try {
        sink.event(t, x);
    } catch (e) {
        sink.error(t, e);
    }
}
function tryEnd(t, sink) {
    try {
        sink.end(t);
    } catch (e) {
        sink.error(t, e);
    }
}
/** @license MIT License (c) copyright 2010-2016 original author or authors */ /**
 * If stream encounters an error, recover and continue with items from stream
 * returned by f.
 * @param f which returns a new stream
 * @param stream
 * @returns new stream which will recover from an error by calling f
 */ var recoverWith = function(f, stream) {
    return isCanonicalEmpty(stream) ? empty() : new RecoverWith(f, stream);
};
/**
 * Create a stream containing only an error
 * @param e error value, preferably an Error or Error subtype
 * @returns new stream containing only an error
 */ var throwError = function(e) {
    return new ErrorStream(e);
};
var ErrorStream = function() {
    function ErrorStream1(e) {
        this.value = e;
    }
    ErrorStream1.prototype.run = function(sink, scheduler) {
        return _scheduler.asap(propagateErrorTask(this.value, sink), scheduler);
    };
    return ErrorStream1;
}();
var RecoverWith = function() {
    function RecoverWith1(f, source) {
        this.f = f;
        this.source = source;
    }
    RecoverWith1.prototype.run = function(sink, scheduler) {
        return new RecoverWithSink(this.f, this.source, sink, scheduler);
    };
    return RecoverWith1;
}();
var RecoverWithSink = function() {
    function RecoverWithSink1(f, source, sink, scheduler) {
        this.f = f;
        this.sink = new SafeSink(sink);
        this.scheduler = scheduler;
        this.disposable = source.run(this, scheduler);
    }
    RecoverWithSink1.prototype.event = function(t, x) {
        tryEvent(t, x, this.sink);
    };
    RecoverWithSink1.prototype.end = function(t) {
        tryEnd(t, this.sink);
    };
    RecoverWithSink1.prototype.error = function(t, e) {
        var nextSink = this.sink.disable();
        _disposable.tryDispose(t, this.disposable, this.sink);
        this._startNext(t, e, nextSink);
    };
    RecoverWithSink1.prototype._startNext = function(t, x, sink) {
        try {
            this.disposable = this._continue(this.f, t, x, sink);
        } catch (e) {
            sink.error(t, e);
        }
    };
    RecoverWithSink1.prototype._continue = function(f, t, x, sink) {
        return run(sink, this.scheduler, withLocalTime(t, f(x)));
    };
    RecoverWithSink1.prototype.dispose = function() {
        return this.disposable.dispose();
    };
    return RecoverWithSink1;
}();
var multicast = function(stream) {
    return stream instanceof Multicast || isCanonicalEmpty(stream) ? stream : new Multicast(stream);
};
var Multicast = function() {
    function Multicast1(source) {
        this.source = new MulticastSource(source);
    }
    Multicast1.prototype.run = function(sink, scheduler) {
        return this.source.run(sink, scheduler);
    };
    return Multicast1;
}();
var MulticastSource = function() {
    function MulticastSource1(source) {
        this.source = source;
        this.sinks = [];
        this.disposable = _disposable.disposeNone();
    }
    MulticastSource1.prototype.run = function(sink, scheduler) {
        var n = this.add(sink);
        if (n === 1) this.disposable = this.source.run(this, scheduler);
        return _disposable.disposeOnce(new MulticastDisposable(this, sink));
    };
    MulticastSource1.prototype.dispose = function() {
        var disposable = this.disposable;
        this.disposable = _disposable.disposeNone();
        return disposable.dispose();
    };
    MulticastSource1.prototype.add = function(sink) {
        this.sinks = _prelude.append(sink, this.sinks);
        return this.sinks.length;
    };
    MulticastSource1.prototype.remove = function(sink) {
        var i = _prelude.findIndex(sink, this.sinks);
        // istanbul ignore next
        if (i >= 0) this.sinks = _prelude.remove(i, this.sinks);
        return this.sinks.length;
    };
    MulticastSource1.prototype.event = function(time, value) {
        var s = this.sinks;
        if (s.length === 1) return s[0].event(time, value);
        for(var i = 0; i < s.length; ++i)tryEvent(time, value, s[i]);
    };
    MulticastSource1.prototype.end = function(time) {
        var s = this.sinks;
        for(var i = 0; i < s.length; ++i)tryEnd(time, s[i]);
    };
    MulticastSource1.prototype.error = function(time, err) {
        var s = this.sinks;
        for(var i = 0; i < s.length; ++i)s[i].error(time, err);
    };
    return MulticastSource1;
}();
var MulticastDisposable = function() {
    function MulticastDisposable1(source, sink) {
        this.source = source;
        this.sink = sink;
    }
    MulticastDisposable1.prototype.dispose = function() {
        if (this.source.remove(this.sink) === 0) this.source.dispose();
    };
    return MulticastDisposable1;
}();
/** @license MIT License (c) copyright 2016 original author or authors */ var run$1 = _prelude.curry3(run);
var withLocalTime$1 = _prelude.curry2(withLocalTime);
var loop$1 = _prelude.curry3(loop);
var scan$1 = _prelude.curry3(scan);
var startWith$1 = _prelude.curry2(startWith);
var map$1 = _prelude.curry2(map);
var constant$1 = _prelude.curry2(constant);
var tap$1 = _prelude.curry2(tap);
var ap$1 = _prelude.curry2(ap);
var chain$1 = _prelude.curry2(chain);
var continueWith$1 = _prelude.curry2(continueWith);
var concatMap$1 = _prelude.curry2(concatMap);
var mergeConcurrently$1 = _prelude.curry2(mergeConcurrently);
var mergeMapConcurrently$1 = _prelude.curry3(mergeMapConcurrently);
var merge$1 = _prelude.curry2(merge);
var combine$1 = _prelude.curry3(combine);
var combineArray$1 = _prelude.curry2(combineArray);
var sample$1 = _prelude.curry2(sample);
var snapshot$1 = _prelude.curry3(snapshot);
var zipItems$1 = _prelude.curry3(zipItems);
var withItems$1 = _prelude.curry2(withItems);
var zip$1 = _prelude.curry3(zip);
var zipArray$1 = _prelude.curry2(zipArray);
var filter$1 = _prelude.curry2(filter);
var skipRepeatsWith$1 = _prelude.curry2(skipRepeatsWith);
var take$1 = _prelude.curry2(take);
var skip$1 = _prelude.curry2(skip);
var slice$1 = _prelude.curry3(slice);
var takeWhile$1 = _prelude.curry2(takeWhile);
var skipWhile$1 = _prelude.curry2(skipWhile);
var skipAfter$1 = _prelude.curry2(skipAfter);
var until$1 = _prelude.curry2(until);
var since$1 = _prelude.curry2(since);
var during$1 = _prelude.curry2(during);
var delay$1 = _prelude.curry2(delay);
var throttle$1 = _prelude.curry2(throttle);
var debounce$1 = _prelude.curry2(debounce);
var recoverWith$1 = _prelude.curry2(recoverWith);
var propagateTask$1 = _prelude.curry3(propagateTask);
var propagateEventTask$1 = _prelude.curry2(propagateEventTask);
var propagateErrorTask$1 = _prelude.curry2(propagateErrorTask);

},{"@most/prelude":"jX2Nl","@most/scheduler":"jTyut","@most/disposable":"kRWXZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jX2Nl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "append", ()=>append
);
parcelHelpers.export(exports, "apply", ()=>apply
);
parcelHelpers.export(exports, "compose", ()=>compose
);
parcelHelpers.export(exports, "concat", ()=>concat
);
parcelHelpers.export(exports, "cons", ()=>cons
);
parcelHelpers.export(exports, "copy", ()=>copy
);
parcelHelpers.export(exports, "curry2", ()=>curry2
);
parcelHelpers.export(exports, "curry3", ()=>curry3
);
parcelHelpers.export(exports, "curry4", ()=>curry4
);
parcelHelpers.export(exports, "drop", ()=>drop
);
parcelHelpers.export(exports, "findIndex", ()=>findIndex
);
parcelHelpers.export(exports, "id", ()=>id
);
parcelHelpers.export(exports, "isArrayLike", ()=>isArrayLike
);
parcelHelpers.export(exports, "map", ()=>map
);
parcelHelpers.export(exports, "reduce", ()=>reduce
);
parcelHelpers.export(exports, "remove", ()=>remove
);
parcelHelpers.export(exports, "removeAll", ()=>removeAll
);
parcelHelpers.export(exports, "replace", ()=>replace
);
parcelHelpers.export(exports, "tail", ()=>tail
);
/** @license MIT License (c) copyright 2010-2016 original author or authors */ // Non-mutating array operations
/**
 * a with x prepended
 */ function cons(x, a) {
    var l = a.length;
    var b = new Array(l + 1);
    b[0] = x;
    for(var i = 0; i < l; ++i)b[i + 1] = a[i];
    return b;
}
/**
 * a with x appended
 */ function append(x, a) {
    var l = a.length;
    var b = new Array(l + 1);
    for(var i = 0; i < l; ++i)b[i] = a[i];
    b[l] = x;
    return b;
}
/**
 * Concats two `ArrayLike`s
 */ function concat(a, b) {
    var al = a.length;
    var bl = b.length;
    var r = new Array(al + bl);
    var i = 0;
    for(i = 0; i < al; i++)r[i] = a[i];
    for(var j = 0; j < bl; j++)r[i++] = b[j];
    return r;
}
//
/**
 * drop first n elements
 */ function drop(n, a) {
    if (n < 0) throw new TypeError('n must be >= 0');
    var l = a.length;
    if (n === 0 || l === 0) return a;
    if (n >= l) return [];
    return unsafeDrop(n, a, l - n);
}
/**
 * Internal helper for drop
 */ function unsafeDrop(n, a, l) {
    var b = new Array(l);
    for(var i = 0; i < l; ++i)b[i] = a[n + i];
    return b;
}
/**
 * drop head element
 */ function tail(a) {
    return drop(1, a);
}
/**
 * duplicate a (shallow duplication)
 */ function copy(a) {
    var l = a.length;
    var b = new Array(l);
    for(var i = 0; i < l; ++i)b[i] = a[i];
    return b;
}
/**
 * transform each element with f
 */ function map(f, a) {
    var l = a.length;
    var b = new Array(l);
    for(var i = 0; i < l; ++i)b[i] = f(a[i]);
    return b;
}
/**
 * accumulate via left-fold
 */ function reduce(f, z, a) {
    var r = z;
    for(var i = 0, l = a.length; i < l; ++i)r = f(r, a[i], i);
    return r;
}
/**
 * replace element at index
 */ function replace(x, i, a) {
    if (i < 0) throw new TypeError('i must be >= 0');
    var l = a.length;
    var b = new Array(l);
    for(var j = 0; j < l; ++j)b[j] = i === j ? x : a[j];
    return b;
}
/**
 * remove element at index
 * @throws
 */ function remove(i, a) {
    if (i < 0) throw new TypeError('i must be >= 0');
    var l = a.length;
    if (l === 0 || i >= l) return a;
    if (l === 1) return [];
    return unsafeRemove(i, a, l - 1);
}
/**
 * Internal helper to remove element at index
 */ function unsafeRemove(i, a, l) {
    var b = new Array(l);
    var j;
    for(j = 0; j < i; ++j)b[j] = a[j];
    for(j = i; j < l; ++j)b[j] = a[j + 1];
    return b;
}
/**
 * remove all elements matching a predicate
 * @deprecated
 */ function removeAll(f, a) {
    var l = a.length;
    var b = new Array(l);
    var j = 0;
    for(var x = void 0, i = 0; i < l; ++i){
        x = a[i];
        if (!f(x)) {
            b[j] = x;
            ++j;
        }
    }
    b.length = j;
    return b;
}
/**
 * find index of x in a, from the left
 */ function findIndex(x, a) {
    for(var i = 0, l = a.length; i < l; ++i){
        if (x === a[i]) return i;
    }
    return -1;
}
/**
 * Return true iff x is array-like
 */ function isArrayLike(x) {
    return x != null && typeof x.length === 'number' && typeof x !== 'function';
}
/** @license MIT License (c) copyright 2010-2016 original author or authors */ var id = function(x) {
    return x;
};
var compose = function(f, g) {
    return function(x) {
        return f(g(x));
    };
};
var apply = function(f, x) {
    return f(x);
};
function curry2(f) {
    function curried(a, b1) {
        switch(arguments.length){
            case 0:
                return curried;
            case 1:
                return function(b) {
                    return f(a, b);
                };
            default:
                return f(a, b1);
        }
    }
    return curried;
}
function curry3(f) {
    function curried(a, b2, c1) {
        switch(arguments.length){
            case 0:
                return curried;
            case 1:
                return curry2(function(b, c) {
                    return f(a, b, c);
                });
            case 2:
                return function(c) {
                    return f(a, b2, c);
                };
            default:
                return f(a, b2, c1);
        }
    }
    return curried;
}
function curry4(f) {
    function curried(a, b3, c2, d1) {
        switch(arguments.length){
            case 0:
                return curried;
            case 1:
                return curry3(function(b, c, d) {
                    return f(a, b, c, d);
                });
            case 2:
                return curry2(function(c, d) {
                    return f(a, b3, c, d);
                });
            case 3:
                return function(d) {
                    return f(a, b3, c2, d);
                };
            default:
                return f(a, b3, c2, d1);
        }
    }
    return curried;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jTyut":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HRTimeClock", ()=>HRTimeClock
);
parcelHelpers.export(exports, "RelativeClock", ()=>RelativeClock
);
parcelHelpers.export(exports, "asap", ()=>asap
);
parcelHelpers.export(exports, "cancelAllTasks", ()=>cancelAllTasks
);
parcelHelpers.export(exports, "cancelTask", ()=>cancelTask
);
parcelHelpers.export(exports, "clockRelativeTo", ()=>clockRelativeTo
);
parcelHelpers.export(exports, "currentTime", ()=>currentTime
);
parcelHelpers.export(exports, "delay", ()=>delay
);
parcelHelpers.export(exports, "newClockTimer", ()=>newClockTimer
);
parcelHelpers.export(exports, "newDateClock", ()=>newDateClock
);
parcelHelpers.export(exports, "newDefaultScheduler", ()=>newDefaultScheduler
);
parcelHelpers.export(exports, "newDefaultTimer", ()=>newDefaultTimer
);
parcelHelpers.export(exports, "newHRTimeClock", ()=>newHRTimeClock
);
parcelHelpers.export(exports, "newPerformanceClock", ()=>newPerformanceClock
);
parcelHelpers.export(exports, "newPlatformClock", ()=>newPlatformClock
);
parcelHelpers.export(exports, "newScheduler", ()=>newScheduler
);
parcelHelpers.export(exports, "newTimeline", ()=>newTimeline
);
parcelHelpers.export(exports, "periodic", ()=>periodic
);
parcelHelpers.export(exports, "schedulerRelativeTo", ()=>schedulerRelativeTo
);
var _prelude = require("@most/prelude");
var process = require("process");
var ScheduledTaskImpl = function() {
    function ScheduledTaskImpl1(time, localOffset, period, task, scheduler) {
        this.time = time;
        this.localOffset = localOffset;
        this.period = period;
        this.task = task;
        this.scheduler = scheduler;
        this.active = true;
    }
    ScheduledTaskImpl1.prototype.run = function() {
        return this.task.run(this.time - this.localOffset);
    };
    ScheduledTaskImpl1.prototype.error = function(e) {
        return this.task.error(this.time - this.localOffset, e);
    };
    ScheduledTaskImpl1.prototype.dispose = function() {
        this.active = false;
        this.scheduler.cancel(this);
        return this.task.dispose();
    };
    return ScheduledTaskImpl1;
}();
var RelativeScheduler = function() {
    function RelativeScheduler1(origin, scheduler) {
        this.origin = origin;
        this.scheduler = scheduler;
    }
    RelativeScheduler1.prototype.currentTime = function() {
        return this.scheduler.currentTime() - this.origin;
    };
    RelativeScheduler1.prototype.scheduleTask = function(localOffset, delay1, period, task) {
        return this.scheduler.scheduleTask(localOffset + this.origin, delay1, period, task);
    };
    RelativeScheduler1.prototype.relative = function(origin) {
        return new RelativeScheduler1(origin + this.origin, this.scheduler);
    };
    RelativeScheduler1.prototype.cancel = function(task) {
        return this.scheduler.cancel(task);
    };
    RelativeScheduler1.prototype.cancelAll = function(f) {
        return this.scheduler.cancelAll(f);
    };
    return RelativeScheduler1;
}();
/** @license MIT License (c) copyright 2010-2017 original author or authors */ var defer = function(task) {
    return Promise.resolve(task).then(runTask);
};
function runTask(task) {
    try {
        return task.run();
    } catch (e) {
        return task.error(e);
    }
}
/** @license MIT License (c) copyright 2010-2017 original author or authors */ var SchedulerImpl = function() {
    function SchedulerImpl1(timer, timeline) {
        var _this = this;
        this._runReadyTasksBound = function() {
            return _this._runReadyTasks();
        };
        this.timer = timer;
        this.timeline = timeline;
        this._timer = null;
        this._nextArrival = Infinity;
    }
    SchedulerImpl1.prototype.currentTime = function() {
        return this.timer.now();
    };
    SchedulerImpl1.prototype.scheduleTask = function(localOffset, delay2, period, task) {
        var time = this.currentTime() + Math.max(0, delay2);
        var st = new ScheduledTaskImpl(time, localOffset, period, task, this);
        this.timeline.add(st);
        this._scheduleNextRun();
        return st;
    };
    SchedulerImpl1.prototype.relative = function(offset) {
        return new RelativeScheduler(offset, this);
    };
    SchedulerImpl1.prototype.cancel = function(task) {
        task.active = false;
        if (this.timeline.remove(task)) this._reschedule();
    };
    // @deprecated
    SchedulerImpl1.prototype.cancelAll = function(f) {
        this.timeline.removeAll(f);
        this._reschedule();
    };
    SchedulerImpl1.prototype._reschedule = function() {
        if (this.timeline.isEmpty()) this._unschedule();
        else this._scheduleNextRun();
    };
    SchedulerImpl1.prototype._unschedule = function() {
        this.timer.clearTimer(this._timer);
        this._timer = null;
    };
    SchedulerImpl1.prototype._scheduleNextRun = function() {
        if (this.timeline.isEmpty()) return;
        var nextArrival = this.timeline.nextArrival();
        if (this._timer === null) this._scheduleNextArrival(nextArrival);
        else if (nextArrival < this._nextArrival) {
            this._unschedule();
            this._scheduleNextArrival(nextArrival);
        }
    };
    SchedulerImpl1.prototype._scheduleNextArrival = function(nextArrival) {
        this._nextArrival = nextArrival;
        var delay3 = Math.max(0, nextArrival - this.currentTime());
        this._timer = this.timer.setTimer(this._runReadyTasksBound, delay3);
    };
    SchedulerImpl1.prototype._runReadyTasks = function() {
        this._timer = null;
        this.timeline.runTasks(this.currentTime(), runTask);
        this._scheduleNextRun();
    };
    return SchedulerImpl1;
}();
/** @license MIT License (c) copyright 2010-2017 original author or authors */ var TimelineImpl = function() {
    function TimelineImpl1() {
        this.tasks = [];
    }
    TimelineImpl1.prototype.nextArrival = function() {
        return this.isEmpty() ? Infinity : this.tasks[0].time;
    };
    TimelineImpl1.prototype.isEmpty = function() {
        return this.tasks.length === 0;
    };
    TimelineImpl1.prototype.add = function(st) {
        insertByTime(st, this.tasks);
    };
    TimelineImpl1.prototype.remove = function(st) {
        var i = binarySearch(getTime(st), this.tasks);
        if (i >= 0 && i < this.tasks.length) {
            var events = this.tasks[i].events;
            var at = _prelude.findIndex(st, events);
            if (at >= 0) {
                events.splice(at, 1);
                if (events.length === 0) this.tasks.splice(i, 1);
                return true;
            }
        }
        return false;
    };
    /**
     * @deprecated
     */ TimelineImpl1.prototype.removeAll = function(f) {
        for(var i = 0; i < this.tasks.length; ++i)removeAllFrom(f, this.tasks[i]);
    };
    TimelineImpl1.prototype.runTasks = function(t, runTask1) {
        var tasks = this.tasks;
        var l = tasks.length;
        var i = 0;
        while(i < l && tasks[i].time <= t)++i;
        this.tasks = tasks.slice(i);
        // Run all ready tasks
        for(var j = 0; j < i; ++j)this.tasks = runReadyTasks(runTask1, tasks[j].events, this.tasks);
    };
    return TimelineImpl1;
}();
function runReadyTasks(runTask2, events, tasks) {
    for(var i = 0; i < events.length; ++i){
        var task = events[i];
        if (task.active) {
            runTask2(task);
            // Reschedule periodic repeating tasks
            // Check active again, since a task may have canceled itself
            if (task.period >= 0 && task.active) {
                task.time = task.time + task.period;
                insertByTime(task, tasks);
            }
        }
    }
    return tasks;
}
function insertByTime(task, timeslots) {
    var l = timeslots.length;
    var time = getTime(task);
    if (l === 0) {
        timeslots.push(newTimeslot(time, [
            task
        ]));
        return;
    }
    var i = binarySearch(time, timeslots);
    if (i >= l) timeslots.push(newTimeslot(time, [
        task
    ]));
    else insertAtTimeslot(task, timeslots, time, i);
}
function insertAtTimeslot(task, timeslots, time, i) {
    var timeslot = timeslots[i];
    if (time === timeslot.time) addEvent(task, timeslot.events);
    else timeslots.splice(i, 0, newTimeslot(time, [
        task
    ]));
}
function addEvent(task, events) {
    if (events.length === 0 || task.time >= events[events.length - 1].time) events.push(task);
    else spliceEvent(task, events);
}
function spliceEvent(task, events) {
    for(var j = 0; j < events.length; j++)if (task.time < events[j].time) {
        events.splice(j, 0, task);
        break;
    }
}
function getTime(scheduledTask) {
    return Math.floor(scheduledTask.time);
}
/**
 * @deprecated
 */ function removeAllFrom(f, timeslot) {
    timeslot.events = _prelude.removeAll(f, timeslot.events);
}
function binarySearch(t, sortedArray) {
    var lo = 0;
    var hi = sortedArray.length;
    var mid, y;
    while(lo < hi){
        mid = Math.floor((lo + hi) / 2);
        y = sortedArray[mid];
        if (t === y.time) return mid;
        else if (t < y.time) hi = mid;
        else lo = mid + 1;
    }
    return hi;
}
var newTimeslot = function(t, events) {
    return {
        time: t,
        events: events
    };
};
/** @license MIT License (c) copyright 2010-2017 original author or authors */ /* global setTimeout, clearTimeout */ var ClockTimer = function() {
    function ClockTimer1(clock) {
        this._clock = clock;
    }
    ClockTimer1.prototype.now = function() {
        return this._clock.now();
    };
    ClockTimer1.prototype.setTimer = function(f, dt) {
        return dt <= 0 ? runAsap(f) : setTimeout(f, dt);
    };
    ClockTimer1.prototype.clearTimer = function(t) {
        return t instanceof Asap ? t.cancel() : clearTimeout(t);
    };
    return ClockTimer1;
}();
var Asap = function() {
    function Asap1(f) {
        this.f = f;
        this.active = true;
    }
    Asap1.prototype.run = function() {
        if (this.active) return this.f();
    };
    Asap1.prototype.error = function(e) {
        throw e;
    };
    Asap1.prototype.cancel = function() {
        this.active = false;
    };
    return Asap1;
}();
function runAsap(f) {
    var task = new Asap(f);
    defer(task);
    return task;
}
/* global performance, process */ var RelativeClock = function() {
    function RelativeClock1(clock, origin) {
        this.origin = origin;
        this.clock = clock;
    }
    RelativeClock1.prototype.now = function() {
        return this.clock.now() - this.origin;
    };
    return RelativeClock1;
}();
var HRTimeClock = function() {
    function HRTimeClock1(hrtime, origin) {
        this.origin = origin;
        this.hrtime = hrtime;
    }
    HRTimeClock1.prototype.now = function() {
        var hrt = this.hrtime(this.origin);
        return (hrt[0] * 1000000000 + hrt[1]) / 1000000;
    };
    return HRTimeClock1;
}();
var clockRelativeTo = function(clock) {
    return new RelativeClock(clock, clock.now());
};
var newPerformanceClock = function() {
    return clockRelativeTo(performance);
};
/**
 * @deprecated will be removed in 2.0.0
 * Date.now is not monotonic, and performance.now is ubiquitous:
 * @see https://caniuse.com/#search=performance.now
 */ var newDateClock = function() {
    return clockRelativeTo(Date);
};
var newHRTimeClock = function() {
    return new HRTimeClock(process.hrtime, process.hrtime());
};
var newPlatformClock = function() {
    if (typeof performance !== 'undefined' && typeof performance.now === 'function') return newPerformanceClock();
    else if (typeof process !== 'undefined' && typeof process.hrtime === 'function') return newHRTimeClock();
    return newDateClock();
};
/**
 * Read the current time from the provided Scheduler
 */ var currentTime = function(scheduler) {
    return scheduler.currentTime();
};
/**
 * Schedule a task to run as soon as possible, but
 * not in the current call stack
 */ var asap = _prelude.curry2(function(task, scheduler) {
    return scheduler.scheduleTask(0, 0, -1, task);
});
/**
 * Schedule a task to run after a millisecond delay
 */ var delay = _prelude.curry3(function(delay4, task, scheduler) {
    return scheduler.scheduleTask(0, delay4, -1, task);
});
/**
 * Schedule a task to run periodically, with the
 * first run starting asap
 */ var periodic = _prelude.curry3(function(period, task, scheduler) {
    return scheduler.scheduleTask(0, 0, period, task);
});
/**
 * Cancel a scheduledTask
 */ var cancelTask = function(scheduledTask) {
    return scheduledTask.dispose();
};
/**
 * Cancel all ScheduledTasks for which a predicate is true
 * @deprecated Will be removed in 2.0.0
 */ var cancelAllTasks = _prelude.curry2(function(predicate, scheduler) {
    console.warn("DEPRECATED cancelAllTasks to be removed in 2.0.0");
    return scheduler.cancelAll(predicate);
});
var schedulerRelativeTo = _prelude.curry2(function(offset, scheduler) {
    return new RelativeScheduler(offset, scheduler);
});
/** @license MIT License (c) copyright 2010-2017 original author or authors */ var newScheduler = _prelude.curry2(function(timer, timeline) {
    return new SchedulerImpl(timer, timeline);
});
var newDefaultScheduler = function() {
    return new SchedulerImpl(newDefaultTimer(), new TimelineImpl());
};
var newDefaultTimer = function() {
    return new ClockTimer(newPlatformClock());
};
var newClockTimer = function(clock) {
    return new ClockTimer(clock);
};
var newTimeline = function() {
    return new TimelineImpl();
};

},{"@most/prelude":"jX2Nl","process":"jhUEF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kRWXZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DisposeAllError", ()=>DisposeAllError
);
parcelHelpers.export(exports, "dispose", ()=>dispose
);
parcelHelpers.export(exports, "disposeAll", ()=>disposeAll
);
parcelHelpers.export(exports, "disposeBoth", ()=>disposeBoth
);
parcelHelpers.export(exports, "disposeNone", ()=>disposeNone
);
parcelHelpers.export(exports, "disposeOnce", ()=>disposeOnce
);
parcelHelpers.export(exports, "disposeWith", ()=>disposeWith
);
parcelHelpers.export(exports, "isDisposeNone", ()=>isDisposeNone
);
parcelHelpers.export(exports, "tryDispose", ()=>tryDispose
);
var _prelude = require("@most/prelude");
var dispose = function(disposable) {
    return disposable.dispose();
};
var disposeNone = function() {
    return NONE;
};
var NONE = new (function() {
    function DisposeNone() {
    }
    DisposeNone.prototype.dispose = function() {
    };
    return DisposeNone;
}())();
var isDisposeNone = function(d) {
    return d === NONE;
};
/**
 * Wrap an existing disposable (which may not already have been once()d)
 * so that it will only dispose its underlying resource at most once.
 */ var disposeOnce = function(disposable) {
    return new DisposeOnce(disposable);
};
var DisposeOnce = function() {
    function DisposeOnce1(disposable) {
        this.disposed = false;
        this.disposable = disposable;
    }
    DisposeOnce1.prototype.dispose = function() {
        if (!this.disposed) {
            this.disposed = true;
            if (this.disposable) {
                this.disposable.dispose();
                this.disposable = undefined;
            }
        }
    };
    return DisposeOnce1;
}();
/** @license MIT License (c) copyright 2010-2017 original author or authors */ /**
 * Create a Disposable that will use the provided
 * dispose function to dispose the resource
 */ var disposeWith = _prelude.curry2(function(dispose1, resource) {
    return disposeOnce(new DisposeWithImpl(dispose1, resource));
});
/**
 * Disposable represents a resource that must be
 * disposed/released. It aggregates a function to dispose
 * the resource and a handle to a key/id/handle/reference
 * that identifies the resource
 */ var DisposeWithImpl = function() {
    function DisposeWithImpl1(dispose2, resource) {
        this._dispose = dispose2;
        this._resource = resource;
    }
    DisposeWithImpl1.prototype.dispose = function() {
        this._dispose(this._resource);
    };
    return DisposeWithImpl1;
}();
/** @license MIT License (c) copyright 2010 original author or authors */ /**
 * Aggregate a list of disposables into a DisposeAll
 */ var disposeAll = function(ds) {
    var merged = _prelude.reduce(merge, [], ds);
    return merged.length === 0 ? disposeNone() : new DisposeAll(merged);
};
/**
 * Convenience to aggregate 2 disposables
 */ var disposeBoth = _prelude.curry2(function(d1, d2) {
    return disposeAll([
        d1,
        d2
    ]);
});
var merge = function(ds, d) {
    return isDisposeNone(d) ? ds : d instanceof DisposeAll ? _prelude.concat(ds, d.disposables) : _prelude.append(d, ds);
};
var DisposeAll = function() {
    function DisposeAll1(disposables) {
        this.disposables = disposables;
    }
    DisposeAll1.prototype.dispose = function() {
        throwIfErrors(disposeCollectErrors(this.disposables));
    };
    return DisposeAll1;
}();
/**
 * Dispose all, safely collecting errors into an array
 */ var disposeCollectErrors = function(disposables) {
    return _prelude.reduce(appendIfError, [], disposables);
};
/**
 * Call dispose and if throws, append thrown error to errors
 */ var appendIfError = function(errors, d) {
    try {
        d.dispose();
    } catch (e) {
        errors.push(e);
    }
    return errors;
};
/**
 * Throw DisposeAllError if errors is non-empty
 * @throws
 */ var throwIfErrors = function(errors) {
    if (errors.length > 0) throw new DisposeAllError(errors.length + " errors", errors);
};
var DisposeAllError = function() {
    function DisposeAllError1(message, errors) {
        this.name = 'DisposeAllError';
        this.message = message;
        this.errors = errors;
        Error.call(this, message);
        if (Error.captureStackTrace) Error.captureStackTrace(this, DisposeAllError1);
        this.stack = "" + this.stack + formatErrorStacks(this.errors);
    }
    return DisposeAllError1;
}();
DisposeAllError.prototype = Object.create(Error.prototype);
var formatErrorStacks = function(errors) {
    return _prelude.reduce(formatErrorStack, '', errors);
};
var formatErrorStack = function(s, e, i) {
    return s + ("\n[" + (i + 1) + "] " + e.stack);
};
/** @license MIT License (c) copyright 2010-2017 original author or authors */ // Try to dispose the disposable.  If it throws, send
// the error to sink.error with the provided Time value
var tryDispose = _prelude.curry3(function(t, disposable, sink) {
    try {
        disposable.dispose();
    } catch (e) {
        sink.error(t, e);
    }
});

},{"@most/prelude":"jX2Nl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k1B4s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "domEvent", ()=>domEvent
);
parcelHelpers.export(exports, "blur", ()=>blur
);
parcelHelpers.export(exports, "focus", ()=>focus
);
parcelHelpers.export(exports, "focusin", ()=>focusin
);
parcelHelpers.export(exports, "focusout", ()=>focusout
);
parcelHelpers.export(exports, "click", ()=>click
);
parcelHelpers.export(exports, "dblclick", ()=>dblclick
);
parcelHelpers.export(exports, "mousedown", ()=>mousedown
);
parcelHelpers.export(exports, "mouseup", ()=>mouseup
);
parcelHelpers.export(exports, "mousemove", ()=>mousemove
);
parcelHelpers.export(exports, "mouseover", ()=>mouseover
);
parcelHelpers.export(exports, "mouseenter", ()=>mouseenter
);
parcelHelpers.export(exports, "mouseout", ()=>mouseout
);
parcelHelpers.export(exports, "mouseleave", ()=>mouseleave
);
parcelHelpers.export(exports, "change", ()=>change
);
parcelHelpers.export(exports, "select", ()=>select
);
parcelHelpers.export(exports, "submit", ()=>submit
);
parcelHelpers.export(exports, "keydown", ()=>keydown
);
parcelHelpers.export(exports, "keypress", ()=>keypress
);
parcelHelpers.export(exports, "keyup", ()=>keyup
);
parcelHelpers.export(exports, "input", ()=>input
);
parcelHelpers.export(exports, "contextmenu", ()=>contextmenu
);
parcelHelpers.export(exports, "resize", ()=>resize
);
parcelHelpers.export(exports, "scroll", ()=>scroll
);
parcelHelpers.export(exports, "error", ()=>error
);
parcelHelpers.export(exports, "hashchange", ()=>hashchange
);
parcelHelpers.export(exports, "popstate", ()=>popstate
);
parcelHelpers.export(exports, "load", ()=>load
);
parcelHelpers.export(exports, "unload", ()=>unload
);
parcelHelpers.export(exports, "pointerdown", ()=>pointerdown
);
parcelHelpers.export(exports, "pointerup", ()=>pointerup
);
parcelHelpers.export(exports, "pointermove", ()=>pointermove
);
parcelHelpers.export(exports, "pointerover", ()=>pointerover
);
parcelHelpers.export(exports, "pointerenter", ()=>pointerenter
);
parcelHelpers.export(exports, "pointerout", ()=>pointerout
);
parcelHelpers.export(exports, "pointerleave", ()=>pointerleave
);
parcelHelpers.export(exports, "touchstart", ()=>touchstart
);
parcelHelpers.export(exports, "touchend", ()=>touchend
);
parcelHelpers.export(exports, "touchmove", ()=>touchmove
);
parcelHelpers.export(exports, "touchcancel", ()=>touchcancel
);
var _scheduler = require("@most/scheduler");
/** @license MIT License (c) copyright 2015-2016 original author or authors */ /** @author Brian Cavalier */ // domEvent :: (EventTarget t, Event e) => String -> t -> boolean=false -> Stream e
var domEvent = function(event, node, capture) {
    if (capture === void 0) capture = false;
    return new DomEvent(event, node, capture);
};
var blur = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('blur', node, capture);
};
var focus = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('focus', node, capture);
};
var focusin = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('focusin', node, capture);
};
var focusout = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('focusout', node, capture);
};
var click = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('click', node, capture);
};
var dblclick = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('dblclick', node, capture);
};
var mousedown = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('mousedown', node, capture);
};
var mouseup = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('mouseup', node, capture);
};
var mousemove = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('mousemove', node, capture);
};
var mouseover = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('mouseover', node, capture);
};
var mouseenter = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('mouseenter', node, capture);
};
var mouseout = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('mouseout', node, capture);
};
var mouseleave = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('mouseleave', node, capture);
};
var change = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('change', node, capture);
};
var select = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('select', node, capture);
};
var submit = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('submit', node, capture);
};
var keydown = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('keydown', node, capture);
};
var keypress = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('keypress', node, capture);
};
var keyup = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('keyup', node, capture);
};
var input = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('input', node, capture);
};
var contextmenu = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('contextmenu', node, capture);
};
var resize = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('resize', node, capture);
};
var scroll = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('scroll', node, capture);
};
var error = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('error', node, capture);
};
var hashchange = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('hashchange', node, capture);
};
var popstate = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('popstate', node, capture);
};
var load = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('load', node, capture);
};
var unload = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('unload', node, capture);
};
var pointerdown = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('pointerdown', node, capture);
};
var pointerup = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('pointerup', node, capture);
};
var pointermove = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('pointermove', node, capture);
};
var pointerover = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('pointerover', node, capture);
};
var pointerenter = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('pointerenter', node, capture);
};
var pointerout = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('pointerout', node, capture);
};
var pointerleave = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('pointerleave', node, capture);
};
var touchstart = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('touchstart', node, capture);
};
var touchend = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('touchend', node, capture);
};
var touchmove = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('touchmove', node, capture);
};
var touchcancel = function(node, capture) {
    if (capture === void 0) capture = false;
    return domEvent('touchcancel', node, capture);
};
var DomEvent = function DomEvent(event, node, capture) {
    this.event = event;
    this.node = node;
    this.capture = capture;
};
DomEvent.prototype.run = function run(sink, scheduler$$1) {
    var this$1 = this;
    var send = function(e) {
        return tryEvent(_scheduler.currentTime(scheduler$$1), e, sink);
    };
    var dispose = function() {
        return this$1.node.removeEventListener(this$1.event, send, this$1.capture);
    };
    this.node.addEventListener(this.event, send, this.capture);
    return {
        dispose: dispose
    };
};
function tryEvent(t, x, sink) {
    try {
        sink.event(t, x);
    } catch (e) {
        sink.error(t, e);
    }
}

},{"@most/scheduler":"kUxJ2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kUxJ2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "newScheduler", ()=>newScheduler
);
parcelHelpers.export(exports, "newDefaultScheduler", ()=>newDefaultScheduler
);
parcelHelpers.export(exports, "newDefaultTimer", ()=>newDefaultTimer
);
parcelHelpers.export(exports, "newClockTimer", ()=>newClockTimer
);
parcelHelpers.export(exports, "newTimeline", ()=>newTimeline
);
parcelHelpers.export(exports, "RelativeClock", ()=>RelativeClock
);
parcelHelpers.export(exports, "HRTimeClock", ()=>HRTimeClock
);
parcelHelpers.export(exports, "clockRelativeTo", ()=>clockRelativeTo
);
parcelHelpers.export(exports, "newPerformanceClock", ()=>newPerformanceClock
);
parcelHelpers.export(exports, "newDateClock", ()=>newDateClock
);
parcelHelpers.export(exports, "newHRTimeClock", ()=>newHRTimeClock
);
parcelHelpers.export(exports, "newPlatformClock", ()=>newPlatformClock
);
parcelHelpers.export(exports, "currentTime", ()=>currentTime
);
parcelHelpers.export(exports, "asap", ()=>asap
);
parcelHelpers.export(exports, "delay", ()=>delay
);
parcelHelpers.export(exports, "periodic", ()=>periodic
);
parcelHelpers.export(exports, "cancelTask", ()=>cancelTask
);
parcelHelpers.export(exports, "cancelAllTasks", ()=>cancelAllTasks
);
parcelHelpers.export(exports, "schedulerRelativeTo", ()=>schedulerRelativeTo
);
var _prelude = require("@most/prelude");
var process = require("process");
/** @license MIT License (c) copyright 2010-2017 original author or authors */ var ScheduledTask = function ScheduledTask(time, localOffset, period, task, scheduler) {
    this.time = time;
    this.localOffset = localOffset;
    this.period = period;
    this.task = task;
    this.scheduler = scheduler;
    this.active = true;
};
ScheduledTask.prototype.run = function run() {
    return this.task.run(this.time - this.localOffset);
};
ScheduledTask.prototype.error = function error(e) {
    return this.task.error(this.time - this.localOffset, e);
};
ScheduledTask.prototype.dispose = function dispose() {
    this.scheduler.cancel(this);
    return this.task.dispose();
};
var RelativeScheduler = function RelativeScheduler(origin, scheduler) {
    this.origin = origin;
    this.scheduler = scheduler;
};
RelativeScheduler.prototype.currentTime = function currentTime() {
    return this.scheduler.currentTime() - this.origin;
};
RelativeScheduler.prototype.scheduleTask = function scheduleTask(localOffset, delay1, period, task) {
    return this.scheduler.scheduleTask(localOffset + this.origin, delay1, period, task);
};
RelativeScheduler.prototype.relative = function relative(origin) {
    return new RelativeScheduler(origin + this.origin, this.scheduler);
};
RelativeScheduler.prototype.cancel = function cancel(task) {
    return this.scheduler.cancel(task);
};
RelativeScheduler.prototype.cancelAll = function cancelAll(f) {
    return this.scheduler.cancelAll(f);
};
/** @license MIT License (c) copyright 2010-2017 original author or authors */ var defer = function(task) {
    return Promise.resolve(task).then(runTask);
};
function runTask(task) {
    try {
        return task.run();
    } catch (e) {
        return task.error(e);
    }
}
/** @license MIT License (c) copyright 2010-2017 original author or authors */ var Scheduler = function Scheduler(timer, timeline) {
    var this$1 = this;
    this.timer = timer;
    this.timeline = timeline;
    this._timer = null;
    this._nextArrival = Infinity;
    this._runReadyTasksBound = function() {
        return this$1._runReadyTasks(this$1.currentTime());
    };
};
Scheduler.prototype.currentTime = function currentTime() {
    return this.timer.now();
};
Scheduler.prototype.scheduleTask = function scheduleTask(localOffset, delay2, period, task) {
    var time = this.currentTime() + Math.max(0, delay2);
    var st = new ScheduledTask(time, localOffset, period, task, this);
    this.timeline.add(st);
    this._scheduleNextRun();
    return st;
};
Scheduler.prototype.relative = function relative(offset) {
    return new RelativeScheduler(offset, this);
};
Scheduler.prototype.cancel = function cancel(task) {
    task.active = false;
    if (this.timeline.remove(task)) this._reschedule();
};
Scheduler.prototype.cancelAll = function cancelAll(f) {
    this.timeline.removeAll(f);
    this._reschedule();
};
Scheduler.prototype._reschedule = function _reschedule() {
    if (this.timeline.isEmpty()) this._unschedule();
    else this._scheduleNextRun(this.currentTime());
};
Scheduler.prototype._unschedule = function _unschedule() {
    this.timer.clearTimer(this._timer);
    this._timer = null;
};
Scheduler.prototype._scheduleNextRun = function _scheduleNextRun() {
    if (this.timeline.isEmpty()) return;
    var nextArrival = this.timeline.nextArrival();
    if (this._timer === null) this._scheduleNextArrival(nextArrival);
    else if (nextArrival < this._nextArrival) {
        this._unschedule();
        this._scheduleNextArrival(nextArrival);
    }
};
Scheduler.prototype._scheduleNextArrival = function _scheduleNextArrival(nextArrival) {
    this._nextArrival = nextArrival;
    var delay3 = Math.max(0, nextArrival - this.currentTime());
    this._timer = this.timer.setTimer(this._runReadyTasksBound, delay3);
};
Scheduler.prototype._runReadyTasks = function _runReadyTasks() {
    this._timer = null;
    this.timeline.runTasks(this.currentTime(), runTask);
    this._scheduleNextRun();
};
/** @license MIT License (c) copyright 2010-2017 original author or authors */ var Timeline = function Timeline() {
    this.tasks = [];
};
Timeline.prototype.nextArrival = function nextArrival() {
    return this.isEmpty() ? Infinity : this.tasks[0].time;
};
Timeline.prototype.isEmpty = function isEmpty() {
    return this.tasks.length === 0;
};
Timeline.prototype.add = function add(st) {
    insertByTime(st, this.tasks);
};
Timeline.prototype.remove = function remove(st) {
    var i = binarySearch(getTime(st), this.tasks);
    if (i >= 0 && i < this.tasks.length) {
        var at = _prelude.findIndex(st, this.tasks[i].events);
        if (at >= 0) {
            this.tasks[i].events.splice(at, 1);
            return true;
        }
    }
    return false;
};
Timeline.prototype.removeAll = function removeAll$$1(f) {
    var this$1 = this;
    for(var i = 0; i < this.tasks.length; ++i)removeAllFrom(f, this$1.tasks[i]);
};
Timeline.prototype.runTasks = function runTasks(t, runTask1) {
    var this$1 = this;
    var tasks = this.tasks;
    var l = tasks.length;
    var i = 0;
    while(i < l && tasks[i].time <= t)++i;
    this.tasks = tasks.slice(i);
    // Run all ready tasks
    for(var j = 0; j < i; ++j)this$1.tasks = runReadyTasks(runTask1, tasks[j].events, this$1.tasks);
};
function runReadyTasks(runTask2, events, tasks) {
    for(var i = 0; i < events.length; ++i){
        var task = events[i];
        if (task.active) {
            runTask2(task);
            // Reschedule periodic repeating tasks
            // Check active again, since a task may have canceled itself
            if (task.period >= 0 && task.active) {
                task.time = task.time + task.period;
                insertByTime(task, tasks);
            }
        }
    }
    return tasks;
}
function insertByTime(task, timeslots) {
    var l = timeslots.length;
    var time = getTime(task);
    if (l === 0) {
        timeslots.push(newTimeslot(time, [
            task
        ]));
        return;
    }
    var i = binarySearch(time, timeslots);
    if (i >= l) timeslots.push(newTimeslot(time, [
        task
    ]));
    else insertAtTimeslot(task, timeslots, time, i);
}
function insertAtTimeslot(task, timeslots, time, i) {
    var timeslot = timeslots[i];
    if (time === timeslot.time) addEvent(task, timeslot.events, time);
    else timeslots.splice(i, 0, newTimeslot(time, [
        task
    ]));
}
function addEvent(task, events) {
    if (events.length === 0 || task.time >= events[events.length - 1].time) events.push(task);
    else spliceEvent(task, events);
}
function spliceEvent(task, events) {
    for(var j = 0; j < events.length; j++)if (task.time < events[j].time) {
        events.splice(j, 0, task);
        break;
    }
}
function getTime(scheduledTask) {
    return Math.floor(scheduledTask.time);
}
function removeAllFrom(f, timeslot) {
    timeslot.events = _prelude.removeAll(f, timeslot.events);
}
function binarySearch(t, sortedArray) {
    var lo = 0;
    var hi = sortedArray.length;
    var mid, y;
    while(lo < hi){
        mid = Math.floor((lo + hi) / 2);
        y = sortedArray[mid];
        if (t === y.time) return mid;
        else if (t < y.time) hi = mid;
        else lo = mid + 1;
    }
    return hi;
}
var newTimeslot = function(t, events) {
    return {
        time: t,
        events: events
    };
};
/** @license MIT License (c) copyright 2010-2017 original author or authors */ /* global setTimeout, clearTimeout */ var ClockTimer = function ClockTimer(clock) {
    this._clock = clock;
};
ClockTimer.prototype.now = function now() {
    return this._clock.now();
};
ClockTimer.prototype.setTimer = function setTimer(f, dt) {
    return dt <= 0 ? runAsap(f) : setTimeout(f, dt);
};
ClockTimer.prototype.clearTimer = function clearTimer(t) {
    return t instanceof Asap ? t.cancel() : clearTimeout(t);
};
var Asap = function Asap(f) {
    this.f = f;
    this.active = true;
};
Asap.prototype.run = function run() {
    return this.active && this.f();
};
Asap.prototype.error = function error(e) {
    throw e;
};
Asap.prototype.cancel = function cancel() {
    this.active = false;
};
function runAsap(f) {
    var task = new Asap(f);
    defer(task);
    return task;
}
/** @license MIT License (c) copyright 2010-2017 original author or authors */ /* global performance, process */ var RelativeClock = function RelativeClock(clock, origin) {
    this.origin = origin;
    this.clock = clock;
};
RelativeClock.prototype.now = function now() {
    return this.clock.now() - this.origin;
};
var HRTimeClock = function HRTimeClock(hrtime, origin) {
    this.origin = origin;
    this.hrtime = hrtime;
};
HRTimeClock.prototype.now = function now() {
    var hrt = this.hrtime(this.origin);
    return (hrt[0] * 1000000000 + hrt[1]) / 1000000;
};
var clockRelativeTo = function(clock) {
    return new RelativeClock(clock, clock.now());
};
var newPerformanceClock = function() {
    return clockRelativeTo(performance);
};
var newDateClock = function() {
    return clockRelativeTo(Date);
};
var newHRTimeClock = function() {
    return new HRTimeClock(process.hrtime, process.hrtime());
};
var newPlatformClock = function() {
    if (typeof performance !== 'undefined' && typeof performance.now === 'function') return newPerformanceClock();
    else if (typeof process !== 'undefined' && typeof process.hrtime === 'function') return newHRTimeClock();
    return newDateClock();
};
// Read the current time from the provided Scheduler
var currentTime = function(scheduler) {
    return scheduler.currentTime();
};
// Schedule a task to run as soon as possible, but
// not in the current call stack
var asap = _prelude.curry2(function(task, scheduler) {
    return scheduler.scheduleTask(0, 0, -1, task);
});
// Schedule a task to run after a millisecond delay
var delay = _prelude.curry3(function(delay4, task, scheduler) {
    return scheduler.scheduleTask(0, delay4, -1, task);
});
// Schedule a task to run periodically, with the
// first run starting asap
var periodic = _prelude.curry3(function(period, task, scheduler) {
    return scheduler.scheduleTask(0, 0, period, task);
});
// Cancel a scheduledTask
var cancelTask = function(scheduledTask) {
    return scheduledTask.dispose();
};
// Cancel all ScheduledTasks for which a predicate
// is true
var cancelAllTasks = _prelude.curry2(function(predicate, scheduler) {
    return scheduler.cancelAll(predicate);
});
var schedulerRelativeTo = _prelude.curry2(function(offset, scheduler) {
    return new RelativeScheduler(offset, scheduler);
});
/** @license MIT License (c) copyright 2010-2017 original author or authors */ var newScheduler = _prelude.curry2(function(timer, timeline) {
    return new Scheduler(timer, timeline);
});
var newDefaultScheduler = function() {
    return new Scheduler(newDefaultTimer(), new Timeline());
};
var newDefaultTimer = function() {
    return new ClockTimer(newPlatformClock());
};
var newClockTimer = function(clock) {
    return new ClockTimer(clock);
};
var newTimeline = function() {
    return new Timeline();
};

},{"@most/prelude":"jX2Nl","process":"jhUEF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d8fuf":[function(require,module,exports) {
'use strict';
var Queue = require('tinyqueue');
module.exports = knn;
module.exports.default = knn;
function knn(tree, x, y, n, predicate, maxDistance) {
    var node = tree.data, result = [], toBBox = tree.toBBox, i, child, dist, candidate;
    var queue = new Queue(undefined, compareDist);
    while(node){
        for(i = 0; i < node.children.length; i++){
            child = node.children[i];
            dist = boxDist(x, y, node.leaf ? toBBox(child) : child);
            if (!maxDistance || dist <= maxDistance * maxDistance) queue.push({
                node: child,
                isItem: node.leaf,
                dist: dist
            });
        }
        while(queue.length && queue.peek().isItem){
            candidate = queue.pop().node;
            if (!predicate || predicate(candidate)) result.push(candidate);
            if (n && result.length === n) return result;
        }
        node = queue.pop();
        if (node) node = node.node;
    }
    return result;
}
function compareDist(a, b) {
    return a.dist - b.dist;
}
function boxDist(x, y, box) {
    var dx = axisDist(x, box.minX, box.maxX), dy = axisDist(y, box.minY, box.maxY);
    return dx * dx + dy * dy;
}
function axisDist(k, min, max) {
    return k < min ? min - k : k <= max ? 0 : k - max;
}

},{"tinyqueue":"9WVEg"}],"9WVEg":[function(require,module,exports) {
(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.TinyQueue = factory());
})(this, function() {
    'use strict';
    var TinyQueue = function TinyQueue(data, compare) {
        if (data === void 0) data = [];
        if (compare === void 0) compare = defaultCompare;
        this.data = data;
        this.length = this.data.length;
        this.compare = compare;
        if (this.length > 0) for(var i = (this.length >> 1) - 1; i >= 0; i--)this._down(i);
    };
    TinyQueue.prototype.push = function push(item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
    };
    TinyQueue.prototype.pop = function pop() {
        if (this.length === 0) return undefined;
        var top = this.data[0];
        var bottom = this.data.pop();
        this.length--;
        if (this.length > 0) {
            this.data[0] = bottom;
            this._down(0);
        }
        return top;
    };
    TinyQueue.prototype.peek = function peek() {
        return this.data[0];
    };
    TinyQueue.prototype._up = function _up(pos) {
        var ref = this;
        var data = ref.data;
        var compare = ref.compare;
        var item = data[pos];
        while(pos > 0){
            var parent = pos - 1 >> 1;
            var current = data[parent];
            if (compare(item, current) >= 0) break;
            data[pos] = current;
            pos = parent;
        }
        data[pos] = item;
    };
    TinyQueue.prototype._down = function _down(pos) {
        var ref = this;
        var data = ref.data;
        var compare = ref.compare;
        var halfLength = this.length >> 1;
        var item = data[pos];
        while(pos < halfLength){
            var left = (pos << 1) + 1;
            var best = data[left];
            var right = left + 1;
            if (right < this.length && compare(data[right], best) < 0) {
                left = right;
                best = data[right];
            }
            if (compare(best, item) >= 0) break;
            data[pos] = best;
            pos = left;
        }
        data[pos] = item;
    };
    function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }
    return TinyQueue;
});

},{}],"16D9h":[function(require,module,exports) {
// UMD: https://github.com/umdjs/umd/blob/master/returnExports.js
(function(root, factory) {
    /* global define: false */ if (typeof define === "function" && define.amd) // AMD. Register as an anonymous module.
    define([], factory);
    else if (typeof exports === "object") // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
    else // Browser globals (root is window)
    root.humanFormat = factory();
})(this, function() {
    "use strict";
    // =================================================================
    function assign(dst, src) {
        var i, n, prop;
        for(i = 1, n = arguments.length; i < n; ++i){
            src = arguments[i];
            if (src != null) {
                for(prop in src)if (has(src, prop)) dst[prop] = src[prop];
            }
        }
        return dst;
    }
    function compareLongestFirst(a, b) {
        return b.length - a.length;
    }
    function compareSmallestFactorFirst(a, b) {
        return a.factor - b.factor;
    }
    // https://www.npmjs.org/package/escape-regexp
    function escapeRegexp(str) {
        return str.replace(/([.*+?=^!:${}()|[\]/\\])/g, "\\$1");
    }
    function forEach(arr, iterator) {
        var i, n;
        for(i = 0, n = arr.length; i < n; ++i)iterator(arr[i], i);
    }
    function forOwn(obj, iterator) {
        var prop;
        for(prop in obj)if (has(obj, prop)) iterator(obj[prop], prop);
    }
    var has = function(hasOwnProperty) {
        return function has(obj, prop) {
            return obj != null && hasOwnProperty.call(obj, prop);
        };
    }(Object.prototype.hasOwnProperty);
    function resolve(container, entry) {
        while(typeof entry === "string")entry = container[entry];
        return entry;
    }
    // =================================================================
    function Scale(prefixes) {
        this._prefixes = prefixes;
        var escapedPrefixes = [];
        var list = [];
        forOwn(prefixes, function(factor, prefix) {
            escapedPrefixes.push(escapeRegexp(prefix));
            list.push({
                factor: factor,
                prefix: prefix
            });
        });
        // Adds lower cased prefixes for case insensitive fallback.
        var lcPrefixes = this._lcPrefixes = {
        };
        forOwn(prefixes, function(factor, prefix) {
            var lcPrefix = prefix.toLowerCase();
            if (!has(prefixes, lcPrefix)) lcPrefixes[lcPrefix] = prefix;
        });
        list.sort(compareSmallestFactorFirst);
        this._list = list;
        escapedPrefixes.sort(compareLongestFirst);
        this._regexp = new RegExp("^\\s*(-)?\\s*(\\d+(?:\\.\\d+)?)\\s*(" + escapedPrefixes.join("|") + ")\\s*(.*)\\s*?$", "i");
    }
    Scale.create = function Scale$create(prefixesList, base, initExp) {
        var prefixes = {
        };
        if (initExp === undefined) initExp = 0;
        forEach(prefixesList, function(prefix, i) {
            prefixes[prefix] = Math.pow(base, i + initExp);
        });
        return new Scale(prefixes);
    };
    // Binary search to find the greatest index which has a value <=.
    Scale.prototype.findPrefix = function Scale$findPrefix(value) {
        var list = this._list;
        var low = 0;
        var high = list.length - 1;
        var mid, current;
        while(low !== high){
            mid = low + high + 1 >> 1;
            current = list[mid].factor;
            if (current > value) high = mid - 1;
            else low = mid;
        }
        return list[low];
    };
    Scale.prototype.parse = function Scale$parse(str, strict) {
        var matches = str.match(this._regexp);
        if (matches === null) return;
        var prefix = matches[3];
        var factor;
        if (has(this._prefixes, prefix)) factor = this._prefixes[prefix];
        else if (!strict && (prefix = prefix.toLowerCase(), has(this._lcPrefixes, prefix))) {
            prefix = this._lcPrefixes[prefix];
            factor = this._prefixes[prefix];
        } else return;
        var value = +matches[2];
        if (matches[1] !== undefined) value = -value;
        return {
            factor: factor,
            prefix: prefix,
            unit: matches[4],
            value: value
        };
    };
    // =================================================================
    var scales = {
        // https://en.wikipedia.org/wiki/Binary_prefix
        binary: Scale.create(",Ki,Mi,Gi,Ti,Pi,Ei,Zi,Yi".split(","), 1024),
        // https://en.wikipedia.org/wiki/Metric_prefix
        //
        // Not all prefixes are present, only those which are multiple of
        // 1000, because humans usually prefer to see close numbers using
        // the same unit to ease the comparison.
        SI: Scale.create("y,z,a,f,p,n,,m,,k,M,G,T,P,E,Z,Y".split(","), 1000, -8)
    };
    var defaults = {
        // Decimal digits for formatting.
        maxDecimals: 2,
        // separator to use between value and units
        separator: " ",
        // Unit to use for formatting.
        unit: ""
    };
    var rawDefaults = {
        scale: "SI",
        // Strict mode prevents parsing of incorrectly cased prefixes.
        strict: false
    };
    function humanFormat(value, opts) {
        opts = assign({
        }, defaults, opts);
        var decimals = opts.decimals;
        if (decimals !== undefined) // humanFormat$raw should not round when using decimals option
        delete opts.maxDecimals;
        var info = humanFormat$raw(value, opts);
        value = decimals !== undefined ? info.value.toFixed(decimals) : String(info.value);
        var suffix = info.prefix + opts.unit;
        return suffix === "" ? value : value + opts.separator + suffix;
    }
    var humanFormat$bytes$opts = {
        scale: "binary",
        unit: "B"
    };
    function humanFormat$bytes(value, opts) {
        return humanFormat(value, opts === undefined ? humanFormat$bytes$opts : assign({
        }, humanFormat$bytes$opts, opts));
    }
    function humanFormat$parse(str, opts) {
        var info = humanFormat$parse$raw(str, opts);
        return info.value * info.factor;
    }
    function humanFormat$parse$raw(str, opts) {
        if (typeof str !== "string") throw new TypeError("str must be a string");
        // Merge default options.
        opts = assign({
        }, rawDefaults, opts);
        // Get current scale.
        var scale = resolve(scales, opts.scale);
        if (scale === undefined) throw new Error("missing scale");
        // TODO: the unit should be checked: it might be absent but it
        // should not differ from the one expected.
        //
        // TODO: if multiple units are specified, at least must match and
        // the returned value should be: { value: <value>, unit: matchedUnit }
        var info = scale.parse(str, opts.strict);
        if (info === undefined) throw new Error("cannot parse str");
        return info;
    }
    function humanFormat$raw(value, opts) {
        // Zero is a special case, it never has any prefix.
        if (value === 0) return {
            value: 0,
            prefix: ""
        };
        else if (value < 0) {
            var result = humanFormat$raw(-value, opts);
            result.value = -result.value;
            return result;
        }
        if (typeof value !== "number" || Number.isNaN(value)) throw new TypeError("value must be a number");
        // Merge default options.
        opts = assign({
        }, rawDefaults, opts);
        // Get current scale.
        var scale = resolve(scales, opts.scale);
        if (scale === undefined) throw new Error("missing scale");
        var power;
        var maxDecimals = opts.maxDecimals;
        var autoMaxDecimals = maxDecimals === "auto";
        if (autoMaxDecimals) power = 10;
        else if (maxDecimals !== undefined) power = Math.pow(10, maxDecimals);
        var prefix = opts.prefix;
        var factor;
        if (prefix !== undefined) {
            if (!has(scale._prefixes, prefix)) throw new Error("invalid prefix");
            factor = scale._prefixes[prefix];
        } else {
            var _ref = scale.findPrefix(value);
            if (power !== undefined) do {
                factor = _ref.factor;
                // factor is usually >> power, therefore it's better to
                // divide factor by power than the other way to limit
                // numerical error
                var r = factor / power;
                value = Math.round(value / r) * r;
            }while ((_ref = scale.findPrefix(value)).factor !== factor)
            else factor = _ref.factor;
            prefix = _ref.prefix;
        }
        value = power === undefined ? value / factor : Math.round(value * power / factor) / power;
        if (autoMaxDecimals && Math.abs(value) >= 10) value = Math.round(value);
        return {
            prefix: prefix,
            value: value
        };
    }
    humanFormat.bytes = humanFormat$bytes;
    humanFormat.parse = humanFormat$parse;
    humanFormat$parse.raw = humanFormat$parse$raw;
    humanFormat.raw = humanFormat$raw;
    humanFormat.Scale = Scale;
    return humanFormat;
});

},{}],"fUigp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tabFocusOn$", ()=>tabFocusOn$
);
parcelHelpers.export(exports, "tabFocusOff$", ()=>tabFocusOff$
);
parcelHelpers.export(exports, "whileTabFocus", ()=>whileTabFocus
);
var _core = require("@most/core");
var _domEvent = require("@most/dom-event");
const visibilitychange = _domEvent.domEvent("visibilitychange", document);
const tabFocusOn$ = _core.filter(()=>!document.hidden
, _core.map(()=>!document.hidden
, visibilitychange));
const tabFocusOff$ = _core.filter(()=>document.hidden
, _core.map(()=>document.hidden
, visibilitychange));
const whileTabFocus = ($)=>_core.join(_core.constant(_core.until(tabFocusOff$, $), _core.merge(tabFocusOn$, _core.now(null))))
;

},{"@most/core":"hGpP7","@most/dom-event":"k1B4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1cqHl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fractionalPositionInElement", ()=>fractionalPositionInElement
);
parcelHelpers.export(exports, "positionInCanvas", ()=>positionInCanvas
);
var _core = require("@most/core");
var _lodashEs = require("lodash-es");
exports.default = _core.map(({ clientX , clientY , target  })=>{
    const el = target;
    let bound = el?.getBoundingClientRect();
    let x = clientX - bound.left - el?.clientLeft;
    let y = clientY - bound.top - el?.clientTop;
    return {
        x,
        y
    };
});
const fractionalPositionInElement = _core.map(({ clientX , clientY , target  })=>{
    const el = target;
    let bound = el?.getBoundingClientRect();
    let x = (clientX - bound.left - el?.clientLeft) / el?.clientWidth;
    let y = (clientY - bound.top - el?.clientTop) / el?.clientHeight;
    return {
        x,
        y
    };
});
const positionInCanvas = _lodashEs.flow(fractionalPositionInElement, _core.map(({ x , y  })=>({
        x: x - 0.5,
        y: -(y - 0.5)
    })
));

},{"@most/core":"hGpP7","lodash-es":"bXNwz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["M2YOe"], "M2YOe", "parcelRequireaf77")

//# sourceMappingURL=tessellation.b71c08e7.js.map
